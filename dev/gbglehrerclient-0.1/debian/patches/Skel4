Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 gbglehrerclient (0.1-10) focal; urgency=medium
 .
   * Initial release (Closes: #nnnn)  <nnnn is the bug number of your ITP>
Author: Felix Schoppe <felix.schoppe@gbg-seelze.eu>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: https://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: 2020-09-22

--- gbglehrerclient-0.1.orig/etc/skel/.atom/.apm/.apmrc
+++ /dev/null
@@ -1,7 +0,0 @@
-; This file is auto-generated and should not be edited since any
-; modifications will be lost the next time any apm command is run.
-;
-; You should instead edit your .apmrc config located in ~/.atom/.apmrc
-cache = /root/.atom/.apm
-; Hide progress-bar to prevent npm from altering apm console output.
-progress = false
\ No newline at end of file
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.apm/language-nxc/3.6.1/package/package.json
+++ /dev/null
@@ -1 +0,0 @@
-{"version":"3.6.1","name":"language-nxc","description":"Atom language support for NXC","repository":{"type":"git","url":"git+https://github.com/nloomans/language-nxc.git"},"main":"./lib/main","license":"MIT","bugs":{"url":"https://github.com/nloomans/language-nxc/issues"},"engines":{"atom":">=1.19.0 <2.0.0"},"providedServices":{"autocomplete.provider":{"versions":{"2.0.0":"getProvider"}}},"readme":"# NXC language support in Atom\n\nlanguage-nxc makes it easier to develop in NXC, which requires little to no setup (depending on your OS / distribution). Its goal is to make developing for NXC easier for everyone.\n\n## Features\n### Comping and uploading\nbuilt-in (cross-platform) compiling and uploading, try `nxc:upload`. **This works on Linux as well!**\n\n![menu](http://i.imgur.com/92Gd8cA.png)\n![bug](http://i.imgur.com/6yuUSmT.png)\n\n### Auto completion\nauto completion for ~~built in~~ **all** functions\n- description\n- link to docs\n\n![Example Usage](http://i.imgur.com/I1v9dMs.gif)\n\n### Syntax highlighting\n\n![syntax highlighting](http://i.imgur.com/SrMTC46.png)\n","readmeFilename":"README.md","homepage":"https://github.com/nloomans/language-nxc#readme","_id":"language-nxc@3.6.1","_shasum":"f7b1924ddcdc97045dcee4932953ecf77b270f66","_resolved":"file:../d-118317-9044-1ygzhlb.ug8dleg66r/package.tgz","_from":"../d-118317-9044-1ygzhlb.ug8dleg66r/package.tgz"}
\ No newline at end of file
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/common.gypi
+++ /dev/null
@@ -1,417 +0,0 @@
-{
-  'variables': {
-    'asan%': 0,
-    'werror': '',                     # Turn off -Werror in V8 build.
-    'visibility%': 'hidden',          # V8's visibility setting
-    'target_arch%': 'ia32',           # set v8's target architecture
-    'host_arch%': 'ia32',             # set v8's host architecture
-    'want_separate_host_toolset%': 0, # V8 should not build target and host
-    'library%': 'static_library',     # allow override to 'shared_library' for DLL/.so builds
-    'component%': 'static_library',   # NB. these names match with what V8 expects
-    'msvs_multi_core_compile': '0',   # we do enable multicore compiles, but not using the V8 way
-    'python%': 'python',
-
-    'node_shared%': 'false',
-    'force_dynamic_crt%': 0,
-    'node_use_v8_platform%': 'true',
-    'node_use_bundled_v8%': 'true',
-    'node_module_version%': '',
-
-    'node_tag%': '',
-    'uv_library%': 'static_library',
-
-    'openssl_fips%': '',
-
-    # Default to -O0 for debug builds.
-    'v8_optimized_debug%': 0,
-
-    # Enable disassembler for `--print-code` v8 options
-    'v8_enable_disassembler': 1,
-
-    # Don't bake anything extra into the snapshot.
-    'v8_use_external_startup_data%': 0,
-
-    # Don't use ICU data file (icudtl.dat) from V8, we use our own.
-    'icu_use_data_file_flag%': 0,
-
-    'conditions': [
-      ['OS == "win"', {
-        'os_posix': 0,
-        'v8_postmortem_support%': 'false',
-      }, {
-        'os_posix': 1,
-        'v8_postmortem_support%': 'true',
-      }],
-      ['OS== "mac"', {
-        'OBJ_DIR': '<(PRODUCT_DIR)/obj.target',
-        'V8_BASE': '<(PRODUCT_DIR)/libv8_base.a',
-      }, {
-        'conditions': [
-          ['GENERATOR=="ninja"', {
-            'OBJ_DIR': '<(PRODUCT_DIR)/obj',
-            'V8_BASE': '<(PRODUCT_DIR)/obj/deps/v8/src/libv8_base.a',
-          }, {
-            'OBJ_DIR': '<(PRODUCT_DIR)/obj.target',
-            'V8_BASE': '<(PRODUCT_DIR)/obj.target/deps/v8/src/libv8_base.a',
-          }],
-        ],
-      }],
-      ['"" != ""', {
-        'OPENSSL_PRODUCT': 'libcrypto.a',
-      }, {
-        'OPENSSL_PRODUCT': 'libopenssl.a',
-      }],
-      ['OS=="mac"', {
-        'clang%': 1,
-      }, {
-        'clang%': 0,
-      }],
-    ],
-  },
-
-  'target_defaults': {
-    'default_configuration': 'Release',
-    'configurations': {
-      'Debug': {
-        'variables': {
-          'v8_enable_handle_zapping': 1,
-        },
-        'defines': [ 'DEBUG', '_DEBUG' ],
-        'cflags': [ '-g', '-O0' ],
-        'conditions': [
-          ['target_arch=="x64"', {
-            'msvs_configuration_platform': 'x64',
-          }],
-          ['OS=="aix"', {
-            'cflags': [ '-gxcoff' ],
-            'ldflags': [ '-Wl,-bbigtoc' ],
-          }],
-          ['OS == "android"', {
-            'cflags': [ '-fPIE' ],
-            'ldflags': [ '-fPIE', '-pie' ]
-          }],
-          ['node_shared=="true"', {
-            'msvs_settings': {
-             'VCCLCompilerTool': {
-               'RuntimeLibrary': 3, # MultiThreadedDebugDLL (/MDd)
-             }
-            }
-          }],
-          ['node_shared=="false"', {
-            'msvs_settings': {
-              'VCCLCompilerTool': {
-                'RuntimeLibrary': 1 # MultiThreadedDebug (/MTd)
-              }
-            }
-          }]
-        ],
-        'msvs_settings': {
-          'VCCLCompilerTool': {
-            'Optimization': 0, # /Od, no optimization
-            'MinimalRebuild': 'false',
-            'OmitFramePointers': 'false',
-            'BasicRuntimeChecks': 3, # /RTC1
-          },
-          'VCLinkerTool': {
-            'LinkIncremental': 2, # enable incremental linking
-          },
-        },
-        'xcode_settings': {
-          'GCC_OPTIMIZATION_LEVEL': '0', # stop gyp from defaulting to -Os
-        },
-      },
-      'Release': {
-        'variables': {
-          'v8_enable_handle_zapping': 0,
-        },
-        'cflags': [ '-O3' ],
-        'conditions': [
-          ['target_arch=="x64"', {
-            'msvs_configuration_platform': 'x64',
-          }],
-          ['OS=="solaris"', {
-            # pull in V8's postmortem metadata
-            'ldflags': [ '-Wl,-z,allextract' ]
-          }],
-          ['OS!="mac" and OS!="win"', {
-            'cflags': [ '-fno-omit-frame-pointer' ],
-          }],
-          ['OS == "android"', {
-            'cflags': [ '-fPIE' ],
-            'ldflags': [ '-fPIE', '-pie' ]
-          }],
-          ['node_shared=="true"', {
-            'msvs_settings': {
-             'VCCLCompilerTool': {
-               'RuntimeLibrary': 2 # MultiThreadedDLL (/MD)
-             }
-            }
-          }],
-          ['node_shared=="false"', {
-            'msvs_settings': {
-              'VCCLCompilerTool': {
-                'RuntimeLibrary': 0 # MultiThreaded (/MT)
-              }
-            }
-          }]
-        ],
-        'msvs_settings': {
-          'VCCLCompilerTool': {
-            'Optimization': 3, # /Ox, full optimization
-            'FavorSizeOrSpeed': 1, # /Ot, favour speed over size
-            'InlineFunctionExpansion': 2, # /Ob2, inline anything eligible
-            'WholeProgramOptimization': 'true', # /GL, whole program optimization, needed for LTCG
-            'OmitFramePointers': 'true',
-            'EnableFunctionLevelLinking': 'true',
-            'EnableIntrinsicFunctions': 'true',
-            'RuntimeTypeInfo': 'false',
-            'AdditionalOptions': [
-              '/MP', # compile across multiple CPUs
-            ],
-          },
-          'VCLibrarianTool': {
-            'AdditionalOptions': [
-              '/LTCG', # link time code generation
-            ],
-          },
-          'VCLinkerTool': {
-            'LinkTimeCodeGeneration': 1, # link-time code generation
-            'OptimizeReferences': 2, # /OPT:REF
-            'EnableCOMDATFolding': 2, # /OPT:ICF
-            'LinkIncremental': 1, # disable incremental linking
-          },
-        },
-      }
-    },
-    # Forcibly disable -Werror.  We support a wide range of compilers, it's
-    # simply not feasible to squelch all warnings, never mind that the
-    # libraries in deps/ are not under our control.
-    'cflags!': ['-Werror'],
-    'msvs_settings': {
-      'VCCLCompilerTool': {
-        'StringPooling': 'true', # pool string literals
-        'DebugInformationFormat': 3, # Generate a PDB
-        'WarningLevel': 3,
-        'BufferSecurityCheck': 'true',
-        'ExceptionHandling': 0, # /EHsc
-        'SuppressStartupBanner': 'true',
-        # Disable "warning C4267: conversion from 'size_t' to 'int',
-        # possible loss of data".  Many originate from our dependencies
-        # and their sheer number drowns out other, more legitimate warnings.
-        'DisableSpecificWarnings': ['4267'],
-        'WarnAsError': 'false',
-      },
-      'VCLibrarianTool': {
-      },
-      'VCLinkerTool': {
-        'conditions': [
-          ['target_arch=="ia32"', {
-            'TargetMachine' : 1, # /MACHINE:X86
-            'target_conditions': [
-              ['_type=="executable"', {
-                'AdditionalOptions': [ '/SubSystem:Console,"5.01"' ],
-              }],
-            ],
-          }],
-          ['target_arch=="x64"', {
-            'TargetMachine' : 17, # /MACHINE:AMD64
-            'target_conditions': [
-              ['_type=="executable"', {
-                'AdditionalOptions': [ '/SubSystem:Console,"5.02"' ],
-              }],
-            ],
-          }],
-        ],
-        'GenerateDebugInformation': 'true',
-        'GenerateMapFile': 'true', # /MAP
-        'MapExports': 'true', # /MAPINFO:EXPORTS
-        'RandomizedBaseAddress': 2, # enable ASLR
-        'DataExecutionPrevention': 2, # enable DEP
-        'AllowIsolation': 'true',
-        'SuppressStartupBanner': 'true',
-      },
-    },
-    'msvs_disabled_warnings': [4351, 4355, 4800],
-    'conditions': [
-      ['asan == 1 and OS != "mac"', {
-        'cflags+': [
-          '-fno-omit-frame-pointer',
-          '-fsanitize=address',
-          '-DLEAK_SANITIZER'
-        ],
-        'cflags!': [ '-fomit-frame-pointer' ],
-        'ldflags': [ '-fsanitize=address' ],
-      }],
-      ['asan == 1 and OS == "mac"', {
-        'xcode_settings': {
-          'OTHER_CFLAGS+': [
-            '-fno-omit-frame-pointer',
-            '-gline-tables-only',
-            '-fsanitize=address',
-            '-DLEAK_SANITIZER'
-          ],
-          'OTHER_CFLAGS!': [
-            '-fomit-frame-pointer',
-          ],
-        },
-        'target_conditions': [
-          ['_type!="static_library"', {
-            'xcode_settings': {'OTHER_LDFLAGS': ['-fsanitize=address']},
-          }],
-        ],
-      }],
-      ['OS == "win"', {
-        'msvs_cygwin_shell': 0, # prevent actions from trying to use cygwin
-        'defines': [
-          'WIN32',
-          # we don't really want VC++ warning us about
-          # how dangerous C functions are...
-          '_CRT_SECURE_NO_DEPRECATE',
-          # ... or that C implementations shouldn't use
-          # POSIX names
-          '_CRT_NONSTDC_NO_DEPRECATE',
-          # Make sure the STL doesn't try to use exceptions
-          '_HAS_EXCEPTIONS=0',
-          'BUILDING_V8_SHARED=1',
-          'BUILDING_UV_SHARED=1',
-        ],
-      }],
-      [ 'OS in "linux freebsd openbsd solaris aix"', {
-        'cflags': [ '-pthread', ],
-        'ldflags': [ '-pthread' ],
-      }],
-      [ 'OS in "linux freebsd openbsd solaris android aix"', {
-        'cflags': [ '-Wall', '-Wextra', '-Wno-unused-parameter', ],
-        'cflags_cc': [ '-fno-rtti', '-fno-exceptions', '-std=gnu++0x' ],
-        'ldflags': [ '-rdynamic' ],
-        'target_conditions': [
-          # The 1990s toolchain on SmartOS can't handle thin archives.
-          ['_type=="static_library" and OS=="solaris"', {
-            'standalone_static_library': 1,
-          }],
-          ['OS=="openbsd"', {
-            'ldflags': [ '-Wl,-z,wxneeded' ],
-          }],
-        ],
-        'conditions': [
-          [ 'target_arch=="ia32"', {
-            'cflags': [ '-m32' ],
-            'ldflags': [ '-m32' ],
-          }],
-          [ 'target_arch=="x32"', {
-            'cflags': [ '-mx32' ],
-            'ldflags': [ '-mx32' ],
-          }],
-          [ 'target_arch=="x64"', {
-            'cflags': [ '-m64' ],
-            'ldflags': [ '-m64' ],
-          }],
-          [ 'target_arch=="ppc" and OS!="aix"', {
-            'cflags': [ '-m32' ],
-            'ldflags': [ '-m32' ],
-          }],
-          [ 'target_arch=="ppc64" and OS!="aix"', {
-	    'cflags': [ '-m64', '-mminimal-toc' ],
-	    'ldflags': [ '-m64' ],
-	   }],
-          [ 'target_arch=="s390"', {
-            'cflags': [ '-m31', '-march=z196' ],
-            'ldflags': [ '-m31', '-march=z196' ],
-          }],
-          [ 'target_arch=="s390x"', {
-            'cflags': [ '-m64', '-march=z196' ],
-            'ldflags': [ '-m64', '-march=z196' ],
-          }],
-          [ 'OS=="solaris"', {
-            'cflags': [ '-pthreads' ],
-            'ldflags': [ '-pthreads' ],
-            'cflags!': [ '-pthread' ],
-            'ldflags!': [ '-pthread' ],
-          }],
-          [ 'OS=="aix"', {
-            'conditions': [
-              [ 'target_arch=="ppc"', {
-                'ldflags': [ '-Wl,-bmaxdata:0x60000000/dsa' ],
-              }],
-              [ 'target_arch=="ppc64"', {
-                'cflags': [ '-maix64' ],
-                'ldflags': [ '-maix64' ],
-              }],
-            ],
-            'ldflags': [ '-Wl,-bbigtoc' ],
-            'ldflags!': [ '-rdynamic' ],
-          }],
-          [ 'node_shared=="true"', {
-            'cflags': [ '-fPIC' ],
-          }],
-        ],
-      }],
-      ['OS=="android"', {
-        'target_conditions': [
-          ['_toolset=="target"', {
-            'defines': [ '_GLIBCXX_USE_C99_MATH' ],
-            'libraries': [ '-llog' ],
-          }],
-        ],
-      }],
-      ['OS=="mac"', {
-        'defines': ['_DARWIN_USE_64_BIT_INODE=1'],
-        'xcode_settings': {
-          'ALWAYS_SEARCH_USER_PATHS': 'NO',
-          'GCC_CW_ASM_SYNTAX': 'NO',                # No -fasm-blocks
-          'GCC_DYNAMIC_NO_PIC': 'NO',               # No -mdynamic-no-pic
-                                                    # (Equivalent to -fPIC)
-          'GCC_ENABLE_CPP_EXCEPTIONS': 'NO',        # -fno-exceptions
-          'GCC_ENABLE_CPP_RTTI': 'NO',              # -fno-rtti
-          'GCC_ENABLE_PASCAL_STRINGS': 'NO',        # No -mpascal-strings
-          'GCC_THREADSAFE_STATICS': 'NO',           # -fno-threadsafe-statics
-          'PREBINDING': 'NO',                       # No -Wl,-prebind
-          'MACOSX_DEPLOYMENT_TARGET': '10.7',       # -mmacosx-version-min=10.7
-          'USE_HEADERMAP': 'NO',
-          'OTHER_CFLAGS': [
-            '-fno-strict-aliasing',
-          ],
-          'WARNING_CFLAGS': [
-            '-Wall',
-            '-Wendif-labels',
-            '-W',
-            '-Wno-unused-parameter',
-          ],
-        },
-        'target_conditions': [
-          ['_type!="static_library"', {
-            'xcode_settings': {
-              'OTHER_LDFLAGS': [
-                '-Wl,-no_pie',
-                '-Wl,-search_paths_first',
-              ],
-            },
-          }],
-        ],
-        'conditions': [
-          ['target_arch=="ia32"', {
-            'xcode_settings': {'ARCHS': ['i386']},
-          }],
-          ['target_arch=="x64"', {
-            'xcode_settings': {'ARCHS': ['x86_64']},
-          }],
-          ['clang==1', {
-            'xcode_settings': {
-              'GCC_VERSION': 'com.apple.compilers.llvm.clang.1_0',
-              'CLANG_CXX_LANGUAGE_STANDARD': 'gnu++0x',  # -std=gnu++0x
-              'CLANG_CXX_LIBRARY': 'libc++',
-            },
-          }],
-        ],
-      }],
-      ['OS=="freebsd" and node_use_dtrace=="true"', {
-        'libraries': [ '-lelf' ],
-      }],
-      ['OS=="freebsd"', {
-        'ldflags': [
-          '-Wl,--export-dynamic',
-        ],
-      }]
-    ],
-  }
-}
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/config.gypi
+++ /dev/null
@@ -1,2 +0,0 @@
-
-{'variables':{}}
\ No newline at end of file
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/http_parser/http_parser.h
+++ /dev/null
@@ -1,362 +0,0 @@
-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-#ifndef http_parser_h
-#define http_parser_h
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* Also update SONAME in the Makefile whenever you change these. */
-#define HTTP_PARSER_VERSION_MAJOR 2
-#define HTTP_PARSER_VERSION_MINOR 7
-#define HTTP_PARSER_VERSION_PATCH 0
-
-#include <sys/types.h>
-#if defined(_WIN32) && !defined(__MINGW32__) && \
-  (!defined(_MSC_VER) || _MSC_VER<1600) && !defined(__WINE__)
-#include <BaseTsd.h>
-#include <stddef.h>
-typedef __int8 int8_t;
-typedef unsigned __int8 uint8_t;
-typedef __int16 int16_t;
-typedef unsigned __int16 uint16_t;
-typedef __int32 int32_t;
-typedef unsigned __int32 uint32_t;
-typedef __int64 int64_t;
-typedef unsigned __int64 uint64_t;
-#else
-#include <stdint.h>
-#endif
-
-/* Compile with -DHTTP_PARSER_STRICT=0 to make less checks, but run
- * faster
- */
-#ifndef HTTP_PARSER_STRICT
-# define HTTP_PARSER_STRICT 1
-#endif
-
-/* Maximium header size allowed. If the macro is not defined
- * before including this header then the default is used. To
- * change the maximum header size, define the macro in the build
- * environment (e.g. -DHTTP_MAX_HEADER_SIZE=<value>). To remove
- * the effective limit on the size of the header, define the macro
- * to a very large number (e.g. -DHTTP_MAX_HEADER_SIZE=0x7fffffff)
- */
-#ifndef HTTP_MAX_HEADER_SIZE
-# define HTTP_MAX_HEADER_SIZE (80*1024)
-#endif
-
-typedef struct http_parser http_parser;
-typedef struct http_parser_settings http_parser_settings;
-
-
-/* Callbacks should return non-zero to indicate an error. The parser will
- * then halt execution.
- *
- * The one exception is on_headers_complete. In a HTTP_RESPONSE parser
- * returning '1' from on_headers_complete will tell the parser that it
- * should not expect a body. This is used when receiving a response to a
- * HEAD request which may contain 'Content-Length' or 'Transfer-Encoding:
- * chunked' headers that indicate the presence of a body.
- *
- * Returning `2` from on_headers_complete will tell parser that it should not
- * expect neither a body nor any futher responses on this connection. This is
- * useful for handling responses to a CONNECT request which may not contain
- * `Upgrade` or `Connection: upgrade` headers.
- *
- * http_data_cb does not return data chunks. It will be called arbitrarily
- * many times for each string. E.G. you might get 10 callbacks for "on_url"
- * each providing just a few characters more data.
- */
-typedef int (*http_data_cb) (http_parser*, const char *at, size_t length);
-typedef int (*http_cb) (http_parser*);
-
-
-/* Request Methods */
-#define HTTP_METHOD_MAP(XX)         \
-  XX(0,  DELETE,      DELETE)       \
-  XX(1,  GET,         GET)          \
-  XX(2,  HEAD,        HEAD)         \
-  XX(3,  POST,        POST)         \
-  XX(4,  PUT,         PUT)          \
-  /* pathological */                \
-  XX(5,  CONNECT,     CONNECT)      \
-  XX(6,  OPTIONS,     OPTIONS)      \
-  XX(7,  TRACE,       TRACE)        \
-  /* WebDAV */                      \
-  XX(8,  COPY,        COPY)         \
-  XX(9,  LOCK,        LOCK)         \
-  XX(10, MKCOL,       MKCOL)        \
-  XX(11, MOVE,        MOVE)         \
-  XX(12, PROPFIND,    PROPFIND)     \
-  XX(13, PROPPATCH,   PROPPATCH)    \
-  XX(14, SEARCH,      SEARCH)       \
-  XX(15, UNLOCK,      UNLOCK)       \
-  XX(16, BIND,        BIND)         \
-  XX(17, REBIND,      REBIND)       \
-  XX(18, UNBIND,      UNBIND)       \
-  XX(19, ACL,         ACL)          \
-  /* subversion */                  \
-  XX(20, REPORT,      REPORT)       \
-  XX(21, MKACTIVITY,  MKACTIVITY)   \
-  XX(22, CHECKOUT,    CHECKOUT)     \
-  XX(23, MERGE,       MERGE)        \
-  /* upnp */                        \
-  XX(24, MSEARCH,     M-SEARCH)     \
-  XX(25, NOTIFY,      NOTIFY)       \
-  XX(26, SUBSCRIBE,   SUBSCRIBE)    \
-  XX(27, UNSUBSCRIBE, UNSUBSCRIBE)  \
-  /* RFC-5789 */                    \
-  XX(28, PATCH,       PATCH)        \
-  XX(29, PURGE,       PURGE)        \
-  /* CalDAV */                      \
-  XX(30, MKCALENDAR,  MKCALENDAR)   \
-  /* RFC-2068, section 19.6.1.2 */  \
-  XX(31, LINK,        LINK)         \
-  XX(32, UNLINK,      UNLINK)       \
-
-enum http_method
-  {
-#define XX(num, name, string) HTTP_##name = num,
-  HTTP_METHOD_MAP(XX)
-#undef XX
-  };
-
-
-enum http_parser_type { HTTP_REQUEST, HTTP_RESPONSE, HTTP_BOTH };
-
-
-/* Flag values for http_parser.flags field */
-enum flags
-  { F_CHUNKED               = 1 << 0
-  , F_CONNECTION_KEEP_ALIVE = 1 << 1
-  , F_CONNECTION_CLOSE      = 1 << 2
-  , F_CONNECTION_UPGRADE    = 1 << 3
-  , F_TRAILING              = 1 << 4
-  , F_UPGRADE               = 1 << 5
-  , F_SKIPBODY              = 1 << 6
-  , F_CONTENTLENGTH         = 1 << 7
-  };
-
-
-/* Map for errno-related constants
- *
- * The provided argument should be a macro that takes 2 arguments.
- */
-#define HTTP_ERRNO_MAP(XX)                                           \
-  /* No error */                                                     \
-  XX(OK, "success")                                                  \
-                                                                     \
-  /* Callback-related errors */                                      \
-  XX(CB_message_begin, "the on_message_begin callback failed")       \
-  XX(CB_url, "the on_url callback failed")                           \
-  XX(CB_header_field, "the on_header_field callback failed")         \
-  XX(CB_header_value, "the on_header_value callback failed")         \
-  XX(CB_headers_complete, "the on_headers_complete callback failed") \
-  XX(CB_body, "the on_body callback failed")                         \
-  XX(CB_message_complete, "the on_message_complete callback failed") \
-  XX(CB_status, "the on_status callback failed")                     \
-  XX(CB_chunk_header, "the on_chunk_header callback failed")         \
-  XX(CB_chunk_complete, "the on_chunk_complete callback failed")     \
-                                                                     \
-  /* Parsing-related errors */                                       \
-  XX(INVALID_EOF_STATE, "stream ended at an unexpected time")        \
-  XX(HEADER_OVERFLOW,                                                \
-     "too many header bytes seen; overflow detected")                \
-  XX(CLOSED_CONNECTION,                                              \
-     "data received after completed connection: close message")      \
-  XX(INVALID_VERSION, "invalid HTTP version")                        \
-  XX(INVALID_STATUS, "invalid HTTP status code")                     \
-  XX(INVALID_METHOD, "invalid HTTP method")                          \
-  XX(INVALID_URL, "invalid URL")                                     \
-  XX(INVALID_HOST, "invalid host")                                   \
-  XX(INVALID_PORT, "invalid port")                                   \
-  XX(INVALID_PATH, "invalid path")                                   \
-  XX(INVALID_QUERY_STRING, "invalid query string")                   \
-  XX(INVALID_FRAGMENT, "invalid fragment")                           \
-  XX(LF_EXPECTED, "LF character expected")                           \
-  XX(INVALID_HEADER_TOKEN, "invalid character in header")            \
-  XX(INVALID_CONTENT_LENGTH,                                         \
-     "invalid character in content-length header")                   \
-  XX(UNEXPECTED_CONTENT_LENGTH,                                      \
-     "unexpected content-length header")                             \
-  XX(INVALID_CHUNK_SIZE,                                             \
-     "invalid character in chunk size header")                       \
-  XX(INVALID_CONSTANT, "invalid constant string")                    \
-  XX(INVALID_INTERNAL_STATE, "encountered unexpected internal state")\
-  XX(STRICT, "strict mode assertion failed")                         \
-  XX(PAUSED, "parser is paused")                                     \
-  XX(UNKNOWN, "an unknown error occurred")
-
-
-/* Define HPE_* values for each errno value above */
-#define HTTP_ERRNO_GEN(n, s) HPE_##n,
-enum http_errno {
-  HTTP_ERRNO_MAP(HTTP_ERRNO_GEN)
-};
-#undef HTTP_ERRNO_GEN
-
-
-/* Get an http_errno value from an http_parser */
-#define HTTP_PARSER_ERRNO(p)            ((enum http_errno) (p)->http_errno)
-
-
-struct http_parser {
-  /** PRIVATE **/
-  unsigned int type : 2;         /* enum http_parser_type */
-  unsigned int flags : 8;        /* F_* values from 'flags' enum; semi-public */
-  unsigned int state : 7;        /* enum state from http_parser.c */
-  unsigned int header_state : 7; /* enum header_state from http_parser.c */
-  unsigned int index : 7;        /* index into current matcher */
-  unsigned int lenient_http_headers : 1;
-
-  uint32_t nread;          /* # bytes read in various scenarios */
-  uint64_t content_length; /* # bytes in body (0 if no Content-Length header) */
-
-  /** READ-ONLY **/
-  unsigned short http_major;
-  unsigned short http_minor;
-  unsigned int status_code : 16; /* responses only */
-  unsigned int method : 8;       /* requests only */
-  unsigned int http_errno : 7;
-
-  /* 1 = Upgrade header was present and the parser has exited because of that.
-   * 0 = No upgrade header present.
-   * Should be checked when http_parser_execute() returns in addition to
-   * error checking.
-   */
-  unsigned int upgrade : 1;
-
-  /** PUBLIC **/
-  void *data; /* A pointer to get hook to the "connection" or "socket" object */
-};
-
-
-struct http_parser_settings {
-  http_cb      on_message_begin;
-  http_data_cb on_url;
-  http_data_cb on_status;
-  http_data_cb on_header_field;
-  http_data_cb on_header_value;
-  http_cb      on_headers_complete;
-  http_data_cb on_body;
-  http_cb      on_message_complete;
-  /* When on_chunk_header is called, the current chunk length is stored
-   * in parser->content_length.
-   */
-  http_cb      on_chunk_header;
-  http_cb      on_chunk_complete;
-};
-
-
-enum http_parser_url_fields
-  { UF_SCHEMA           = 0
-  , UF_HOST             = 1
-  , UF_PORT             = 2
-  , UF_PATH             = 3
-  , UF_QUERY            = 4
-  , UF_FRAGMENT         = 5
-  , UF_USERINFO         = 6
-  , UF_MAX              = 7
-  };
-
-
-/* Result structure for http_parser_parse_url().
- *
- * Callers should index into field_data[] with UF_* values iff field_set
- * has the relevant (1 << UF_*) bit set. As a courtesy to clients (and
- * because we probably have padding left over), we convert any port to
- * a uint16_t.
- */
-struct http_parser_url {
-  uint16_t field_set;           /* Bitmask of (1 << UF_*) values */
-  uint16_t port;                /* Converted UF_PORT string */
-
-  struct {
-    uint16_t off;               /* Offset into buffer in which field starts */
-    uint16_t len;               /* Length of run in buffer */
-  } field_data[UF_MAX];
-};
-
-
-/* Returns the library version. Bits 16-23 contain the major version number,
- * bits 8-15 the minor version number and bits 0-7 the patch level.
- * Usage example:
- *
- *   unsigned long version = http_parser_version();
- *   unsigned major = (version >> 16) & 255;
- *   unsigned minor = (version >> 8) & 255;
- *   unsigned patch = version & 255;
- *   printf("http_parser v%u.%u.%u\n", major, minor, patch);
- */
-unsigned long http_parser_version(void);
-
-void http_parser_init(http_parser *parser, enum http_parser_type type);
-
-
-/* Initialize http_parser_settings members to 0
- */
-void http_parser_settings_init(http_parser_settings *settings);
-
-
-/* Executes the parser. Returns number of parsed bytes. Sets
- * `parser->http_errno` on error. */
-size_t http_parser_execute(http_parser *parser,
-                           const http_parser_settings *settings,
-                           const char *data,
-                           size_t len);
-
-
-/* If http_should_keep_alive() in the on_headers_complete or
- * on_message_complete callback returns 0, then this should be
- * the last message on the connection.
- * If you are the server, respond with the "Connection: close" header.
- * If you are the client, close the connection.
- */
-int http_should_keep_alive(const http_parser *parser);
-
-/* Returns a string version of the HTTP method. */
-const char *http_method_str(enum http_method m);
-
-/* Return a string name of the given error */
-const char *http_errno_name(enum http_errno err);
-
-/* Return a string description of the given error */
-const char *http_errno_description(enum http_errno err);
-
-/* Initialize all http_parser_url members to 0 */
-void http_parser_url_init(struct http_parser_url *u);
-
-/* Parse a URL; return nonzero on failure */
-int http_parser_parse_url(const char *buf, size_t buflen,
-                          int is_connect,
-                          struct http_parser_url *u);
-
-/* Pause or un-pause the parser; a nonzero value pauses */
-void http_parser_pause(http_parser *parser, int paused);
-
-/* Checks if this is the final chunk of the body. */
-int http_body_is_final(const http_parser *parser);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/npm/node_modules/node-gyp/addon.gypi
+++ /dev/null
@@ -1,116 +0,0 @@
-{
-  'target_defaults': {
-    'type': 'loadable_module',
-    'win_delay_load_hook': 'true',
-    'product_prefix': '',
-
-    'include_dirs': [
-      '<(node_root_dir)/include/node',
-      '<(node_root_dir)/src',
-      '<(node_root_dir)/deps/uv/include',
-      '<(node_root_dir)/deps/v8/include'
-    ],
-    'defines!': [
-      'BUILDING_UV_SHARED=1',  # Inherited from common.gypi.
-      'BUILDING_V8_SHARED=1',  # Inherited from common.gypi.
-    ],
-    'defines': [
-      'NODE_GYP_MODULE_NAME=>(_target_name)',
-      'USING_UV_SHARED=1',
-      'USING_V8_SHARED=1',
-      # Warn when using deprecated V8 APIs.
-      'V8_DEPRECATION_WARNINGS=1'
-    ],
-
-    'target_conditions': [
-      ['_type=="loadable_module"', {
-        'product_extension': 'node',
-        'defines': [
-          'BUILDING_NODE_EXTENSION'
-        ],
-        'xcode_settings': {
-          'OTHER_LDFLAGS': [
-            '-undefined dynamic_lookup'
-          ],
-        },
-      }],
-
-      ['_type=="static_library"', {
-        # set to `1` to *disable* the -T thin archive 'ld' flag.
-        # older linkers don't support this flag.
-        'standalone_static_library': '<(standalone_static_library)'
-      }],
-
-      ['_win_delay_load_hook=="true"', {
-        # If the addon specifies `'win_delay_load_hook': 'true'` in its
-        # binding.gyp, link a delay-load hook into the DLL. This hook ensures
-        # that the addon will work regardless of whether the node/iojs binary
-        # is named node.exe, iojs.exe, or something else.
-        'conditions': [
-          [ 'OS=="win"', {
-            'sources': [
-              '<(node_gyp_dir)/src/win_delay_load_hook.cc',
-            ],
-            'msvs_settings': {
-              'VCLinkerTool': {
-                'DelayLoadDLLs': [ 'iojs.exe', 'node.exe' ],
-                # Don't print a linker warning when no imports from either .exe
-                # are used.
-                'AdditionalOptions': [ '/ignore:4199' ],
-              },
-            },
-          }],
-        ],
-      }],
-    ],
-
-    'conditions': [
-      [ 'OS=="mac"', {
-        'defines': [
-          '_DARWIN_USE_64_BIT_INODE=1'
-        ],
-        'xcode_settings': {
-          'DYLIB_INSTALL_NAME_BASE': '@rpath'
-        },
-      }],
-      [ 'OS=="aix"', {
-        'ldflags': [
-          '-Wl,-bimport:<(node_exp_file)'
-        ],
-      }],
-      [ 'OS=="win"', {
-        'libraries': [
-          '-lkernel32.lib',
-          '-luser32.lib',
-          '-lgdi32.lib',
-          '-lwinspool.lib',
-          '-lcomdlg32.lib',
-          '-ladvapi32.lib',
-          '-lshell32.lib',
-          '-lole32.lib',
-          '-loleaut32.lib',
-          '-luuid.lib',
-          '-lodbc32.lib',
-          '-lDelayImp.lib',
-          '-l"<(node_root_dir)/$(ConfigurationName)/<(node_lib_file)"'
-        ],
-        'msvs_disabled_warnings': [
-          # warning C4251: 'node::ObjectWrap::handle_' : class 'v8::Persistent<T>'
-          # needs to have dll-interface to be used by
-          # clients of class 'node::ObjectWrap'
-          4251
-        ],
-      }, {
-        # OS!="win"
-        'defines': [
-          '_LARGEFILE_SOURCE',
-          '_FILE_OFFSET_BITS=64'
-        ],
-      }],
-      [ 'OS in "freebsd openbsd netbsd solaris" or \
-         (OS=="linux" and target_arch!="ia32")', {
-        'cflags': [ '-fPIC' ],
-      }]
-    ]
-  }
-}
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/common.gypi
+++ /dev/null
@@ -1,206 +0,0 @@
-{
-  'variables': {
-    'target_arch%': 'ia32',          # set v8's target architecture
-    'host_arch%': 'ia32',            # set v8's host architecture
-    'uv_library%': 'static_library', # allow override to 'shared_library' for DLL/.so builds
-    'msvs_multi_core_compile': '0',  # we do enable multicore compiles, but not using the V8 way
-  },
-
-  'target_defaults': {
-    'default_configuration': 'Debug',
-    'configurations': {
-      'Debug': {
-        'defines': [ 'DEBUG', '_DEBUG' ],
-        'cflags': [ '-g' ],
-        'msvs_settings': {
-          'VCCLCompilerTool': {
-            'target_conditions': [
-              ['uv_library=="static_library"', {
-                'RuntimeLibrary': 1, # static debug
-              }, {
-                'RuntimeLibrary': 3, # DLL debug
-              }],
-            ],
-            'Optimization': 0, # /Od, no optimization
-            'MinimalRebuild': 'false',
-            'OmitFramePointers': 'false',
-            'BasicRuntimeChecks': 3, # /RTC1
-          },
-          'VCLinkerTool': {
-            'LinkIncremental': 2, # enable incremental linking
-          },
-        },
-        'xcode_settings': {
-          'GCC_OPTIMIZATION_LEVEL': '0',
-          'OTHER_CFLAGS': [ '-Wno-strict-aliasing' ],
-        },
-        'conditions': [
-          ['OS != "os390"', {
-            'cflags': [ '-O0', '-fwrapv' ]
-          }],
-          ['OS == "android"', {
-            'cflags': [ '-fPIE' ],
-            'ldflags': [ '-fPIE', '-pie' ]
-          }]
-        ]
-      },
-      'Release': {
-        'defines': [ 'NDEBUG' ],
-        'cflags': [
-          '-O3',
-          '-fstrict-aliasing',
-          '-fomit-frame-pointer',
-          '-fdata-sections',
-          '-ffunction-sections',
-        ],
-        'msvs_settings': {
-          'VCCLCompilerTool': {
-            'target_conditions': [
-              ['uv_library=="static_library"', {
-                'RuntimeLibrary': 0, # static release
-              }, {
-                'RuntimeLibrary': 2, # debug release
-              }],
-            ],
-            'Optimization': 3, # /Ox, full optimization
-            'FavorSizeOrSpeed': 1, # /Ot, favour speed over size
-            'InlineFunctionExpansion': 2, # /Ob2, inline anything eligible
-            'WholeProgramOptimization': 'true', # /GL, whole program optimization, needed for LTCG
-            'OmitFramePointers': 'true',
-            'EnableFunctionLevelLinking': 'true',
-            'EnableIntrinsicFunctions': 'true',
-          },
-          'VCLibrarianTool': {
-            'AdditionalOptions': [
-              '/LTCG', # link time code generation
-            ],
-          },
-          'VCLinkerTool': {
-            'LinkTimeCodeGeneration': 1, # link-time code generation
-            'OptimizeReferences': 2, # /OPT:REF
-            'EnableCOMDATFolding': 2, # /OPT:ICF
-            'LinkIncremental': 1, # disable incremental linking
-          },
-        },
-      }
-    },
-    'msvs_settings': {
-      'VCCLCompilerTool': {
-        'StringPooling': 'true', # pool string literals
-        'DebugInformationFormat': 3, # Generate a PDB
-        'WarningLevel': 3,
-        'BufferSecurityCheck': 'true',
-        'ExceptionHandling': 1, # /EHsc
-        'SuppressStartupBanner': 'true',
-        'WarnAsError': 'false',
-        'AdditionalOptions': [
-           '/MP', # compile across multiple CPUs
-         ],
-      },
-      'VCLibrarianTool': {
-      },
-      'VCLinkerTool': {
-        'GenerateDebugInformation': 'true',
-        'RandomizedBaseAddress': 2, # enable ASLR
-        'DataExecutionPrevention': 2, # enable DEP
-        'AllowIsolation': 'true',
-        'SuppressStartupBanner': 'true',
-        'target_conditions': [
-          ['_type=="executable"', {
-            'SubSystem': 1, # console executable
-          }],
-        ],
-      },
-    },
-    'conditions': [
-      ['OS == "win"', {
-        'msvs_cygwin_shell': 0, # prevent actions from trying to use cygwin
-        'defines': [
-          'WIN32',
-          # we don't really want VC++ warning us about
-          # how dangerous C functions are...
-          '_CRT_SECURE_NO_DEPRECATE',
-          # ... or that C implementations shouldn't use
-          # POSIX names
-          '_CRT_NONSTDC_NO_DEPRECATE',
-        ],
-        'target_conditions': [
-          ['target_arch=="x64"', {
-            'msvs_configuration_platform': 'x64'
-          }]
-        ]
-      }],
-      ['OS in "freebsd dragonflybsd linux openbsd solaris android"', {
-        'cflags': [ '-Wall' ],
-        'cflags_cc': [ '-fno-rtti', '-fno-exceptions' ],
-        'target_conditions': [
-          ['_type=="static_library"', {
-            'standalone_static_library': 1, # disable thin archive which needs binutils >= 2.19
-          }],
-        ],
-        'conditions': [
-          [ 'host_arch != target_arch and target_arch=="ia32"', {
-            'cflags': [ '-m32' ],
-            'ldflags': [ '-m32' ],
-          }],
-          [ 'target_arch=="x32"', {
-            'cflags': [ '-mx32' ],
-            'ldflags': [ '-mx32' ],
-          }],
-          [ 'OS=="linux"', {
-            'cflags': [ '-ansi' ],
-          }],
-          [ 'OS=="solaris"', {
-            'cflags': [ '-pthreads' ],
-            'ldflags': [ '-pthreads' ],
-          }],
-          [ 'OS not in "solaris android os390"', {
-            'cflags': [ '-pthread' ],
-            'ldflags': [ '-pthread' ],
-          }],
-        ],
-      }],
-      ['OS=="mac"', {
-        'xcode_settings': {
-          'ALWAYS_SEARCH_USER_PATHS': 'NO',
-          'GCC_CW_ASM_SYNTAX': 'NO',                # No -fasm-blocks
-          'GCC_DYNAMIC_NO_PIC': 'NO',               # No -mdynamic-no-pic
-                                                    # (Equivalent to -fPIC)
-          'GCC_ENABLE_CPP_EXCEPTIONS': 'NO',        # -fno-exceptions
-          'GCC_ENABLE_CPP_RTTI': 'NO',              # -fno-rtti
-          'GCC_ENABLE_PASCAL_STRINGS': 'NO',        # No -mpascal-strings
-          'GCC_THREADSAFE_STATICS': 'NO',           # -fno-threadsafe-statics
-          'PREBINDING': 'NO',                       # No -Wl,-prebind
-          'USE_HEADERMAP': 'NO',
-          'OTHER_CFLAGS': [
-            '-fstrict-aliasing',
-          ],
-          'WARNING_CFLAGS': [
-            '-Wall',
-            '-Wendif-labels',
-            '-W',
-            '-Wno-unused-parameter',
-          ],
-        },
-        'conditions': [
-          ['target_arch=="ia32"', {
-            'xcode_settings': {'ARCHS': ['i386']},
-          }],
-          ['target_arch=="x64"', {
-            'xcode_settings': {'ARCHS': ['x86_64']},
-          }],
-        ],
-        'target_conditions': [
-          ['_type!="static_library"', {
-            'xcode_settings': {'OTHER_LDFLAGS': ['-Wl,-search_paths_first']},
-          }],
-        ],
-      }],
-     ['OS=="solaris"', {
-       'cflags': [ '-fno-omit-frame-pointer' ],
-       # pull in V8's postmortem metadata
-       'ldflags': [ '-Wl,-z,allextract' ]
-     }],
-    ],
-  },
-}
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/include/android-ifaddrs.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (c) 1995, 1999
- *	Berkeley Software Design, Inc.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * THIS SOFTWARE IS PROVIDED BY Berkeley Software Design, Inc. ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL Berkeley Software Design, Inc. BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	BSDI ifaddrs.h,v 2.5 2000/02/23 14:51:59 dab Exp
- */
-
-#ifndef	_IFADDRS_H_
-#define	_IFADDRS_H_
-
-struct ifaddrs {
-	struct ifaddrs  *ifa_next;
-	char		*ifa_name;
-	unsigned int	 ifa_flags;
-	struct sockaddr	*ifa_addr;
-	struct sockaddr	*ifa_netmask;
-	struct sockaddr	*ifa_dstaddr;
-	void		*ifa_data;
-};
-
-/*
- * This may have been defined in <net/if.h>.  Note that if <net/if.h> is
- * to be included it must be included before this header file.
- */
-#ifndef	ifa_broadaddr
-#define	ifa_broadaddr	ifa_dstaddr	/* broadcast address interface */
-#endif
-
-#include <sys/cdefs.h>
-
-__BEGIN_DECLS
-extern int getifaddrs(struct ifaddrs **ifap);
-extern void freeifaddrs(struct ifaddrs *ifa);
-__END_DECLS
-
-#endif
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/include/pthread-barrier.h
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
-Copyright (c) 2016, Kari Tristan Helgason <kthelgason@gmail.com>
-
-Permission to use, copy, modify, and/or distribute this software for any
-purpose with or without fee is hereby granted, provided that the above
-copyright notice and this permission notice appear in all copies.
-
-THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
-WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
-MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
-ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
-WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
-ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
-OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-*/
-
-#ifndef _UV_PTHREAD_BARRIER_
-#define _UV_PTHREAD_BARRIER_
-#include <errno.h>
-#include <pthread.h>
-#if !defined(__MVS__)
-#include <semaphore.h> /* sem_t */
-#endif
-
-#define PTHREAD_BARRIER_SERIAL_THREAD  0x12345
-
-/*
- * To maintain ABI compatibility with
- * libuv v1.x struct is padded according
- * to target platform
- */
-#if defined(__ANDROID__)
-# define UV_BARRIER_STRUCT_PADDING \
-  sizeof(pthread_mutex_t) + \
-  sizeof(pthread_cond_t) + \
-  sizeof(unsigned int) - \
-  sizeof(void *)
-#elif defined(__APPLE__)
-# define UV_BARRIER_STRUCT_PADDING \
-  sizeof(pthread_mutex_t) + \
-  2 * sizeof(sem_t) + \
-  2 * sizeof(unsigned int) - \
-  sizeof(void *)
-#else
-# define UV_BARRIER_STRUCT_PADDING 0
-#endif
-
-typedef struct {
-  pthread_mutex_t  mutex;
-  pthread_cond_t   cond;
-  unsigned         threshold;
-  unsigned         in;
-  unsigned         out;
-} _uv_barrier;
-
-typedef struct {
-  _uv_barrier* b;
-  char _pad[UV_BARRIER_STRUCT_PADDING];
-} pthread_barrier_t;
-
-int pthread_barrier_init(pthread_barrier_t* barrier,
-                         const void* barrier_attr,
-                         unsigned count);
-
-int pthread_barrier_wait(pthread_barrier_t* barrier);
-int pthread_barrier_destroy(pthread_barrier_t *barrier);
-
-#endif /* _UV_PTHREAD_BARRIER_ */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/include/stdint-msvc2008.h
+++ /dev/null
@@ -1,247 +0,0 @@
-// ISO C9x  compliant stdint.h for Microsoft Visual Studio
-// Based on ISO/IEC 9899:TC2 Committee draft (May 6, 2005) WG14/N1124 
-// 
-//  Copyright (c) 2006-2008 Alexander Chemeris
-// 
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are met:
-// 
-//   1. Redistributions of source code must retain the above copyright notice,
-//      this list of conditions and the following disclaimer.
-// 
-//   2. Redistributions in binary form must reproduce the above copyright
-//      notice, this list of conditions and the following disclaimer in the
-//      documentation and/or other materials provided with the distribution.
-// 
-//   3. The name of the author may be used to endorse or promote products
-//      derived from this software without specific prior written permission.
-// 
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
-// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
-// EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
-// OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
-// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
-// OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
-// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-// 
-///////////////////////////////////////////////////////////////////////////////
-
-#ifndef _MSC_VER // [
-#error "Use this header only with Microsoft Visual C++ compilers!"
-#endif // _MSC_VER ]
-
-#ifndef _MSC_STDINT_H_ // [
-#define _MSC_STDINT_H_
-
-#if _MSC_VER > 1000
-#pragma once
-#endif
-
-#include <limits.h>
-
-// For Visual Studio 6 in C++ mode and for many Visual Studio versions when
-// compiling for ARM we should wrap <wchar.h> include with 'extern "C++" {}'
-// or compiler give many errors like this:
-//   error C2733: second C linkage of overloaded function 'wmemchr' not allowed
-#ifdef __cplusplus
-extern "C" {
-#endif
-#  include <wchar.h>
-#ifdef __cplusplus
-}
-#endif
-
-// Define _W64 macros to mark types changing their size, like intptr_t.
-#ifndef _W64
-#  if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
-#     define _W64 __w64
-#  else
-#     define _W64
-#  endif
-#endif
-
-
-// 7.18.1 Integer types
-
-// 7.18.1.1 Exact-width integer types
-
-// Visual Studio 6 and Embedded Visual C++ 4 doesn't
-// realize that, e.g. char has the same size as __int8
-// so we give up on __intX for them.
-#if (_MSC_VER < 1300)
-   typedef signed char       int8_t;
-   typedef signed short      int16_t;
-   typedef signed int        int32_t;
-   typedef unsigned char     uint8_t;
-   typedef unsigned short    uint16_t;
-   typedef unsigned int      uint32_t;
-#else
-   typedef signed __int8     int8_t;
-   typedef signed __int16    int16_t;
-   typedef signed __int32    int32_t;
-   typedef unsigned __int8   uint8_t;
-   typedef unsigned __int16  uint16_t;
-   typedef unsigned __int32  uint32_t;
-#endif
-typedef signed __int64       int64_t;
-typedef unsigned __int64     uint64_t;
-
-
-// 7.18.1.2 Minimum-width integer types
-typedef int8_t    int_least8_t;
-typedef int16_t   int_least16_t;
-typedef int32_t   int_least32_t;
-typedef int64_t   int_least64_t;
-typedef uint8_t   uint_least8_t;
-typedef uint16_t  uint_least16_t;
-typedef uint32_t  uint_least32_t;
-typedef uint64_t  uint_least64_t;
-
-// 7.18.1.3 Fastest minimum-width integer types
-typedef int8_t    int_fast8_t;
-typedef int16_t   int_fast16_t;
-typedef int32_t   int_fast32_t;
-typedef int64_t   int_fast64_t;
-typedef uint8_t   uint_fast8_t;
-typedef uint16_t  uint_fast16_t;
-typedef uint32_t  uint_fast32_t;
-typedef uint64_t  uint_fast64_t;
-
-// 7.18.1.4 Integer types capable of holding object pointers
-#ifdef _WIN64 // [
-   typedef signed __int64    intptr_t;
-   typedef unsigned __int64  uintptr_t;
-#else // _WIN64 ][
-   typedef _W64 signed int   intptr_t;
-   typedef _W64 unsigned int uintptr_t;
-#endif // _WIN64 ]
-
-// 7.18.1.5 Greatest-width integer types
-typedef int64_t   intmax_t;
-typedef uint64_t  uintmax_t;
-
-
-// 7.18.2 Limits of specified-width integer types
-
-#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS) // [   See footnote 220 at page 257 and footnote 221 at page 259
-
-// 7.18.2.1 Limits of exact-width integer types
-#define INT8_MIN     ((int8_t)_I8_MIN)
-#define INT8_MAX     _I8_MAX
-#define INT16_MIN    ((int16_t)_I16_MIN)
-#define INT16_MAX    _I16_MAX
-#define INT32_MIN    ((int32_t)_I32_MIN)
-#define INT32_MAX    _I32_MAX
-#define INT64_MIN    ((int64_t)_I64_MIN)
-#define INT64_MAX    _I64_MAX
-#define UINT8_MAX    _UI8_MAX
-#define UINT16_MAX   _UI16_MAX
-#define UINT32_MAX   _UI32_MAX
-#define UINT64_MAX   _UI64_MAX
-
-// 7.18.2.2 Limits of minimum-width integer types
-#define INT_LEAST8_MIN    INT8_MIN
-#define INT_LEAST8_MAX    INT8_MAX
-#define INT_LEAST16_MIN   INT16_MIN
-#define INT_LEAST16_MAX   INT16_MAX
-#define INT_LEAST32_MIN   INT32_MIN
-#define INT_LEAST32_MAX   INT32_MAX
-#define INT_LEAST64_MIN   INT64_MIN
-#define INT_LEAST64_MAX   INT64_MAX
-#define UINT_LEAST8_MAX   UINT8_MAX
-#define UINT_LEAST16_MAX  UINT16_MAX
-#define UINT_LEAST32_MAX  UINT32_MAX
-#define UINT_LEAST64_MAX  UINT64_MAX
-
-// 7.18.2.3 Limits of fastest minimum-width integer types
-#define INT_FAST8_MIN    INT8_MIN
-#define INT_FAST8_MAX    INT8_MAX
-#define INT_FAST16_MIN   INT16_MIN
-#define INT_FAST16_MAX   INT16_MAX
-#define INT_FAST32_MIN   INT32_MIN
-#define INT_FAST32_MAX   INT32_MAX
-#define INT_FAST64_MIN   INT64_MIN
-#define INT_FAST64_MAX   INT64_MAX
-#define UINT_FAST8_MAX   UINT8_MAX
-#define UINT_FAST16_MAX  UINT16_MAX
-#define UINT_FAST32_MAX  UINT32_MAX
-#define UINT_FAST64_MAX  UINT64_MAX
-
-// 7.18.2.4 Limits of integer types capable of holding object pointers
-#ifdef _WIN64 // [
-#  define INTPTR_MIN   INT64_MIN
-#  define INTPTR_MAX   INT64_MAX
-#  define UINTPTR_MAX  UINT64_MAX
-#else // _WIN64 ][
-#  define INTPTR_MIN   INT32_MIN
-#  define INTPTR_MAX   INT32_MAX
-#  define UINTPTR_MAX  UINT32_MAX
-#endif // _WIN64 ]
-
-// 7.18.2.5 Limits of greatest-width integer types
-#define INTMAX_MIN   INT64_MIN
-#define INTMAX_MAX   INT64_MAX
-#define UINTMAX_MAX  UINT64_MAX
-
-// 7.18.3 Limits of other integer types
-
-#ifdef _WIN64 // [
-#  define PTRDIFF_MIN  _I64_MIN
-#  define PTRDIFF_MAX  _I64_MAX
-#else  // _WIN64 ][
-#  define PTRDIFF_MIN  _I32_MIN
-#  define PTRDIFF_MAX  _I32_MAX
-#endif  // _WIN64 ]
-
-#define SIG_ATOMIC_MIN  INT_MIN
-#define SIG_ATOMIC_MAX  INT_MAX
-
-#ifndef SIZE_MAX // [
-#  ifdef _WIN64 // [
-#     define SIZE_MAX  _UI64_MAX
-#  else // _WIN64 ][
-#     define SIZE_MAX  _UI32_MAX
-#  endif // _WIN64 ]
-#endif // SIZE_MAX ]
-
-// WCHAR_MIN and WCHAR_MAX are also defined in <wchar.h>
-#ifndef WCHAR_MIN // [
-#  define WCHAR_MIN  0
-#endif  // WCHAR_MIN ]
-#ifndef WCHAR_MAX // [
-#  define WCHAR_MAX  _UI16_MAX
-#endif  // WCHAR_MAX ]
-
-#define WINT_MIN  0
-#define WINT_MAX  _UI16_MAX
-
-#endif // __STDC_LIMIT_MACROS ]
-
-
-// 7.18.4 Limits of other integer types
-
-#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS) // [   See footnote 224 at page 260
-
-// 7.18.4.1 Macros for minimum-width integer constants
-
-#define INT8_C(val)  val##i8
-#define INT16_C(val) val##i16
-#define INT32_C(val) val##i32
-#define INT64_C(val) val##i64
-
-#define UINT8_C(val)  val##ui8
-#define UINT16_C(val) val##ui16
-#define UINT32_C(val) val##ui32
-#define UINT64_C(val) val##ui64
-
-// 7.18.4.2 Macros for greatest-width integer constants
-#define INTMAX_C   INT64_C
-#define UINTMAX_C  UINT64_C
-
-#endif // __STDC_CONSTANT_MACROS ]
-
-
-#endif // _MSC_STDINT_H_ ]
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/include/tree.h
+++ /dev/null
@@ -1,768 +0,0 @@
-/*-
- * Copyright 2002 Niels Provos <provos@citi.umich.edu>
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef  UV_TREE_H_
-#define  UV_TREE_H_
-
-#ifndef UV__UNUSED
-# if __GNUC__
-#  define UV__UNUSED __attribute__((unused))
-# else
-#  define UV__UNUSED
-# endif
-#endif
-
-/*
- * This file defines data structures for different types of trees:
- * splay trees and red-black trees.
- *
- * A splay tree is a self-organizing data structure.  Every operation
- * on the tree causes a splay to happen.  The splay moves the requested
- * node to the root of the tree and partly rebalances it.
- *
- * This has the benefit that request locality causes faster lookups as
- * the requested nodes move to the top of the tree.  On the other hand,
- * every lookup causes memory writes.
- *
- * The Balance Theorem bounds the total access time for m operations
- * and n inserts on an initially empty tree as O((m + n)lg n).  The
- * amortized cost for a sequence of m accesses to a splay tree is O(lg n);
- *
- * A red-black tree is a binary search tree with the node color as an
- * extra attribute.  It fulfills a set of conditions:
- *  - every search path from the root to a leaf consists of the
- *    same number of black nodes,
- *  - each red node (except for the root) has a black parent,
- *  - each leaf node is black.
- *
- * Every operation on a red-black tree is bounded as O(lg n).
- * The maximum height of a red-black tree is 2lg (n+1).
- */
-
-#define SPLAY_HEAD(name, type)                                                \
-struct name {                                                                 \
-  struct type *sph_root; /* root of the tree */                               \
-}
-
-#define SPLAY_INITIALIZER(root)                                               \
-  { NULL }
-
-#define SPLAY_INIT(root) do {                                                 \
-  (root)->sph_root = NULL;                                                    \
-} while (/*CONSTCOND*/ 0)
-
-#define SPLAY_ENTRY(type)                                                     \
-struct {                                                                      \
-  struct type *spe_left;          /* left element */                          \
-  struct type *spe_right;         /* right element */                         \
-}
-
-#define SPLAY_LEFT(elm, field)    (elm)->field.spe_left
-#define SPLAY_RIGHT(elm, field)   (elm)->field.spe_right
-#define SPLAY_ROOT(head)          (head)->sph_root
-#define SPLAY_EMPTY(head)         (SPLAY_ROOT(head) == NULL)
-
-/* SPLAY_ROTATE_{LEFT,RIGHT} expect that tmp hold SPLAY_{RIGHT,LEFT} */
-#define SPLAY_ROTATE_RIGHT(head, tmp, field) do {                             \
-  SPLAY_LEFT((head)->sph_root, field) = SPLAY_RIGHT(tmp, field);              \
-  SPLAY_RIGHT(tmp, field) = (head)->sph_root;                                 \
-  (head)->sph_root = tmp;                                                     \
-} while (/*CONSTCOND*/ 0)
-
-#define SPLAY_ROTATE_LEFT(head, tmp, field) do {                              \
-  SPLAY_RIGHT((head)->sph_root, field) = SPLAY_LEFT(tmp, field);              \
-  SPLAY_LEFT(tmp, field) = (head)->sph_root;                                  \
-  (head)->sph_root = tmp;                                                     \
-} while (/*CONSTCOND*/ 0)
-
-#define SPLAY_LINKLEFT(head, tmp, field) do {                                 \
-  SPLAY_LEFT(tmp, field) = (head)->sph_root;                                  \
-  tmp = (head)->sph_root;                                                     \
-  (head)->sph_root = SPLAY_LEFT((head)->sph_root, field);                     \
-} while (/*CONSTCOND*/ 0)
-
-#define SPLAY_LINKRIGHT(head, tmp, field) do {                                \
-  SPLAY_RIGHT(tmp, field) = (head)->sph_root;                                 \
-  tmp = (head)->sph_root;                                                     \
-  (head)->sph_root = SPLAY_RIGHT((head)->sph_root, field);                    \
-} while (/*CONSTCOND*/ 0)
-
-#define SPLAY_ASSEMBLE(head, node, left, right, field) do {                   \
-  SPLAY_RIGHT(left, field) = SPLAY_LEFT((head)->sph_root, field);             \
-  SPLAY_LEFT(right, field) = SPLAY_RIGHT((head)->sph_root, field);            \
-  SPLAY_LEFT((head)->sph_root, field) = SPLAY_RIGHT(node, field);             \
-  SPLAY_RIGHT((head)->sph_root, field) = SPLAY_LEFT(node, field);             \
-} while (/*CONSTCOND*/ 0)
-
-/* Generates prototypes and inline functions */
-
-#define SPLAY_PROTOTYPE(name, type, field, cmp)                               \
-void name##_SPLAY(struct name *, struct type *);                              \
-void name##_SPLAY_MINMAX(struct name *, int);                                 \
-struct type *name##_SPLAY_INSERT(struct name *, struct type *);               \
-struct type *name##_SPLAY_REMOVE(struct name *, struct type *);               \
-                                                                              \
-/* Finds the node with the same key as elm */                                 \
-static __inline struct type *                                                 \
-name##_SPLAY_FIND(struct name *head, struct type *elm)                        \
-{                                                                             \
-  if (SPLAY_EMPTY(head))                                                      \
-    return(NULL);                                                             \
-  name##_SPLAY(head, elm);                                                    \
-  if ((cmp)(elm, (head)->sph_root) == 0)                                      \
-    return (head->sph_root);                                                  \
-  return (NULL);                                                              \
-}                                                                             \
-                                                                              \
-static __inline struct type *                                                 \
-name##_SPLAY_NEXT(struct name *head, struct type *elm)                        \
-{                                                                             \
-  name##_SPLAY(head, elm);                                                    \
-  if (SPLAY_RIGHT(elm, field) != NULL) {                                      \
-    elm = SPLAY_RIGHT(elm, field);                                            \
-    while (SPLAY_LEFT(elm, field) != NULL) {                                  \
-      elm = SPLAY_LEFT(elm, field);                                           \
-    }                                                                         \
-  } else                                                                      \
-    elm = NULL;                                                               \
-  return (elm);                                                               \
-}                                                                             \
-                                                                              \
-static __inline struct type *                                                 \
-name##_SPLAY_MIN_MAX(struct name *head, int val)                              \
-{                                                                             \
-  name##_SPLAY_MINMAX(head, val);                                             \
-  return (SPLAY_ROOT(head));                                                  \
-}
-
-/* Main splay operation.
- * Moves node close to the key of elm to top
- */
-#define SPLAY_GENERATE(name, type, field, cmp)                                \
-struct type *                                                                 \
-name##_SPLAY_INSERT(struct name *head, struct type *elm)                      \
-{                                                                             \
-    if (SPLAY_EMPTY(head)) {                                                  \
-      SPLAY_LEFT(elm, field) = SPLAY_RIGHT(elm, field) = NULL;                \
-    } else {                                                                  \
-      int __comp;                                                             \
-      name##_SPLAY(head, elm);                                                \
-      __comp = (cmp)(elm, (head)->sph_root);                                  \
-      if(__comp < 0) {                                                        \
-        SPLAY_LEFT(elm, field) = SPLAY_LEFT((head)->sph_root, field);         \
-        SPLAY_RIGHT(elm, field) = (head)->sph_root;                           \
-        SPLAY_LEFT((head)->sph_root, field) = NULL;                           \
-      } else if (__comp > 0) {                                                \
-        SPLAY_RIGHT(elm, field) = SPLAY_RIGHT((head)->sph_root, field);       \
-        SPLAY_LEFT(elm, field) = (head)->sph_root;                            \
-        SPLAY_RIGHT((head)->sph_root, field) = NULL;                          \
-      } else                                                                  \
-        return ((head)->sph_root);                                            \
-    }                                                                         \
-    (head)->sph_root = (elm);                                                 \
-    return (NULL);                                                            \
-}                                                                             \
-                                                                              \
-struct type *                                                                 \
-name##_SPLAY_REMOVE(struct name *head, struct type *elm)                      \
-{                                                                             \
-  struct type *__tmp;                                                         \
-  if (SPLAY_EMPTY(head))                                                      \
-    return (NULL);                                                            \
-  name##_SPLAY(head, elm);                                                    \
-  if ((cmp)(elm, (head)->sph_root) == 0) {                                    \
-    if (SPLAY_LEFT((head)->sph_root, field) == NULL) {                        \
-      (head)->sph_root = SPLAY_RIGHT((head)->sph_root, field);                \
-    } else {                                                                  \
-      __tmp = SPLAY_RIGHT((head)->sph_root, field);                           \
-      (head)->sph_root = SPLAY_LEFT((head)->sph_root, field);                 \
-      name##_SPLAY(head, elm);                                                \
-      SPLAY_RIGHT((head)->sph_root, field) = __tmp;                           \
-    }                                                                         \
-    return (elm);                                                             \
-  }                                                                           \
-  return (NULL);                                                              \
-}                                                                             \
-                                                                              \
-void                                                                          \
-name##_SPLAY(struct name *head, struct type *elm)                             \
-{                                                                             \
-  struct type __node, *__left, *__right, *__tmp;                              \
-  int __comp;                                                                 \
-                                                                              \
-  SPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;            \
-  __left = __right = &__node;                                                 \
-                                                                              \
-  while ((__comp = (cmp)(elm, (head)->sph_root)) != 0) {                      \
-    if (__comp < 0) {                                                         \
-      __tmp = SPLAY_LEFT((head)->sph_root, field);                            \
-      if (__tmp == NULL)                                                      \
-        break;                                                                \
-      if ((cmp)(elm, __tmp) < 0){                                             \
-        SPLAY_ROTATE_RIGHT(head, __tmp, field);                               \
-        if (SPLAY_LEFT((head)->sph_root, field) == NULL)                      \
-          break;                                                              \
-      }                                                                       \
-      SPLAY_LINKLEFT(head, __right, field);                                   \
-    } else if (__comp > 0) {                                                  \
-      __tmp = SPLAY_RIGHT((head)->sph_root, field);                           \
-      if (__tmp == NULL)                                                      \
-        break;                                                                \
-      if ((cmp)(elm, __tmp) > 0){                                             \
-        SPLAY_ROTATE_LEFT(head, __tmp, field);                                \
-        if (SPLAY_RIGHT((head)->sph_root, field) == NULL)                     \
-          break;                                                              \
-      }                                                                       \
-      SPLAY_LINKRIGHT(head, __left, field);                                   \
-    }                                                                         \
-  }                                                                           \
-  SPLAY_ASSEMBLE(head, &__node, __left, __right, field);                      \
-}                                                                             \
-                                                                              \
-/* Splay with either the minimum or the maximum element                       \
- * Used to find minimum or maximum element in tree.                           \
- */                                                                           \
-void name##_SPLAY_MINMAX(struct name *head, int __comp)                       \
-{                                                                             \
-  struct type __node, *__left, *__right, *__tmp;                              \
-                                                                              \
-  SPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;            \
-  __left = __right = &__node;                                                 \
-                                                                              \
-  while (1) {                                                                 \
-    if (__comp < 0) {                                                         \
-      __tmp = SPLAY_LEFT((head)->sph_root, field);                            \
-      if (__tmp == NULL)                                                      \
-        break;                                                                \
-      if (__comp < 0){                                                        \
-        SPLAY_ROTATE_RIGHT(head, __tmp, field);                               \
-        if (SPLAY_LEFT((head)->sph_root, field) == NULL)                      \
-          break;                                                              \
-      }                                                                       \
-      SPLAY_LINKLEFT(head, __right, field);                                   \
-    } else if (__comp > 0) {                                                  \
-      __tmp = SPLAY_RIGHT((head)->sph_root, field);                           \
-      if (__tmp == NULL)                                                      \
-        break;                                                                \
-      if (__comp > 0) {                                                       \
-        SPLAY_ROTATE_LEFT(head, __tmp, field);                                \
-        if (SPLAY_RIGHT((head)->sph_root, field) == NULL)                     \
-          break;                                                              \
-      }                                                                       \
-      SPLAY_LINKRIGHT(head, __left, field);                                   \
-    }                                                                         \
-  }                                                                           \
-  SPLAY_ASSEMBLE(head, &__node, __left, __right, field);                      \
-}
-
-#define SPLAY_NEGINF  -1
-#define SPLAY_INF     1
-
-#define SPLAY_INSERT(name, x, y)  name##_SPLAY_INSERT(x, y)
-#define SPLAY_REMOVE(name, x, y)  name##_SPLAY_REMOVE(x, y)
-#define SPLAY_FIND(name, x, y)    name##_SPLAY_FIND(x, y)
-#define SPLAY_NEXT(name, x, y)    name##_SPLAY_NEXT(x, y)
-#define SPLAY_MIN(name, x)        (SPLAY_EMPTY(x) ? NULL                      \
-                                  : name##_SPLAY_MIN_MAX(x, SPLAY_NEGINF))
-#define SPLAY_MAX(name, x)        (SPLAY_EMPTY(x) ? NULL                      \
-                                  : name##_SPLAY_MIN_MAX(x, SPLAY_INF))
-
-#define SPLAY_FOREACH(x, name, head)                                          \
-  for ((x) = SPLAY_MIN(name, head);                                           \
-       (x) != NULL;                                                           \
-       (x) = SPLAY_NEXT(name, head, x))
-
-/* Macros that define a red-black tree */
-#define RB_HEAD(name, type)                                                   \
-struct name {                                                                 \
-  struct type *rbh_root; /* root of the tree */                               \
-}
-
-#define RB_INITIALIZER(root)                                                  \
-  { NULL }
-
-#define RB_INIT(root) do {                                                    \
-  (root)->rbh_root = NULL;                                                    \
-} while (/*CONSTCOND*/ 0)
-
-#define RB_BLACK  0
-#define RB_RED    1
-#define RB_ENTRY(type)                                                        \
-struct {                                                                      \
-  struct type *rbe_left;        /* left element */                            \
-  struct type *rbe_right;       /* right element */                           \
-  struct type *rbe_parent;      /* parent element */                          \
-  int rbe_color;                /* node color */                              \
-}
-
-#define RB_LEFT(elm, field)     (elm)->field.rbe_left
-#define RB_RIGHT(elm, field)    (elm)->field.rbe_right
-#define RB_PARENT(elm, field)   (elm)->field.rbe_parent
-#define RB_COLOR(elm, field)    (elm)->field.rbe_color
-#define RB_ROOT(head)           (head)->rbh_root
-#define RB_EMPTY(head)          (RB_ROOT(head) == NULL)
-
-#define RB_SET(elm, parent, field) do {                                       \
-  RB_PARENT(elm, field) = parent;                                             \
-  RB_LEFT(elm, field) = RB_RIGHT(elm, field) = NULL;                          \
-  RB_COLOR(elm, field) = RB_RED;                                              \
-} while (/*CONSTCOND*/ 0)
-
-#define RB_SET_BLACKRED(black, red, field) do {                               \
-  RB_COLOR(black, field) = RB_BLACK;                                          \
-  RB_COLOR(red, field) = RB_RED;                                              \
-} while (/*CONSTCOND*/ 0)
-
-#ifndef RB_AUGMENT
-#define RB_AUGMENT(x)  do {} while (0)
-#endif
-
-#define RB_ROTATE_LEFT(head, elm, tmp, field) do {                            \
-  (tmp) = RB_RIGHT(elm, field);                                               \
-  if ((RB_RIGHT(elm, field) = RB_LEFT(tmp, field)) != NULL) {                 \
-    RB_PARENT(RB_LEFT(tmp, field), field) = (elm);                            \
-  }                                                                           \
-  RB_AUGMENT(elm);                                                            \
-  if ((RB_PARENT(tmp, field) = RB_PARENT(elm, field)) != NULL) {              \
-    if ((elm) == RB_LEFT(RB_PARENT(elm, field), field))                       \
-      RB_LEFT(RB_PARENT(elm, field), field) = (tmp);                          \
-    else                                                                      \
-      RB_RIGHT(RB_PARENT(elm, field), field) = (tmp);                         \
-  } else                                                                      \
-    (head)->rbh_root = (tmp);                                                 \
-  RB_LEFT(tmp, field) = (elm);                                                \
-  RB_PARENT(elm, field) = (tmp);                                              \
-  RB_AUGMENT(tmp);                                                            \
-  if ((RB_PARENT(tmp, field)))                                                \
-    RB_AUGMENT(RB_PARENT(tmp, field));                                        \
-} while (/*CONSTCOND*/ 0)
-
-#define RB_ROTATE_RIGHT(head, elm, tmp, field) do {                           \
-  (tmp) = RB_LEFT(elm, field);                                                \
-  if ((RB_LEFT(elm, field) = RB_RIGHT(tmp, field)) != NULL) {                 \
-    RB_PARENT(RB_RIGHT(tmp, field), field) = (elm);                           \
-  }                                                                           \
-  RB_AUGMENT(elm);                                                            \
-  if ((RB_PARENT(tmp, field) = RB_PARENT(elm, field)) != NULL) {              \
-    if ((elm) == RB_LEFT(RB_PARENT(elm, field), field))                       \
-      RB_LEFT(RB_PARENT(elm, field), field) = (tmp);                          \
-    else                                                                      \
-      RB_RIGHT(RB_PARENT(elm, field), field) = (tmp);                         \
-  } else                                                                      \
-    (head)->rbh_root = (tmp);                                                 \
-  RB_RIGHT(tmp, field) = (elm);                                               \
-  RB_PARENT(elm, field) = (tmp);                                              \
-  RB_AUGMENT(tmp);                                                            \
-  if ((RB_PARENT(tmp, field)))                                                \
-    RB_AUGMENT(RB_PARENT(tmp, field));                                        \
-} while (/*CONSTCOND*/ 0)
-
-/* Generates prototypes and inline functions */
-#define  RB_PROTOTYPE(name, type, field, cmp)                                 \
-  RB_PROTOTYPE_INTERNAL(name, type, field, cmp,)
-#define  RB_PROTOTYPE_STATIC(name, type, field, cmp)                          \
-  RB_PROTOTYPE_INTERNAL(name, type, field, cmp, UV__UNUSED static)
-#define RB_PROTOTYPE_INTERNAL(name, type, field, cmp, attr)                   \
-attr void name##_RB_INSERT_COLOR(struct name *, struct type *);               \
-attr void name##_RB_REMOVE_COLOR(struct name *, struct type *, struct type *);\
-attr struct type *name##_RB_REMOVE(struct name *, struct type *);             \
-attr struct type *name##_RB_INSERT(struct name *, struct type *);             \
-attr struct type *name##_RB_FIND(struct name *, struct type *);               \
-attr struct type *name##_RB_NFIND(struct name *, struct type *);              \
-attr struct type *name##_RB_NEXT(struct type *);                              \
-attr struct type *name##_RB_PREV(struct type *);                              \
-attr struct type *name##_RB_MINMAX(struct name *, int);                       \
-                                                                              \
-
-/* Main rb operation.
- * Moves node close to the key of elm to top
- */
-#define  RB_GENERATE(name, type, field, cmp)                                  \
-  RB_GENERATE_INTERNAL(name, type, field, cmp,)
-#define  RB_GENERATE_STATIC(name, type, field, cmp)                           \
-  RB_GENERATE_INTERNAL(name, type, field, cmp, UV__UNUSED static)
-#define RB_GENERATE_INTERNAL(name, type, field, cmp, attr)                    \
-attr void                                                                     \
-name##_RB_INSERT_COLOR(struct name *head, struct type *elm)                   \
-{                                                                             \
-  struct type *parent, *gparent, *tmp;                                        \
-  while ((parent = RB_PARENT(elm, field)) != NULL &&                          \
-      RB_COLOR(parent, field) == RB_RED) {                                    \
-    gparent = RB_PARENT(parent, field);                                       \
-    if (parent == RB_LEFT(gparent, field)) {                                  \
-      tmp = RB_RIGHT(gparent, field);                                         \
-      if (tmp && RB_COLOR(tmp, field) == RB_RED) {                            \
-        RB_COLOR(tmp, field) = RB_BLACK;                                      \
-        RB_SET_BLACKRED(parent, gparent, field);                              \
-        elm = gparent;                                                        \
-        continue;                                                             \
-      }                                                                       \
-      if (RB_RIGHT(parent, field) == elm) {                                   \
-        RB_ROTATE_LEFT(head, parent, tmp, field);                             \
-        tmp = parent;                                                         \
-        parent = elm;                                                         \
-        elm = tmp;                                                            \
-      }                                                                       \
-      RB_SET_BLACKRED(parent, gparent, field);                                \
-      RB_ROTATE_RIGHT(head, gparent, tmp, field);                             \
-    } else {                                                                  \
-      tmp = RB_LEFT(gparent, field);                                          \
-      if (tmp && RB_COLOR(tmp, field) == RB_RED) {                            \
-        RB_COLOR(tmp, field) = RB_BLACK;                                      \
-        RB_SET_BLACKRED(parent, gparent, field);                              \
-        elm = gparent;                                                        \
-        continue;                                                             \
-      }                                                                       \
-      if (RB_LEFT(parent, field) == elm) {                                    \
-        RB_ROTATE_RIGHT(head, parent, tmp, field);                            \
-        tmp = parent;                                                         \
-        parent = elm;                                                         \
-        elm = tmp;                                                            \
-      }                                                                       \
-      RB_SET_BLACKRED(parent, gparent, field);                                \
-      RB_ROTATE_LEFT(head, gparent, tmp, field);                              \
-    }                                                                         \
-  }                                                                           \
-  RB_COLOR(head->rbh_root, field) = RB_BLACK;                                 \
-}                                                                             \
-                                                                              \
-attr void                                                                     \
-name##_RB_REMOVE_COLOR(struct name *head, struct type *parent,                \
-    struct type *elm)                                                         \
-{                                                                             \
-  struct type *tmp;                                                           \
-  while ((elm == NULL || RB_COLOR(elm, field) == RB_BLACK) &&                 \
-      elm != RB_ROOT(head)) {                                                 \
-    if (RB_LEFT(parent, field) == elm) {                                      \
-      tmp = RB_RIGHT(parent, field);                                          \
-      if (RB_COLOR(tmp, field) == RB_RED) {                                   \
-        RB_SET_BLACKRED(tmp, parent, field);                                  \
-        RB_ROTATE_LEFT(head, parent, tmp, field);                             \
-        tmp = RB_RIGHT(parent, field);                                        \
-      }                                                                       \
-      if ((RB_LEFT(tmp, field) == NULL ||                                     \
-          RB_COLOR(RB_LEFT(tmp, field), field) == RB_BLACK) &&                \
-          (RB_RIGHT(tmp, field) == NULL ||                                    \
-          RB_COLOR(RB_RIGHT(tmp, field), field) == RB_BLACK)) {               \
-        RB_COLOR(tmp, field) = RB_RED;                                        \
-        elm = parent;                                                         \
-        parent = RB_PARENT(elm, field);                                       \
-      } else {                                                                \
-        if (RB_RIGHT(tmp, field) == NULL ||                                   \
-            RB_COLOR(RB_RIGHT(tmp, field), field) == RB_BLACK) {              \
-          struct type *oleft;                                                 \
-          if ((oleft = RB_LEFT(tmp, field))                                   \
-              != NULL)                                                        \
-            RB_COLOR(oleft, field) = RB_BLACK;                                \
-          RB_COLOR(tmp, field) = RB_RED;                                      \
-          RB_ROTATE_RIGHT(head, tmp, oleft, field);                           \
-          tmp = RB_RIGHT(parent, field);                                      \
-        }                                                                     \
-        RB_COLOR(tmp, field) = RB_COLOR(parent, field);                       \
-        RB_COLOR(parent, field) = RB_BLACK;                                   \
-        if (RB_RIGHT(tmp, field))                                             \
-          RB_COLOR(RB_RIGHT(tmp, field), field) = RB_BLACK;                   \
-        RB_ROTATE_LEFT(head, parent, tmp, field);                             \
-        elm = RB_ROOT(head);                                                  \
-        break;                                                                \
-      }                                                                       \
-    } else {                                                                  \
-      tmp = RB_LEFT(parent, field);                                           \
-      if (RB_COLOR(tmp, field) == RB_RED) {                                   \
-        RB_SET_BLACKRED(tmp, parent, field);                                  \
-        RB_ROTATE_RIGHT(head, parent, tmp, field);                            \
-        tmp = RB_LEFT(parent, field);                                         \
-      }                                                                       \
-      if ((RB_LEFT(tmp, field) == NULL ||                                     \
-          RB_COLOR(RB_LEFT(tmp, field), field) == RB_BLACK) &&                \
-          (RB_RIGHT(tmp, field) == NULL ||                                    \
-          RB_COLOR(RB_RIGHT(tmp, field), field) == RB_BLACK)) {               \
-        RB_COLOR(tmp, field) = RB_RED;                                        \
-        elm = parent;                                                         \
-        parent = RB_PARENT(elm, field);                                       \
-      } else {                                                                \
-        if (RB_LEFT(tmp, field) == NULL ||                                    \
-            RB_COLOR(RB_LEFT(tmp, field), field) == RB_BLACK) {               \
-          struct type *oright;                                                \
-          if ((oright = RB_RIGHT(tmp, field))                                 \
-              != NULL)                                                        \
-            RB_COLOR(oright, field) = RB_BLACK;                               \
-          RB_COLOR(tmp, field) = RB_RED;                                      \
-          RB_ROTATE_LEFT(head, tmp, oright, field);                           \
-          tmp = RB_LEFT(parent, field);                                       \
-        }                                                                     \
-        RB_COLOR(tmp, field) = RB_COLOR(parent, field);                       \
-        RB_COLOR(parent, field) = RB_BLACK;                                   \
-        if (RB_LEFT(tmp, field))                                              \
-          RB_COLOR(RB_LEFT(tmp, field), field) = RB_BLACK;                    \
-        RB_ROTATE_RIGHT(head, parent, tmp, field);                            \
-        elm = RB_ROOT(head);                                                  \
-        break;                                                                \
-      }                                                                       \
-    }                                                                         \
-  }                                                                           \
-  if (elm)                                                                    \
-    RB_COLOR(elm, field) = RB_BLACK;                                          \
-}                                                                             \
-                                                                              \
-attr struct type *                                                            \
-name##_RB_REMOVE(struct name *head, struct type *elm)                         \
-{                                                                             \
-  struct type *child, *parent, *old = elm;                                    \
-  int color;                                                                  \
-  if (RB_LEFT(elm, field) == NULL)                                            \
-    child = RB_RIGHT(elm, field);                                             \
-  else if (RB_RIGHT(elm, field) == NULL)                                      \
-    child = RB_LEFT(elm, field);                                              \
-  else {                                                                      \
-    struct type *left;                                                        \
-    elm = RB_RIGHT(elm, field);                                               \
-    while ((left = RB_LEFT(elm, field)) != NULL)                              \
-      elm = left;                                                             \
-    child = RB_RIGHT(elm, field);                                             \
-    parent = RB_PARENT(elm, field);                                           \
-    color = RB_COLOR(elm, field);                                             \
-    if (child)                                                                \
-      RB_PARENT(child, field) = parent;                                       \
-    if (parent) {                                                             \
-      if (RB_LEFT(parent, field) == elm)                                      \
-        RB_LEFT(parent, field) = child;                                       \
-      else                                                                    \
-        RB_RIGHT(parent, field) = child;                                      \
-      RB_AUGMENT(parent);                                                     \
-    } else                                                                    \
-      RB_ROOT(head) = child;                                                  \
-    if (RB_PARENT(elm, field) == old)                                         \
-      parent = elm;                                                           \
-    (elm)->field = (old)->field;                                              \
-    if (RB_PARENT(old, field)) {                                              \
-      if (RB_LEFT(RB_PARENT(old, field), field) == old)                       \
-        RB_LEFT(RB_PARENT(old, field), field) = elm;                          \
-      else                                                                    \
-        RB_RIGHT(RB_PARENT(old, field), field) = elm;                         \
-      RB_AUGMENT(RB_PARENT(old, field));                                      \
-    } else                                                                    \
-      RB_ROOT(head) = elm;                                                    \
-    RB_PARENT(RB_LEFT(old, field), field) = elm;                              \
-    if (RB_RIGHT(old, field))                                                 \
-      RB_PARENT(RB_RIGHT(old, field), field) = elm;                           \
-    if (parent) {                                                             \
-      left = parent;                                                          \
-      do {                                                                    \
-        RB_AUGMENT(left);                                                     \
-      } while ((left = RB_PARENT(left, field)) != NULL);                      \
-    }                                                                         \
-    goto color;                                                               \
-  }                                                                           \
-  parent = RB_PARENT(elm, field);                                             \
-  color = RB_COLOR(elm, field);                                               \
-  if (child)                                                                  \
-    RB_PARENT(child, field) = parent;                                         \
-  if (parent) {                                                               \
-    if (RB_LEFT(parent, field) == elm)                                        \
-      RB_LEFT(parent, field) = child;                                         \
-    else                                                                      \
-      RB_RIGHT(parent, field) = child;                                        \
-    RB_AUGMENT(parent);                                                       \
-  } else                                                                      \
-    RB_ROOT(head) = child;                                                    \
-color:                                                                        \
-  if (color == RB_BLACK)                                                      \
-    name##_RB_REMOVE_COLOR(head, parent, child);                              \
-  return (old);                                                               \
-}                                                                             \
-                                                                              \
-/* Inserts a node into the RB tree */                                         \
-attr struct type *                                                            \
-name##_RB_INSERT(struct name *head, struct type *elm)                         \
-{                                                                             \
-  struct type *tmp;                                                           \
-  struct type *parent = NULL;                                                 \
-  int comp = 0;                                                               \
-  tmp = RB_ROOT(head);                                                        \
-  while (tmp) {                                                               \
-    parent = tmp;                                                             \
-    comp = (cmp)(elm, parent);                                                \
-    if (comp < 0)                                                             \
-      tmp = RB_LEFT(tmp, field);                                              \
-    else if (comp > 0)                                                        \
-      tmp = RB_RIGHT(tmp, field);                                             \
-    else                                                                      \
-      return (tmp);                                                           \
-  }                                                                           \
-  RB_SET(elm, parent, field);                                                 \
-  if (parent != NULL) {                                                       \
-    if (comp < 0)                                                             \
-      RB_LEFT(parent, field) = elm;                                           \
-    else                                                                      \
-      RB_RIGHT(parent, field) = elm;                                          \
-    RB_AUGMENT(parent);                                                       \
-  } else                                                                      \
-    RB_ROOT(head) = elm;                                                      \
-  name##_RB_INSERT_COLOR(head, elm);                                          \
-  return (NULL);                                                              \
-}                                                                             \
-                                                                              \
-/* Finds the node with the same key as elm */                                 \
-attr struct type *                                                            \
-name##_RB_FIND(struct name *head, struct type *elm)                           \
-{                                                                             \
-  struct type *tmp = RB_ROOT(head);                                           \
-  int comp;                                                                   \
-  while (tmp) {                                                               \
-    comp = cmp(elm, tmp);                                                     \
-    if (comp < 0)                                                             \
-      tmp = RB_LEFT(tmp, field);                                              \
-    else if (comp > 0)                                                        \
-      tmp = RB_RIGHT(tmp, field);                                             \
-    else                                                                      \
-      return (tmp);                                                           \
-  }                                                                           \
-  return (NULL);                                                              \
-}                                                                             \
-                                                                              \
-/* Finds the first node greater than or equal to the search key */            \
-attr struct type *                                                            \
-name##_RB_NFIND(struct name *head, struct type *elm)                          \
-{                                                                             \
-  struct type *tmp = RB_ROOT(head);                                           \
-  struct type *res = NULL;                                                    \
-  int comp;                                                                   \
-  while (tmp) {                                                               \
-    comp = cmp(elm, tmp);                                                     \
-    if (comp < 0) {                                                           \
-      res = tmp;                                                              \
-      tmp = RB_LEFT(tmp, field);                                              \
-    }                                                                         \
-    else if (comp > 0)                                                        \
-      tmp = RB_RIGHT(tmp, field);                                             \
-    else                                                                      \
-      return (tmp);                                                           \
-  }                                                                           \
-  return (res);                                                               \
-}                                                                             \
-                                                                              \
-/* ARGSUSED */                                                                \
-attr struct type *                                                            \
-name##_RB_NEXT(struct type *elm)                                              \
-{                                                                             \
-  if (RB_RIGHT(elm, field)) {                                                 \
-    elm = RB_RIGHT(elm, field);                                               \
-    while (RB_LEFT(elm, field))                                               \
-      elm = RB_LEFT(elm, field);                                              \
-  } else {                                                                    \
-    if (RB_PARENT(elm, field) &&                                              \
-        (elm == RB_LEFT(RB_PARENT(elm, field), field)))                       \
-      elm = RB_PARENT(elm, field);                                            \
-    else {                                                                    \
-      while (RB_PARENT(elm, field) &&                                         \
-          (elm == RB_RIGHT(RB_PARENT(elm, field), field)))                    \
-        elm = RB_PARENT(elm, field);                                          \
-      elm = RB_PARENT(elm, field);                                            \
-    }                                                                         \
-  }                                                                           \
-  return (elm);                                                               \
-}                                                                             \
-                                                                              \
-/* ARGSUSED */                                                                \
-attr struct type *                                                            \
-name##_RB_PREV(struct type *elm)                                              \
-{                                                                             \
-  if (RB_LEFT(elm, field)) {                                                  \
-    elm = RB_LEFT(elm, field);                                                \
-    while (RB_RIGHT(elm, field))                                              \
-      elm = RB_RIGHT(elm, field);                                             \
-  } else {                                                                    \
-    if (RB_PARENT(elm, field) &&                                              \
-        (elm == RB_RIGHT(RB_PARENT(elm, field), field)))                      \
-      elm = RB_PARENT(elm, field);                                            \
-    else {                                                                    \
-      while (RB_PARENT(elm, field) &&                                         \
-          (elm == RB_LEFT(RB_PARENT(elm, field), field)))                     \
-        elm = RB_PARENT(elm, field);                                          \
-      elm = RB_PARENT(elm, field);                                            \
-    }                                                                         \
-  }                                                                           \
-  return (elm);                                                               \
-}                                                                             \
-                                                                              \
-attr struct type *                                                            \
-name##_RB_MINMAX(struct name *head, int val)                                  \
-{                                                                             \
-  struct type *tmp = RB_ROOT(head);                                           \
-  struct type *parent = NULL;                                                 \
-  while (tmp) {                                                               \
-    parent = tmp;                                                             \
-    if (val < 0)                                                              \
-      tmp = RB_LEFT(tmp, field);                                              \
-    else                                                                      \
-      tmp = RB_RIGHT(tmp, field);                                             \
-  }                                                                           \
-  return (parent);                                                            \
-}
-
-#define RB_NEGINF   -1
-#define RB_INF      1
-
-#define RB_INSERT(name, x, y)   name##_RB_INSERT(x, y)
-#define RB_REMOVE(name, x, y)   name##_RB_REMOVE(x, y)
-#define RB_FIND(name, x, y)     name##_RB_FIND(x, y)
-#define RB_NFIND(name, x, y)    name##_RB_NFIND(x, y)
-#define RB_NEXT(name, x, y)     name##_RB_NEXT(y)
-#define RB_PREV(name, x, y)     name##_RB_PREV(y)
-#define RB_MIN(name, x)         name##_RB_MINMAX(x, RB_NEGINF)
-#define RB_MAX(name, x)         name##_RB_MINMAX(x, RB_INF)
-
-#define RB_FOREACH(x, name, head)                                             \
-  for ((x) = RB_MIN(name, head);                                              \
-       (x) != NULL;                                                           \
-       (x) = name##_RB_NEXT(x))
-
-#define RB_FOREACH_FROM(x, name, y)                                           \
-  for ((x) = (y);                                                             \
-      ((x) != NULL) && ((y) = name##_RB_NEXT(x), (x) != NULL);                \
-       (x) = (y))
-
-#define RB_FOREACH_SAFE(x, name, head, y)                                     \
-  for ((x) = RB_MIN(name, head);                                              \
-      ((x) != NULL) && ((y) = name##_RB_NEXT(x), (x) != NULL);                \
-       (x) = (y))
-
-#define RB_FOREACH_REVERSE(x, name, head)                                     \
-  for ((x) = RB_MAX(name, head);                                              \
-       (x) != NULL;                                                           \
-       (x) = name##_RB_PREV(x))
-
-#define RB_FOREACH_REVERSE_FROM(x, name, y)                                   \
-  for ((x) = (y);                                                             \
-      ((x) != NULL) && ((y) = name##_RB_PREV(x), (x) != NULL);                \
-       (x) = (y))
-
-#define RB_FOREACH_REVERSE_SAFE(x, name, head, y)                             \
-  for ((x) = RB_MAX(name, head);                                              \
-      ((x) != NULL) && ((y) = name##_RB_PREV(x), (x) != NULL);                \
-       (x) = (y))
-
-#endif  /* UV_TREE_H_ */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/include/uv-aix.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef UV_AIX_H
-#define UV_AIX_H
-
-#define UV_PLATFORM_LOOP_FIELDS                                               \
-  int fs_fd;                                                                  \
-
-#define UV_PLATFORM_FS_EVENT_FIELDS                                           \
-  uv__io_t event_watcher;                                                     \
-  char *dir_filename;                                                         \
-
-#endif /* UV_AIX_H */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/include/uv-bsd.h
+++ /dev/null
@@ -1,34 +0,0 @@
-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef UV_BSD_H
-#define UV_BSD_H
-
-#define UV_PLATFORM_FS_EVENT_FIELDS                                           \
-  uv__io_t event_watcher;                                                     \
-
-#define UV_IO_PRIVATE_PLATFORM_FIELDS                                         \
-  int rcount;                                                                 \
-  int wcount;                                                                 \
-
-#define UV_HAVE_KQUEUE 1
-
-#endif /* UV_BSD_H */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/include/uv-darwin.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef UV_DARWIN_H
-#define UV_DARWIN_H
-
-#if defined(__APPLE__) && defined(__MACH__)
-# include <mach/mach.h>
-# include <mach/task.h>
-# include <mach/semaphore.h>
-# include <TargetConditionals.h>
-# define UV_PLATFORM_SEM_T semaphore_t
-#endif
-
-#define UV_IO_PRIVATE_PLATFORM_FIELDS                                         \
-  int rcount;                                                                 \
-  int wcount;                                                                 \
-
-#define UV_PLATFORM_LOOP_FIELDS                                               \
-  uv_thread_t cf_thread;                                                      \
-  void* _cf_reserved;                                                         \
-  void* cf_state;                                                             \
-  uv_mutex_t cf_mutex;                                                        \
-  uv_sem_t cf_sem;                                                            \
-  void* cf_signals[2];                                                        \
-
-#define UV_PLATFORM_FS_EVENT_FIELDS                                           \
-  uv__io_t event_watcher;                                                     \
-  char* realpath;                                                             \
-  int realpath_len;                                                           \
-  int cf_flags;                                                               \
-  uv_async_t* cf_cb;                                                          \
-  void* cf_events[2];                                                         \
-  void* cf_member[2];                                                         \
-  int cf_error;                                                               \
-  uv_mutex_t cf_mutex;                                                        \
-
-#define UV_STREAM_PRIVATE_PLATFORM_FIELDS                                     \
-  void* select;                                                               \
-
-#define UV_HAVE_KQUEUE 1
-
-#endif /* UV_DARWIN_H */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/include/uv-errno.h
+++ /dev/null
@@ -1,419 +0,0 @@
-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef UV_ERRNO_H_
-#define UV_ERRNO_H_
-
-#include <errno.h>
-
-#define UV__EOF     (-4095)
-#define UV__UNKNOWN (-4094)
-
-#define UV__EAI_ADDRFAMILY  (-3000)
-#define UV__EAI_AGAIN       (-3001)
-#define UV__EAI_BADFLAGS    (-3002)
-#define UV__EAI_CANCELED    (-3003)
-#define UV__EAI_FAIL        (-3004)
-#define UV__EAI_FAMILY      (-3005)
-#define UV__EAI_MEMORY      (-3006)
-#define UV__EAI_NODATA      (-3007)
-#define UV__EAI_NONAME      (-3008)
-#define UV__EAI_OVERFLOW    (-3009)
-#define UV__EAI_SERVICE     (-3010)
-#define UV__EAI_SOCKTYPE    (-3011)
-#define UV__EAI_BADHINTS    (-3013)
-#define UV__EAI_PROTOCOL    (-3014)
-
-/* Only map to the system errno on non-Windows platforms. It's apparently
- * a fairly common practice for Windows programmers to redefine errno codes.
- */
-#if defined(E2BIG) && !defined(_WIN32)
-# define UV__E2BIG (-E2BIG)
-#else
-# define UV__E2BIG (-4093)
-#endif
-
-#if defined(EACCES) && !defined(_WIN32)
-# define UV__EACCES (-EACCES)
-#else
-# define UV__EACCES (-4092)
-#endif
-
-#if defined(EADDRINUSE) && !defined(_WIN32)
-# define UV__EADDRINUSE (-EADDRINUSE)
-#else
-# define UV__EADDRINUSE (-4091)
-#endif
-
-#if defined(EADDRNOTAVAIL) && !defined(_WIN32)
-# define UV__EADDRNOTAVAIL (-EADDRNOTAVAIL)
-#else
-# define UV__EADDRNOTAVAIL (-4090)
-#endif
-
-#if defined(EAFNOSUPPORT) && !defined(_WIN32)
-# define UV__EAFNOSUPPORT (-EAFNOSUPPORT)
-#else
-# define UV__EAFNOSUPPORT (-4089)
-#endif
-
-#if defined(EAGAIN) && !defined(_WIN32)
-# define UV__EAGAIN (-EAGAIN)
-#else
-# define UV__EAGAIN (-4088)
-#endif
-
-#if defined(EALREADY) && !defined(_WIN32)
-# define UV__EALREADY (-EALREADY)
-#else
-# define UV__EALREADY (-4084)
-#endif
-
-#if defined(EBADF) && !defined(_WIN32)
-# define UV__EBADF (-EBADF)
-#else
-# define UV__EBADF (-4083)
-#endif
-
-#if defined(EBUSY) && !defined(_WIN32)
-# define UV__EBUSY (-EBUSY)
-#else
-# define UV__EBUSY (-4082)
-#endif
-
-#if defined(ECANCELED) && !defined(_WIN32)
-# define UV__ECANCELED (-ECANCELED)
-#else
-# define UV__ECANCELED (-4081)
-#endif
-
-#if defined(ECHARSET) && !defined(_WIN32)
-# define UV__ECHARSET (-ECHARSET)
-#else
-# define UV__ECHARSET (-4080)
-#endif
-
-#if defined(ECONNABORTED) && !defined(_WIN32)
-# define UV__ECONNABORTED (-ECONNABORTED)
-#else
-# define UV__ECONNABORTED (-4079)
-#endif
-
-#if defined(ECONNREFUSED) && !defined(_WIN32)
-# define UV__ECONNREFUSED (-ECONNREFUSED)
-#else
-# define UV__ECONNREFUSED (-4078)
-#endif
-
-#if defined(ECONNRESET) && !defined(_WIN32)
-# define UV__ECONNRESET (-ECONNRESET)
-#else
-# define UV__ECONNRESET (-4077)
-#endif
-
-#if defined(EDESTADDRREQ) && !defined(_WIN32)
-# define UV__EDESTADDRREQ (-EDESTADDRREQ)
-#else
-# define UV__EDESTADDRREQ (-4076)
-#endif
-
-#if defined(EEXIST) && !defined(_WIN32)
-# define UV__EEXIST (-EEXIST)
-#else
-# define UV__EEXIST (-4075)
-#endif
-
-#if defined(EFAULT) && !defined(_WIN32)
-# define UV__EFAULT (-EFAULT)
-#else
-# define UV__EFAULT (-4074)
-#endif
-
-#if defined(EHOSTUNREACH) && !defined(_WIN32)
-# define UV__EHOSTUNREACH (-EHOSTUNREACH)
-#else
-# define UV__EHOSTUNREACH (-4073)
-#endif
-
-#if defined(EINTR) && !defined(_WIN32)
-# define UV__EINTR (-EINTR)
-#else
-# define UV__EINTR (-4072)
-#endif
-
-#if defined(EINVAL) && !defined(_WIN32)
-# define UV__EINVAL (-EINVAL)
-#else
-# define UV__EINVAL (-4071)
-#endif
-
-#if defined(EIO) && !defined(_WIN32)
-# define UV__EIO (-EIO)
-#else
-# define UV__EIO (-4070)
-#endif
-
-#if defined(EISCONN) && !defined(_WIN32)
-# define UV__EISCONN (-EISCONN)
-#else
-# define UV__EISCONN (-4069)
-#endif
-
-#if defined(EISDIR) && !defined(_WIN32)
-# define UV__EISDIR (-EISDIR)
-#else
-# define UV__EISDIR (-4068)
-#endif
-
-#if defined(ELOOP) && !defined(_WIN32)
-# define UV__ELOOP (-ELOOP)
-#else
-# define UV__ELOOP (-4067)
-#endif
-
-#if defined(EMFILE) && !defined(_WIN32)
-# define UV__EMFILE (-EMFILE)
-#else
-# define UV__EMFILE (-4066)
-#endif
-
-#if defined(EMSGSIZE) && !defined(_WIN32)
-# define UV__EMSGSIZE (-EMSGSIZE)
-#else
-# define UV__EMSGSIZE (-4065)
-#endif
-
-#if defined(ENAMETOOLONG) && !defined(_WIN32)
-# define UV__ENAMETOOLONG (-ENAMETOOLONG)
-#else
-# define UV__ENAMETOOLONG (-4064)
-#endif
-
-#if defined(ENETDOWN) && !defined(_WIN32)
-# define UV__ENETDOWN (-ENETDOWN)
-#else
-# define UV__ENETDOWN (-4063)
-#endif
-
-#if defined(ENETUNREACH) && !defined(_WIN32)
-# define UV__ENETUNREACH (-ENETUNREACH)
-#else
-# define UV__ENETUNREACH (-4062)
-#endif
-
-#if defined(ENFILE) && !defined(_WIN32)
-# define UV__ENFILE (-ENFILE)
-#else
-# define UV__ENFILE (-4061)
-#endif
-
-#if defined(ENOBUFS) && !defined(_WIN32)
-# define UV__ENOBUFS (-ENOBUFS)
-#else
-# define UV__ENOBUFS (-4060)
-#endif
-
-#if defined(ENODEV) && !defined(_WIN32)
-# define UV__ENODEV (-ENODEV)
-#else
-# define UV__ENODEV (-4059)
-#endif
-
-#if defined(ENOENT) && !defined(_WIN32)
-# define UV__ENOENT (-ENOENT)
-#else
-# define UV__ENOENT (-4058)
-#endif
-
-#if defined(ENOMEM) && !defined(_WIN32)
-# define UV__ENOMEM (-ENOMEM)
-#else
-# define UV__ENOMEM (-4057)
-#endif
-
-#if defined(ENONET) && !defined(_WIN32)
-# define UV__ENONET (-ENONET)
-#else
-# define UV__ENONET (-4056)
-#endif
-
-#if defined(ENOSPC) && !defined(_WIN32)
-# define UV__ENOSPC (-ENOSPC)
-#else
-# define UV__ENOSPC (-4055)
-#endif
-
-#if defined(ENOSYS) && !defined(_WIN32)
-# define UV__ENOSYS (-ENOSYS)
-#else
-# define UV__ENOSYS (-4054)
-#endif
-
-#if defined(ENOTCONN) && !defined(_WIN32)
-# define UV__ENOTCONN (-ENOTCONN)
-#else
-# define UV__ENOTCONN (-4053)
-#endif
-
-#if defined(ENOTDIR) && !defined(_WIN32)
-# define UV__ENOTDIR (-ENOTDIR)
-#else
-# define UV__ENOTDIR (-4052)
-#endif
-
-#if defined(ENOTEMPTY) && !defined(_WIN32)
-# define UV__ENOTEMPTY (-ENOTEMPTY)
-#else
-# define UV__ENOTEMPTY (-4051)
-#endif
-
-#if defined(ENOTSOCK) && !defined(_WIN32)
-# define UV__ENOTSOCK (-ENOTSOCK)
-#else
-# define UV__ENOTSOCK (-4050)
-#endif
-
-#if defined(ENOTSUP) && !defined(_WIN32)
-# define UV__ENOTSUP (-ENOTSUP)
-#else
-# define UV__ENOTSUP (-4049)
-#endif
-
-#if defined(EPERM) && !defined(_WIN32)
-# define UV__EPERM (-EPERM)
-#else
-# define UV__EPERM (-4048)
-#endif
-
-#if defined(EPIPE) && !defined(_WIN32)
-# define UV__EPIPE (-EPIPE)
-#else
-# define UV__EPIPE (-4047)
-#endif
-
-#if defined(EPROTO) && !defined(_WIN32)
-# define UV__EPROTO (-EPROTO)
-#else
-# define UV__EPROTO (-4046)
-#endif
-
-#if defined(EPROTONOSUPPORT) && !defined(_WIN32)
-# define UV__EPROTONOSUPPORT (-EPROTONOSUPPORT)
-#else
-# define UV__EPROTONOSUPPORT (-4045)
-#endif
-
-#if defined(EPROTOTYPE) && !defined(_WIN32)
-# define UV__EPROTOTYPE (-EPROTOTYPE)
-#else
-# define UV__EPROTOTYPE (-4044)
-#endif
-
-#if defined(EROFS) && !defined(_WIN32)
-# define UV__EROFS (-EROFS)
-#else
-# define UV__EROFS (-4043)
-#endif
-
-#if defined(ESHUTDOWN) && !defined(_WIN32)
-# define UV__ESHUTDOWN (-ESHUTDOWN)
-#else
-# define UV__ESHUTDOWN (-4042)
-#endif
-
-#if defined(ESPIPE) && !defined(_WIN32)
-# define UV__ESPIPE (-ESPIPE)
-#else
-# define UV__ESPIPE (-4041)
-#endif
-
-#if defined(ESRCH) && !defined(_WIN32)
-# define UV__ESRCH (-ESRCH)
-#else
-# define UV__ESRCH (-4040)
-#endif
-
-#if defined(ETIMEDOUT) && !defined(_WIN32)
-# define UV__ETIMEDOUT (-ETIMEDOUT)
-#else
-# define UV__ETIMEDOUT (-4039)
-#endif
-
-#if defined(ETXTBSY) && !defined(_WIN32)
-# define UV__ETXTBSY (-ETXTBSY)
-#else
-# define UV__ETXTBSY (-4038)
-#endif
-
-#if defined(EXDEV) && !defined(_WIN32)
-# define UV__EXDEV (-EXDEV)
-#else
-# define UV__EXDEV (-4037)
-#endif
-
-#if defined(EFBIG) && !defined(_WIN32)
-# define UV__EFBIG (-EFBIG)
-#else
-# define UV__EFBIG (-4036)
-#endif
-
-#if defined(ENOPROTOOPT) && !defined(_WIN32)
-# define UV__ENOPROTOOPT (-ENOPROTOOPT)
-#else
-# define UV__ENOPROTOOPT (-4035)
-#endif
-
-#if defined(ERANGE) && !defined(_WIN32)
-# define UV__ERANGE (-ERANGE)
-#else
-# define UV__ERANGE (-4034)
-#endif
-
-#if defined(ENXIO) && !defined(_WIN32)
-# define UV__ENXIO (-ENXIO)
-#else
-# define UV__ENXIO (-4033)
-#endif
-
-#if defined(EMLINK) && !defined(_WIN32)
-# define UV__EMLINK (-EMLINK)
-#else
-# define UV__EMLINK (-4032)
-#endif
-
-/* EHOSTDOWN is not visible on BSD-like systems when _POSIX_C_SOURCE is
- * defined. Fortunately, its value is always 64 so it's possible albeit
- * icky to hard-code it.
- */
-#if defined(EHOSTDOWN) && !defined(_WIN32)
-# define UV__EHOSTDOWN (-EHOSTDOWN)
-#elif defined(__APPLE__) || \
-      defined(__DragonFly__) || \
-      defined(__FreeBSD__) || \
-      defined(__FreeBSD_kernel__) || \
-      defined(__NetBSD__) || \
-      defined(__OpenBSD__)
-# define UV__EHOSTDOWN (-64)
-#else
-# define UV__EHOSTDOWN (-4031)
-#endif
-
-#endif /* UV_ERRNO_H_ */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/include/uv-linux.h
+++ /dev/null
@@ -1,34 +0,0 @@
-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef UV_LINUX_H
-#define UV_LINUX_H
-
-#define UV_PLATFORM_LOOP_FIELDS                                               \
-  uv__io_t inotify_read_watcher;                                              \
-  void* inotify_watchers;                                                     \
-  int inotify_fd;                                                             \
-
-#define UV_PLATFORM_FS_EVENT_FIELDS                                           \
-  void* watchers[2];                                                          \
-  int wd;                                                                     \
-
-#endif /* UV_LINUX_H */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/include/uv-os390.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/* Copyright libuv project contributors. All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef UV_MVS_H
-#define UV_MVS_H
-
-#define UV_PLATFORM_SEM_T int
-
-#define UV_PLATFORM_LOOP_FIELDS                                               \
-  void* ep;                                                                   \
-
-#endif /* UV_MVS_H */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/include/uv-sunos.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef UV_SUNOS_H
-#define UV_SUNOS_H
-
-#include <sys/port.h>
-#include <port.h>
-
-/* For the sake of convenience and reduced #ifdef-ery in src/unix/sunos.c,
- * add the fs_event fields even when this version of SunOS doesn't support
- * file watching.
- */
-#define UV_PLATFORM_LOOP_FIELDS                                               \
-  uv__io_t fs_event_watcher;                                                  \
-  int fs_fd;                                                                  \
-
-#if defined(PORT_SOURCE_FILE)
-
-# define UV_PLATFORM_FS_EVENT_FIELDS                                          \
-  file_obj_t fo;                                                              \
-  int fd;                                                                     \
-
-#endif /* defined(PORT_SOURCE_FILE) */
-
-#endif /* UV_SUNOS_H */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/include/uv-threadpool.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-/*
- * This file is private to libuv. It provides common functionality to both
- * Windows and Unix backends.
- */
-
-#ifndef UV_THREADPOOL_H_
-#define UV_THREADPOOL_H_
-
-struct uv__work {
-  void (*work)(struct uv__work *w);
-  void (*done)(struct uv__work *w, int status);
-  struct uv_loop_s* loop;
-  void* wq[2];
-};
-
-#endif /* UV_THREADPOOL_H_ */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/include/uv-unix.h
+++ /dev/null
@@ -1,375 +0,0 @@
-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef UV_UNIX_H
-#define UV_UNIX_H
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <dirent.h>
-
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <netinet/tcp.h>
-#include <arpa/inet.h>
-#include <netdb.h>
-
-#include <termios.h>
-#include <pwd.h>
-
-#if !defined(__MVS__)
-#include <semaphore.h>
-#endif
-#include <pthread.h>
-#include <signal.h>
-
-#include "uv-threadpool.h"
-
-#if defined(__linux__)
-# include "uv-linux.h"
-#elif defined (__MVS__)
-# include "uv-os390.h"
-#elif defined(_AIX)
-# include "uv-aix.h"
-#elif defined(__sun)
-# include "uv-sunos.h"
-#elif defined(__APPLE__)
-# include "uv-darwin.h"
-#elif defined(__DragonFly__)       || \
-      defined(__FreeBSD__)         || \
-      defined(__FreeBSD_kernel__)  || \
-      defined(__OpenBSD__)         || \
-      defined(__NetBSD__)
-# include "uv-bsd.h"
-#endif
-
-#ifndef PTHREAD_BARRIER_SERIAL_THREAD
-# include "pthread-barrier.h"
-#endif
-
-#ifndef NI_MAXHOST
-# define NI_MAXHOST 1025
-#endif
-
-#ifndef NI_MAXSERV
-# define NI_MAXSERV 32
-#endif
-
-#ifndef UV_IO_PRIVATE_PLATFORM_FIELDS
-# define UV_IO_PRIVATE_PLATFORM_FIELDS /* empty */
-#endif
-
-struct uv__io_s;
-struct uv__async;
-struct uv_loop_s;
-
-typedef void (*uv__io_cb)(struct uv_loop_s* loop,
-                          struct uv__io_s* w,
-                          unsigned int events);
-typedef struct uv__io_s uv__io_t;
-
-struct uv__io_s {
-  uv__io_cb cb;
-  void* pending_queue[2];
-  void* watcher_queue[2];
-  unsigned int pevents; /* Pending event mask i.e. mask at next tick. */
-  unsigned int events;  /* Current event mask. */
-  int fd;
-  UV_IO_PRIVATE_PLATFORM_FIELDS
-};
-
-typedef void (*uv__async_cb)(struct uv_loop_s* loop,
-                             struct uv__async* w,
-                             unsigned int nevents);
-
-struct uv__async {
-  uv__async_cb cb;
-  uv__io_t io_watcher;
-  int wfd;
-};
-
-#ifndef UV_PLATFORM_SEM_T
-# define UV_PLATFORM_SEM_T sem_t
-#endif
-
-#ifndef UV_PLATFORM_LOOP_FIELDS
-# define UV_PLATFORM_LOOP_FIELDS /* empty */
-#endif
-
-#ifndef UV_PLATFORM_FS_EVENT_FIELDS
-# define UV_PLATFORM_FS_EVENT_FIELDS /* empty */
-#endif
-
-#ifndef UV_STREAM_PRIVATE_PLATFORM_FIELDS
-# define UV_STREAM_PRIVATE_PLATFORM_FIELDS /* empty */
-#endif
-
-/* Note: May be cast to struct iovec. See writev(2). */
-typedef struct uv_buf_t {
-  char* base;
-  size_t len;
-} uv_buf_t;
-
-typedef int uv_file;
-typedef int uv_os_sock_t;
-typedef int uv_os_fd_t;
-
-#define UV_ONCE_INIT PTHREAD_ONCE_INIT
-
-typedef pthread_once_t uv_once_t;
-typedef pthread_t uv_thread_t;
-typedef pthread_mutex_t uv_mutex_t;
-typedef pthread_rwlock_t uv_rwlock_t;
-typedef UV_PLATFORM_SEM_T uv_sem_t;
-typedef pthread_cond_t uv_cond_t;
-typedef pthread_key_t uv_key_t;
-typedef pthread_barrier_t uv_barrier_t;
-
-
-/* Platform-specific definitions for uv_spawn support. */
-typedef gid_t uv_gid_t;
-typedef uid_t uv_uid_t;
-
-typedef struct dirent uv__dirent_t;
-
-#if defined(DT_UNKNOWN)
-# define HAVE_DIRENT_TYPES
-# if defined(DT_REG)
-#  define UV__DT_FILE DT_REG
-# else
-#  define UV__DT_FILE -1
-# endif
-# if defined(DT_DIR)
-#  define UV__DT_DIR DT_DIR
-# else
-#  define UV__DT_DIR -2
-# endif
-# if defined(DT_LNK)
-#  define UV__DT_LINK DT_LNK
-# else
-#  define UV__DT_LINK -3
-# endif
-# if defined(DT_FIFO)
-#  define UV__DT_FIFO DT_FIFO
-# else
-#  define UV__DT_FIFO -4
-# endif
-# if defined(DT_SOCK)
-#  define UV__DT_SOCKET DT_SOCK
-# else
-#  define UV__DT_SOCKET -5
-# endif
-# if defined(DT_CHR)
-#  define UV__DT_CHAR DT_CHR
-# else
-#  define UV__DT_CHAR -6
-# endif
-# if defined(DT_BLK)
-#  define UV__DT_BLOCK DT_BLK
-# else
-#  define UV__DT_BLOCK -7
-# endif
-#endif
-
-/* Platform-specific definitions for uv_dlopen support. */
-#define UV_DYNAMIC /* empty */
-
-typedef struct {
-  void* handle;
-  char* errmsg;
-} uv_lib_t;
-
-#define UV_LOOP_PRIVATE_FIELDS                                                \
-  unsigned long flags;                                                        \
-  int backend_fd;                                                             \
-  void* pending_queue[2];                                                     \
-  void* watcher_queue[2];                                                     \
-  uv__io_t** watchers;                                                        \
-  unsigned int nwatchers;                                                     \
-  unsigned int nfds;                                                          \
-  void* wq[2];                                                                \
-  uv_mutex_t wq_mutex;                                                        \
-  uv_async_t wq_async;                                                        \
-  uv_rwlock_t cloexec_lock;                                                   \
-  uv_handle_t* closing_handles;                                               \
-  void* process_handles[2];                                                   \
-  void* prepare_handles[2];                                                   \
-  void* check_handles[2];                                                     \
-  void* idle_handles[2];                                                      \
-  void* async_handles[2];                                                     \
-  struct uv__async async_watcher;                                             \
-  struct {                                                                    \
-    void* min;                                                                \
-    unsigned int nelts;                                                       \
-  } timer_heap;                                                               \
-  uint64_t timer_counter;                                                     \
-  uint64_t time;                                                              \
-  int signal_pipefd[2];                                                       \
-  uv__io_t signal_io_watcher;                                                 \
-  uv_signal_t child_watcher;                                                  \
-  int emfile_fd;                                                              \
-  UV_PLATFORM_LOOP_FIELDS                                                     \
-
-#define UV_REQ_TYPE_PRIVATE /* empty */
-
-#define UV_REQ_PRIVATE_FIELDS  /* empty */
-
-#define UV_PRIVATE_REQ_TYPES /* empty */
-
-#define UV_WRITE_PRIVATE_FIELDS                                               \
-  void* queue[2];                                                             \
-  unsigned int write_index;                                                   \
-  uv_buf_t* bufs;                                                             \
-  unsigned int nbufs;                                                         \
-  int error;                                                                  \
-  uv_buf_t bufsml[4];                                                         \
-
-#define UV_CONNECT_PRIVATE_FIELDS                                             \
-  void* queue[2];                                                             \
-
-#define UV_SHUTDOWN_PRIVATE_FIELDS /* empty */
-
-#define UV_UDP_SEND_PRIVATE_FIELDS                                            \
-  void* queue[2];                                                             \
-  struct sockaddr_storage addr;                                               \
-  unsigned int nbufs;                                                         \
-  uv_buf_t* bufs;                                                             \
-  ssize_t status;                                                             \
-  uv_udp_send_cb send_cb;                                                     \
-  uv_buf_t bufsml[4];                                                         \
-
-#define UV_HANDLE_PRIVATE_FIELDS                                              \
-  uv_handle_t* next_closing;                                                  \
-  unsigned int flags;                                                         \
-
-#define UV_STREAM_PRIVATE_FIELDS                                              \
-  uv_connect_t *connect_req;                                                  \
-  uv_shutdown_t *shutdown_req;                                                \
-  uv__io_t io_watcher;                                                        \
-  void* write_queue[2];                                                       \
-  void* write_completed_queue[2];                                             \
-  uv_connection_cb connection_cb;                                             \
-  int delayed_error;                                                          \
-  int accepted_fd;                                                            \
-  void* queued_fds;                                                           \
-  UV_STREAM_PRIVATE_PLATFORM_FIELDS                                           \
-
-#define UV_TCP_PRIVATE_FIELDS /* empty */
-
-#define UV_UDP_PRIVATE_FIELDS                                                 \
-  uv_alloc_cb alloc_cb;                                                       \
-  uv_udp_recv_cb recv_cb;                                                     \
-  uv__io_t io_watcher;                                                        \
-  void* write_queue[2];                                                       \
-  void* write_completed_queue[2];                                             \
-
-#define UV_PIPE_PRIVATE_FIELDS                                                \
-  const char* pipe_fname; /* strdup'ed */
-
-#define UV_POLL_PRIVATE_FIELDS                                                \
-  uv__io_t io_watcher;
-
-#define UV_PREPARE_PRIVATE_FIELDS                                             \
-  uv_prepare_cb prepare_cb;                                                   \
-  void* queue[2];                                                             \
-
-#define UV_CHECK_PRIVATE_FIELDS                                               \
-  uv_check_cb check_cb;                                                       \
-  void* queue[2];                                                             \
-
-#define UV_IDLE_PRIVATE_FIELDS                                                \
-  uv_idle_cb idle_cb;                                                         \
-  void* queue[2];                                                             \
-
-#define UV_ASYNC_PRIVATE_FIELDS                                               \
-  uv_async_cb async_cb;                                                       \
-  void* queue[2];                                                             \
-  int pending;                                                                \
-
-#define UV_TIMER_PRIVATE_FIELDS                                               \
-  uv_timer_cb timer_cb;                                                       \
-  void* heap_node[3];                                                         \
-  uint64_t timeout;                                                           \
-  uint64_t repeat;                                                            \
-  uint64_t start_id;
-
-#define UV_GETADDRINFO_PRIVATE_FIELDS                                         \
-  struct uv__work work_req;                                                   \
-  uv_getaddrinfo_cb cb;                                                       \
-  struct addrinfo* hints;                                                     \
-  char* hostname;                                                             \
-  char* service;                                                              \
-  struct addrinfo* addrinfo;                                                  \
-  int retcode;
-
-#define UV_GETNAMEINFO_PRIVATE_FIELDS                                         \
-  struct uv__work work_req;                                                   \
-  uv_getnameinfo_cb getnameinfo_cb;                                           \
-  struct sockaddr_storage storage;                                            \
-  int flags;                                                                  \
-  char host[NI_MAXHOST];                                                      \
-  char service[NI_MAXSERV];                                                   \
-  int retcode;
-
-#define UV_PROCESS_PRIVATE_FIELDS                                             \
-  void* queue[2];                                                             \
-  int status;                                                                 \
-
-#define UV_FS_PRIVATE_FIELDS                                                  \
-  const char *new_path;                                                       \
-  uv_file file;                                                               \
-  int flags;                                                                  \
-  mode_t mode;                                                                \
-  unsigned int nbufs;                                                         \
-  uv_buf_t* bufs;                                                             \
-  off_t off;                                                                  \
-  uv_uid_t uid;                                                               \
-  uv_gid_t gid;                                                               \
-  double atime;                                                               \
-  double mtime;                                                               \
-  struct uv__work work_req;                                                   \
-  uv_buf_t bufsml[4];                                                         \
-
-#define UV_WORK_PRIVATE_FIELDS                                                \
-  struct uv__work work_req;
-
-#define UV_TTY_PRIVATE_FIELDS                                                 \
-  struct termios orig_termios;                                                \
-  int mode;
-
-#define UV_SIGNAL_PRIVATE_FIELDS                                              \
-  /* RB_ENTRY(uv_signal_s) tree_entry; */                                     \
-  struct {                                                                    \
-    struct uv_signal_s* rbe_left;                                             \
-    struct uv_signal_s* rbe_right;                                            \
-    struct uv_signal_s* rbe_parent;                                           \
-    int rbe_color;                                                            \
-  } tree_entry;                                                               \
-  /* Use two counters here so we don have to fiddle with atomics. */          \
-  unsigned int caught_signals;                                                \
-  unsigned int dispatched_signals;
-
-#define UV_FS_EVENT_PRIVATE_FIELDS                                            \
-  uv_fs_event_cb cb;                                                          \
-  UV_PLATFORM_FS_EVENT_FIELDS                                                 \
-
-#endif /* UV_UNIX_H */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/include/uv-version.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef UV_VERSION_H
-#define UV_VERSION_H
-
- /*
- * Versions with the same major number are ABI stable. API is allowed to
- * evolve between minor releases, but only in a backwards compatible way.
- * Make sure you update the -soname directives in configure.ac
- * and uv.gyp whenever you bump UV_VERSION_MAJOR or UV_VERSION_MINOR (but
- * not UV_VERSION_PATCH.)
- */
-
-#define UV_VERSION_MAJOR 1
-#define UV_VERSION_MINOR 11
-#define UV_VERSION_PATCH 0
-#define UV_VERSION_IS_RELEASE 1
-#define UV_VERSION_SUFFIX ""
-
-#define UV_VERSION_HEX  ((UV_VERSION_MAJOR << 16) | \
-                         (UV_VERSION_MINOR <<  8) | \
-                         (UV_VERSION_PATCH))
-
-#endif /* UV_VERSION_H */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/include/uv-win.h
+++ /dev/null
@@ -1,650 +0,0 @@
-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef _WIN32_WINNT
-# define _WIN32_WINNT   0x0502
-#endif
-
-#if !defined(_SSIZE_T_) && !defined(_SSIZE_T_DEFINED)
-typedef intptr_t ssize_t;
-# define _SSIZE_T_
-# define _SSIZE_T_DEFINED
-#endif
-
-#include <winsock2.h>
-
-#if defined(__MINGW32__) && !defined(__MINGW64_VERSION_MAJOR)
-typedef struct pollfd {
-  SOCKET fd;
-  short  events;
-  short  revents;
-} WSAPOLLFD, *PWSAPOLLFD, *LPWSAPOLLFD;
-#endif
-
-#ifndef LOCALE_INVARIANT
-# define LOCALE_INVARIANT 0x007f
-#endif
-
-#include <mswsock.h>
-#include <ws2tcpip.h>
-#include <windows.h>
-
-#include <process.h>
-#include <signal.h>
-#include <fcntl.h>
-#include <sys/stat.h>
-
-#if defined(_MSC_VER) && _MSC_VER < 1600
-# include "stdint-msvc2008.h"
-#else
-# include <stdint.h>
-#endif
-
-#include "tree.h"
-#include "uv-threadpool.h"
-
-#define MAX_PIPENAME_LEN 256
-
-#ifndef S_IFLNK
-# define S_IFLNK 0xA000
-#endif
-
-/* Additional signals supported by uv_signal and or uv_kill. The CRT defines
- * the following signals already:
- *
- *   #define SIGINT           2
- *   #define SIGILL           4
- *   #define SIGABRT_COMPAT   6
- *   #define SIGFPE           8
- *   #define SIGSEGV         11
- *   #define SIGTERM         15
- *   #define SIGBREAK        21
- *   #define SIGABRT         22
- *
- * The additional signals have values that are common on other Unix
- * variants (Linux and Darwin)
- */
-#define SIGHUP                1
-#define SIGKILL               9
-#define SIGWINCH             28
-
-/* The CRT defines SIGABRT_COMPAT as 6, which equals SIGABRT on many */
-/* unix-like platforms. However MinGW doesn't define it, so we do. */
-#ifndef SIGABRT_COMPAT
-# define SIGABRT_COMPAT       6
-#endif
-
-/*
- * Guids and typedefs for winsock extension functions
- * Mingw32 doesn't have these :-(
- */
-#ifndef WSAID_ACCEPTEX
-# define WSAID_ACCEPTEX                                                       \
-         {0xb5367df1, 0xcbac, 0x11cf,                                         \
-         {0x95, 0xca, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92}}
-
-# define WSAID_CONNECTEX                                                      \
-         {0x25a207b9, 0xddf3, 0x4660,                                         \
-         {0x8e, 0xe9, 0x76, 0xe5, 0x8c, 0x74, 0x06, 0x3e}}
-
-# define WSAID_GETACCEPTEXSOCKADDRS                                           \
-         {0xb5367df2, 0xcbac, 0x11cf,                                         \
-         {0x95, 0xca, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92}}
-
-# define WSAID_DISCONNECTEX                                                   \
-         {0x7fda2e11, 0x8630, 0x436f,                                         \
-         {0xa0, 0x31, 0xf5, 0x36, 0xa6, 0xee, 0xc1, 0x57}}
-
-# define WSAID_TRANSMITFILE                                                   \
-         {0xb5367df0, 0xcbac, 0x11cf,                                         \
-         {0x95, 0xca, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92}}
-
-  typedef BOOL (PASCAL *LPFN_ACCEPTEX)
-                      (SOCKET sListenSocket,
-                       SOCKET sAcceptSocket,
-                       PVOID lpOutputBuffer,
-                       DWORD dwReceiveDataLength,
-                       DWORD dwLocalAddressLength,
-                       DWORD dwRemoteAddressLength,
-                       LPDWORD lpdwBytesReceived,
-                       LPOVERLAPPED lpOverlapped);
-
-  typedef BOOL (PASCAL *LPFN_CONNECTEX)
-                      (SOCKET s,
-                       const struct sockaddr* name,
-                       int namelen,
-                       PVOID lpSendBuffer,
-                       DWORD dwSendDataLength,
-                       LPDWORD lpdwBytesSent,
-                       LPOVERLAPPED lpOverlapped);
-
-  typedef void (PASCAL *LPFN_GETACCEPTEXSOCKADDRS)
-                      (PVOID lpOutputBuffer,
-                       DWORD dwReceiveDataLength,
-                       DWORD dwLocalAddressLength,
-                       DWORD dwRemoteAddressLength,
-                       LPSOCKADDR* LocalSockaddr,
-                       LPINT LocalSockaddrLength,
-                       LPSOCKADDR* RemoteSockaddr,
-                       LPINT RemoteSockaddrLength);
-
-  typedef BOOL (PASCAL *LPFN_DISCONNECTEX)
-                      (SOCKET hSocket,
-                       LPOVERLAPPED lpOverlapped,
-                       DWORD dwFlags,
-                       DWORD reserved);
-
-  typedef BOOL (PASCAL *LPFN_TRANSMITFILE)
-                      (SOCKET hSocket,
-                       HANDLE hFile,
-                       DWORD nNumberOfBytesToWrite,
-                       DWORD nNumberOfBytesPerSend,
-                       LPOVERLAPPED lpOverlapped,
-                       LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers,
-                       DWORD dwFlags);
-
-  typedef PVOID RTL_SRWLOCK;
-  typedef RTL_SRWLOCK SRWLOCK, *PSRWLOCK;
-#endif
-
-typedef int (WSAAPI* LPFN_WSARECV)
-            (SOCKET socket,
-             LPWSABUF buffers,
-             DWORD buffer_count,
-             LPDWORD bytes,
-             LPDWORD flags,
-             LPWSAOVERLAPPED overlapped,
-             LPWSAOVERLAPPED_COMPLETION_ROUTINE completion_routine);
-
-typedef int (WSAAPI* LPFN_WSARECVFROM)
-            (SOCKET socket,
-             LPWSABUF buffers,
-             DWORD buffer_count,
-             LPDWORD bytes,
-             LPDWORD flags,
-             struct sockaddr* addr,
-             LPINT addr_len,
-             LPWSAOVERLAPPED overlapped,
-             LPWSAOVERLAPPED_COMPLETION_ROUTINE completion_routine);
-
-#ifndef _NTDEF_
-  typedef LONG NTSTATUS;
-  typedef NTSTATUS *PNTSTATUS;
-#endif
-
-#ifndef RTL_CONDITION_VARIABLE_INIT
-  typedef PVOID CONDITION_VARIABLE, *PCONDITION_VARIABLE;
-#endif
-
-typedef struct _AFD_POLL_HANDLE_INFO {
-  HANDLE Handle;
-  ULONG Events;
-  NTSTATUS Status;
-} AFD_POLL_HANDLE_INFO, *PAFD_POLL_HANDLE_INFO;
-
-typedef struct _AFD_POLL_INFO {
-  LARGE_INTEGER Timeout;
-  ULONG NumberOfHandles;
-  ULONG Exclusive;
-  AFD_POLL_HANDLE_INFO Handles[1];
-} AFD_POLL_INFO, *PAFD_POLL_INFO;
-
-#define UV_MSAFD_PROVIDER_COUNT 3
-
-
-/**
- * It should be possible to cast uv_buf_t[] to WSABUF[]
- * see http://msdn.microsoft.com/en-us/library/ms741542(v=vs.85).aspx
- */
-typedef struct uv_buf_t {
-  ULONG len;
-  char* base;
-} uv_buf_t;
-
-typedef int uv_file;
-typedef SOCKET uv_os_sock_t;
-typedef HANDLE uv_os_fd_t;
-
-typedef HANDLE uv_thread_t;
-
-typedef HANDLE uv_sem_t;
-
-typedef CRITICAL_SECTION uv_mutex_t;
-
-/* This condition variable implementation is based on the SetEvent solution
- * (section 3.2) at http://www.cs.wustl.edu/~schmidt/win32-cv-1.html
- * We could not use the SignalObjectAndWait solution (section 3.4) because
- * it want the 2nd argument (type uv_mutex_t) of uv_cond_wait() and
- * uv_cond_timedwait() to be HANDLEs, but we use CRITICAL_SECTIONs.
- */
-
-typedef union {
-  CONDITION_VARIABLE cond_var;
-  struct {
-    unsigned int waiters_count;
-    CRITICAL_SECTION waiters_count_lock;
-    HANDLE signal_event;
-    HANDLE broadcast_event;
-  } fallback;
-} uv_cond_t;
-
-typedef union {
-  struct {
-    unsigned int num_readers_;
-    CRITICAL_SECTION num_readers_lock_;
-    HANDLE write_semaphore_;
-  } state_;
-  /* TODO: remove me in v2.x. */
-  struct {
-    SRWLOCK unused_;
-  } unused1_;
-  /* TODO: remove me in v2.x. */
-  struct {
-    uv_mutex_t unused1_;
-    uv_mutex_t unused2_;
-  } unused2_;
-} uv_rwlock_t;
-
-typedef struct {
-  unsigned int n;
-  unsigned int count;
-  uv_mutex_t mutex;
-  uv_sem_t turnstile1;
-  uv_sem_t turnstile2;
-} uv_barrier_t;
-
-typedef struct {
-  DWORD tls_index;
-} uv_key_t;
-
-#define UV_ONCE_INIT { 0, NULL }
-
-typedef struct uv_once_s {
-  unsigned char ran;
-  HANDLE event;
-} uv_once_t;
-
-/* Platform-specific definitions for uv_spawn support. */
-typedef unsigned char uv_uid_t;
-typedef unsigned char uv_gid_t;
-
-typedef struct uv__dirent_s {
-  int d_type;
-  char d_name[1];
-} uv__dirent_t;
-
-#define HAVE_DIRENT_TYPES
-#define UV__DT_DIR     UV_DIRENT_DIR
-#define UV__DT_FILE    UV_DIRENT_FILE
-#define UV__DT_LINK    UV_DIRENT_LINK
-#define UV__DT_FIFO    UV_DIRENT_FIFO
-#define UV__DT_SOCKET  UV_DIRENT_SOCKET
-#define UV__DT_CHAR    UV_DIRENT_CHAR
-#define UV__DT_BLOCK   UV_DIRENT_BLOCK
-
-/* Platform-specific definitions for uv_dlopen support. */
-#define UV_DYNAMIC FAR WINAPI
-typedef struct {
-  HMODULE handle;
-  char* errmsg;
-} uv_lib_t;
-
-RB_HEAD(uv_timer_tree_s, uv_timer_s);
-
-#define UV_LOOP_PRIVATE_FIELDS                                                \
-    /* The loop's I/O completion port */                                      \
-  HANDLE iocp;                                                                \
-  /* The current time according to the event loop. in msecs. */               \
-  uint64_t time;                                                              \
-  /* Tail of a single-linked circular queue of pending reqs. If the queue */  \
-  /* is empty, tail_ is NULL. If there is only one item, */                   \
-  /* tail_->next_req == tail_ */                                              \
-  uv_req_t* pending_reqs_tail;                                                \
-  /* Head of a single-linked list of closed handles */                        \
-  uv_handle_t* endgame_handles;                                               \
-  /* The head of the timers tree */                                           \
-  struct uv_timer_tree_s timers;                                              \
-    /* Lists of active loop (prepare / check / idle) watchers */              \
-  uv_prepare_t* prepare_handles;                                              \
-  uv_check_t* check_handles;                                                  \
-  uv_idle_t* idle_handles;                                                    \
-  /* This pointer will refer to the prepare/check/idle handle whose */        \
-  /* callback is scheduled to be called next. This is needed to allow */      \
-  /* safe removal from one of the lists above while that list being */        \
-  /* iterated over. */                                                        \
-  uv_prepare_t* next_prepare_handle;                                          \
-  uv_check_t* next_check_handle;                                              \
-  uv_idle_t* next_idle_handle;                                                \
-  /* This handle holds the peer sockets for the fast variant of uv_poll_t */  \
-  SOCKET poll_peer_sockets[UV_MSAFD_PROVIDER_COUNT];                          \
-  /* Counter to keep track of active tcp streams */                           \
-  unsigned int active_tcp_streams;                                            \
-  /* Counter to keep track of active udp streams */                           \
-  unsigned int active_udp_streams;                                            \
-  /* Counter to started timer */                                              \
-  uint64_t timer_counter;                                                     \
-  /* Threadpool */                                                            \
-  void* wq[2];                                                                \
-  uv_mutex_t wq_mutex;                                                        \
-  uv_async_t wq_async;
-
-#define UV_REQ_TYPE_PRIVATE                                                   \
-  /* TODO: remove the req suffix */                                           \
-  UV_ACCEPT,                                                                  \
-  UV_FS_EVENT_REQ,                                                            \
-  UV_POLL_REQ,                                                                \
-  UV_PROCESS_EXIT,                                                            \
-  UV_READ,                                                                    \
-  UV_UDP_RECV,                                                                \
-  UV_WAKEUP,                                                                  \
-  UV_SIGNAL_REQ,
-
-#define UV_REQ_PRIVATE_FIELDS                                                 \
-  union {                                                                     \
-    /* Used by I/O operations */                                              \
-    struct {                                                                  \
-      OVERLAPPED overlapped;                                                  \
-      size_t queued_bytes;                                                    \
-    } io;                                                                     \
-  } u;                                                                        \
-  struct uv_req_s* next_req;
-
-#define UV_WRITE_PRIVATE_FIELDS                                               \
-  int ipc_header;                                                             \
-  uv_buf_t write_buffer;                                                      \
-  HANDLE event_handle;                                                        \
-  HANDLE wait_handle;
-
-#define UV_CONNECT_PRIVATE_FIELDS                                             \
-  /* empty */
-
-#define UV_SHUTDOWN_PRIVATE_FIELDS                                            \
-  /* empty */
-
-#define UV_UDP_SEND_PRIVATE_FIELDS                                            \
-  /* empty */
-
-#define UV_PRIVATE_REQ_TYPES                                                  \
-  typedef struct uv_pipe_accept_s {                                           \
-    UV_REQ_FIELDS                                                             \
-    HANDLE pipeHandle;                                                        \
-    struct uv_pipe_accept_s* next_pending;                                    \
-  } uv_pipe_accept_t;                                                         \
-                                                                              \
-  typedef struct uv_tcp_accept_s {                                            \
-    UV_REQ_FIELDS                                                             \
-    SOCKET accept_socket;                                                     \
-    char accept_buffer[sizeof(struct sockaddr_storage) * 2 + 32];             \
-    HANDLE event_handle;                                                      \
-    HANDLE wait_handle;                                                       \
-    struct uv_tcp_accept_s* next_pending;                                     \
-  } uv_tcp_accept_t;                                                          \
-                                                                              \
-  typedef struct uv_read_s {                                                  \
-    UV_REQ_FIELDS                                                             \
-    HANDLE event_handle;                                                      \
-    HANDLE wait_handle;                                                       \
-  } uv_read_t;
-
-#define uv_stream_connection_fields                                           \
-  unsigned int write_reqs_pending;                                            \
-  uv_shutdown_t* shutdown_req;
-
-#define uv_stream_server_fields                                               \
-  uv_connection_cb connection_cb;
-
-#define UV_STREAM_PRIVATE_FIELDS                                              \
-  unsigned int reqs_pending;                                                  \
-  int activecnt;                                                              \
-  uv_read_t read_req;                                                         \
-  union {                                                                     \
-    struct { uv_stream_connection_fields } conn;                              \
-    struct { uv_stream_server_fields     } serv;                              \
-  } stream;
-
-#define uv_tcp_server_fields                                                  \
-  uv_tcp_accept_t* accept_reqs;                                               \
-  unsigned int processed_accepts;                                             \
-  uv_tcp_accept_t* pending_accepts;                                           \
-  LPFN_ACCEPTEX func_acceptex;
-
-#define uv_tcp_connection_fields                                              \
-  uv_buf_t read_buffer;                                                       \
-  LPFN_CONNECTEX func_connectex;
-
-#define UV_TCP_PRIVATE_FIELDS                                                 \
-  SOCKET socket;                                                              \
-  int delayed_error;                                                          \
-  union {                                                                     \
-    struct { uv_tcp_server_fields } serv;                                     \
-    struct { uv_tcp_connection_fields } conn;                                 \
-  } tcp;
-
-#define UV_UDP_PRIVATE_FIELDS                                                 \
-  SOCKET socket;                                                              \
-  unsigned int reqs_pending;                                                  \
-  int activecnt;                                                              \
-  uv_req_t recv_req;                                                          \
-  uv_buf_t recv_buffer;                                                       \
-  struct sockaddr_storage recv_from;                                          \
-  int recv_from_len;                                                          \
-  uv_udp_recv_cb recv_cb;                                                     \
-  uv_alloc_cb alloc_cb;                                                       \
-  LPFN_WSARECV func_wsarecv;                                                  \
-  LPFN_WSARECVFROM func_wsarecvfrom;
-
-#define uv_pipe_server_fields                                                 \
-  int pending_instances;                                                      \
-  uv_pipe_accept_t* accept_reqs;                                              \
-  uv_pipe_accept_t* pending_accepts;
-
-#define uv_pipe_connection_fields                                             \
-  uv_timer_t* eof_timer;                                                      \
-  uv_write_t ipc_header_write_req;                                            \
-  int ipc_pid;                                                                \
-  uint64_t remaining_ipc_rawdata_bytes;                                       \
-  struct {                                                                    \
-    void* queue[2];                                                           \
-    int queue_len;                                                            \
-  } pending_ipc_info;                                                         \
-  uv_write_t* non_overlapped_writes_tail;                                     \
-  uv_mutex_t readfile_mutex;                                                  \
-  volatile HANDLE readfile_thread;
-
-#define UV_PIPE_PRIVATE_FIELDS                                                \
-  HANDLE handle;                                                              \
-  WCHAR* name;                                                                \
-  union {                                                                     \
-    struct { uv_pipe_server_fields } serv;                                    \
-    struct { uv_pipe_connection_fields } conn;                                \
-  } pipe;
-
-/* TODO: put the parser states in an union - TTY handles are always */
-/* half-duplex so read-state can safely overlap write-state. */
-#define UV_TTY_PRIVATE_FIELDS                                                 \
-  HANDLE handle;                                                              \
-  union {                                                                     \
-    struct {                                                                  \
-      /* Used for readable TTY handles */                                     \
-      /* TODO: remove me in v2.x. */                                          \
-      HANDLE unused_;                                                         \
-      uv_buf_t read_line_buffer;                                              \
-      HANDLE read_raw_wait;                                                   \
-      /* Fields used for translating win keystrokes into vt100 characters */  \
-      char last_key[8];                                                       \
-      unsigned char last_key_offset;                                          \
-      unsigned char last_key_len;                                             \
-      WCHAR last_utf16_high_surrogate;                                        \
-      INPUT_RECORD last_input_record;                                         \
-    } rd;                                                                     \
-    struct {                                                                  \
-      /* Used for writable TTY handles */                                     \
-      /* utf8-to-utf16 conversion state */                                    \
-      unsigned int utf8_codepoint;                                            \
-      unsigned char utf8_bytes_left;                                          \
-      /* eol conversion state */                                              \
-      unsigned char previous_eol;                                             \
-      /* ansi parser state */                                                 \
-      unsigned char ansi_parser_state;                                        \
-      unsigned char ansi_csi_argc;                                            \
-      unsigned short ansi_csi_argv[4];                                        \
-      COORD saved_position;                                                   \
-      WORD saved_attributes;                                                  \
-    } wr;                                                                     \
-  } tty;
-
-#define UV_POLL_PRIVATE_FIELDS                                                \
-  SOCKET socket;                                                              \
-  /* Used in fast mode */                                                     \
-  SOCKET peer_socket;                                                         \
-  AFD_POLL_INFO afd_poll_info_1;                                              \
-  AFD_POLL_INFO afd_poll_info_2;                                              \
-  /* Used in fast and slow mode. */                                           \
-  uv_req_t poll_req_1;                                                        \
-  uv_req_t poll_req_2;                                                        \
-  unsigned char submitted_events_1;                                           \
-  unsigned char submitted_events_2;                                           \
-  unsigned char mask_events_1;                                                \
-  unsigned char mask_events_2;                                                \
-  unsigned char events;
-
-#define UV_TIMER_PRIVATE_FIELDS                                               \
-  RB_ENTRY(uv_timer_s) tree_entry;                                            \
-  uint64_t due;                                                               \
-  uint64_t repeat;                                                            \
-  uint64_t start_id;                                                          \
-  uv_timer_cb timer_cb;
-
-#define UV_ASYNC_PRIVATE_FIELDS                                               \
-  struct uv_req_s async_req;                                                  \
-  uv_async_cb async_cb;                                                       \
-  /* char to avoid alignment issues */                                        \
-  char volatile async_sent;
-
-#define UV_PREPARE_PRIVATE_FIELDS                                             \
-  uv_prepare_t* prepare_prev;                                                 \
-  uv_prepare_t* prepare_next;                                                 \
-  uv_prepare_cb prepare_cb;
-
-#define UV_CHECK_PRIVATE_FIELDS                                               \
-  uv_check_t* check_prev;                                                     \
-  uv_check_t* check_next;                                                     \
-  uv_check_cb check_cb;
-
-#define UV_IDLE_PRIVATE_FIELDS                                                \
-  uv_idle_t* idle_prev;                                                       \
-  uv_idle_t* idle_next;                                                       \
-  uv_idle_cb idle_cb;
-
-#define UV_HANDLE_PRIVATE_FIELDS                                              \
-  uv_handle_t* endgame_next;                                                  \
-  unsigned int flags;
-
-#define UV_GETADDRINFO_PRIVATE_FIELDS                                         \
-  struct uv__work work_req;                                                   \
-  uv_getaddrinfo_cb getaddrinfo_cb;                                           \
-  void* alloc;                                                                \
-  WCHAR* node;                                                                \
-  WCHAR* service;                                                             \
-  /* The addrinfoW field is used to store a pointer to the hints, and    */   \
-  /* later on to store the result of GetAddrInfoW. The final result will */   \
-  /* be converted to struct addrinfo* and stored in the addrinfo field.  */   \
-  struct addrinfoW* addrinfow;                                                \
-  struct addrinfo* addrinfo;                                                  \
-  int retcode;
-
-#define UV_GETNAMEINFO_PRIVATE_FIELDS                                         \
-  struct uv__work work_req;                                                   \
-  uv_getnameinfo_cb getnameinfo_cb;                                           \
-  struct sockaddr_storage storage;                                            \
-  int flags;                                                                  \
-  char host[NI_MAXHOST];                                                      \
-  char service[NI_MAXSERV];                                                   \
-  int retcode;
-
-#define UV_PROCESS_PRIVATE_FIELDS                                             \
-  struct uv_process_exit_s {                                                  \
-    UV_REQ_FIELDS                                                             \
-  } exit_req;                                                                 \
-  BYTE* child_stdio_buffer;                                                   \
-  int exit_signal;                                                            \
-  HANDLE wait_handle;                                                         \
-  HANDLE process_handle;                                                      \
-  volatile char exit_cb_pending;
-
-#define UV_FS_PRIVATE_FIELDS                                                  \
-  struct uv__work work_req;                                                   \
-  int flags;                                                                  \
-  DWORD sys_errno_;                                                           \
-  union {                                                                     \
-    /* TODO: remove me in 0.9. */                                             \
-    WCHAR* pathw;                                                             \
-    int fd;                                                                   \
-  } file;                                                                     \
-  union {                                                                     \
-    struct {                                                                  \
-      int mode;                                                               \
-      WCHAR* new_pathw;                                                       \
-      int file_flags;                                                         \
-      int fd_out;                                                             \
-      unsigned int nbufs;                                                     \
-      uv_buf_t* bufs;                                                         \
-      int64_t offset;                                                         \
-      uv_buf_t bufsml[4];                                                     \
-    } info;                                                                   \
-    struct {                                                                  \
-      double atime;                                                           \
-      double mtime;                                                           \
-    } time;                                                                   \
-  } fs;
-
-#define UV_WORK_PRIVATE_FIELDS                                                \
-  struct uv__work work_req;
-
-#define UV_FS_EVENT_PRIVATE_FIELDS                                            \
-  struct uv_fs_event_req_s {                                                  \
-    UV_REQ_FIELDS                                                             \
-  } req;                                                                      \
-  HANDLE dir_handle;                                                          \
-  int req_pending;                                                            \
-  uv_fs_event_cb cb;                                                          \
-  WCHAR* filew;                                                               \
-  WCHAR* short_filew;                                                         \
-  WCHAR* dirw;                                                                \
-  char* buffer;
-
-#define UV_SIGNAL_PRIVATE_FIELDS                                              \
-  RB_ENTRY(uv_signal_s) tree_entry;                                           \
-  struct uv_req_s signal_req;                                                 \
-  unsigned long pending_signum;
-
-#ifndef F_OK
-#define F_OK 0
-#endif
-#ifndef R_OK
-#define R_OK 4
-#endif
-#ifndef W_OK
-#define W_OK 2
-#endif
-#ifndef X_OK
-#define X_OK 1
-#endif
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/include/uv.h
+++ /dev/null
@@ -1,1499 +0,0 @@
-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-/* See https://github.com/libuv/libuv#documentation for documentation. */
-
-#ifndef UV_H
-#define UV_H
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#ifdef _WIN32
-  /* Windows - set up dll import/export decorators. */
-# if defined(BUILDING_UV_SHARED)
-    /* Building shared library. */
-#   define UV_EXTERN __declspec(dllexport)
-# elif defined(USING_UV_SHARED)
-    /* Using shared library. */
-#   define UV_EXTERN __declspec(dllimport)
-# else
-    /* Building static library. */
-#   define UV_EXTERN /* nothing */
-# endif
-#elif __GNUC__ >= 4
-# define UV_EXTERN __attribute__((visibility("default")))
-#else
-# define UV_EXTERN /* nothing */
-#endif
-
-#include "uv-errno.h"
-#include "uv-version.h"
-#include <stddef.h>
-#include <stdio.h>
-
-#if defined(_MSC_VER) && _MSC_VER < 1600
-# include "stdint-msvc2008.h"
-#else
-# include <stdint.h>
-#endif
-
-#if defined(_WIN32)
-# include "uv-win.h"
-#else
-# include "uv-unix.h"
-#endif
-
-/* Expand this list if necessary. */
-#define UV_ERRNO_MAP(XX)                                                      \
-  XX(E2BIG, "argument list too long")                                         \
-  XX(EACCES, "permission denied")                                             \
-  XX(EADDRINUSE, "address already in use")                                    \
-  XX(EADDRNOTAVAIL, "address not available")                                  \
-  XX(EAFNOSUPPORT, "address family not supported")                            \
-  XX(EAGAIN, "resource temporarily unavailable")                              \
-  XX(EAI_ADDRFAMILY, "address family not supported")                          \
-  XX(EAI_AGAIN, "temporary failure")                                          \
-  XX(EAI_BADFLAGS, "bad ai_flags value")                                      \
-  XX(EAI_BADHINTS, "invalid value for hints")                                 \
-  XX(EAI_CANCELED, "request canceled")                                        \
-  XX(EAI_FAIL, "permanent failure")                                           \
-  XX(EAI_FAMILY, "ai_family not supported")                                   \
-  XX(EAI_MEMORY, "out of memory")                                             \
-  XX(EAI_NODATA, "no address")                                                \
-  XX(EAI_NONAME, "unknown node or service")                                   \
-  XX(EAI_OVERFLOW, "argument buffer overflow")                                \
-  XX(EAI_PROTOCOL, "resolved protocol is unknown")                            \
-  XX(EAI_SERVICE, "service not available for socket type")                    \
-  XX(EAI_SOCKTYPE, "socket type not supported")                               \
-  XX(EALREADY, "connection already in progress")                              \
-  XX(EBADF, "bad file descriptor")                                            \
-  XX(EBUSY, "resource busy or locked")                                        \
-  XX(ECANCELED, "operation canceled")                                         \
-  XX(ECHARSET, "invalid Unicode character")                                   \
-  XX(ECONNABORTED, "software caused connection abort")                        \
-  XX(ECONNREFUSED, "connection refused")                                      \
-  XX(ECONNRESET, "connection reset by peer")                                  \
-  XX(EDESTADDRREQ, "destination address required")                            \
-  XX(EEXIST, "file already exists")                                           \
-  XX(EFAULT, "bad address in system call argument")                           \
-  XX(EFBIG, "file too large")                                                 \
-  XX(EHOSTUNREACH, "host is unreachable")                                     \
-  XX(EINTR, "interrupted system call")                                        \
-  XX(EINVAL, "invalid argument")                                              \
-  XX(EIO, "i/o error")                                                        \
-  XX(EISCONN, "socket is already connected")                                  \
-  XX(EISDIR, "illegal operation on a directory")                              \
-  XX(ELOOP, "too many symbolic links encountered")                            \
-  XX(EMFILE, "too many open files")                                           \
-  XX(EMSGSIZE, "message too long")                                            \
-  XX(ENAMETOOLONG, "name too long")                                           \
-  XX(ENETDOWN, "network is down")                                             \
-  XX(ENETUNREACH, "network is unreachable")                                   \
-  XX(ENFILE, "file table overflow")                                           \
-  XX(ENOBUFS, "no buffer space available")                                    \
-  XX(ENODEV, "no such device")                                                \
-  XX(ENOENT, "no such file or directory")                                     \
-  XX(ENOMEM, "not enough memory")                                             \
-  XX(ENONET, "machine is not on the network")                                 \
-  XX(ENOPROTOOPT, "protocol not available")                                   \
-  XX(ENOSPC, "no space left on device")                                       \
-  XX(ENOSYS, "function not implemented")                                      \
-  XX(ENOTCONN, "socket is not connected")                                     \
-  XX(ENOTDIR, "not a directory")                                              \
-  XX(ENOTEMPTY, "directory not empty")                                        \
-  XX(ENOTSOCK, "socket operation on non-socket")                              \
-  XX(ENOTSUP, "operation not supported on socket")                            \
-  XX(EPERM, "operation not permitted")                                        \
-  XX(EPIPE, "broken pipe")                                                    \
-  XX(EPROTO, "protocol error")                                                \
-  XX(EPROTONOSUPPORT, "protocol not supported")                               \
-  XX(EPROTOTYPE, "protocol wrong type for socket")                            \
-  XX(ERANGE, "result too large")                                              \
-  XX(EROFS, "read-only file system")                                          \
-  XX(ESHUTDOWN, "cannot send after transport endpoint shutdown")              \
-  XX(ESPIPE, "invalid seek")                                                  \
-  XX(ESRCH, "no such process")                                                \
-  XX(ETIMEDOUT, "connection timed out")                                       \
-  XX(ETXTBSY, "text file is busy")                                            \
-  XX(EXDEV, "cross-device link not permitted")                                \
-  XX(UNKNOWN, "unknown error")                                                \
-  XX(EOF, "end of file")                                                      \
-  XX(ENXIO, "no such device or address")                                      \
-  XX(EMLINK, "too many links")                                                \
-  XX(EHOSTDOWN, "host is down")                                               \
-
-#define UV_HANDLE_TYPE_MAP(XX)                                                \
-  XX(ASYNC, async)                                                            \
-  XX(CHECK, check)                                                            \
-  XX(FS_EVENT, fs_event)                                                      \
-  XX(FS_POLL, fs_poll)                                                        \
-  XX(HANDLE, handle)                                                          \
-  XX(IDLE, idle)                                                              \
-  XX(NAMED_PIPE, pipe)                                                        \
-  XX(POLL, poll)                                                              \
-  XX(PREPARE, prepare)                                                        \
-  XX(PROCESS, process)                                                        \
-  XX(STREAM, stream)                                                          \
-  XX(TCP, tcp)                                                                \
-  XX(TIMER, timer)                                                            \
-  XX(TTY, tty)                                                                \
-  XX(UDP, udp)                                                                \
-  XX(SIGNAL, signal)                                                          \
-
-#define UV_REQ_TYPE_MAP(XX)                                                   \
-  XX(REQ, req)                                                                \
-  XX(CONNECT, connect)                                                        \
-  XX(WRITE, write)                                                            \
-  XX(SHUTDOWN, shutdown)                                                      \
-  XX(UDP_SEND, udp_send)                                                      \
-  XX(FS, fs)                                                                  \
-  XX(WORK, work)                                                              \
-  XX(GETADDRINFO, getaddrinfo)                                                \
-  XX(GETNAMEINFO, getnameinfo)                                                \
-
-typedef enum {
-#define XX(code, _) UV_ ## code = UV__ ## code,
-  UV_ERRNO_MAP(XX)
-#undef XX
-  UV_ERRNO_MAX = UV__EOF - 1
-} uv_errno_t;
-
-typedef enum {
-  UV_UNKNOWN_HANDLE = 0,
-#define XX(uc, lc) UV_##uc,
-  UV_HANDLE_TYPE_MAP(XX)
-#undef XX
-  UV_FILE,
-  UV_HANDLE_TYPE_MAX
-} uv_handle_type;
-
-typedef enum {
-  UV_UNKNOWN_REQ = 0,
-#define XX(uc, lc) UV_##uc,
-  UV_REQ_TYPE_MAP(XX)
-#undef XX
-  UV_REQ_TYPE_PRIVATE
-  UV_REQ_TYPE_MAX
-} uv_req_type;
-
-
-/* Handle types. */
-typedef struct uv_loop_s uv_loop_t;
-typedef struct uv_handle_s uv_handle_t;
-typedef struct uv_stream_s uv_stream_t;
-typedef struct uv_tcp_s uv_tcp_t;
-typedef struct uv_udp_s uv_udp_t;
-typedef struct uv_pipe_s uv_pipe_t;
-typedef struct uv_tty_s uv_tty_t;
-typedef struct uv_poll_s uv_poll_t;
-typedef struct uv_timer_s uv_timer_t;
-typedef struct uv_prepare_s uv_prepare_t;
-typedef struct uv_check_s uv_check_t;
-typedef struct uv_idle_s uv_idle_t;
-typedef struct uv_async_s uv_async_t;
-typedef struct uv_process_s uv_process_t;
-typedef struct uv_fs_event_s uv_fs_event_t;
-typedef struct uv_fs_poll_s uv_fs_poll_t;
-typedef struct uv_signal_s uv_signal_t;
-
-/* Request types. */
-typedef struct uv_req_s uv_req_t;
-typedef struct uv_getaddrinfo_s uv_getaddrinfo_t;
-typedef struct uv_getnameinfo_s uv_getnameinfo_t;
-typedef struct uv_shutdown_s uv_shutdown_t;
-typedef struct uv_write_s uv_write_t;
-typedef struct uv_connect_s uv_connect_t;
-typedef struct uv_udp_send_s uv_udp_send_t;
-typedef struct uv_fs_s uv_fs_t;
-typedef struct uv_work_s uv_work_t;
-
-/* None of the above. */
-typedef struct uv_cpu_info_s uv_cpu_info_t;
-typedef struct uv_interface_address_s uv_interface_address_t;
-typedef struct uv_dirent_s uv_dirent_t;
-typedef struct uv_passwd_s uv_passwd_t;
-
-typedef enum {
-  UV_LOOP_BLOCK_SIGNAL
-} uv_loop_option;
-
-typedef enum {
-  UV_RUN_DEFAULT = 0,
-  UV_RUN_ONCE,
-  UV_RUN_NOWAIT
-} uv_run_mode;
-
-
-UV_EXTERN unsigned int uv_version(void);
-UV_EXTERN const char* uv_version_string(void);
-
-typedef void* (*uv_malloc_func)(size_t size);
-typedef void* (*uv_realloc_func)(void* ptr, size_t size);
-typedef void* (*uv_calloc_func)(size_t count, size_t size);
-typedef void (*uv_free_func)(void* ptr);
-
-UV_EXTERN int uv_replace_allocator(uv_malloc_func malloc_func,
-                                   uv_realloc_func realloc_func,
-                                   uv_calloc_func calloc_func,
-                                   uv_free_func free_func);
-
-UV_EXTERN uv_loop_t* uv_default_loop(void);
-UV_EXTERN int uv_loop_init(uv_loop_t* loop);
-UV_EXTERN int uv_loop_close(uv_loop_t* loop);
-/*
- * NOTE:
- *  This function is DEPRECATED (to be removed after 0.12), users should
- *  allocate the loop manually and use uv_loop_init instead.
- */
-UV_EXTERN uv_loop_t* uv_loop_new(void);
-/*
- * NOTE:
- *  This function is DEPRECATED (to be removed after 0.12). Users should use
- *  uv_loop_close and free the memory manually instead.
- */
-UV_EXTERN void uv_loop_delete(uv_loop_t*);
-UV_EXTERN size_t uv_loop_size(void);
-UV_EXTERN int uv_loop_alive(const uv_loop_t* loop);
-UV_EXTERN int uv_loop_configure(uv_loop_t* loop, uv_loop_option option, ...);
-
-UV_EXTERN int uv_run(uv_loop_t*, uv_run_mode mode);
-UV_EXTERN void uv_stop(uv_loop_t*);
-
-UV_EXTERN void uv_ref(uv_handle_t*);
-UV_EXTERN void uv_unref(uv_handle_t*);
-UV_EXTERN int uv_has_ref(const uv_handle_t*);
-
-UV_EXTERN void uv_update_time(uv_loop_t*);
-UV_EXTERN uint64_t uv_now(const uv_loop_t*);
-
-UV_EXTERN int uv_backend_fd(const uv_loop_t*);
-UV_EXTERN int uv_backend_timeout(const uv_loop_t*);
-
-typedef void (*uv_alloc_cb)(uv_handle_t* handle,
-                            size_t suggested_size,
-                            uv_buf_t* buf);
-typedef void (*uv_read_cb)(uv_stream_t* stream,
-                           ssize_t nread,
-                           const uv_buf_t* buf);
-typedef void (*uv_write_cb)(uv_write_t* req, int status);
-typedef void (*uv_connect_cb)(uv_connect_t* req, int status);
-typedef void (*uv_shutdown_cb)(uv_shutdown_t* req, int status);
-typedef void (*uv_connection_cb)(uv_stream_t* server, int status);
-typedef void (*uv_close_cb)(uv_handle_t* handle);
-typedef void (*uv_poll_cb)(uv_poll_t* handle, int status, int events);
-typedef void (*uv_timer_cb)(uv_timer_t* handle);
-typedef void (*uv_async_cb)(uv_async_t* handle);
-typedef void (*uv_prepare_cb)(uv_prepare_t* handle);
-typedef void (*uv_check_cb)(uv_check_t* handle);
-typedef void (*uv_idle_cb)(uv_idle_t* handle);
-typedef void (*uv_exit_cb)(uv_process_t*, int64_t exit_status, int term_signal);
-typedef void (*uv_walk_cb)(uv_handle_t* handle, void* arg);
-typedef void (*uv_fs_cb)(uv_fs_t* req);
-typedef void (*uv_work_cb)(uv_work_t* req);
-typedef void (*uv_after_work_cb)(uv_work_t* req, int status);
-typedef void (*uv_getaddrinfo_cb)(uv_getaddrinfo_t* req,
-                                  int status,
-                                  struct addrinfo* res);
-typedef void (*uv_getnameinfo_cb)(uv_getnameinfo_t* req,
-                                  int status,
-                                  const char* hostname,
-                                  const char* service);
-
-typedef struct {
-  long tv_sec;
-  long tv_nsec;
-} uv_timespec_t;
-
-
-typedef struct {
-  uint64_t st_dev;
-  uint64_t st_mode;
-  uint64_t st_nlink;
-  uint64_t st_uid;
-  uint64_t st_gid;
-  uint64_t st_rdev;
-  uint64_t st_ino;
-  uint64_t st_size;
-  uint64_t st_blksize;
-  uint64_t st_blocks;
-  uint64_t st_flags;
-  uint64_t st_gen;
-  uv_timespec_t st_atim;
-  uv_timespec_t st_mtim;
-  uv_timespec_t st_ctim;
-  uv_timespec_t st_birthtim;
-} uv_stat_t;
-
-
-typedef void (*uv_fs_event_cb)(uv_fs_event_t* handle,
-                               const char* filename,
-                               int events,
-                               int status);
-
-typedef void (*uv_fs_poll_cb)(uv_fs_poll_t* handle,
-                              int status,
-                              const uv_stat_t* prev,
-                              const uv_stat_t* curr);
-
-typedef void (*uv_signal_cb)(uv_signal_t* handle, int signum);
-
-
-typedef enum {
-  UV_LEAVE_GROUP = 0,
-  UV_JOIN_GROUP
-} uv_membership;
-
-
-UV_EXTERN int uv_translate_sys_error(int sys_errno);
-
-UV_EXTERN const char* uv_strerror(int err);
-UV_EXTERN const char* uv_err_name(int err);
-
-
-#define UV_REQ_FIELDS                                                         \
-  /* public */                                                                \
-  void* data;                                                                 \
-  /* read-only */                                                             \
-  uv_req_type type;                                                           \
-  /* private */                                                               \
-  void* active_queue[2];                                                      \
-  void* reserved[4];                                                          \
-  UV_REQ_PRIVATE_FIELDS                                                       \
-
-/* Abstract base class of all requests. */
-struct uv_req_s {
-  UV_REQ_FIELDS
-};
-
-
-/* Platform-specific request types. */
-UV_PRIVATE_REQ_TYPES
-
-
-UV_EXTERN int uv_shutdown(uv_shutdown_t* req,
-                          uv_stream_t* handle,
-                          uv_shutdown_cb cb);
-
-struct uv_shutdown_s {
-  UV_REQ_FIELDS
-  uv_stream_t* handle;
-  uv_shutdown_cb cb;
-  UV_SHUTDOWN_PRIVATE_FIELDS
-};
-
-
-#define UV_HANDLE_FIELDS                                                      \
-  /* public */                                                                \
-  void* data;                                                                 \
-  /* read-only */                                                             \
-  uv_loop_t* loop;                                                            \
-  uv_handle_type type;                                                        \
-  /* private */                                                               \
-  uv_close_cb close_cb;                                                       \
-  void* handle_queue[2];                                                      \
-  union {                                                                     \
-    int fd;                                                                   \
-    void* reserved[4];                                                        \
-  } u;                                                                        \
-  UV_HANDLE_PRIVATE_FIELDS                                                    \
-
-/* The abstract base class of all handles. */
-struct uv_handle_s {
-  UV_HANDLE_FIELDS
-};
-
-UV_EXTERN size_t uv_handle_size(uv_handle_type type);
-UV_EXTERN size_t uv_req_size(uv_req_type type);
-
-UV_EXTERN int uv_is_active(const uv_handle_t* handle);
-
-UV_EXTERN void uv_walk(uv_loop_t* loop, uv_walk_cb walk_cb, void* arg);
-
-/* Helpers for ad hoc debugging, no API/ABI stability guaranteed. */
-UV_EXTERN void uv_print_all_handles(uv_loop_t* loop, FILE* stream);
-UV_EXTERN void uv_print_active_handles(uv_loop_t* loop, FILE* stream);
-
-UV_EXTERN void uv_close(uv_handle_t* handle, uv_close_cb close_cb);
-
-UV_EXTERN int uv_send_buffer_size(uv_handle_t* handle, int* value);
-UV_EXTERN int uv_recv_buffer_size(uv_handle_t* handle, int* value);
-
-UV_EXTERN int uv_fileno(const uv_handle_t* handle, uv_os_fd_t* fd);
-
-UV_EXTERN uv_buf_t uv_buf_init(char* base, unsigned int len);
-
-
-#define UV_STREAM_FIELDS                                                      \
-  /* number of bytes queued for writing */                                    \
-  size_t write_queue_size;                                                    \
-  uv_alloc_cb alloc_cb;                                                       \
-  uv_read_cb read_cb;                                                         \
-  /* private */                                                               \
-  UV_STREAM_PRIVATE_FIELDS
-
-/*
- * uv_stream_t is a subclass of uv_handle_t.
- *
- * uv_stream is an abstract class.
- *
- * uv_stream_t is the parent class of uv_tcp_t, uv_pipe_t and uv_tty_t.
- */
-struct uv_stream_s {
-  UV_HANDLE_FIELDS
-  UV_STREAM_FIELDS
-};
-
-UV_EXTERN int uv_listen(uv_stream_t* stream, int backlog, uv_connection_cb cb);
-UV_EXTERN int uv_accept(uv_stream_t* server, uv_stream_t* client);
-
-UV_EXTERN int uv_read_start(uv_stream_t*,
-                            uv_alloc_cb alloc_cb,
-                            uv_read_cb read_cb);
-UV_EXTERN int uv_read_stop(uv_stream_t*);
-
-UV_EXTERN int uv_write(uv_write_t* req,
-                       uv_stream_t* handle,
-                       const uv_buf_t bufs[],
-                       unsigned int nbufs,
-                       uv_write_cb cb);
-UV_EXTERN int uv_write2(uv_write_t* req,
-                        uv_stream_t* handle,
-                        const uv_buf_t bufs[],
-                        unsigned int nbufs,
-                        uv_stream_t* send_handle,
-                        uv_write_cb cb);
-UV_EXTERN int uv_try_write(uv_stream_t* handle,
-                           const uv_buf_t bufs[],
-                           unsigned int nbufs);
-
-/* uv_write_t is a subclass of uv_req_t. */
-struct uv_write_s {
-  UV_REQ_FIELDS
-  uv_write_cb cb;
-  uv_stream_t* send_handle;
-  uv_stream_t* handle;
-  UV_WRITE_PRIVATE_FIELDS
-};
-
-
-UV_EXTERN int uv_is_readable(const uv_stream_t* handle);
-UV_EXTERN int uv_is_writable(const uv_stream_t* handle);
-
-UV_EXTERN int uv_stream_set_blocking(uv_stream_t* handle, int blocking);
-
-UV_EXTERN int uv_is_closing(const uv_handle_t* handle);
-
-
-/*
- * uv_tcp_t is a subclass of uv_stream_t.
- *
- * Represents a TCP stream or TCP server.
- */
-struct uv_tcp_s {
-  UV_HANDLE_FIELDS
-  UV_STREAM_FIELDS
-  UV_TCP_PRIVATE_FIELDS
-};
-
-UV_EXTERN int uv_tcp_init(uv_loop_t*, uv_tcp_t* handle);
-UV_EXTERN int uv_tcp_init_ex(uv_loop_t*, uv_tcp_t* handle, unsigned int flags);
-UV_EXTERN int uv_tcp_open(uv_tcp_t* handle, uv_os_sock_t sock);
-UV_EXTERN int uv_tcp_nodelay(uv_tcp_t* handle, int enable);
-UV_EXTERN int uv_tcp_keepalive(uv_tcp_t* handle,
-                               int enable,
-                               unsigned int delay);
-UV_EXTERN int uv_tcp_simultaneous_accepts(uv_tcp_t* handle, int enable);
-
-enum uv_tcp_flags {
-  /* Used with uv_tcp_bind, when an IPv6 address is used. */
-  UV_TCP_IPV6ONLY = 1
-};
-
-UV_EXTERN int uv_tcp_bind(uv_tcp_t* handle,
-                          const struct sockaddr* addr,
-                          unsigned int flags);
-UV_EXTERN int uv_tcp_getsockname(const uv_tcp_t* handle,
-                                 struct sockaddr* name,
-                                 int* namelen);
-UV_EXTERN int uv_tcp_getpeername(const uv_tcp_t* handle,
-                                 struct sockaddr* name,
-                                 int* namelen);
-UV_EXTERN int uv_tcp_connect(uv_connect_t* req,
-                             uv_tcp_t* handle,
-                             const struct sockaddr* addr,
-                             uv_connect_cb cb);
-
-/* uv_connect_t is a subclass of uv_req_t. */
-struct uv_connect_s {
-  UV_REQ_FIELDS
-  uv_connect_cb cb;
-  uv_stream_t* handle;
-  UV_CONNECT_PRIVATE_FIELDS
-};
-
-
-/*
- * UDP support.
- */
-
-enum uv_udp_flags {
-  /* Disables dual stack mode. */
-  UV_UDP_IPV6ONLY = 1,
-  /*
-   * Indicates message was truncated because read buffer was too small. The
-   * remainder was discarded by the OS. Used in uv_udp_recv_cb.
-   */
-  UV_UDP_PARTIAL = 2,
-  /*
-   * Indicates if SO_REUSEADDR will be set when binding the handle.
-   * This sets the SO_REUSEPORT socket flag on the BSDs and OS X. On other
-   * Unix platforms, it sets the SO_REUSEADDR flag.  What that means is that
-   * multiple threads or processes can bind to the same address without error
-   * (provided they all set the flag) but only the last one to bind will receive
-   * any traffic, in effect "stealing" the port from the previous listener.
-   */
-  UV_UDP_REUSEADDR = 4
-};
-
-typedef void (*uv_udp_send_cb)(uv_udp_send_t* req, int status);
-typedef void (*uv_udp_recv_cb)(uv_udp_t* handle,
-                               ssize_t nread,
-                               const uv_buf_t* buf,
-                               const struct sockaddr* addr,
-                               unsigned flags);
-
-/* uv_udp_t is a subclass of uv_handle_t. */
-struct uv_udp_s {
-  UV_HANDLE_FIELDS
-  /* read-only */
-  /*
-   * Number of bytes queued for sending. This field strictly shows how much
-   * information is currently queued.
-   */
-  size_t send_queue_size;
-  /*
-   * Number of send requests currently in the queue awaiting to be processed.
-   */
-  size_t send_queue_count;
-  UV_UDP_PRIVATE_FIELDS
-};
-
-/* uv_udp_send_t is a subclass of uv_req_t. */
-struct uv_udp_send_s {
-  UV_REQ_FIELDS
-  uv_udp_t* handle;
-  uv_udp_send_cb cb;
-  UV_UDP_SEND_PRIVATE_FIELDS
-};
-
-UV_EXTERN int uv_udp_init(uv_loop_t*, uv_udp_t* handle);
-UV_EXTERN int uv_udp_init_ex(uv_loop_t*, uv_udp_t* handle, unsigned int flags);
-UV_EXTERN int uv_udp_open(uv_udp_t* handle, uv_os_sock_t sock);
-UV_EXTERN int uv_udp_bind(uv_udp_t* handle,
-                          const struct sockaddr* addr,
-                          unsigned int flags);
-
-UV_EXTERN int uv_udp_getsockname(const uv_udp_t* handle,
-                                 struct sockaddr* name,
-                                 int* namelen);
-UV_EXTERN int uv_udp_set_membership(uv_udp_t* handle,
-                                    const char* multicast_addr,
-                                    const char* interface_addr,
-                                    uv_membership membership);
-UV_EXTERN int uv_udp_set_multicast_loop(uv_udp_t* handle, int on);
-UV_EXTERN int uv_udp_set_multicast_ttl(uv_udp_t* handle, int ttl);
-UV_EXTERN int uv_udp_set_multicast_interface(uv_udp_t* handle,
-                                             const char* interface_addr);
-UV_EXTERN int uv_udp_set_broadcast(uv_udp_t* handle, int on);
-UV_EXTERN int uv_udp_set_ttl(uv_udp_t* handle, int ttl);
-UV_EXTERN int uv_udp_send(uv_udp_send_t* req,
-                          uv_udp_t* handle,
-                          const uv_buf_t bufs[],
-                          unsigned int nbufs,
-                          const struct sockaddr* addr,
-                          uv_udp_send_cb send_cb);
-UV_EXTERN int uv_udp_try_send(uv_udp_t* handle,
-                              const uv_buf_t bufs[],
-                              unsigned int nbufs,
-                              const struct sockaddr* addr);
-UV_EXTERN int uv_udp_recv_start(uv_udp_t* handle,
-                                uv_alloc_cb alloc_cb,
-                                uv_udp_recv_cb recv_cb);
-UV_EXTERN int uv_udp_recv_stop(uv_udp_t* handle);
-
-
-/*
- * uv_tty_t is a subclass of uv_stream_t.
- *
- * Representing a stream for the console.
- */
-struct uv_tty_s {
-  UV_HANDLE_FIELDS
-  UV_STREAM_FIELDS
-  UV_TTY_PRIVATE_FIELDS
-};
-
-typedef enum {
-  /* Initial/normal terminal mode */
-  UV_TTY_MODE_NORMAL,
-  /* Raw input mode (On Windows, ENABLE_WINDOW_INPUT is also enabled) */
-  UV_TTY_MODE_RAW,
-  /* Binary-safe I/O mode for IPC (Unix-only) */
-  UV_TTY_MODE_IO
-} uv_tty_mode_t;
-
-UV_EXTERN int uv_tty_init(uv_loop_t*, uv_tty_t*, uv_file fd, int readable);
-UV_EXTERN int uv_tty_set_mode(uv_tty_t*, uv_tty_mode_t mode);
-UV_EXTERN int uv_tty_reset_mode(void);
-UV_EXTERN int uv_tty_get_winsize(uv_tty_t*, int* width, int* height);
-
-#ifdef __cplusplus
-extern "C++" {
-
-inline int uv_tty_set_mode(uv_tty_t* handle, int mode) {
-  return uv_tty_set_mode(handle, static_cast<uv_tty_mode_t>(mode));
-}
-
-}
-#endif
-
-UV_EXTERN uv_handle_type uv_guess_handle(uv_file file);
-
-/*
- * uv_pipe_t is a subclass of uv_stream_t.
- *
- * Representing a pipe stream or pipe server. On Windows this is a Named
- * Pipe. On Unix this is a Unix domain socket.
- */
-struct uv_pipe_s {
-  UV_HANDLE_FIELDS
-  UV_STREAM_FIELDS
-  int ipc; /* non-zero if this pipe is used for passing handles */
-  UV_PIPE_PRIVATE_FIELDS
-};
-
-UV_EXTERN int uv_pipe_init(uv_loop_t*, uv_pipe_t* handle, int ipc);
-UV_EXTERN int uv_pipe_open(uv_pipe_t*, uv_file file);
-UV_EXTERN int uv_pipe_bind(uv_pipe_t* handle, const char* name);
-UV_EXTERN void uv_pipe_connect(uv_connect_t* req,
-                               uv_pipe_t* handle,
-                               const char* name,
-                               uv_connect_cb cb);
-UV_EXTERN int uv_pipe_getsockname(const uv_pipe_t* handle,
-                                  char* buffer,
-                                  size_t* size);
-UV_EXTERN int uv_pipe_getpeername(const uv_pipe_t* handle,
-                                  char* buffer,
-                                  size_t* size);
-UV_EXTERN void uv_pipe_pending_instances(uv_pipe_t* handle, int count);
-UV_EXTERN int uv_pipe_pending_count(uv_pipe_t* handle);
-UV_EXTERN uv_handle_type uv_pipe_pending_type(uv_pipe_t* handle);
-
-
-struct uv_poll_s {
-  UV_HANDLE_FIELDS
-  uv_poll_cb poll_cb;
-  UV_POLL_PRIVATE_FIELDS
-};
-
-enum uv_poll_event {
-  UV_READABLE = 1,
-  UV_WRITABLE = 2,
-  UV_DISCONNECT = 4
-};
-
-UV_EXTERN int uv_poll_init(uv_loop_t* loop, uv_poll_t* handle, int fd);
-UV_EXTERN int uv_poll_init_socket(uv_loop_t* loop,
-                                  uv_poll_t* handle,
-                                  uv_os_sock_t socket);
-UV_EXTERN int uv_poll_start(uv_poll_t* handle, int events, uv_poll_cb cb);
-UV_EXTERN int uv_poll_stop(uv_poll_t* handle);
-
-
-struct uv_prepare_s {
-  UV_HANDLE_FIELDS
-  UV_PREPARE_PRIVATE_FIELDS
-};
-
-UV_EXTERN int uv_prepare_init(uv_loop_t*, uv_prepare_t* prepare);
-UV_EXTERN int uv_prepare_start(uv_prepare_t* prepare, uv_prepare_cb cb);
-UV_EXTERN int uv_prepare_stop(uv_prepare_t* prepare);
-
-
-struct uv_check_s {
-  UV_HANDLE_FIELDS
-  UV_CHECK_PRIVATE_FIELDS
-};
-
-UV_EXTERN int uv_check_init(uv_loop_t*, uv_check_t* check);
-UV_EXTERN int uv_check_start(uv_check_t* check, uv_check_cb cb);
-UV_EXTERN int uv_check_stop(uv_check_t* check);
-
-
-struct uv_idle_s {
-  UV_HANDLE_FIELDS
-  UV_IDLE_PRIVATE_FIELDS
-};
-
-UV_EXTERN int uv_idle_init(uv_loop_t*, uv_idle_t* idle);
-UV_EXTERN int uv_idle_start(uv_idle_t* idle, uv_idle_cb cb);
-UV_EXTERN int uv_idle_stop(uv_idle_t* idle);
-
-
-struct uv_async_s {
-  UV_HANDLE_FIELDS
-  UV_ASYNC_PRIVATE_FIELDS
-};
-
-UV_EXTERN int uv_async_init(uv_loop_t*,
-                            uv_async_t* async,
-                            uv_async_cb async_cb);
-UV_EXTERN int uv_async_send(uv_async_t* async);
-
-
-/*
- * uv_timer_t is a subclass of uv_handle_t.
- *
- * Used to get woken up at a specified time in the future.
- */
-struct uv_timer_s {
-  UV_HANDLE_FIELDS
-  UV_TIMER_PRIVATE_FIELDS
-};
-
-UV_EXTERN int uv_timer_init(uv_loop_t*, uv_timer_t* handle);
-UV_EXTERN int uv_timer_start(uv_timer_t* handle,
-                             uv_timer_cb cb,
-                             uint64_t timeout,
-                             uint64_t repeat);
-UV_EXTERN int uv_timer_stop(uv_timer_t* handle);
-UV_EXTERN int uv_timer_again(uv_timer_t* handle);
-UV_EXTERN void uv_timer_set_repeat(uv_timer_t* handle, uint64_t repeat);
-UV_EXTERN uint64_t uv_timer_get_repeat(const uv_timer_t* handle);
-
-
-/*
- * uv_getaddrinfo_t is a subclass of uv_req_t.
- *
- * Request object for uv_getaddrinfo.
- */
-struct uv_getaddrinfo_s {
-  UV_REQ_FIELDS
-  /* read-only */
-  uv_loop_t* loop;
-  /* struct addrinfo* addrinfo is marked as private, but it really isn't. */
-  UV_GETADDRINFO_PRIVATE_FIELDS
-};
-
-
-UV_EXTERN int uv_getaddrinfo(uv_loop_t* loop,
-                             uv_getaddrinfo_t* req,
-                             uv_getaddrinfo_cb getaddrinfo_cb,
-                             const char* node,
-                             const char* service,
-                             const struct addrinfo* hints);
-UV_EXTERN void uv_freeaddrinfo(struct addrinfo* ai);
-
-
-/*
-* uv_getnameinfo_t is a subclass of uv_req_t.
-*
-* Request object for uv_getnameinfo.
-*/
-struct uv_getnameinfo_s {
-  UV_REQ_FIELDS
-  /* read-only */
-  uv_loop_t* loop;
-  /* host and service are marked as private, but they really aren't. */
-  UV_GETNAMEINFO_PRIVATE_FIELDS
-};
-
-UV_EXTERN int uv_getnameinfo(uv_loop_t* loop,
-                             uv_getnameinfo_t* req,
-                             uv_getnameinfo_cb getnameinfo_cb,
-                             const struct sockaddr* addr,
-                             int flags);
-
-
-/* uv_spawn() options. */
-typedef enum {
-  UV_IGNORE         = 0x00,
-  UV_CREATE_PIPE    = 0x01,
-  UV_INHERIT_FD     = 0x02,
-  UV_INHERIT_STREAM = 0x04,
-
-  /*
-   * When UV_CREATE_PIPE is specified, UV_READABLE_PIPE and UV_WRITABLE_PIPE
-   * determine the direction of flow, from the child process' perspective. Both
-   * flags may be specified to create a duplex data stream.
-   */
-  UV_READABLE_PIPE  = 0x10,
-  UV_WRITABLE_PIPE  = 0x20
-} uv_stdio_flags;
-
-typedef struct uv_stdio_container_s {
-  uv_stdio_flags flags;
-
-  union {
-    uv_stream_t* stream;
-    int fd;
-  } data;
-} uv_stdio_container_t;
-
-typedef struct uv_process_options_s {
-  uv_exit_cb exit_cb; /* Called after the process exits. */
-  const char* file;   /* Path to program to execute. */
-  /*
-   * Command line arguments. args[0] should be the path to the program. On
-   * Windows this uses CreateProcess which concatenates the arguments into a
-   * string this can cause some strange errors. See the note at
-   * windows_verbatim_arguments.
-   */
-  char** args;
-  /*
-   * This will be set as the environ variable in the subprocess. If this is
-   * NULL then the parents environ will be used.
-   */
-  char** env;
-  /*
-   * If non-null this represents a directory the subprocess should execute
-   * in. Stands for current working directory.
-   */
-  const char* cwd;
-  /*
-   * Various flags that control how uv_spawn() behaves. See the definition of
-   * `enum uv_process_flags` below.
-   */
-  unsigned int flags;
-  /*
-   * The `stdio` field points to an array of uv_stdio_container_t structs that
-   * describe the file descriptors that will be made available to the child
-   * process. The convention is that stdio[0] points to stdin, fd 1 is used for
-   * stdout, and fd 2 is stderr.
-   *
-   * Note that on windows file descriptors greater than 2 are available to the
-   * child process only if the child processes uses the MSVCRT runtime.
-   */
-  int stdio_count;
-  uv_stdio_container_t* stdio;
-  /*
-   * Libuv can change the child process' user/group id. This happens only when
-   * the appropriate bits are set in the flags fields. This is not supported on
-   * windows; uv_spawn() will fail and set the error to UV_ENOTSUP.
-   */
-  uv_uid_t uid;
-  uv_gid_t gid;
-} uv_process_options_t;
-
-/*
- * These are the flags that can be used for the uv_process_options.flags field.
- */
-enum uv_process_flags {
-  /*
-   * Set the child process' user id. The user id is supplied in the `uid` field
-   * of the options struct. This does not work on windows; setting this flag
-   * will cause uv_spawn() to fail.
-   */
-  UV_PROCESS_SETUID = (1 << 0),
-  /*
-   * Set the child process' group id. The user id is supplied in the `gid`
-   * field of the options struct. This does not work on windows; setting this
-   * flag will cause uv_spawn() to fail.
-   */
-  UV_PROCESS_SETGID = (1 << 1),
-  /*
-   * Do not wrap any arguments in quotes, or perform any other escaping, when
-   * converting the argument list into a command line string. This option is
-   * only meaningful on Windows systems. On Unix it is silently ignored.
-   */
-  UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS = (1 << 2),
-  /*
-   * Spawn the child process in a detached state - this will make it a process
-   * group leader, and will effectively enable the child to keep running after
-   * the parent exits.  Note that the child process will still keep the
-   * parent's event loop alive unless the parent process calls uv_unref() on
-   * the child's process handle.
-   */
-  UV_PROCESS_DETACHED = (1 << 3),
-  /*
-   * Hide the subprocess console window that would normally be created. This
-   * option is only meaningful on Windows systems. On Unix it is silently
-   * ignored.
-   */
-  UV_PROCESS_WINDOWS_HIDE = (1 << 4)
-};
-
-/*
- * uv_process_t is a subclass of uv_handle_t.
- */
-struct uv_process_s {
-  UV_HANDLE_FIELDS
-  uv_exit_cb exit_cb;
-  int pid;
-  UV_PROCESS_PRIVATE_FIELDS
-};
-
-UV_EXTERN int uv_spawn(uv_loop_t* loop,
-                       uv_process_t* handle,
-                       const uv_process_options_t* options);
-UV_EXTERN int uv_process_kill(uv_process_t*, int signum);
-UV_EXTERN int uv_kill(int pid, int signum);
-
-
-/*
- * uv_work_t is a subclass of uv_req_t.
- */
-struct uv_work_s {
-  UV_REQ_FIELDS
-  uv_loop_t* loop;
-  uv_work_cb work_cb;
-  uv_after_work_cb after_work_cb;
-  UV_WORK_PRIVATE_FIELDS
-};
-
-UV_EXTERN int uv_queue_work(uv_loop_t* loop,
-                            uv_work_t* req,
-                            uv_work_cb work_cb,
-                            uv_after_work_cb after_work_cb);
-
-UV_EXTERN int uv_cancel(uv_req_t* req);
-
-
-struct uv_cpu_info_s {
-  char* model;
-  int speed;
-  struct uv_cpu_times_s {
-    uint64_t user;
-    uint64_t nice;
-    uint64_t sys;
-    uint64_t idle;
-    uint64_t irq;
-  } cpu_times;
-};
-
-struct uv_interface_address_s {
-  char* name;
-  char phys_addr[6];
-  int is_internal;
-  union {
-    struct sockaddr_in address4;
-    struct sockaddr_in6 address6;
-  } address;
-  union {
-    struct sockaddr_in netmask4;
-    struct sockaddr_in6 netmask6;
-  } netmask;
-};
-
-struct uv_passwd_s {
-  char* username;
-  long uid;
-  long gid;
-  char* shell;
-  char* homedir;
-};
-
-typedef enum {
-  UV_DIRENT_UNKNOWN,
-  UV_DIRENT_FILE,
-  UV_DIRENT_DIR,
-  UV_DIRENT_LINK,
-  UV_DIRENT_FIFO,
-  UV_DIRENT_SOCKET,
-  UV_DIRENT_CHAR,
-  UV_DIRENT_BLOCK
-} uv_dirent_type_t;
-
-struct uv_dirent_s {
-  const char* name;
-  uv_dirent_type_t type;
-};
-
-UV_EXTERN char** uv_setup_args(int argc, char** argv);
-UV_EXTERN int uv_get_process_title(char* buffer, size_t size);
-UV_EXTERN int uv_set_process_title(const char* title);
-UV_EXTERN int uv_resident_set_memory(size_t* rss);
-UV_EXTERN int uv_uptime(double* uptime);
-
-typedef struct {
-  long tv_sec;
-  long tv_usec;
-} uv_timeval_t;
-
-typedef struct {
-   uv_timeval_t ru_utime; /* user CPU time used */
-   uv_timeval_t ru_stime; /* system CPU time used */
-   uint64_t ru_maxrss;    /* maximum resident set size */
-   uint64_t ru_ixrss;     /* integral shared memory size */
-   uint64_t ru_idrss;     /* integral unshared data size */
-   uint64_t ru_isrss;     /* integral unshared stack size */
-   uint64_t ru_minflt;    /* page reclaims (soft page faults) */
-   uint64_t ru_majflt;    /* page faults (hard page faults) */
-   uint64_t ru_nswap;     /* swaps */
-   uint64_t ru_inblock;   /* block input operations */
-   uint64_t ru_oublock;   /* block output operations */
-   uint64_t ru_msgsnd;    /* IPC messages sent */
-   uint64_t ru_msgrcv;    /* IPC messages received */
-   uint64_t ru_nsignals;  /* signals received */
-   uint64_t ru_nvcsw;     /* voluntary context switches */
-   uint64_t ru_nivcsw;    /* involuntary context switches */
-} uv_rusage_t;
-
-UV_EXTERN int uv_getrusage(uv_rusage_t* rusage);
-
-UV_EXTERN int uv_os_homedir(char* buffer, size_t* size);
-UV_EXTERN int uv_os_tmpdir(char* buffer, size_t* size);
-UV_EXTERN int uv_os_get_passwd(uv_passwd_t* pwd);
-UV_EXTERN void uv_os_free_passwd(uv_passwd_t* pwd);
-
-UV_EXTERN int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count);
-UV_EXTERN void uv_free_cpu_info(uv_cpu_info_t* cpu_infos, int count);
-
-UV_EXTERN int uv_interface_addresses(uv_interface_address_t** addresses,
-                                     int* count);
-UV_EXTERN void uv_free_interface_addresses(uv_interface_address_t* addresses,
-                                           int count);
-
-
-typedef enum {
-  UV_FS_UNKNOWN = -1,
-  UV_FS_CUSTOM,
-  UV_FS_OPEN,
-  UV_FS_CLOSE,
-  UV_FS_READ,
-  UV_FS_WRITE,
-  UV_FS_SENDFILE,
-  UV_FS_STAT,
-  UV_FS_LSTAT,
-  UV_FS_FSTAT,
-  UV_FS_FTRUNCATE,
-  UV_FS_UTIME,
-  UV_FS_FUTIME,
-  UV_FS_ACCESS,
-  UV_FS_CHMOD,
-  UV_FS_FCHMOD,
-  UV_FS_FSYNC,
-  UV_FS_FDATASYNC,
-  UV_FS_UNLINK,
-  UV_FS_RMDIR,
-  UV_FS_MKDIR,
-  UV_FS_MKDTEMP,
-  UV_FS_RENAME,
-  UV_FS_SCANDIR,
-  UV_FS_LINK,
-  UV_FS_SYMLINK,
-  UV_FS_READLINK,
-  UV_FS_CHOWN,
-  UV_FS_FCHOWN,
-  UV_FS_REALPATH
-} uv_fs_type;
-
-/* uv_fs_t is a subclass of uv_req_t. */
-struct uv_fs_s {
-  UV_REQ_FIELDS
-  uv_fs_type fs_type;
-  uv_loop_t* loop;
-  uv_fs_cb cb;
-  ssize_t result;
-  void* ptr;
-  const char* path;
-  uv_stat_t statbuf;  /* Stores the result of uv_fs_stat() and uv_fs_fstat(). */
-  UV_FS_PRIVATE_FIELDS
-};
-
-UV_EXTERN void uv_fs_req_cleanup(uv_fs_t* req);
-UV_EXTERN int uv_fs_close(uv_loop_t* loop,
-                          uv_fs_t* req,
-                          uv_file file,
-                          uv_fs_cb cb);
-UV_EXTERN int uv_fs_open(uv_loop_t* loop,
-                         uv_fs_t* req,
-                         const char* path,
-                         int flags,
-                         int mode,
-                         uv_fs_cb cb);
-UV_EXTERN int uv_fs_read(uv_loop_t* loop,
-                         uv_fs_t* req,
-                         uv_file file,
-                         const uv_buf_t bufs[],
-                         unsigned int nbufs,
-                         int64_t offset,
-                         uv_fs_cb cb);
-UV_EXTERN int uv_fs_unlink(uv_loop_t* loop,
-                           uv_fs_t* req,
-                           const char* path,
-                           uv_fs_cb cb);
-UV_EXTERN int uv_fs_write(uv_loop_t* loop,
-                          uv_fs_t* req,
-                          uv_file file,
-                          const uv_buf_t bufs[],
-                          unsigned int nbufs,
-                          int64_t offset,
-                          uv_fs_cb cb);
-UV_EXTERN int uv_fs_mkdir(uv_loop_t* loop,
-                          uv_fs_t* req,
-                          const char* path,
-                          int mode,
-                          uv_fs_cb cb);
-UV_EXTERN int uv_fs_mkdtemp(uv_loop_t* loop,
-                            uv_fs_t* req,
-                            const char* tpl,
-                            uv_fs_cb cb);
-UV_EXTERN int uv_fs_rmdir(uv_loop_t* loop,
-                          uv_fs_t* req,
-                          const char* path,
-                          uv_fs_cb cb);
-UV_EXTERN int uv_fs_scandir(uv_loop_t* loop,
-                            uv_fs_t* req,
-                            const char* path,
-                            int flags,
-                            uv_fs_cb cb);
-UV_EXTERN int uv_fs_scandir_next(uv_fs_t* req,
-                                 uv_dirent_t* ent);
-UV_EXTERN int uv_fs_stat(uv_loop_t* loop,
-                         uv_fs_t* req,
-                         const char* path,
-                         uv_fs_cb cb);
-UV_EXTERN int uv_fs_fstat(uv_loop_t* loop,
-                          uv_fs_t* req,
-                          uv_file file,
-                          uv_fs_cb cb);
-UV_EXTERN int uv_fs_rename(uv_loop_t* loop,
-                           uv_fs_t* req,
-                           const char* path,
-                           const char* new_path,
-                           uv_fs_cb cb);
-UV_EXTERN int uv_fs_fsync(uv_loop_t* loop,
-                          uv_fs_t* req,
-                          uv_file file,
-                          uv_fs_cb cb);
-UV_EXTERN int uv_fs_fdatasync(uv_loop_t* loop,
-                              uv_fs_t* req,
-                              uv_file file,
-                              uv_fs_cb cb);
-UV_EXTERN int uv_fs_ftruncate(uv_loop_t* loop,
-                              uv_fs_t* req,
-                              uv_file file,
-                              int64_t offset,
-                              uv_fs_cb cb);
-UV_EXTERN int uv_fs_sendfile(uv_loop_t* loop,
-                             uv_fs_t* req,
-                             uv_file out_fd,
-                             uv_file in_fd,
-                             int64_t in_offset,
-                             size_t length,
-                             uv_fs_cb cb);
-UV_EXTERN int uv_fs_access(uv_loop_t* loop,
-                           uv_fs_t* req,
-                           const char* path,
-                           int mode,
-                           uv_fs_cb cb);
-UV_EXTERN int uv_fs_chmod(uv_loop_t* loop,
-                          uv_fs_t* req,
-                          const char* path,
-                          int mode,
-                          uv_fs_cb cb);
-UV_EXTERN int uv_fs_utime(uv_loop_t* loop,
-                          uv_fs_t* req,
-                          const char* path,
-                          double atime,
-                          double mtime,
-                          uv_fs_cb cb);
-UV_EXTERN int uv_fs_futime(uv_loop_t* loop,
-                           uv_fs_t* req,
-                           uv_file file,
-                           double atime,
-                           double mtime,
-                           uv_fs_cb cb);
-UV_EXTERN int uv_fs_lstat(uv_loop_t* loop,
-                          uv_fs_t* req,
-                          const char* path,
-                          uv_fs_cb cb);
-UV_EXTERN int uv_fs_link(uv_loop_t* loop,
-                         uv_fs_t* req,
-                         const char* path,
-                         const char* new_path,
-                         uv_fs_cb cb);
-
-/*
- * This flag can be used with uv_fs_symlink() on Windows to specify whether
- * path argument points to a directory.
- */
-#define UV_FS_SYMLINK_DIR          0x0001
-
-/*
- * This flag can be used with uv_fs_symlink() on Windows to specify whether
- * the symlink is to be created using junction points.
- */
-#define UV_FS_SYMLINK_JUNCTION     0x0002
-
-UV_EXTERN int uv_fs_symlink(uv_loop_t* loop,
-                            uv_fs_t* req,
-                            const char* path,
-                            const char* new_path,
-                            int flags,
-                            uv_fs_cb cb);
-UV_EXTERN int uv_fs_readlink(uv_loop_t* loop,
-                             uv_fs_t* req,
-                             const char* path,
-                             uv_fs_cb cb);
-UV_EXTERN int uv_fs_realpath(uv_loop_t* loop,
-                             uv_fs_t* req,
-                             const char* path,
-                             uv_fs_cb cb);
-UV_EXTERN int uv_fs_fchmod(uv_loop_t* loop,
-                           uv_fs_t* req,
-                           uv_file file,
-                           int mode,
-                           uv_fs_cb cb);
-UV_EXTERN int uv_fs_chown(uv_loop_t* loop,
-                          uv_fs_t* req,
-                          const char* path,
-                          uv_uid_t uid,
-                          uv_gid_t gid,
-                          uv_fs_cb cb);
-UV_EXTERN int uv_fs_fchown(uv_loop_t* loop,
-                           uv_fs_t* req,
-                           uv_file file,
-                           uv_uid_t uid,
-                           uv_gid_t gid,
-                           uv_fs_cb cb);
-
-
-enum uv_fs_event {
-  UV_RENAME = 1,
-  UV_CHANGE = 2
-};
-
-
-struct uv_fs_event_s {
-  UV_HANDLE_FIELDS
-  /* private */
-  char* path;
-  UV_FS_EVENT_PRIVATE_FIELDS
-};
-
-
-/*
- * uv_fs_stat() based polling file watcher.
- */
-struct uv_fs_poll_s {
-  UV_HANDLE_FIELDS
-  /* Private, don't touch. */
-  void* poll_ctx;
-};
-
-UV_EXTERN int uv_fs_poll_init(uv_loop_t* loop, uv_fs_poll_t* handle);
-UV_EXTERN int uv_fs_poll_start(uv_fs_poll_t* handle,
-                               uv_fs_poll_cb poll_cb,
-                               const char* path,
-                               unsigned int interval);
-UV_EXTERN int uv_fs_poll_stop(uv_fs_poll_t* handle);
-UV_EXTERN int uv_fs_poll_getpath(uv_fs_poll_t* handle,
-                                 char* buffer,
-                                 size_t* size);
-
-
-struct uv_signal_s {
-  UV_HANDLE_FIELDS
-  uv_signal_cb signal_cb;
-  int signum;
-  UV_SIGNAL_PRIVATE_FIELDS
-};
-
-UV_EXTERN int uv_signal_init(uv_loop_t* loop, uv_signal_t* handle);
-UV_EXTERN int uv_signal_start(uv_signal_t* handle,
-                              uv_signal_cb signal_cb,
-                              int signum);
-UV_EXTERN int uv_signal_stop(uv_signal_t* handle);
-
-UV_EXTERN void uv_loadavg(double avg[3]);
-
-
-/*
- * Flags to be passed to uv_fs_event_start().
- */
-enum uv_fs_event_flags {
-  /*
-   * By default, if the fs event watcher is given a directory name, we will
-   * watch for all events in that directory. This flags overrides this behavior
-   * and makes fs_event report only changes to the directory entry itself. This
-   * flag does not affect individual files watched.
-   * This flag is currently not implemented yet on any backend.
-   */
-  UV_FS_EVENT_WATCH_ENTRY = 1,
-
-  /*
-   * By default uv_fs_event will try to use a kernel interface such as inotify
-   * or kqueue to detect events. This may not work on remote filesystems such
-   * as NFS mounts. This flag makes fs_event fall back to calling stat() on a
-   * regular interval.
-   * This flag is currently not implemented yet on any backend.
-   */
-  UV_FS_EVENT_STAT = 2,
-
-  /*
-   * By default, event watcher, when watching directory, is not registering
-   * (is ignoring) changes in it's subdirectories.
-   * This flag will override this behaviour on platforms that support it.
-   */
-  UV_FS_EVENT_RECURSIVE = 4
-};
-
-
-UV_EXTERN int uv_fs_event_init(uv_loop_t* loop, uv_fs_event_t* handle);
-UV_EXTERN int uv_fs_event_start(uv_fs_event_t* handle,
-                                uv_fs_event_cb cb,
-                                const char* path,
-                                unsigned int flags);
-UV_EXTERN int uv_fs_event_stop(uv_fs_event_t* handle);
-UV_EXTERN int uv_fs_event_getpath(uv_fs_event_t* handle,
-                                  char* buffer,
-                                  size_t* size);
-
-UV_EXTERN int uv_ip4_addr(const char* ip, int port, struct sockaddr_in* addr);
-UV_EXTERN int uv_ip6_addr(const char* ip, int port, struct sockaddr_in6* addr);
-
-UV_EXTERN int uv_ip4_name(const struct sockaddr_in* src, char* dst, size_t size);
-UV_EXTERN int uv_ip6_name(const struct sockaddr_in6* src, char* dst, size_t size);
-
-UV_EXTERN int uv_inet_ntop(int af, const void* src, char* dst, size_t size);
-UV_EXTERN int uv_inet_pton(int af, const char* src, void* dst);
-
-UV_EXTERN int uv_exepath(char* buffer, size_t* size);
-
-UV_EXTERN int uv_cwd(char* buffer, size_t* size);
-
-UV_EXTERN int uv_chdir(const char* dir);
-
-UV_EXTERN uint64_t uv_get_free_memory(void);
-UV_EXTERN uint64_t uv_get_total_memory(void);
-
-UV_EXTERN uint64_t uv_hrtime(void);
-
-UV_EXTERN void uv_disable_stdio_inheritance(void);
-
-UV_EXTERN int uv_dlopen(const char* filename, uv_lib_t* lib);
-UV_EXTERN void uv_dlclose(uv_lib_t* lib);
-UV_EXTERN int uv_dlsym(uv_lib_t* lib, const char* name, void** ptr);
-UV_EXTERN const char* uv_dlerror(const uv_lib_t* lib);
-
-UV_EXTERN int uv_mutex_init(uv_mutex_t* handle);
-UV_EXTERN void uv_mutex_destroy(uv_mutex_t* handle);
-UV_EXTERN void uv_mutex_lock(uv_mutex_t* handle);
-UV_EXTERN int uv_mutex_trylock(uv_mutex_t* handle);
-UV_EXTERN void uv_mutex_unlock(uv_mutex_t* handle);
-
-UV_EXTERN int uv_rwlock_init(uv_rwlock_t* rwlock);
-UV_EXTERN void uv_rwlock_destroy(uv_rwlock_t* rwlock);
-UV_EXTERN void uv_rwlock_rdlock(uv_rwlock_t* rwlock);
-UV_EXTERN int uv_rwlock_tryrdlock(uv_rwlock_t* rwlock);
-UV_EXTERN void uv_rwlock_rdunlock(uv_rwlock_t* rwlock);
-UV_EXTERN void uv_rwlock_wrlock(uv_rwlock_t* rwlock);
-UV_EXTERN int uv_rwlock_trywrlock(uv_rwlock_t* rwlock);
-UV_EXTERN void uv_rwlock_wrunlock(uv_rwlock_t* rwlock);
-
-UV_EXTERN int uv_sem_init(uv_sem_t* sem, unsigned int value);
-UV_EXTERN void uv_sem_destroy(uv_sem_t* sem);
-UV_EXTERN void uv_sem_post(uv_sem_t* sem);
-UV_EXTERN void uv_sem_wait(uv_sem_t* sem);
-UV_EXTERN int uv_sem_trywait(uv_sem_t* sem);
-
-UV_EXTERN int uv_cond_init(uv_cond_t* cond);
-UV_EXTERN void uv_cond_destroy(uv_cond_t* cond);
-UV_EXTERN void uv_cond_signal(uv_cond_t* cond);
-UV_EXTERN void uv_cond_broadcast(uv_cond_t* cond);
-
-UV_EXTERN int uv_barrier_init(uv_barrier_t* barrier, unsigned int count);
-UV_EXTERN void uv_barrier_destroy(uv_barrier_t* barrier);
-UV_EXTERN int uv_barrier_wait(uv_barrier_t* barrier);
-
-UV_EXTERN void uv_cond_wait(uv_cond_t* cond, uv_mutex_t* mutex);
-UV_EXTERN int uv_cond_timedwait(uv_cond_t* cond,
-                                uv_mutex_t* mutex,
-                                uint64_t timeout);
-
-UV_EXTERN void uv_once(uv_once_t* guard, void (*callback)(void));
-
-UV_EXTERN int uv_key_create(uv_key_t* key);
-UV_EXTERN void uv_key_delete(uv_key_t* key);
-UV_EXTERN void* uv_key_get(uv_key_t* key);
-UV_EXTERN void uv_key_set(uv_key_t* key, void* value);
-
-typedef void (*uv_thread_cb)(void* arg);
-
-UV_EXTERN int uv_thread_create(uv_thread_t* tid, uv_thread_cb entry, void* arg);
-UV_EXTERN uv_thread_t uv_thread_self(void);
-UV_EXTERN int uv_thread_join(uv_thread_t *tid);
-UV_EXTERN int uv_thread_equal(const uv_thread_t* t1, const uv_thread_t* t2);
-
-/* The presence of these unions force similar struct layout. */
-#define XX(_, name) uv_ ## name ## _t name;
-union uv_any_handle {
-  UV_HANDLE_TYPE_MAP(XX)
-};
-
-union uv_any_req {
-  UV_REQ_TYPE_MAP(XX)
-};
-#undef XX
-
-
-struct uv_loop_s {
-  /* User data - use this for whatever. */
-  void* data;
-  /* Callback when loop's watcher queue updates. */
-  void (*on_watcher_queue_updated)(uv_loop_t*);
-  /* Loop reference counting. */
-  unsigned int active_handles;
-  void* handle_queue[2];
-  void* active_reqs[2];
-  /* Internal flag to signal loop stop. */
-  unsigned int stop_flag;
-  UV_LOOP_PRIVATE_FIELDS
-};
-
-
-/* Don't export the private CPP symbols. */
-#undef UV_HANDLE_TYPE_PRIVATE
-#undef UV_REQ_TYPE_PRIVATE
-#undef UV_REQ_PRIVATE_FIELDS
-#undef UV_STREAM_PRIVATE_FIELDS
-#undef UV_TCP_PRIVATE_FIELDS
-#undef UV_PREPARE_PRIVATE_FIELDS
-#undef UV_CHECK_PRIVATE_FIELDS
-#undef UV_IDLE_PRIVATE_FIELDS
-#undef UV_ASYNC_PRIVATE_FIELDS
-#undef UV_TIMER_PRIVATE_FIELDS
-#undef UV_GETADDRINFO_PRIVATE_FIELDS
-#undef UV_GETNAMEINFO_PRIVATE_FIELDS
-#undef UV_FS_REQ_PRIVATE_FIELDS
-#undef UV_WORK_PRIVATE_FIELDS
-#undef UV_FS_EVENT_PRIVATE_FIELDS
-#undef UV_SIGNAL_PRIVATE_FIELDS
-#undef UV_LOOP_PRIVATE_FIELDS
-#undef UV_LOOP_PRIVATE_PLATFORM_FIELDS
-
-#ifdef __cplusplus
-}
-#endif
-#endif /* UV_H */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/samples/socks5-proxy/defs.h
+++ /dev/null
@@ -1,139 +0,0 @@
-/* Copyright StrongLoop, Inc. All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef DEFS_H_
-#define DEFS_H_
-
-#include "s5.h"
-#include "uv.h"
-
-#include <assert.h>
-#include <netinet/in.h>  /* sockaddr_in, sockaddr_in6 */
-#include <stddef.h>      /* size_t, ssize_t */
-#include <stdint.h>
-#include <sys/socket.h>  /* sockaddr */
-
-struct client_ctx;
-
-typedef struct {
-  const char *bind_host;
-  unsigned short bind_port;
-  unsigned int idle_timeout;
-} server_config;
-
-typedef struct {
-  unsigned int idle_timeout;  /* Connection idle timeout in ms. */
-  uv_tcp_t tcp_handle;
-  uv_loop_t *loop;
-} server_ctx;
-
-typedef struct {
-  unsigned char rdstate;
-  unsigned char wrstate;
-  unsigned int idle_timeout;
-  struct client_ctx *client;  /* Backlink to owning client context. */
-  ssize_t result;
-  union {
-    uv_handle_t handle;
-    uv_stream_t stream;
-    uv_tcp_t tcp;
-    uv_udp_t udp;
-  } handle;
-  uv_timer_t timer_handle;  /* For detecting timeouts. */
-  uv_write_t write_req;
-  /* We only need one of these at a time so make them share memory. */
-  union {
-    uv_getaddrinfo_t addrinfo_req;
-    uv_connect_t connect_req;
-    uv_req_t req;
-    struct sockaddr_in6 addr6;
-    struct sockaddr_in addr4;
-    struct sockaddr addr;
-    char buf[2048];  /* Scratch space. Used to read data into. */
-  } t;
-} conn;
-
-typedef struct client_ctx {
-  unsigned int state;
-  server_ctx *sx;  /* Backlink to owning server context. */
-  s5_ctx parser;  /* The SOCKS protocol parser. */
-  conn incoming;  /* Connection with the SOCKS client. */
-  conn outgoing;  /* Connection with upstream. */
-} client_ctx;
-
-/* server.c */
-int server_run(const server_config *cf, uv_loop_t *loop);
-int can_auth_none(const server_ctx *sx, const client_ctx *cx);
-int can_auth_passwd(const server_ctx *sx, const client_ctx *cx);
-int can_access(const server_ctx *sx,
-               const client_ctx *cx,
-               const struct sockaddr *addr);
-
-/* client.c */
-void client_finish_init(server_ctx *sx, client_ctx *cx);
-
-/* util.c */
-#if defined(__GNUC__)
-# define ATTRIBUTE_FORMAT_PRINTF(a, b) __attribute__((format(printf, a, b)))
-#else
-# define ATTRIBUTE_FORMAT_PRINTF(a, b)
-#endif
-void pr_info(const char *fmt, ...) ATTRIBUTE_FORMAT_PRINTF(1, 2);
-void pr_warn(const char *fmt, ...) ATTRIBUTE_FORMAT_PRINTF(1, 2);
-void pr_err(const char *fmt, ...) ATTRIBUTE_FORMAT_PRINTF(1, 2);
-void *xmalloc(size_t size);
-
-/* main.c */
-const char *_getprogname(void);
-
-/* getopt.c */
-#if !HAVE_UNISTD_H
-extern char *optarg;
-int getopt(int argc, char **argv, const char *options);
-#endif
-
-/* ASSERT() is for debug checks, CHECK() for run-time sanity checks.
- * DEBUG_CHECKS is for expensive debug checks that we only want to
- * enable in debug builds but still want type-checked by the compiler
- * in release builds.
- */
-#if defined(NDEBUG)
-# define ASSERT(exp)
-# define CHECK(exp)   do { if (!(exp)) abort(); } while (0)
-# define DEBUG_CHECKS (0)
-#else
-# define ASSERT(exp)  assert(exp)
-# define CHECK(exp)   assert(exp)
-# define DEBUG_CHECKS (1)
-#endif
-
-#define UNREACHABLE() CHECK(!"Unreachable code reached.")
-
-/* This macro looks complicated but it's not: it calculates the address
- * of the embedding struct through the address of the embedded struct.
- * In other words, if struct A embeds struct B, then we can obtain
- * the address of A by taking the address of B and subtracting the
- * field offset of B in A.
- */
-#define CONTAINER_OF(ptr, type, field)                                        \
-  ((type *) ((char *) (ptr) - ((char *) &((type *) 0)->field)))
-
-#endif  /* DEFS_H_ */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/samples/socks5-proxy/s5.h
+++ /dev/null
@@ -1,94 +0,0 @@
-/* Copyright StrongLoop, Inc. All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef S5_H_
-#define S5_H_
-
-#include <stddef.h>
-#include <stdint.h>
-
-#define S5_ERR_MAP(V)                                                         \
-  V(-1, bad_version, "Bad protocol version.")                                 \
-  V(-2, bad_cmd, "Bad protocol command.")                                     \
-  V(-3, bad_atyp, "Bad address type.")                                        \
-  V(0, ok, "No error.")                                                       \
-  V(1, auth_select, "Select authentication method.")                          \
-  V(2, auth_verify, "Verify authentication.")                                 \
-  V(3, exec_cmd, "Execute command.")                                          \
-
-typedef enum {
-#define S5_ERR_GEN(code, name, _) s5_ ## name = code,
-  S5_ERR_MAP(S5_ERR_GEN)
-#undef S5_ERR_GEN
-  s5_max_errors
-} s5_err;
-
-typedef enum {
-  S5_AUTH_NONE = 1 << 0,
-  S5_AUTH_GSSAPI = 1 << 1,
-  S5_AUTH_PASSWD = 1 << 2
-} s5_auth_method;
-
-typedef enum {
-  s5_auth_allow,
-  s5_auth_deny
-} s5_auth_result;
-
-typedef enum {
-  s5_atyp_ipv4,
-  s5_atyp_ipv6,
-  s5_atyp_host
-} s5_atyp;
-
-typedef enum {
-  s5_cmd_tcp_connect,
-  s5_cmd_tcp_bind,
-  s5_cmd_udp_assoc
-} s5_cmd;
-
-typedef struct {
-  uint32_t arg0;  /* Scratch space for the state machine. */
-  uint32_t arg1;  /* Scratch space for the state machine. */
-  uint8_t state;
-  uint8_t methods;
-  uint8_t cmd;
-  uint8_t atyp;
-  uint8_t userlen;
-  uint8_t passlen;
-  uint16_t dport;
-  uint8_t username[257];
-  uint8_t password[257];
-  uint8_t daddr[257];  /* TODO(bnoordhuis) Merge with username/password. */
-} s5_ctx;
-
-void s5_init(s5_ctx *ctx);
-
-s5_err s5_parse(s5_ctx *cx, uint8_t **data, size_t *size);
-
-/* Only call after s5_parse() has returned s5_want_auth_method. */
-unsigned int s5_auth_methods(const s5_ctx *cx);
-
-/* Call after s5_parse() has returned s5_want_auth_method. */
-int s5_select_auth(s5_ctx *cx, s5_auth_method method);
-
-const char *s5_strerror(s5_err err);
-
-#endif  /* S5_H_ */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/src/heap-inl.h
+++ /dev/null
@@ -1,245 +0,0 @@
-/* Copyright (c) 2013, Ben Noordhuis <info@bnoordhuis.nl>
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-
-#ifndef UV_SRC_HEAP_H_
-#define UV_SRC_HEAP_H_
-
-#include <stddef.h>  /* NULL */
-
-#if defined(__GNUC__)
-# define HEAP_EXPORT(declaration) __attribute__((unused)) static declaration
-#else
-# define HEAP_EXPORT(declaration) static declaration
-#endif
-
-struct heap_node {
-  struct heap_node* left;
-  struct heap_node* right;
-  struct heap_node* parent;
-};
-
-/* A binary min heap.  The usual properties hold: the root is the lowest
- * element in the set, the height of the tree is at most log2(nodes) and
- * it's always a complete binary tree.
- *
- * The heap function try hard to detect corrupted tree nodes at the cost
- * of a minor reduction in performance.  Compile with -DNDEBUG to disable.
- */
-struct heap {
-  struct heap_node* min;
-  unsigned int nelts;
-};
-
-/* Return non-zero if a < b. */
-typedef int (*heap_compare_fn)(const struct heap_node* a,
-                               const struct heap_node* b);
-
-/* Public functions. */
-HEAP_EXPORT(void heap_init(struct heap* heap));
-HEAP_EXPORT(struct heap_node* heap_min(const struct heap* heap));
-HEAP_EXPORT(void heap_insert(struct heap* heap,
-                             struct heap_node* newnode,
-                             heap_compare_fn less_than));
-HEAP_EXPORT(void heap_remove(struct heap* heap,
-                             struct heap_node* node,
-                             heap_compare_fn less_than));
-HEAP_EXPORT(void heap_dequeue(struct heap* heap, heap_compare_fn less_than));
-
-/* Implementation follows. */
-
-HEAP_EXPORT(void heap_init(struct heap* heap)) {
-  heap->min = NULL;
-  heap->nelts = 0;
-}
-
-HEAP_EXPORT(struct heap_node* heap_min(const struct heap* heap)) {
-  return heap->min;
-}
-
-/* Swap parent with child. Child moves closer to the root, parent moves away. */
-static void heap_node_swap(struct heap* heap,
-                           struct heap_node* parent,
-                           struct heap_node* child) {
-  struct heap_node* sibling;
-  struct heap_node t;
-
-  t = *parent;
-  *parent = *child;
-  *child = t;
-
-  parent->parent = child;
-  if (child->left == child) {
-    child->left = parent;
-    sibling = child->right;
-  } else {
-    child->right = parent;
-    sibling = child->left;
-  }
-  if (sibling != NULL)
-    sibling->parent = child;
-
-  if (parent->left != NULL)
-    parent->left->parent = parent;
-  if (parent->right != NULL)
-    parent->right->parent = parent;
-
-  if (child->parent == NULL)
-    heap->min = child;
-  else if (child->parent->left == parent)
-    child->parent->left = child;
-  else
-    child->parent->right = child;
-}
-
-HEAP_EXPORT(void heap_insert(struct heap* heap,
-                             struct heap_node* newnode,
-                             heap_compare_fn less_than)) {
-  struct heap_node** parent;
-  struct heap_node** child;
-  unsigned int path;
-  unsigned int n;
-  unsigned int k;
-
-  newnode->left = NULL;
-  newnode->right = NULL;
-  newnode->parent = NULL;
-
-  /* Calculate the path from the root to the insertion point.  This is a min
-   * heap so we always insert at the left-most free node of the bottom row.
-   */
-  path = 0;
-  for (k = 0, n = 1 + heap->nelts; n >= 2; k += 1, n /= 2)
-    path = (path << 1) | (n & 1);
-
-  /* Now traverse the heap using the path we calculated in the previous step. */
-  parent = child = &heap->min;
-  while (k > 0) {
-    parent = child;
-    if (path & 1)
-      child = &(*child)->right;
-    else
-      child = &(*child)->left;
-    path >>= 1;
-    k -= 1;
-  }
-
-  /* Insert the new node. */
-  newnode->parent = *parent;
-  *child = newnode;
-  heap->nelts += 1;
-
-  /* Walk up the tree and check at each node if the heap property holds.
-   * It's a min heap so parent < child must be true.
-   */
-  while (newnode->parent != NULL && less_than(newnode, newnode->parent))
-    heap_node_swap(heap, newnode->parent, newnode);
-}
-
-HEAP_EXPORT(void heap_remove(struct heap* heap,
-                             struct heap_node* node,
-                             heap_compare_fn less_than)) {
-  struct heap_node* smallest;
-  struct heap_node** max;
-  struct heap_node* child;
-  unsigned int path;
-  unsigned int k;
-  unsigned int n;
-
-  if (heap->nelts == 0)
-    return;
-
-  /* Calculate the path from the min (the root) to the max, the left-most node
-   * of the bottom row.
-   */
-  path = 0;
-  for (k = 0, n = heap->nelts; n >= 2; k += 1, n /= 2)
-    path = (path << 1) | (n & 1);
-
-  /* Now traverse the heap using the path we calculated in the previous step. */
-  max = &heap->min;
-  while (k > 0) {
-    if (path & 1)
-      max = &(*max)->right;
-    else
-      max = &(*max)->left;
-    path >>= 1;
-    k -= 1;
-  }
-
-  heap->nelts -= 1;
-
-  /* Unlink the max node. */
-  child = *max;
-  *max = NULL;
-
-  if (child == node) {
-    /* We're removing either the max or the last node in the tree. */
-    if (child == heap->min) {
-      heap->min = NULL;
-    }
-    return;
-  }
-
-  /* Replace the to be deleted node with the max node. */
-  child->left = node->left;
-  child->right = node->right;
-  child->parent = node->parent;
-
-  if (child->left != NULL) {
-    child->left->parent = child;
-  }
-
-  if (child->right != NULL) {
-    child->right->parent = child;
-  }
-
-  if (node->parent == NULL) {
-    heap->min = child;
-  } else if (node->parent->left == node) {
-    node->parent->left = child;
-  } else {
-    node->parent->right = child;
-  }
-
-  /* Walk down the subtree and check at each node if the heap property holds.
-   * It's a min heap so parent < child must be true.  If the parent is bigger,
-   * swap it with the smallest child.
-   */
-  for (;;) {
-    smallest = child;
-    if (child->left != NULL && less_than(child->left, smallest))
-      smallest = child->left;
-    if (child->right != NULL && less_than(child->right, smallest))
-      smallest = child->right;
-    if (smallest == child)
-      break;
-    heap_node_swap(heap, child, smallest);
-  }
-
-  /* Walk up the subtree and check that each parent is less than the node
-   * this is required, because `max` node is not guaranteed to be the
-   * actual maximum in tree
-   */
-  while (child->parent != NULL && less_than(child, child->parent))
-    heap_node_swap(heap, child->parent, child);
-}
-
-HEAP_EXPORT(void heap_dequeue(struct heap* heap, heap_compare_fn less_than)) {
-  heap_remove(heap, heap->min, less_than);
-}
-
-#undef HEAP_EXPORT
-
-#endif  /* UV_SRC_HEAP_H_ */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/src/queue.h
+++ /dev/null
@@ -1,108 +0,0 @@
-/* Copyright (c) 2013, Ben Noordhuis <info@bnoordhuis.nl>
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-
-#ifndef QUEUE_H_
-#define QUEUE_H_
-
-#include <stddef.h>
-
-typedef void *QUEUE[2];
-
-/* Private macros. */
-#define QUEUE_NEXT(q)       (*(QUEUE **) &((*(q))[0]))
-#define QUEUE_PREV(q)       (*(QUEUE **) &((*(q))[1]))
-#define QUEUE_PREV_NEXT(q)  (QUEUE_NEXT(QUEUE_PREV(q)))
-#define QUEUE_NEXT_PREV(q)  (QUEUE_PREV(QUEUE_NEXT(q)))
-
-/* Public macros. */
-#define QUEUE_DATA(ptr, type, field)                                          \
-  ((type *) ((char *) (ptr) - offsetof(type, field)))
-
-/* Important note: mutating the list while QUEUE_FOREACH is
- * iterating over its elements results in undefined behavior.
- */
-#define QUEUE_FOREACH(q, h)                                                   \
-  for ((q) = QUEUE_NEXT(h); (q) != (h); (q) = QUEUE_NEXT(q))
-
-#define QUEUE_EMPTY(q)                                                        \
-  ((const QUEUE *) (q) == (const QUEUE *) QUEUE_NEXT(q))
-
-#define QUEUE_HEAD(q)                                                         \
-  (QUEUE_NEXT(q))
-
-#define QUEUE_INIT(q)                                                         \
-  do {                                                                        \
-    QUEUE_NEXT(q) = (q);                                                      \
-    QUEUE_PREV(q) = (q);                                                      \
-  }                                                                           \
-  while (0)
-
-#define QUEUE_ADD(h, n)                                                       \
-  do {                                                                        \
-    QUEUE_PREV_NEXT(h) = QUEUE_NEXT(n);                                       \
-    QUEUE_NEXT_PREV(n) = QUEUE_PREV(h);                                       \
-    QUEUE_PREV(h) = QUEUE_PREV(n);                                            \
-    QUEUE_PREV_NEXT(h) = (h);                                                 \
-  }                                                                           \
-  while (0)
-
-#define QUEUE_SPLIT(h, q, n)                                                  \
-  do {                                                                        \
-    QUEUE_PREV(n) = QUEUE_PREV(h);                                            \
-    QUEUE_PREV_NEXT(n) = (n);                                                 \
-    QUEUE_NEXT(n) = (q);                                                      \
-    QUEUE_PREV(h) = QUEUE_PREV(q);                                            \
-    QUEUE_PREV_NEXT(h) = (h);                                                 \
-    QUEUE_PREV(q) = (n);                                                      \
-  }                                                                           \
-  while (0)
-
-#define QUEUE_MOVE(h, n)                                                      \
-  do {                                                                        \
-    if (QUEUE_EMPTY(h))                                                       \
-      QUEUE_INIT(n);                                                          \
-    else {                                                                    \
-      QUEUE* q = QUEUE_HEAD(h);                                               \
-      QUEUE_SPLIT(h, q, n);                                                   \
-    }                                                                         \
-  }                                                                           \
-  while (0)
-
-#define QUEUE_INSERT_HEAD(h, q)                                               \
-  do {                                                                        \
-    QUEUE_NEXT(q) = QUEUE_NEXT(h);                                            \
-    QUEUE_PREV(q) = (h);                                                      \
-    QUEUE_NEXT_PREV(q) = (q);                                                 \
-    QUEUE_NEXT(h) = (q);                                                      \
-  }                                                                           \
-  while (0)
-
-#define QUEUE_INSERT_TAIL(h, q)                                               \
-  do {                                                                        \
-    QUEUE_NEXT(q) = (h);                                                      \
-    QUEUE_PREV(q) = QUEUE_PREV(h);                                            \
-    QUEUE_PREV_NEXT(q) = (q);                                                 \
-    QUEUE_PREV(h) = (q);                                                      \
-  }                                                                           \
-  while (0)
-
-#define QUEUE_REMOVE(q)                                                       \
-  do {                                                                        \
-    QUEUE_PREV_NEXT(q) = QUEUE_NEXT(q);                                       \
-    QUEUE_NEXT_PREV(q) = QUEUE_PREV(q);                                       \
-  }                                                                           \
-  while (0)
-
-#endif /* QUEUE_H_ */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/src/unix/atomic-ops.h
+++ /dev/null
@@ -1,97 +0,0 @@
-/* Copyright (c) 2013, Ben Noordhuis <info@bnoordhuis.nl>
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-
-#ifndef UV_ATOMIC_OPS_H_
-#define UV_ATOMIC_OPS_H_
-
-#include "internal.h"  /* UV_UNUSED */
-
-#if defined(__SUNPRO_C) || defined(__SUNPRO_CC)
-#include <atomic.h>
-#define __sync_val_compare_and_swap(p, o, n) atomic_cas_ptr(p, o, n)
-#endif
-
-UV_UNUSED(static int cmpxchgi(int* ptr, int oldval, int newval));
-UV_UNUSED(static long cmpxchgl(long* ptr, long oldval, long newval));
-UV_UNUSED(static void cpu_relax(void));
-
-/* Prefer hand-rolled assembly over the gcc builtins because the latter also
- * issue full memory barriers.
- */
-UV_UNUSED(static int cmpxchgi(int* ptr, int oldval, int newval)) {
-#if defined(__i386__) || defined(__x86_64__)
-  int out;
-  __asm__ __volatile__ ("lock; cmpxchg %2, %1;"
-                        : "=a" (out), "+m" (*(volatile int*) ptr)
-                        : "r" (newval), "0" (oldval)
-                        : "memory");
-  return out;
-#elif defined(_AIX) && defined(__xlC__)
-  const int out = (*(volatile int*) ptr);
-  __compare_and_swap(ptr, &oldval, newval);
-  return out;
-#elif defined(__MVS__)
-  unsigned int op4;
-  if (__plo_CSST(ptr, (unsigned int*) &oldval, newval,
-                (unsigned int*) ptr, *ptr, &op4))
-    return oldval;
-  else
-    return op4;
-#else
-  return __sync_val_compare_and_swap(ptr, oldval, newval);
-#endif
-}
-
-UV_UNUSED(static long cmpxchgl(long* ptr, long oldval, long newval)) {
-#if defined(__i386__) || defined(__x86_64__)
-  long out;
-  __asm__ __volatile__ ("lock; cmpxchg %2, %1;"
-                        : "=a" (out), "+m" (*(volatile long*) ptr)
-                        : "r" (newval), "0" (oldval)
-                        : "memory");
-  return out;
-#elif defined(_AIX) && defined(__xlC__)
-  const long out = (*(volatile int*) ptr);
-# if defined(__64BIT__)
-  __compare_and_swaplp(ptr, &oldval, newval);
-# else
-  __compare_and_swap(ptr, &oldval, newval);
-# endif /* if defined(__64BIT__) */
-  return out;
-#elif defined (__MVS__)
-#ifdef _LP64
-  unsigned long long op4;
-  if (__plo_CSSTGR(ptr, (unsigned long long*) &oldval, newval,
-                  (unsigned long long*) ptr, *ptr, &op4))
-#else
-  unsigned long op4;
-  if (__plo_CSST(ptr, (unsigned int*) &oldval, newval,
-                (unsigned int*) ptr, *ptr, &op4))
-#endif
-    return oldval;
-  else
-    return op4;
-#else
-  return __sync_val_compare_and_swap(ptr, oldval, newval);
-#endif
-}
-
-UV_UNUSED(static void cpu_relax(void)) {
-#if defined(__i386__) || defined(__x86_64__)
-  __asm__ __volatile__ ("rep; nop");  /* a.k.a. PAUSE */
-#endif
-}
-
-#endif  /* UV_ATOMIC_OPS_H_ */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/src/unix/internal.h
+++ /dev/null
@@ -1,329 +0,0 @@
-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef UV_UNIX_INTERNAL_H_
-#define UV_UNIX_INTERNAL_H_
-
-#include "uv-common.h"
-
-#include <assert.h>
-#include <stdlib.h> /* abort */
-#include <string.h> /* strrchr */
-#include <fcntl.h>  /* O_CLOEXEC, may be */
-#include <stdio.h>
-
-#if defined(__STRICT_ANSI__)
-# define inline __inline
-#endif
-
-#if defined(__linux__)
-# include "linux-syscalls.h"
-#endif /* __linux__ */
-
-#if defined(__MVS__)
-# include "os390-syscalls.h"
-#endif /* __MVS__ */
-
-#if defined(__sun)
-# include <sys/port.h>
-# include <port.h>
-#endif /* __sun */
-
-#if defined(_AIX)
-# define reqevents events
-# define rtnevents revents
-# include <sys/poll.h>
-#else
-# include <poll.h>
-#endif /* _AIX */
-
-#if defined(__APPLE__) && !TARGET_OS_IPHONE
-# include <AvailabilityMacros.h>
-#endif
-
-#if defined(__ANDROID__)
-int uv__pthread_sigmask(int how, const sigset_t* set, sigset_t* oset);
-# ifdef pthread_sigmask
-# undef pthread_sigmask
-# endif
-# define pthread_sigmask(how, set, oldset) uv__pthread_sigmask(how, set, oldset)
-#endif
-
-#define ACCESS_ONCE(type, var)                                                \
-  (*(volatile type*) &(var))
-
-#define ROUND_UP(a, b)                                                        \
-  ((a) % (b) ? ((a) + (b)) - ((a) % (b)) : (a))
-
-#define UNREACHABLE()                                                         \
-  do {                                                                        \
-    assert(0 && "unreachable code");                                          \
-    abort();                                                                  \
-  }                                                                           \
-  while (0)
-
-#define SAVE_ERRNO(block)                                                     \
-  do {                                                                        \
-    int _saved_errno = errno;                                                 \
-    do { block; } while (0);                                                  \
-    errno = _saved_errno;                                                     \
-  }                                                                           \
-  while (0)
-
-/* The __clang__ and __INTEL_COMPILER checks are superfluous because they
- * define __GNUC__. They are here to convey to you, dear reader, that these
- * macros are enabled when compiling with clang or icc.
- */
-#if defined(__clang__) ||                                                     \
-    defined(__GNUC__) ||                                                      \
-    defined(__INTEL_COMPILER) ||                                              \
-    defined(__SUNPRO_C)
-# define UV_DESTRUCTOR(declaration) __attribute__((destructor)) declaration
-# define UV_UNUSED(declaration)     __attribute__((unused)) declaration
-#else
-# define UV_DESTRUCTOR(declaration) declaration
-# define UV_UNUSED(declaration)     declaration
-#endif
-
-/* Leans on the fact that, on Linux, POLLRDHUP == EPOLLRDHUP. */
-#ifdef POLLRDHUP
-# define UV__POLLRDHUP POLLRDHUP
-#else
-# define UV__POLLRDHUP 0x2000
-#endif
-
-#if !defined(O_CLOEXEC) && defined(__FreeBSD__)
-/*
- * It may be that we are just missing `__POSIX_VISIBLE >= 200809`.
- * Try using fixed value const and give up, if it doesn't work
- */
-# define O_CLOEXEC 0x00100000
-#endif
-
-typedef struct uv__stream_queued_fds_s uv__stream_queued_fds_t;
-
-/* handle flags */
-enum {
-  UV_CLOSING              = 0x01,   /* uv_close() called but not finished. */
-  UV_CLOSED               = 0x02,   /* close(2) finished. */
-  UV_STREAM_READING       = 0x04,   /* uv_read_start() called. */
-  UV_STREAM_SHUTTING      = 0x08,   /* uv_shutdown() called but not complete. */
-  UV_STREAM_SHUT          = 0x10,   /* Write side closed. */
-  UV_STREAM_READABLE      = 0x20,   /* The stream is readable */
-  UV_STREAM_WRITABLE      = 0x40,   /* The stream is writable */
-  UV_STREAM_BLOCKING      = 0x80,   /* Synchronous writes. */
-  UV_STREAM_READ_PARTIAL  = 0x100,  /* read(2) read less than requested. */
-  UV_STREAM_READ_EOF      = 0x200,  /* read(2) read EOF. */
-  UV_TCP_NODELAY          = 0x400,  /* Disable Nagle. */
-  UV_TCP_KEEPALIVE        = 0x800,  /* Turn on keep-alive. */
-  UV_TCP_SINGLE_ACCEPT    = 0x1000, /* Only accept() when idle. */
-  UV_HANDLE_IPV6          = 0x10000, /* Handle is bound to a IPv6 socket. */
-  UV_UDP_PROCESSING       = 0x20000, /* Handle is running the send callback queue. */
-  UV_HANDLE_BOUND         = 0x40000  /* Handle is bound to an address and port */
-};
-
-/* loop flags */
-enum {
-  UV_LOOP_BLOCK_SIGPROF = 1
-};
-
-typedef enum {
-  UV_CLOCK_PRECISE = 0,  /* Use the highest resolution clock available. */
-  UV_CLOCK_FAST = 1      /* Use the fastest clock with <= 1ms granularity. */
-} uv_clocktype_t;
-
-struct uv__stream_queued_fds_s {
-  unsigned int size;
-  unsigned int offset;
-  int fds[1];
-};
-
-
-#if defined(_AIX) || \
-    defined(__APPLE__) || \
-    defined(__DragonFly__) || \
-    defined(__FreeBSD__) || \
-    defined(__FreeBSD_kernel__) || \
-    defined(__linux__)
-#define uv__cloexec uv__cloexec_ioctl
-#define uv__nonblock uv__nonblock_ioctl
-#else
-#define uv__cloexec uv__cloexec_fcntl
-#define uv__nonblock uv__nonblock_fcntl
-#endif
-
-/* core */
-int uv__cloexec_ioctl(int fd, int set);
-int uv__cloexec_fcntl(int fd, int set);
-int uv__nonblock_ioctl(int fd, int set);
-int uv__nonblock_fcntl(int fd, int set);
-int uv__close(int fd);
-int uv__close_nocheckstdio(int fd);
-int uv__socket(int domain, int type, int protocol);
-int uv__dup(int fd);
-ssize_t uv__recvmsg(int fd, struct msghdr *msg, int flags);
-void uv__make_close_pending(uv_handle_t* handle);
-int uv__getiovmax(void);
-
-void uv__io_init(uv__io_t* w, uv__io_cb cb, int fd);
-void uv__io_start(uv_loop_t* loop, uv__io_t* w, unsigned int events);
-void uv__io_stop(uv_loop_t* loop, uv__io_t* w, unsigned int events);
-void uv__io_close(uv_loop_t* loop, uv__io_t* w);
-void uv__io_feed(uv_loop_t* loop, uv__io_t* w);
-int uv__io_active(const uv__io_t* w, unsigned int events);
-int uv__io_check_fd(uv_loop_t* loop, int fd);
-void uv__io_poll(uv_loop_t* loop, int timeout); /* in milliseconds or -1 */
-
-/* async */
-void uv__async_send(struct uv__async* wa);
-void uv__async_init(struct uv__async* wa);
-int uv__async_start(uv_loop_t* loop, struct uv__async* wa, uv__async_cb cb);
-void uv__async_stop(uv_loop_t* loop, struct uv__async* wa);
-
-/* loop */
-void uv__run_idle(uv_loop_t* loop);
-void uv__run_check(uv_loop_t* loop);
-void uv__run_prepare(uv_loop_t* loop);
-
-/* stream */
-void uv__stream_init(uv_loop_t* loop, uv_stream_t* stream,
-    uv_handle_type type);
-int uv__stream_open(uv_stream_t*, int fd, int flags);
-void uv__stream_destroy(uv_stream_t* stream);
-#if defined(__APPLE__)
-int uv__stream_try_select(uv_stream_t* stream, int* fd);
-#endif /* defined(__APPLE__) */
-void uv__server_io(uv_loop_t* loop, uv__io_t* w, unsigned int events);
-int uv__accept(int sockfd);
-int uv__dup2_cloexec(int oldfd, int newfd);
-int uv__open_cloexec(const char* path, int flags);
-
-/* tcp */
-int uv_tcp_listen(uv_tcp_t* tcp, int backlog, uv_connection_cb cb);
-int uv__tcp_nodelay(int fd, int on);
-int uv__tcp_keepalive(int fd, int on, unsigned int delay);
-
-/* pipe */
-int uv_pipe_listen(uv_pipe_t* handle, int backlog, uv_connection_cb cb);
-
-/* timer */
-void uv__run_timers(uv_loop_t* loop);
-int uv__next_timeout(const uv_loop_t* loop);
-
-/* signal */
-void uv__signal_close(uv_signal_t* handle);
-void uv__signal_global_once_init(void);
-void uv__signal_loop_cleanup(uv_loop_t* loop);
-
-/* platform specific */
-uint64_t uv__hrtime(uv_clocktype_t type);
-int uv__kqueue_init(uv_loop_t* loop);
-int uv__platform_loop_init(uv_loop_t* loop);
-void uv__platform_loop_delete(uv_loop_t* loop);
-void uv__platform_invalidate_fd(uv_loop_t* loop, int fd);
-
-/* various */
-void uv__async_close(uv_async_t* handle);
-void uv__check_close(uv_check_t* handle);
-void uv__fs_event_close(uv_fs_event_t* handle);
-void uv__idle_close(uv_idle_t* handle);
-void uv__pipe_close(uv_pipe_t* handle);
-void uv__poll_close(uv_poll_t* handle);
-void uv__prepare_close(uv_prepare_t* handle);
-void uv__process_close(uv_process_t* handle);
-void uv__stream_close(uv_stream_t* handle);
-void uv__tcp_close(uv_tcp_t* handle);
-void uv__timer_close(uv_timer_t* handle);
-void uv__udp_close(uv_udp_t* handle);
-void uv__udp_finish_close(uv_udp_t* handle);
-uv_handle_type uv__handle_type(int fd);
-FILE* uv__open_file(const char* path);
-int uv__getpwuid_r(uv_passwd_t* pwd);
-
-
-#if defined(__APPLE__)
-int uv___stream_fd(const uv_stream_t* handle);
-#define uv__stream_fd(handle) (uv___stream_fd((const uv_stream_t*) (handle)))
-#else
-#define uv__stream_fd(handle) ((handle)->io_watcher.fd)
-#endif /* defined(__APPLE__) */
-
-#ifdef UV__O_NONBLOCK
-# define UV__F_NONBLOCK UV__O_NONBLOCK
-#else
-# define UV__F_NONBLOCK 1
-#endif
-
-int uv__make_socketpair(int fds[2], int flags);
-int uv__make_pipe(int fds[2], int flags);
-
-#if defined(__APPLE__)
-
-int uv__fsevents_init(uv_fs_event_t* handle);
-int uv__fsevents_close(uv_fs_event_t* handle);
-void uv__fsevents_loop_delete(uv_loop_t* loop);
-
-/* OSX < 10.7 has no file events, polyfill them */
-#ifndef MAC_OS_X_VERSION_10_7
-
-static const int kFSEventStreamCreateFlagFileEvents = 0x00000010;
-static const int kFSEventStreamEventFlagItemCreated = 0x00000100;
-static const int kFSEventStreamEventFlagItemRemoved = 0x00000200;
-static const int kFSEventStreamEventFlagItemInodeMetaMod = 0x00000400;
-static const int kFSEventStreamEventFlagItemRenamed = 0x00000800;
-static const int kFSEventStreamEventFlagItemModified = 0x00001000;
-static const int kFSEventStreamEventFlagItemFinderInfoMod = 0x00002000;
-static const int kFSEventStreamEventFlagItemChangeOwner = 0x00004000;
-static const int kFSEventStreamEventFlagItemXattrMod = 0x00008000;
-static const int kFSEventStreamEventFlagItemIsFile = 0x00010000;
-static const int kFSEventStreamEventFlagItemIsDir = 0x00020000;
-static const int kFSEventStreamEventFlagItemIsSymlink = 0x00040000;
-
-#endif /* __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ < 1070 */
-
-#endif /* defined(__APPLE__) */
-
-UV_UNUSED(static void uv__req_init(uv_loop_t* loop,
-                                   uv_req_t* req,
-                                   uv_req_type type)) {
-  req->type = type;
-  uv__req_register(loop, req);
-}
-#define uv__req_init(loop, req, type) \
-  uv__req_init((loop), (uv_req_t*)(req), (type))
-
-UV_UNUSED(static void uv__update_time(uv_loop_t* loop)) {
-  /* Use a fast time source if available.  We only need millisecond precision.
-   */
-  loop->time = uv__hrtime(UV_CLOCK_FAST) / 1000000;
-}
-
-UV_UNUSED(static char* uv__basename_r(const char* path)) {
-  char* s;
-
-  s = strrchr(path, '/');
-  if (s == NULL)
-    return (char*) path;
-
-  return s + 1;
-}
-
-#endif /* UV_UNIX_INTERNAL_H_ */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/src/unix/linux-syscalls.h
+++ /dev/null
@@ -1,151 +0,0 @@
-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef UV_LINUX_SYSCALL_H_
-#define UV_LINUX_SYSCALL_H_
-
-#undef  _GNU_SOURCE
-#define _GNU_SOURCE
-
-#include <stdint.h>
-#include <signal.h>
-#include <sys/types.h>
-#include <sys/time.h>
-#include <sys/socket.h>
-
-#if defined(__alpha__)
-# define UV__O_CLOEXEC        0x200000
-#elif defined(__hppa__)
-# define UV__O_CLOEXEC        0x200000
-#elif defined(__sparc__)
-# define UV__O_CLOEXEC        0x400000
-#else
-# define UV__O_CLOEXEC        0x80000
-#endif
-
-#if defined(__alpha__)
-# define UV__O_NONBLOCK       0x4
-#elif defined(__hppa__)
-# define UV__O_NONBLOCK       O_NONBLOCK
-#elif defined(__mips__)
-# define UV__O_NONBLOCK       0x80
-#elif defined(__sparc__)
-# define UV__O_NONBLOCK       0x4000
-#else
-# define UV__O_NONBLOCK       0x800
-#endif
-
-#define UV__EFD_CLOEXEC       UV__O_CLOEXEC
-#define UV__EFD_NONBLOCK      UV__O_NONBLOCK
-
-#define UV__IN_CLOEXEC        UV__O_CLOEXEC
-#define UV__IN_NONBLOCK       UV__O_NONBLOCK
-
-#define UV__SOCK_CLOEXEC      UV__O_CLOEXEC
-#if defined(SOCK_NONBLOCK)
-# define UV__SOCK_NONBLOCK    SOCK_NONBLOCK
-#else
-# define UV__SOCK_NONBLOCK    UV__O_NONBLOCK
-#endif
-
-/* epoll flags */
-#define UV__EPOLL_CLOEXEC     UV__O_CLOEXEC
-#define UV__EPOLL_CTL_ADD     1
-#define UV__EPOLL_CTL_DEL     2
-#define UV__EPOLL_CTL_MOD     3
-
-/* inotify flags */
-#define UV__IN_ACCESS         0x001
-#define UV__IN_MODIFY         0x002
-#define UV__IN_ATTRIB         0x004
-#define UV__IN_CLOSE_WRITE    0x008
-#define UV__IN_CLOSE_NOWRITE  0x010
-#define UV__IN_OPEN           0x020
-#define UV__IN_MOVED_FROM     0x040
-#define UV__IN_MOVED_TO       0x080
-#define UV__IN_CREATE         0x100
-#define UV__IN_DELETE         0x200
-#define UV__IN_DELETE_SELF    0x400
-#define UV__IN_MOVE_SELF      0x800
-
-#if defined(__x86_64__)
-struct uv__epoll_event {
-  uint32_t events;
-  uint64_t data;
-} __attribute__((packed));
-#else
-struct uv__epoll_event {
-  uint32_t events;
-  uint64_t data;
-};
-#endif
-
-struct uv__inotify_event {
-  int32_t wd;
-  uint32_t mask;
-  uint32_t cookie;
-  uint32_t len;
-  /* char name[0]; */
-};
-
-struct uv__mmsghdr {
-  struct msghdr msg_hdr;
-  unsigned int msg_len;
-};
-
-int uv__accept4(int fd, struct sockaddr* addr, socklen_t* addrlen, int flags);
-int uv__eventfd(unsigned int count);
-int uv__epoll_create(int size);
-int uv__epoll_create1(int flags);
-int uv__epoll_ctl(int epfd, int op, int fd, struct uv__epoll_event *ev);
-int uv__epoll_wait(int epfd,
-                   struct uv__epoll_event* events,
-                   int nevents,
-                   int timeout);
-int uv__epoll_pwait(int epfd,
-                    struct uv__epoll_event* events,
-                    int nevents,
-                    int timeout,
-                    uint64_t sigmask);
-int uv__eventfd2(unsigned int count, int flags);
-int uv__inotify_init(void);
-int uv__inotify_init1(int flags);
-int uv__inotify_add_watch(int fd, const char* path, uint32_t mask);
-int uv__inotify_rm_watch(int fd, int32_t wd);
-int uv__pipe2(int pipefd[2], int flags);
-int uv__recvmmsg(int fd,
-                 struct uv__mmsghdr* mmsg,
-                 unsigned int vlen,
-                 unsigned int flags,
-                 struct timespec* timeout);
-int uv__sendmmsg(int fd,
-                 struct uv__mmsghdr* mmsg,
-                 unsigned int vlen,
-                 unsigned int flags);
-int uv__utimesat(int dirfd,
-                 const char* path,
-                 const struct timespec times[2],
-                 int flags);
-ssize_t uv__preadv(int fd, const struct iovec *iov, int iovcnt, int64_t offset);
-ssize_t uv__pwritev(int fd, const struct iovec *iov, int iovcnt, int64_t offset);
-int uv__dup3(int oldfd, int newfd, int flags);
-
-#endif /* UV_LINUX_SYSCALL_H_ */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/src/unix/os390-syscalls.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/* Copyright libuv project contributors. All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-
-#ifndef UV_OS390_SYSCALL_H_
-#define UV_OS390_SYSCALL_H_
-
-#include "uv.h"
-#include "internal.h"
-#include <dirent.h>
-#include <poll.h>
-#include <pthread.h>
-
-#define EPOLL_CTL_ADD             1
-#define EPOLL_CTL_DEL             2
-#define EPOLL_CTL_MOD             3
-#define MAX_EPOLL_INSTANCES       256
-#define MAX_ITEMS_PER_EPOLL       1024
-
-#define UV__O_CLOEXEC             0x80000
-#define UV__EPOLL_CLOEXEC         UV__O_CLOEXEC
-#define UV__EPOLL_CTL_ADD         EPOLL_CTL_ADD
-#define UV__EPOLL_CTL_DEL         EPOLL_CTL_DEL
-#define UV__EPOLL_CTL_MOD         EPOLL_CTL_MOD
-
-struct epoll_event {
-  int events;
-  int fd;
-};
-
-typedef struct {
-  QUEUE member;
-  struct pollfd* items;
-  unsigned long size;
-} uv__os390_epoll;
-
-/* epoll api */
-uv__os390_epoll* epoll_create1(int flags);
-int epoll_ctl(uv__os390_epoll* ep, int op, int fd, struct epoll_event *event);
-int epoll_wait(uv__os390_epoll* ep, struct epoll_event *events, int maxevents, int timeout);
-int epoll_file_close(int fd);
-
-/* utility functions */
-int nanosleep(const struct timespec* req, struct timespec* rem);
-int scandir(const char* maindir, struct dirent*** namelist,
-            int (*filter)(const struct dirent *),
-            int (*compar)(const struct dirent **,
-            const struct dirent **));
-char *mkdtemp(char* path);
-
-#endif /* UV_OS390_SYSCALL_H_ */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/src/unix/spinlock.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/* Copyright (c) 2013, Ben Noordhuis <info@bnoordhuis.nl>
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-
-#ifndef UV_SPINLOCK_H_
-#define UV_SPINLOCK_H_
-
-#include "internal.h"  /* ACCESS_ONCE, UV_UNUSED */
-#include "atomic-ops.h"
-
-#define UV_SPINLOCK_INITIALIZER { 0 }
-
-typedef struct {
-  int lock;
-} uv_spinlock_t;
-
-UV_UNUSED(static void uv_spinlock_init(uv_spinlock_t* spinlock));
-UV_UNUSED(static void uv_spinlock_lock(uv_spinlock_t* spinlock));
-UV_UNUSED(static void uv_spinlock_unlock(uv_spinlock_t* spinlock));
-UV_UNUSED(static int uv_spinlock_trylock(uv_spinlock_t* spinlock));
-
-UV_UNUSED(static void uv_spinlock_init(uv_spinlock_t* spinlock)) {
-  ACCESS_ONCE(int, spinlock->lock) = 0;
-}
-
-UV_UNUSED(static void uv_spinlock_lock(uv_spinlock_t* spinlock)) {
-  while (!uv_spinlock_trylock(spinlock)) cpu_relax();
-}
-
-UV_UNUSED(static void uv_spinlock_unlock(uv_spinlock_t* spinlock)) {
-  ACCESS_ONCE(int, spinlock->lock) = 0;
-}
-
-UV_UNUSED(static int uv_spinlock_trylock(uv_spinlock_t* spinlock)) {
-  /* TODO(bnoordhuis) Maybe change to a ticket lock to guarantee fair queueing.
-   * Not really critical until we have locks that are (frequently) contended
-   * for by several threads.
-   */
-  return 0 == cmpxchgi(&spinlock->lock, 0, 1);
-}
-
-#endif  /* UV_SPINLOCK_H_ */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/src/uv-common.h
+++ /dev/null
@@ -1,227 +0,0 @@
-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-/*
- * This file is private to libuv. It provides common functionality to both
- * Windows and Unix backends.
- */
-
-#ifndef UV_COMMON_H_
-#define UV_COMMON_H_
-
-#include <assert.h>
-#include <stdarg.h>
-#include <stddef.h>
-
-#if defined(_MSC_VER) && _MSC_VER < 1600
-# include "stdint-msvc2008.h"
-#else
-# include <stdint.h>
-#endif
-
-#include "uv.h"
-#include "tree.h"
-#include "queue.h"
-
-#if !defined(snprintf) && defined(_MSC_VER) && _MSC_VER < 1900
-extern int snprintf(char*, size_t, const char*, ...);
-#endif
-
-#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))
-
-#define container_of(ptr, type, member) \
-  ((type *) ((char *) (ptr) - offsetof(type, member)))
-
-#define STATIC_ASSERT(expr)                                                   \
-  void uv__static_assert(int static_assert_failed[1 - 2 * !(expr)])
-
-#ifndef _WIN32
-enum {
-  UV__HANDLE_INTERNAL = 0x8000,
-  UV__HANDLE_ACTIVE   = 0x4000,
-  UV__HANDLE_REF      = 0x2000,
-  UV__HANDLE_CLOSING  = 0 /* no-op on unix */
-};
-#else
-# define UV__HANDLE_INTERNAL  0x80
-# define UV__HANDLE_ACTIVE    0x40
-# define UV__HANDLE_REF       0x20
-# define UV__HANDLE_CLOSING   0x01
-#endif
-
-int uv__loop_configure(uv_loop_t* loop, uv_loop_option option, va_list ap);
-
-void uv__loop_close(uv_loop_t* loop);
-
-int uv__tcp_bind(uv_tcp_t* tcp,
-                 const struct sockaddr* addr,
-                 unsigned int addrlen,
-                 unsigned int flags);
-
-int uv__tcp_connect(uv_connect_t* req,
-                   uv_tcp_t* handle,
-                   const struct sockaddr* addr,
-                   unsigned int addrlen,
-                   uv_connect_cb cb);
-
-int uv__udp_bind(uv_udp_t* handle,
-                 const struct sockaddr* addr,
-                 unsigned int  addrlen,
-                 unsigned int flags);
-
-int uv__udp_send(uv_udp_send_t* req,
-                 uv_udp_t* handle,
-                 const uv_buf_t bufs[],
-                 unsigned int nbufs,
-                 const struct sockaddr* addr,
-                 unsigned int addrlen,
-                 uv_udp_send_cb send_cb);
-
-int uv__udp_try_send(uv_udp_t* handle,
-                     const uv_buf_t bufs[],
-                     unsigned int nbufs,
-                     const struct sockaddr* addr,
-                     unsigned int addrlen);
-
-int uv__udp_recv_start(uv_udp_t* handle, uv_alloc_cb alloccb,
-                       uv_udp_recv_cb recv_cb);
-
-int uv__udp_recv_stop(uv_udp_t* handle);
-
-void uv__fs_poll_close(uv_fs_poll_t* handle);
-
-int uv__getaddrinfo_translate_error(int sys_err);    /* EAI_* error. */
-
-void uv__work_submit(uv_loop_t* loop,
-                     struct uv__work *w,
-                     void (*work)(struct uv__work *w),
-                     void (*done)(struct uv__work *w, int status));
-
-void uv__work_done(uv_async_t* handle);
-
-size_t uv__count_bufs(const uv_buf_t bufs[], unsigned int nbufs);
-
-int uv__socket_sockopt(uv_handle_t* handle, int optname, int* value);
-
-void uv__fs_scandir_cleanup(uv_fs_t* req);
-
-#define uv__has_active_reqs(loop)                                             \
-  (QUEUE_EMPTY(&(loop)->active_reqs) == 0)
-
-#define uv__req_register(loop, req)                                           \
-  do {                                                                        \
-    QUEUE_INSERT_TAIL(&(loop)->active_reqs, &(req)->active_queue);            \
-  }                                                                           \
-  while (0)
-
-#define uv__req_unregister(loop, req)                                         \
-  do {                                                                        \
-    assert(uv__has_active_reqs(loop));                                        \
-    QUEUE_REMOVE(&(req)->active_queue);                                       \
-  }                                                                           \
-  while (0)
-
-#define uv__has_active_handles(loop)                                          \
-  ((loop)->active_handles > 0)
-
-#define uv__active_handle_add(h)                                              \
-  do {                                                                        \
-    (h)->loop->active_handles++;                                              \
-  }                                                                           \
-  while (0)
-
-#define uv__active_handle_rm(h)                                               \
-  do {                                                                        \
-    (h)->loop->active_handles--;                                              \
-  }                                                                           \
-  while (0)
-
-#define uv__is_active(h)                                                      \
-  (((h)->flags & UV__HANDLE_ACTIVE) != 0)
-
-#define uv__is_closing(h)                                                     \
-  (((h)->flags & (UV_CLOSING |  UV_CLOSED)) != 0)
-
-#define uv__handle_start(h)                                                   \
-  do {                                                                        \
-    assert(((h)->flags & UV__HANDLE_CLOSING) == 0);                           \
-    if (((h)->flags & UV__HANDLE_ACTIVE) != 0) break;                         \
-    (h)->flags |= UV__HANDLE_ACTIVE;                                          \
-    if (((h)->flags & UV__HANDLE_REF) != 0) uv__active_handle_add(h);         \
-  }                                                                           \
-  while (0)
-
-#define uv__handle_stop(h)                                                    \
-  do {                                                                        \
-    assert(((h)->flags & UV__HANDLE_CLOSING) == 0);                           \
-    if (((h)->flags & UV__HANDLE_ACTIVE) == 0) break;                         \
-    (h)->flags &= ~UV__HANDLE_ACTIVE;                                         \
-    if (((h)->flags & UV__HANDLE_REF) != 0) uv__active_handle_rm(h);          \
-  }                                                                           \
-  while (0)
-
-#define uv__handle_ref(h)                                                     \
-  do {                                                                        \
-    if (((h)->flags & UV__HANDLE_REF) != 0) break;                            \
-    (h)->flags |= UV__HANDLE_REF;                                             \
-    if (((h)->flags & UV__HANDLE_CLOSING) != 0) break;                        \
-    if (((h)->flags & UV__HANDLE_ACTIVE) != 0) uv__active_handle_add(h);      \
-  }                                                                           \
-  while (0)
-
-#define uv__handle_unref(h)                                                   \
-  do {                                                                        \
-    if (((h)->flags & UV__HANDLE_REF) == 0) break;                            \
-    (h)->flags &= ~UV__HANDLE_REF;                                            \
-    if (((h)->flags & UV__HANDLE_CLOSING) != 0) break;                        \
-    if (((h)->flags & UV__HANDLE_ACTIVE) != 0) uv__active_handle_rm(h);       \
-  }                                                                           \
-  while (0)
-
-#define uv__has_ref(h)                                                        \
-  (((h)->flags & UV__HANDLE_REF) != 0)
-
-#if defined(_WIN32)
-# define uv__handle_platform_init(h) ((h)->u.fd = -1)
-#else
-# define uv__handle_platform_init(h) ((h)->next_closing = NULL)
-#endif
-
-#define uv__handle_init(loop_, h, type_)                                      \
-  do {                                                                        \
-    (h)->loop = (loop_);                                                      \
-    (h)->type = (type_);                                                      \
-    (h)->flags = UV__HANDLE_REF;  /* Ref the loop when active. */             \
-    QUEUE_INSERT_TAIL(&(loop_)->handle_queue, &(h)->handle_queue);            \
-    uv__handle_platform_init(h);                                              \
-  }                                                                           \
-  while (0)
-
-
-/* Allocator prototypes */
-void *uv__calloc(size_t count, size_t size);
-char *uv__strdup(const char* s);
-char *uv__strndup(const char* s, size_t n);
-void* uv__malloc(size_t size);
-void uv__free(void* ptr);
-void* uv__realloc(void* ptr, size_t size);
-
-#endif /* UV_COMMON_H_ */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/src/win/atomicops-inl.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef UV_WIN_ATOMICOPS_INL_H_
-#define UV_WIN_ATOMICOPS_INL_H_
-
-#include "uv.h"
-
-
-/* Atomic set operation on char */
-#ifdef _MSC_VER /* MSVC */
-
-/* _InterlockedOr8 is supported by MSVC on x32 and x64. It is  slightly less */
-/* efficient than InterlockedExchange, but InterlockedExchange8 does not */
-/* exist, and interlocked operations on larger targets might require the */
-/* target to be aligned. */
-#pragma intrinsic(_InterlockedOr8)
-
-static char __declspec(inline) uv__atomic_exchange_set(char volatile* target) {
-  return _InterlockedOr8(target, 1);
-}
-
-#else /* GCC */
-
-/* Mingw-32 version, hopefully this works for 64-bit gcc as well. */
-static inline char uv__atomic_exchange_set(char volatile* target) {
-  const char one = 1;
-  char old_value;
-  __asm__ __volatile__ ("lock xchgb %0, %1\n\t"
-                        : "=r"(old_value), "=m"(*target)
-                        : "0"(one), "m"(*target)
-                        : "memory");
-  return old_value;
-}
-
-#endif
-
-#endif /* UV_WIN_ATOMICOPS_INL_H_ */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/src/win/handle-inl.h
+++ /dev/null
@@ -1,179 +0,0 @@
-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef UV_WIN_HANDLE_INL_H_
-#define UV_WIN_HANDLE_INL_H_
-
-#include <assert.h>
-#include <io.h>
-
-#include "uv.h"
-#include "internal.h"
-
-
-#define DECREASE_ACTIVE_COUNT(loop, handle)                             \
-  do {                                                                  \
-    if (--(handle)->activecnt == 0 &&                                   \
-        !((handle)->flags & UV__HANDLE_CLOSING)) {                      \
-      uv__handle_stop((handle));                                        \
-    }                                                                   \
-    assert((handle)->activecnt >= 0);                                   \
-  } while (0)
-
-
-#define INCREASE_ACTIVE_COUNT(loop, handle)                             \
-  do {                                                                  \
-    if ((handle)->activecnt++ == 0) {                                   \
-      uv__handle_start((handle));                                       \
-    }                                                                   \
-    assert((handle)->activecnt > 0);                                    \
-  } while (0)
-
-
-#define DECREASE_PENDING_REQ_COUNT(handle)                              \
-  do {                                                                  \
-    assert(handle->reqs_pending > 0);                                   \
-    handle->reqs_pending--;                                             \
-                                                                        \
-    if (handle->flags & UV__HANDLE_CLOSING &&                           \
-        handle->reqs_pending == 0) {                                    \
-      uv_want_endgame(loop, (uv_handle_t*)handle);                      \
-    }                                                                   \
-  } while (0)
-
-
-#define uv__handle_closing(handle)                                      \
-  do {                                                                  \
-    assert(!((handle)->flags & UV__HANDLE_CLOSING));                    \
-                                                                        \
-    if (!(((handle)->flags & UV__HANDLE_ACTIVE) &&                      \
-          ((handle)->flags & UV__HANDLE_REF)))                          \
-      uv__active_handle_add((uv_handle_t*) (handle));                   \
-                                                                        \
-    (handle)->flags |= UV__HANDLE_CLOSING;                              \
-    (handle)->flags &= ~UV__HANDLE_ACTIVE;                              \
-  } while (0)
-
-
-#define uv__handle_close(handle)                                        \
-  do {                                                                  \
-    QUEUE_REMOVE(&(handle)->handle_queue);                              \
-    uv__active_handle_rm((uv_handle_t*) (handle));                      \
-                                                                        \
-    (handle)->flags |= UV_HANDLE_CLOSED;                                \
-                                                                        \
-    if ((handle)->close_cb)                                             \
-      (handle)->close_cb((uv_handle_t*) (handle));                      \
-  } while (0)
-
-
-INLINE static void uv_want_endgame(uv_loop_t* loop, uv_handle_t* handle) {
-  if (!(handle->flags & UV_HANDLE_ENDGAME_QUEUED)) {
-    handle->flags |= UV_HANDLE_ENDGAME_QUEUED;
-
-    handle->endgame_next = loop->endgame_handles;
-    loop->endgame_handles = handle;
-  }
-}
-
-
-INLINE static void uv_process_endgames(uv_loop_t* loop) {
-  uv_handle_t* handle;
-
-  while (loop->endgame_handles) {
-    handle = loop->endgame_handles;
-    loop->endgame_handles = handle->endgame_next;
-
-    handle->flags &= ~UV_HANDLE_ENDGAME_QUEUED;
-
-    switch (handle->type) {
-      case UV_TCP:
-        uv_tcp_endgame(loop, (uv_tcp_t*) handle);
-        break;
-
-      case UV_NAMED_PIPE:
-        uv_pipe_endgame(loop, (uv_pipe_t*) handle);
-        break;
-
-      case UV_TTY:
-        uv_tty_endgame(loop, (uv_tty_t*) handle);
-        break;
-
-      case UV_UDP:
-        uv_udp_endgame(loop, (uv_udp_t*) handle);
-        break;
-
-      case UV_POLL:
-        uv_poll_endgame(loop, (uv_poll_t*) handle);
-        break;
-
-      case UV_TIMER:
-        uv_timer_endgame(loop, (uv_timer_t*) handle);
-        break;
-
-      case UV_PREPARE:
-      case UV_CHECK:
-      case UV_IDLE:
-        uv_loop_watcher_endgame(loop, handle);
-        break;
-
-      case UV_ASYNC:
-        uv_async_endgame(loop, (uv_async_t*) handle);
-        break;
-
-      case UV_SIGNAL:
-        uv_signal_endgame(loop, (uv_signal_t*) handle);
-        break;
-
-      case UV_PROCESS:
-        uv_process_endgame(loop, (uv_process_t*) handle);
-        break;
-
-      case UV_FS_EVENT:
-        uv_fs_event_endgame(loop, (uv_fs_event_t*) handle);
-        break;
-
-      case UV_FS_POLL:
-        uv__fs_poll_endgame(loop, (uv_fs_poll_t*) handle);
-        break;
-
-      default:
-        assert(0);
-        break;
-    }
-  }
-}
-
-INLINE static HANDLE uv__get_osfhandle(int fd)
-{
-  /* _get_osfhandle() raises an assert in debug builds if the FD is invalid. */
-  /* But  it also correctly checks the FD and returns INVALID_HANDLE_VALUE */
-  /* for invalid FDs in release builds (or if you let the assert continue).  */
-  /* So this wrapper function disables asserts when calling _get_osfhandle. */
-
-  HANDLE handle;
-  UV_BEGIN_DISABLE_CRT_ASSERT();
-  handle = (HANDLE) _get_osfhandle(fd);
-  UV_END_DISABLE_CRT_ASSERT();
-  return handle;
-}
-
-#endif /* UV_WIN_HANDLE_INL_H_ */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/src/win/internal.h
+++ /dev/null
@@ -1,394 +0,0 @@
-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef UV_WIN_INTERNAL_H_
-#define UV_WIN_INTERNAL_H_
-
-#include "uv.h"
-#include "../uv-common.h"
-
-#include "tree.h"
-#include "winapi.h"
-#include "winsock.h"
-
-#ifdef _MSC_VER
-# define INLINE __inline
-# define UV_THREAD_LOCAL __declspec( thread )
-#else
-# define INLINE inline
-# define UV_THREAD_LOCAL __thread
-#endif
-
-
-#ifdef _DEBUG
-
-extern UV_THREAD_LOCAL int uv__crt_assert_enabled;
-
-#define UV_BEGIN_DISABLE_CRT_ASSERT()                           \
-  {                                                             \
-    int uv__saved_crt_assert_enabled = uv__crt_assert_enabled;  \
-    uv__crt_assert_enabled = FALSE;
-
-
-#define UV_END_DISABLE_CRT_ASSERT()                             \
-    uv__crt_assert_enabled = uv__saved_crt_assert_enabled;      \
-  }
-
-#else
-#define UV_BEGIN_DISABLE_CRT_ASSERT()
-#define UV_END_DISABLE_CRT_ASSERT()
-#endif
-
-/*
- * Handles
- * (also see handle-inl.h)
- */
-
-/* Used by all handles. */
-#define UV_HANDLE_CLOSED                        0x00000002
-#define UV_HANDLE_ENDGAME_QUEUED                0x00000008
-
-/* uv-common.h: #define UV__HANDLE_CLOSING      0x00000001 */
-/* uv-common.h: #define UV__HANDLE_ACTIVE       0x00000040 */
-/* uv-common.h: #define UV__HANDLE_REF          0x00000020 */
-/* uv-common.h: #define UV_HANDLE_INTERNAL      0x00000080 */
-
-/* Used by streams and UDP handles. */
-#define UV_HANDLE_READING                       0x00000100
-#define UV_HANDLE_BOUND                         0x00000200
-#define UV_HANDLE_LISTENING                     0x00000800
-#define UV_HANDLE_CONNECTION                    0x00001000
-#define UV_HANDLE_READABLE                      0x00008000
-#define UV_HANDLE_WRITABLE                      0x00010000
-#define UV_HANDLE_READ_PENDING                  0x00020000
-#define UV_HANDLE_SYNC_BYPASS_IOCP              0x00040000
-#define UV_HANDLE_ZERO_READ                     0x00080000
-#define UV_HANDLE_EMULATE_IOCP                  0x00100000
-#define UV_HANDLE_BLOCKING_WRITES               0x00200000
-#define UV_HANDLE_CANCELLATION_PENDING          0x00400000
-
-/* Used by uv_tcp_t and uv_udp_t handles */
-#define UV_HANDLE_IPV6                          0x01000000
-
-/* Only used by uv_tcp_t handles. */
-#define UV_HANDLE_TCP_NODELAY                   0x02000000
-#define UV_HANDLE_TCP_KEEPALIVE                 0x04000000
-#define UV_HANDLE_TCP_SINGLE_ACCEPT             0x08000000
-#define UV_HANDLE_TCP_ACCEPT_STATE_CHANGING     0x10000000
-#define UV_HANDLE_TCP_SOCKET_CLOSED             0x20000000
-#define UV_HANDLE_SHARED_TCP_SOCKET             0x40000000
-
-/* Only used by uv_pipe_t handles. */
-#define UV_HANDLE_NON_OVERLAPPED_PIPE           0x01000000
-#define UV_HANDLE_PIPESERVER                    0x02000000
-#define UV_HANDLE_PIPE_READ_CANCELABLE          0x04000000
-
-/* Only used by uv_tty_t handles. */
-#define UV_HANDLE_TTY_READABLE                  0x01000000
-#define UV_HANDLE_TTY_RAW                       0x02000000
-#define UV_HANDLE_TTY_SAVED_POSITION            0x04000000
-#define UV_HANDLE_TTY_SAVED_ATTRIBUTES          0x08000000
-
-/* Only used by uv_poll_t handles. */
-#define UV_HANDLE_POLL_SLOW                     0x02000000
-
-
-/*
- * Requests: see req-inl.h
- */
-
-
-/*
- * Streams: see stream-inl.h
- */
-
-
-/*
- * TCP
- */
-
-typedef struct {
-  WSAPROTOCOL_INFOW socket_info;
-  int delayed_error;
-} uv__ipc_socket_info_ex;
-
-int uv_tcp_listen(uv_tcp_t* handle, int backlog, uv_connection_cb cb);
-int uv_tcp_accept(uv_tcp_t* server, uv_tcp_t* client);
-int uv_tcp_read_start(uv_tcp_t* handle, uv_alloc_cb alloc_cb,
-    uv_read_cb read_cb);
-int uv_tcp_write(uv_loop_t* loop, uv_write_t* req, uv_tcp_t* handle,
-    const uv_buf_t bufs[], unsigned int nbufs, uv_write_cb cb);
-int uv__tcp_try_write(uv_tcp_t* handle, const uv_buf_t bufs[],
-    unsigned int nbufs);
-
-void uv_process_tcp_read_req(uv_loop_t* loop, uv_tcp_t* handle, uv_req_t* req);
-void uv_process_tcp_write_req(uv_loop_t* loop, uv_tcp_t* handle,
-    uv_write_t* req);
-void uv_process_tcp_accept_req(uv_loop_t* loop, uv_tcp_t* handle,
-    uv_req_t* req);
-void uv_process_tcp_connect_req(uv_loop_t* loop, uv_tcp_t* handle,
-    uv_connect_t* req);
-
-void uv_tcp_close(uv_loop_t* loop, uv_tcp_t* tcp);
-void uv_tcp_endgame(uv_loop_t* loop, uv_tcp_t* handle);
-
-int uv_tcp_import(uv_tcp_t* tcp, uv__ipc_socket_info_ex* socket_info_ex,
-    int tcp_connection);
-
-int uv_tcp_duplicate_socket(uv_tcp_t* handle, int pid,
-    LPWSAPROTOCOL_INFOW protocol_info);
-
-
-/*
- * UDP
- */
-void uv_process_udp_recv_req(uv_loop_t* loop, uv_udp_t* handle, uv_req_t* req);
-void uv_process_udp_send_req(uv_loop_t* loop, uv_udp_t* handle,
-    uv_udp_send_t* req);
-
-void uv_udp_close(uv_loop_t* loop, uv_udp_t* handle);
-void uv_udp_endgame(uv_loop_t* loop, uv_udp_t* handle);
-
-
-/*
- * Pipes
- */
-int uv_stdio_pipe_server(uv_loop_t* loop, uv_pipe_t* handle, DWORD access,
-    char* name, size_t nameSize);
-
-int uv_pipe_listen(uv_pipe_t* handle, int backlog, uv_connection_cb cb);
-int uv_pipe_accept(uv_pipe_t* server, uv_stream_t* client);
-int uv_pipe_read_start(uv_pipe_t* handle, uv_alloc_cb alloc_cb,
-    uv_read_cb read_cb);
-int uv_pipe_write(uv_loop_t* loop, uv_write_t* req, uv_pipe_t* handle,
-    const uv_buf_t bufs[], unsigned int nbufs, uv_write_cb cb);
-int uv_pipe_write2(uv_loop_t* loop, uv_write_t* req, uv_pipe_t* handle,
-    const uv_buf_t bufs[], unsigned int nbufs, uv_stream_t* send_handle,
-    uv_write_cb cb);
-void uv__pipe_pause_read(uv_pipe_t* handle);
-void uv__pipe_unpause_read(uv_pipe_t* handle);
-void uv__pipe_stop_read(uv_pipe_t* handle);
-
-void uv_process_pipe_read_req(uv_loop_t* loop, uv_pipe_t* handle,
-    uv_req_t* req);
-void uv_process_pipe_write_req(uv_loop_t* loop, uv_pipe_t* handle,
-    uv_write_t* req);
-void uv_process_pipe_accept_req(uv_loop_t* loop, uv_pipe_t* handle,
-    uv_req_t* raw_req);
-void uv_process_pipe_connect_req(uv_loop_t* loop, uv_pipe_t* handle,
-    uv_connect_t* req);
-void uv_process_pipe_shutdown_req(uv_loop_t* loop, uv_pipe_t* handle,
-    uv_shutdown_t* req);
-
-void uv_pipe_close(uv_loop_t* loop, uv_pipe_t* handle);
-void uv_pipe_cleanup(uv_loop_t* loop, uv_pipe_t* handle);
-void uv_pipe_endgame(uv_loop_t* loop, uv_pipe_t* handle);
-
-
-/*
- * TTY
- */
-void uv_console_init();
-
-int uv_tty_read_start(uv_tty_t* handle, uv_alloc_cb alloc_cb,
-    uv_read_cb read_cb);
-int uv_tty_read_stop(uv_tty_t* handle);
-int uv_tty_write(uv_loop_t* loop, uv_write_t* req, uv_tty_t* handle,
-    const uv_buf_t bufs[], unsigned int nbufs, uv_write_cb cb);
-int uv__tty_try_write(uv_tty_t* handle, const uv_buf_t bufs[],
-    unsigned int nbufs);
-void uv_tty_close(uv_tty_t* handle);
-
-void uv_process_tty_read_req(uv_loop_t* loop, uv_tty_t* handle,
-    uv_req_t* req);
-void uv_process_tty_write_req(uv_loop_t* loop, uv_tty_t* handle,
-    uv_write_t* req);
-/* TODO: remove me */
-void uv_process_tty_accept_req(uv_loop_t* loop, uv_tty_t* handle,
-    uv_req_t* raw_req);
-/* TODO: remove me */
-void uv_process_tty_connect_req(uv_loop_t* loop, uv_tty_t* handle,
-    uv_connect_t* req);
-
-void uv_tty_endgame(uv_loop_t* loop, uv_tty_t* handle);
-
-
-/*
- * Poll watchers
- */
-void uv_process_poll_req(uv_loop_t* loop, uv_poll_t* handle,
-    uv_req_t* req);
-
-int uv_poll_close(uv_loop_t* loop, uv_poll_t* handle);
-void uv_poll_endgame(uv_loop_t* loop, uv_poll_t* handle);
-
-
-/*
- * Timers
- */
-void uv_timer_endgame(uv_loop_t* loop, uv_timer_t* handle);
-
-DWORD uv__next_timeout(const uv_loop_t* loop);
-void uv_process_timers(uv_loop_t* loop);
-
-
-/*
- * Loop watchers
- */
-void uv_loop_watcher_endgame(uv_loop_t* loop, uv_handle_t* handle);
-
-void uv_prepare_invoke(uv_loop_t* loop);
-void uv_check_invoke(uv_loop_t* loop);
-void uv_idle_invoke(uv_loop_t* loop);
-
-void uv__once_init();
-
-
-/*
- * Async watcher
- */
-void uv_async_close(uv_loop_t* loop, uv_async_t* handle);
-void uv_async_endgame(uv_loop_t* loop, uv_async_t* handle);
-
-void uv_process_async_wakeup_req(uv_loop_t* loop, uv_async_t* handle,
-    uv_req_t* req);
-
-
-/*
- * Signal watcher
- */
-void uv_signals_init();
-int uv__signal_dispatch(int signum);
-
-void uv_signal_close(uv_loop_t* loop, uv_signal_t* handle);
-void uv_signal_endgame(uv_loop_t* loop, uv_signal_t* handle);
-
-void uv_process_signal_req(uv_loop_t* loop, uv_signal_t* handle,
-    uv_req_t* req);
-
-
-/*
- * Spawn
- */
-void uv_process_proc_exit(uv_loop_t* loop, uv_process_t* handle);
-void uv_process_close(uv_loop_t* loop, uv_process_t* handle);
-void uv_process_endgame(uv_loop_t* loop, uv_process_t* handle);
-
-
-/*
- * Error
- */
-int uv_translate_sys_error(int sys_errno);
-
-
-/*
- * FS
- */
-void uv_fs_init();
-
-
-/*
- * FS Event
- */
-void uv_process_fs_event_req(uv_loop_t* loop, uv_req_t* req,
-    uv_fs_event_t* handle);
-void uv_fs_event_close(uv_loop_t* loop, uv_fs_event_t* handle);
-void uv_fs_event_endgame(uv_loop_t* loop, uv_fs_event_t* handle);
-
-
-/*
- * Stat poller.
- */
-void uv__fs_poll_endgame(uv_loop_t* loop, uv_fs_poll_t* handle);
-
-
-/*
- * Utilities.
- */
-void uv__util_init();
-
-uint64_t uv__hrtime(double scale);
-int uv_parent_pid();
-int uv_current_pid();
-__declspec(noreturn) void uv_fatal_error(const int errorno, const char* syscall);
-int uv__getpwuid_r(uv_passwd_t* pwd);
-int uv__convert_utf16_to_utf8(const WCHAR* utf16, int utf16len, char** utf8);
-
-
-/*
- * Process stdio handles.
- */
-int uv__stdio_create(uv_loop_t* loop,
-                     const uv_process_options_t* options,
-                     BYTE** buffer_ptr);
-void uv__stdio_destroy(BYTE* buffer);
-void uv__stdio_noinherit(BYTE* buffer);
-int uv__stdio_verify(BYTE* buffer, WORD size);
-WORD uv__stdio_size(BYTE* buffer);
-HANDLE uv__stdio_handle(BYTE* buffer, int fd);
-
-
-/*
- * Winapi and ntapi utility functions
- */
-void uv_winapi_init();
-
-
-/*
- * Winsock utility functions
- */
-void uv_winsock_init();
-
-int uv_ntstatus_to_winsock_error(NTSTATUS status);
-
-BOOL uv_get_acceptex_function(SOCKET socket, LPFN_ACCEPTEX* target);
-BOOL uv_get_connectex_function(SOCKET socket, LPFN_CONNECTEX* target);
-
-int WSAAPI uv_wsarecv_workaround(SOCKET socket, WSABUF* buffers,
-    DWORD buffer_count, DWORD* bytes, DWORD* flags, WSAOVERLAPPED *overlapped,
-    LPWSAOVERLAPPED_COMPLETION_ROUTINE completion_routine);
-int WSAAPI uv_wsarecvfrom_workaround(SOCKET socket, WSABUF* buffers,
-    DWORD buffer_count, DWORD* bytes, DWORD* flags, struct sockaddr* addr,
-    int* addr_len, WSAOVERLAPPED *overlapped,
-    LPWSAOVERLAPPED_COMPLETION_ROUTINE completion_routine);
-
-int WSAAPI uv_msafd_poll(SOCKET socket, AFD_POLL_INFO* info_in,
-    AFD_POLL_INFO* info_out, OVERLAPPED* overlapped);
-
-/* Whether there are any non-IFS LSPs stacked on TCP */
-extern int uv_tcp_non_ifs_lsp_ipv4;
-extern int uv_tcp_non_ifs_lsp_ipv6;
-
-/* Ip address used to bind to any port at any interface */
-extern struct sockaddr_in uv_addr_ip4_any_;
-extern struct sockaddr_in6 uv_addr_ip6_any_;
-
-/*
- * Wake all loops with fake message
- */
-void uv__wake_all_loops();
-
-/*
- * Init system wake-up detection
- */
-void uv__init_detect_system_wakeup();
-
-#endif /* UV_WIN_INTERNAL_H_ */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/src/win/req-inl.h
+++ /dev/null
@@ -1,224 +0,0 @@
-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef UV_WIN_REQ_INL_H_
-#define UV_WIN_REQ_INL_H_
-
-#include <assert.h>
-
-#include "uv.h"
-#include "internal.h"
-
-
-#define SET_REQ_STATUS(req, status)                                     \
-   (req)->u.io.overlapped.Internal = (ULONG_PTR) (status)
-
-#define SET_REQ_ERROR(req, error)                                       \
-  SET_REQ_STATUS((req), NTSTATUS_FROM_WIN32((error)))
-
-#define SET_REQ_SUCCESS(req)                                            \
-  SET_REQ_STATUS((req), STATUS_SUCCESS)
-
-#define GET_REQ_STATUS(req)                                             \
-  ((NTSTATUS) (req)->u.io.overlapped.Internal)
-
-#define REQ_SUCCESS(req)                                                \
-  (NT_SUCCESS(GET_REQ_STATUS((req))))
-
-#define GET_REQ_ERROR(req)                                              \
-  (pRtlNtStatusToDosError(GET_REQ_STATUS((req))))
-
-#define GET_REQ_SOCK_ERROR(req)                                         \
-  (uv_ntstatus_to_winsock_error(GET_REQ_STATUS((req))))
-
-
-#define REGISTER_HANDLE_REQ(loop, handle, req)                          \
-  do {                                                                  \
-    INCREASE_ACTIVE_COUNT((loop), (handle));                            \
-    uv__req_register((loop), (req));                                    \
-  } while (0)
-
-#define UNREGISTER_HANDLE_REQ(loop, handle, req)                        \
-  do {                                                                  \
-    DECREASE_ACTIVE_COUNT((loop), (handle));                            \
-    uv__req_unregister((loop), (req));                                  \
-  } while (0)
-
-
-#define UV_SUCCEEDED_WITHOUT_IOCP(result)                               \
-  ((result) && (handle->flags & UV_HANDLE_SYNC_BYPASS_IOCP))
-
-#define UV_SUCCEEDED_WITH_IOCP(result)                                  \
-  ((result) || (GetLastError() == ERROR_IO_PENDING))
-
-
-#define POST_COMPLETION_FOR_REQ(loop, req)                              \
-  if (!PostQueuedCompletionStatus((loop)->iocp,                         \
-                                  0,                                    \
-                                  0,                                    \
-                                  &((req)->u.io.overlapped))) {         \
-    uv_fatal_error(GetLastError(), "PostQueuedCompletionStatus");       \
-  }
-
-
-INLINE static void uv_req_init(uv_loop_t* loop, uv_req_t* req) {
-  req->type = UV_UNKNOWN_REQ;
-  SET_REQ_SUCCESS(req);
-}
-
-
-INLINE static uv_req_t* uv_overlapped_to_req(OVERLAPPED* overlapped) {
-  return CONTAINING_RECORD(overlapped, uv_req_t, u.io.overlapped);
-}
-
-
-INLINE static void uv_insert_pending_req(uv_loop_t* loop, uv_req_t* req) {
-  req->next_req = NULL;
-  if (loop->pending_reqs_tail) {
-#ifdef _DEBUG
-    /* Ensure the request is not already in the queue, or the queue
-     * will get corrupted.
-     */
-    uv_req_t* current = loop->pending_reqs_tail;
-    do {
-      assert(req != current);
-      current = current->next_req;
-    } while(current != loop->pending_reqs_tail);
-#endif
-
-    req->next_req = loop->pending_reqs_tail->next_req;
-    loop->pending_reqs_tail->next_req = req;
-    loop->pending_reqs_tail = req;
-  } else {
-    req->next_req = req;
-    loop->pending_reqs_tail = req;
-  }
-}
-
-
-#define DELEGATE_STREAM_REQ(loop, req, method, handle_at)                     \
-  do {                                                                        \
-    switch (((uv_handle_t*) (req)->handle_at)->type) {                        \
-      case UV_TCP:                                                            \
-        uv_process_tcp_##method##_req(loop,                                   \
-                                      (uv_tcp_t*) ((req)->handle_at),         \
-                                      req);                                   \
-        break;                                                                \
-                                                                              \
-      case UV_NAMED_PIPE:                                                     \
-        uv_process_pipe_##method##_req(loop,                                  \
-                                       (uv_pipe_t*) ((req)->handle_at),       \
-                                       req);                                  \
-        break;                                                                \
-                                                                              \
-      case UV_TTY:                                                            \
-        uv_process_tty_##method##_req(loop,                                   \
-                                      (uv_tty_t*) ((req)->handle_at),         \
-                                      req);                                   \
-        break;                                                                \
-                                                                              \
-      default:                                                                \
-        assert(0);                                                            \
-    }                                                                         \
-  } while (0)
-
-
-INLINE static int uv_process_reqs(uv_loop_t* loop) {
-  uv_req_t* req;
-  uv_req_t* first;
-  uv_req_t* next;
-
-  if (loop->pending_reqs_tail == NULL)
-    return 0;
-
-  first = loop->pending_reqs_tail->next_req;
-  next = first;
-  loop->pending_reqs_tail = NULL;
-
-  while (next != NULL) {
-    req = next;
-    next = req->next_req != first ? req->next_req : NULL;
-
-    switch (req->type) {
-      case UV_READ:
-        DELEGATE_STREAM_REQ(loop, req, read, data);
-        break;
-
-      case UV_WRITE:
-        DELEGATE_STREAM_REQ(loop, (uv_write_t*) req, write, handle);
-        break;
-
-      case UV_ACCEPT:
-        DELEGATE_STREAM_REQ(loop, req, accept, data);
-        break;
-
-      case UV_CONNECT:
-        DELEGATE_STREAM_REQ(loop, (uv_connect_t*) req, connect, handle);
-        break;
-
-      case UV_SHUTDOWN:
-        /* Tcp shutdown requests don't come here. */
-        assert(((uv_shutdown_t*) req)->handle->type == UV_NAMED_PIPE);
-        uv_process_pipe_shutdown_req(
-            loop,
-            (uv_pipe_t*) ((uv_shutdown_t*) req)->handle,
-            (uv_shutdown_t*) req);
-        break;
-
-      case UV_UDP_RECV:
-        uv_process_udp_recv_req(loop, (uv_udp_t*) req->data, req);
-        break;
-
-      case UV_UDP_SEND:
-        uv_process_udp_send_req(loop,
-                                ((uv_udp_send_t*) req)->handle,
-                                (uv_udp_send_t*) req);
-        break;
-
-      case UV_WAKEUP:
-        uv_process_async_wakeup_req(loop, (uv_async_t*) req->data, req);
-        break;
-
-      case UV_SIGNAL_REQ:
-        uv_process_signal_req(loop, (uv_signal_t*) req->data, req);
-        break;
-
-      case UV_POLL_REQ:
-        uv_process_poll_req(loop, (uv_poll_t*) req->data, req);
-        break;
-
-      case UV_PROCESS_EXIT:
-        uv_process_proc_exit(loop, (uv_process_t*) req->data);
-        break;
-
-      case UV_FS_EVENT_REQ:
-        uv_process_fs_event_req(loop, req, (uv_fs_event_t*) req->data);
-        break;
-
-      default:
-        assert(0);
-    }
-  }
-
-  return 1;
-}
-
-#endif /* UV_WIN_REQ_INL_H_ */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/src/win/stream-inl.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef UV_WIN_STREAM_INL_H_
-#define UV_WIN_STREAM_INL_H_
-
-#include <assert.h>
-
-#include "uv.h"
-#include "internal.h"
-#include "handle-inl.h"
-#include "req-inl.h"
-
-
-INLINE static void uv_stream_init(uv_loop_t* loop,
-                                  uv_stream_t* handle,
-                                  uv_handle_type type) {
-  uv__handle_init(loop, (uv_handle_t*) handle, type);
-  handle->write_queue_size = 0;
-  handle->activecnt = 0;
-}
-
-
-INLINE static void uv_connection_init(uv_stream_t* handle) {
-  handle->flags |= UV_HANDLE_CONNECTION;
-  handle->stream.conn.write_reqs_pending = 0;
-
-  uv_req_init(handle->loop, (uv_req_t*) &(handle->read_req));
-  handle->read_req.event_handle = NULL;
-  handle->read_req.wait_handle = INVALID_HANDLE_VALUE;
-  handle->read_req.type = UV_READ;
-  handle->read_req.data = handle;
-
-  handle->stream.conn.shutdown_req = NULL;
-}
-
-
-#endif /* UV_WIN_STREAM_INL_H_ */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/src/win/winapi.h
+++ /dev/null
@@ -1,4752 +0,0 @@
-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef UV_WIN_WINAPI_H_
-#define UV_WIN_WINAPI_H_
-
-#include <windows.h>
-
-
-/*
- * Ntdll headers
- */
-#ifndef STATUS_SEVERITY_SUCCESS
-# define STATUS_SEVERITY_SUCCESS 0x0
-#endif
-
-#ifndef STATUS_SEVERITY_INFORMATIONAL
-# define STATUS_SEVERITY_INFORMATIONAL 0x1
-#endif
-
-#ifndef STATUS_SEVERITY_WARNING
-# define STATUS_SEVERITY_WARNING 0x2
-#endif
-
-#ifndef STATUS_SEVERITY_ERROR
-# define STATUS_SEVERITY_ERROR 0x3
-#endif
-
-#ifndef FACILITY_NTWIN32
-# define FACILITY_NTWIN32 0x7
-#endif
-
-#ifndef NT_SUCCESS
-# define NT_SUCCESS(status) (((NTSTATUS) (status)) >= 0)
-#endif
-
-#ifndef NT_INFORMATION
-# define NT_INFORMATION(status) ((((ULONG) (status)) >> 30) == 1)
-#endif
-
-#ifndef NT_WARNING
-# define NT_WARNING(status) ((((ULONG) (status)) >> 30) == 2)
-#endif
-
-#ifndef NT_ERROR
-# define NT_ERROR(status) ((((ULONG) (status)) >> 30) == 3)
-#endif
-
-#ifndef STATUS_SUCCESS
-# define STATUS_SUCCESS ((NTSTATUS) 0x00000000L)
-#endif
-
-#ifndef STATUS_WAIT_0
-# define STATUS_WAIT_0 ((NTSTATUS) 0x00000000L)
-#endif
-
-#ifndef STATUS_WAIT_1
-# define STATUS_WAIT_1 ((NTSTATUS) 0x00000001L)
-#endif
-
-#ifndef STATUS_WAIT_2
-# define STATUS_WAIT_2 ((NTSTATUS) 0x00000002L)
-#endif
-
-#ifndef STATUS_WAIT_3
-# define STATUS_WAIT_3 ((NTSTATUS) 0x00000003L)
-#endif
-
-#ifndef STATUS_WAIT_63
-# define STATUS_WAIT_63 ((NTSTATUS) 0x0000003FL)
-#endif
-
-#ifndef STATUS_ABANDONED
-# define STATUS_ABANDONED ((NTSTATUS) 0x00000080L)
-#endif
-
-#ifndef STATUS_ABANDONED_WAIT_0
-# define STATUS_ABANDONED_WAIT_0 ((NTSTATUS) 0x00000080L)
-#endif
-
-#ifndef STATUS_ABANDONED_WAIT_63
-# define STATUS_ABANDONED_WAIT_63 ((NTSTATUS) 0x000000BFL)
-#endif
-
-#ifndef STATUS_USER_APC
-# define STATUS_USER_APC ((NTSTATUS) 0x000000C0L)
-#endif
-
-#ifndef STATUS_KERNEL_APC
-# define STATUS_KERNEL_APC ((NTSTATUS) 0x00000100L)
-#endif
-
-#ifndef STATUS_ALERTED
-# define STATUS_ALERTED ((NTSTATUS) 0x00000101L)
-#endif
-
-#ifndef STATUS_TIMEOUT
-# define STATUS_TIMEOUT ((NTSTATUS) 0x00000102L)
-#endif
-
-#ifndef STATUS_PENDING
-# define STATUS_PENDING ((NTSTATUS) 0x00000103L)
-#endif
-
-#ifndef STATUS_REPARSE
-# define STATUS_REPARSE ((NTSTATUS) 0x00000104L)
-#endif
-
-#ifndef STATUS_MORE_ENTRIES
-# define STATUS_MORE_ENTRIES ((NTSTATUS) 0x00000105L)
-#endif
-
-#ifndef STATUS_NOT_ALL_ASSIGNED
-# define STATUS_NOT_ALL_ASSIGNED ((NTSTATUS) 0x00000106L)
-#endif
-
-#ifndef STATUS_SOME_NOT_MAPPED
-# define STATUS_SOME_NOT_MAPPED ((NTSTATUS) 0x00000107L)
-#endif
-
-#ifndef STATUS_OPLOCK_BREAK_IN_PROGRESS
-# define STATUS_OPLOCK_BREAK_IN_PROGRESS ((NTSTATUS) 0x00000108L)
-#endif
-
-#ifndef STATUS_VOLUME_MOUNTED
-# define STATUS_VOLUME_MOUNTED ((NTSTATUS) 0x00000109L)
-#endif
-
-#ifndef STATUS_RXACT_COMMITTED
-# define STATUS_RXACT_COMMITTED ((NTSTATUS) 0x0000010AL)
-#endif
-
-#ifndef STATUS_NOTIFY_CLEANUP
-# define STATUS_NOTIFY_CLEANUP ((NTSTATUS) 0x0000010BL)
-#endif
-
-#ifndef STATUS_NOTIFY_ENUM_DIR
-# define STATUS_NOTIFY_ENUM_DIR ((NTSTATUS) 0x0000010CL)
-#endif
-
-#ifndef STATUS_NO_QUOTAS_FOR_ACCOUNT
-# define STATUS_NO_QUOTAS_FOR_ACCOUNT ((NTSTATUS) 0x0000010DL)
-#endif
-
-#ifndef STATUS_PRIMARY_TRANSPORT_CONNECT_FAILED
-# define STATUS_PRIMARY_TRANSPORT_CONNECT_FAILED ((NTSTATUS) 0x0000010EL)
-#endif
-
-#ifndef STATUS_PAGE_FAULT_TRANSITION
-# define STATUS_PAGE_FAULT_TRANSITION ((NTSTATUS) 0x00000110L)
-#endif
-
-#ifndef STATUS_PAGE_FAULT_DEMAND_ZERO
-# define STATUS_PAGE_FAULT_DEMAND_ZERO ((NTSTATUS) 0x00000111L)
-#endif
-
-#ifndef STATUS_PAGE_FAULT_COPY_ON_WRITE
-# define STATUS_PAGE_FAULT_COPY_ON_WRITE ((NTSTATUS) 0x00000112L)
-#endif
-
-#ifndef STATUS_PAGE_FAULT_GUARD_PAGE
-# define STATUS_PAGE_FAULT_GUARD_PAGE ((NTSTATUS) 0x00000113L)
-#endif
-
-#ifndef STATUS_PAGE_FAULT_PAGING_FILE
-# define STATUS_PAGE_FAULT_PAGING_FILE ((NTSTATUS) 0x00000114L)
-#endif
-
-#ifndef STATUS_CACHE_PAGE_LOCKED
-# define STATUS_CACHE_PAGE_LOCKED ((NTSTATUS) 0x00000115L)
-#endif
-
-#ifndef STATUS_CRASH_DUMP
-# define STATUS_CRASH_DUMP ((NTSTATUS) 0x00000116L)
-#endif
-
-#ifndef STATUS_BUFFER_ALL_ZEROS
-# define STATUS_BUFFER_ALL_ZEROS ((NTSTATUS) 0x00000117L)
-#endif
-
-#ifndef STATUS_REPARSE_OBJECT
-# define STATUS_REPARSE_OBJECT ((NTSTATUS) 0x00000118L)
-#endif
-
-#ifndef STATUS_RESOURCE_REQUIREMENTS_CHANGED
-# define STATUS_RESOURCE_REQUIREMENTS_CHANGED ((NTSTATUS) 0x00000119L)
-#endif
-
-#ifndef STATUS_TRANSLATION_COMPLETE
-# define STATUS_TRANSLATION_COMPLETE ((NTSTATUS) 0x00000120L)
-#endif
-
-#ifndef STATUS_DS_MEMBERSHIP_EVALUATED_LOCALLY
-# define STATUS_DS_MEMBERSHIP_EVALUATED_LOCALLY ((NTSTATUS) 0x00000121L)
-#endif
-
-#ifndef STATUS_NOTHING_TO_TERMINATE
-# define STATUS_NOTHING_TO_TERMINATE ((NTSTATUS) 0x00000122L)
-#endif
-
-#ifndef STATUS_PROCESS_NOT_IN_JOB
-# define STATUS_PROCESS_NOT_IN_JOB ((NTSTATUS) 0x00000123L)
-#endif
-
-#ifndef STATUS_PROCESS_IN_JOB
-# define STATUS_PROCESS_IN_JOB ((NTSTATUS) 0x00000124L)
-#endif
-
-#ifndef STATUS_VOLSNAP_HIBERNATE_READY
-# define STATUS_VOLSNAP_HIBERNATE_READY ((NTSTATUS) 0x00000125L)
-#endif
-
-#ifndef STATUS_FSFILTER_OP_COMPLETED_SUCCESSFULLY
-# define STATUS_FSFILTER_OP_COMPLETED_SUCCESSFULLY ((NTSTATUS) 0x00000126L)
-#endif
-
-#ifndef STATUS_INTERRUPT_VECTOR_ALREADY_CONNECTED
-# define STATUS_INTERRUPT_VECTOR_ALREADY_CONNECTED ((NTSTATUS) 0x00000127L)
-#endif
-
-#ifndef STATUS_INTERRUPT_STILL_CONNECTED
-# define STATUS_INTERRUPT_STILL_CONNECTED ((NTSTATUS) 0x00000128L)
-#endif
-
-#ifndef STATUS_PROCESS_CLONED
-# define STATUS_PROCESS_CLONED ((NTSTATUS) 0x00000129L)
-#endif
-
-#ifndef STATUS_FILE_LOCKED_WITH_ONLY_READERS
-# define STATUS_FILE_LOCKED_WITH_ONLY_READERS ((NTSTATUS) 0x0000012AL)
-#endif
-
-#ifndef STATUS_FILE_LOCKED_WITH_WRITERS
-# define STATUS_FILE_LOCKED_WITH_WRITERS ((NTSTATUS) 0x0000012BL)
-#endif
-
-#ifndef STATUS_RESOURCEMANAGER_READ_ONLY
-# define STATUS_RESOURCEMANAGER_READ_ONLY ((NTSTATUS) 0x00000202L)
-#endif
-
-#ifndef STATUS_RING_PREVIOUSLY_EMPTY
-# define STATUS_RING_PREVIOUSLY_EMPTY ((NTSTATUS) 0x00000210L)
-#endif
-
-#ifndef STATUS_RING_PREVIOUSLY_FULL
-# define STATUS_RING_PREVIOUSLY_FULL ((NTSTATUS) 0x00000211L)
-#endif
-
-#ifndef STATUS_RING_PREVIOUSLY_ABOVE_QUOTA
-# define STATUS_RING_PREVIOUSLY_ABOVE_QUOTA ((NTSTATUS) 0x00000212L)
-#endif
-
-#ifndef STATUS_RING_NEWLY_EMPTY
-# define STATUS_RING_NEWLY_EMPTY ((NTSTATUS) 0x00000213L)
-#endif
-
-#ifndef STATUS_RING_SIGNAL_OPPOSITE_ENDPOINT
-# define STATUS_RING_SIGNAL_OPPOSITE_ENDPOINT ((NTSTATUS) 0x00000214L)
-#endif
-
-#ifndef STATUS_OPLOCK_SWITCHED_TO_NEW_HANDLE
-# define STATUS_OPLOCK_SWITCHED_TO_NEW_HANDLE ((NTSTATUS) 0x00000215L)
-#endif
-
-#ifndef STATUS_OPLOCK_HANDLE_CLOSED
-# define STATUS_OPLOCK_HANDLE_CLOSED ((NTSTATUS) 0x00000216L)
-#endif
-
-#ifndef STATUS_WAIT_FOR_OPLOCK
-# define STATUS_WAIT_FOR_OPLOCK ((NTSTATUS) 0x00000367L)
-#endif
-
-#ifndef STATUS_OBJECT_NAME_EXISTS
-# define STATUS_OBJECT_NAME_EXISTS ((NTSTATUS) 0x40000000L)
-#endif
-
-#ifndef STATUS_THREAD_WAS_SUSPENDED
-# define STATUS_THREAD_WAS_SUSPENDED ((NTSTATUS) 0x40000001L)
-#endif
-
-#ifndef STATUS_WORKING_SET_LIMIT_RANGE
-# define STATUS_WORKING_SET_LIMIT_RANGE ((NTSTATUS) 0x40000002L)
-#endif
-
-#ifndef STATUS_IMAGE_NOT_AT_BASE
-# define STATUS_IMAGE_NOT_AT_BASE ((NTSTATUS) 0x40000003L)
-#endif
-
-#ifndef STATUS_RXACT_STATE_CREATED
-# define STATUS_RXACT_STATE_CREATED ((NTSTATUS) 0x40000004L)
-#endif
-
-#ifndef STATUS_SEGMENT_NOTIFICATION
-# define STATUS_SEGMENT_NOTIFICATION ((NTSTATUS) 0x40000005L)
-#endif
-
-#ifndef STATUS_LOCAL_USER_SESSION_KEY
-# define STATUS_LOCAL_USER_SESSION_KEY ((NTSTATUS) 0x40000006L)
-#endif
-
-#ifndef STATUS_BAD_CURRENT_DIRECTORY
-# define STATUS_BAD_CURRENT_DIRECTORY ((NTSTATUS) 0x40000007L)
-#endif
-
-#ifndef STATUS_SERIAL_MORE_WRITES
-# define STATUS_SERIAL_MORE_WRITES ((NTSTATUS) 0x40000008L)
-#endif
-
-#ifndef STATUS_REGISTRY_RECOVERED
-# define STATUS_REGISTRY_RECOVERED ((NTSTATUS) 0x40000009L)
-#endif
-
-#ifndef STATUS_FT_READ_RECOVERY_FROM_BACKUP
-# define STATUS_FT_READ_RECOVERY_FROM_BACKUP ((NTSTATUS) 0x4000000AL)
-#endif
-
-#ifndef STATUS_FT_WRITE_RECOVERY
-# define STATUS_FT_WRITE_RECOVERY ((NTSTATUS) 0x4000000BL)
-#endif
-
-#ifndef STATUS_SERIAL_COUNTER_TIMEOUT
-# define STATUS_SERIAL_COUNTER_TIMEOUT ((NTSTATUS) 0x4000000CL)
-#endif
-
-#ifndef STATUS_NULL_LM_PASSWORD
-# define STATUS_NULL_LM_PASSWORD ((NTSTATUS) 0x4000000DL)
-#endif
-
-#ifndef STATUS_IMAGE_MACHINE_TYPE_MISMATCH
-# define STATUS_IMAGE_MACHINE_TYPE_MISMATCH ((NTSTATUS) 0x4000000EL)
-#endif
-
-#ifndef STATUS_RECEIVE_PARTIAL
-# define STATUS_RECEIVE_PARTIAL ((NTSTATUS) 0x4000000FL)
-#endif
-
-#ifndef STATUS_RECEIVE_EXPEDITED
-# define STATUS_RECEIVE_EXPEDITED ((NTSTATUS) 0x40000010L)
-#endif
-
-#ifndef STATUS_RECEIVE_PARTIAL_EXPEDITED
-# define STATUS_RECEIVE_PARTIAL_EXPEDITED ((NTSTATUS) 0x40000011L)
-#endif
-
-#ifndef STATUS_EVENT_DONE
-# define STATUS_EVENT_DONE ((NTSTATUS) 0x40000012L)
-#endif
-
-#ifndef STATUS_EVENT_PENDING
-# define STATUS_EVENT_PENDING ((NTSTATUS) 0x40000013L)
-#endif
-
-#ifndef STATUS_CHECKING_FILE_SYSTEM
-# define STATUS_CHECKING_FILE_SYSTEM ((NTSTATUS) 0x40000014L)
-#endif
-
-#ifndef STATUS_FATAL_APP_EXIT
-# define STATUS_FATAL_APP_EXIT ((NTSTATUS) 0x40000015L)
-#endif
-
-#ifndef STATUS_PREDEFINED_HANDLE
-# define STATUS_PREDEFINED_HANDLE ((NTSTATUS) 0x40000016L)
-#endif
-
-#ifndef STATUS_WAS_UNLOCKED
-# define STATUS_WAS_UNLOCKED ((NTSTATUS) 0x40000017L)
-#endif
-
-#ifndef STATUS_SERVICE_NOTIFICATION
-# define STATUS_SERVICE_NOTIFICATION ((NTSTATUS) 0x40000018L)
-#endif
-
-#ifndef STATUS_WAS_LOCKED
-# define STATUS_WAS_LOCKED ((NTSTATUS) 0x40000019L)
-#endif
-
-#ifndef STATUS_LOG_HARD_ERROR
-# define STATUS_LOG_HARD_ERROR ((NTSTATUS) 0x4000001AL)
-#endif
-
-#ifndef STATUS_ALREADY_WIN32
-# define STATUS_ALREADY_WIN32 ((NTSTATUS) 0x4000001BL)
-#endif
-
-#ifndef STATUS_WX86_UNSIMULATE
-# define STATUS_WX86_UNSIMULATE ((NTSTATUS) 0x4000001CL)
-#endif
-
-#ifndef STATUS_WX86_CONTINUE
-# define STATUS_WX86_CONTINUE ((NTSTATUS) 0x4000001DL)
-#endif
-
-#ifndef STATUS_WX86_SINGLE_STEP
-# define STATUS_WX86_SINGLE_STEP ((NTSTATUS) 0x4000001EL)
-#endif
-
-#ifndef STATUS_WX86_BREAKPOINT
-# define STATUS_WX86_BREAKPOINT ((NTSTATUS) 0x4000001FL)
-#endif
-
-#ifndef STATUS_WX86_EXCEPTION_CONTINUE
-# define STATUS_WX86_EXCEPTION_CONTINUE ((NTSTATUS) 0x40000020L)
-#endif
-
-#ifndef STATUS_WX86_EXCEPTION_LASTCHANCE
-# define STATUS_WX86_EXCEPTION_LASTCHANCE ((NTSTATUS) 0x40000021L)
-#endif
-
-#ifndef STATUS_WX86_EXCEPTION_CHAIN
-# define STATUS_WX86_EXCEPTION_CHAIN ((NTSTATUS) 0x40000022L)
-#endif
-
-#ifndef STATUS_IMAGE_MACHINE_TYPE_MISMATCH_EXE
-# define STATUS_IMAGE_MACHINE_TYPE_MISMATCH_EXE ((NTSTATUS) 0x40000023L)
-#endif
-
-#ifndef STATUS_NO_YIELD_PERFORMED
-# define STATUS_NO_YIELD_PERFORMED ((NTSTATUS) 0x40000024L)
-#endif
-
-#ifndef STATUS_TIMER_RESUME_IGNORED
-# define STATUS_TIMER_RESUME_IGNORED ((NTSTATUS) 0x40000025L)
-#endif
-
-#ifndef STATUS_ARBITRATION_UNHANDLED
-# define STATUS_ARBITRATION_UNHANDLED ((NTSTATUS) 0x40000026L)
-#endif
-
-#ifndef STATUS_CARDBUS_NOT_SUPPORTED
-# define STATUS_CARDBUS_NOT_SUPPORTED ((NTSTATUS) 0x40000027L)
-#endif
-
-#ifndef STATUS_WX86_CREATEWX86TIB
-# define STATUS_WX86_CREATEWX86TIB ((NTSTATUS) 0x40000028L)
-#endif
-
-#ifndef STATUS_MP_PROCESSOR_MISMATCH
-# define STATUS_MP_PROCESSOR_MISMATCH ((NTSTATUS) 0x40000029L)
-#endif
-
-#ifndef STATUS_HIBERNATED
-# define STATUS_HIBERNATED ((NTSTATUS) 0x4000002AL)
-#endif
-
-#ifndef STATUS_RESUME_HIBERNATION
-# define STATUS_RESUME_HIBERNATION ((NTSTATUS) 0x4000002BL)
-#endif
-
-#ifndef STATUS_FIRMWARE_UPDATED
-# define STATUS_FIRMWARE_UPDATED ((NTSTATUS) 0x4000002CL)
-#endif
-
-#ifndef STATUS_DRIVERS_LEAKING_LOCKED_PAGES
-# define STATUS_DRIVERS_LEAKING_LOCKED_PAGES ((NTSTATUS) 0x4000002DL)
-#endif
-
-#ifndef STATUS_MESSAGE_RETRIEVED
-# define STATUS_MESSAGE_RETRIEVED ((NTSTATUS) 0x4000002EL)
-#endif
-
-#ifndef STATUS_SYSTEM_POWERSTATE_TRANSITION
-# define STATUS_SYSTEM_POWERSTATE_TRANSITION ((NTSTATUS) 0x4000002FL)
-#endif
-
-#ifndef STATUS_ALPC_CHECK_COMPLETION_LIST
-# define STATUS_ALPC_CHECK_COMPLETION_LIST ((NTSTATUS) 0x40000030L)
-#endif
-
-#ifndef STATUS_SYSTEM_POWERSTATE_COMPLEX_TRANSITION
-# define STATUS_SYSTEM_POWERSTATE_COMPLEX_TRANSITION ((NTSTATUS) 0x40000031L)
-#endif
-
-#ifndef STATUS_ACCESS_AUDIT_BY_POLICY
-# define STATUS_ACCESS_AUDIT_BY_POLICY ((NTSTATUS) 0x40000032L)
-#endif
-
-#ifndef STATUS_ABANDON_HIBERFILE
-# define STATUS_ABANDON_HIBERFILE ((NTSTATUS) 0x40000033L)
-#endif
-
-#ifndef STATUS_BIZRULES_NOT_ENABLED
-# define STATUS_BIZRULES_NOT_ENABLED ((NTSTATUS) 0x40000034L)
-#endif
-
-#ifndef STATUS_GUARD_PAGE_VIOLATION
-# define STATUS_GUARD_PAGE_VIOLATION ((NTSTATUS) 0x80000001L)
-#endif
-
-#ifndef STATUS_DATATYPE_MISALIGNMENT
-# define STATUS_DATATYPE_MISALIGNMENT ((NTSTATUS) 0x80000002L)
-#endif
-
-#ifndef STATUS_BREAKPOINT
-# define STATUS_BREAKPOINT ((NTSTATUS) 0x80000003L)
-#endif
-
-#ifndef STATUS_SINGLE_STEP
-# define STATUS_SINGLE_STEP ((NTSTATUS) 0x80000004L)
-#endif
-
-#ifndef STATUS_BUFFER_OVERFLOW
-# define STATUS_BUFFER_OVERFLOW ((NTSTATUS) 0x80000005L)
-#endif
-
-#ifndef STATUS_NO_MORE_FILES
-# define STATUS_NO_MORE_FILES ((NTSTATUS) 0x80000006L)
-#endif
-
-#ifndef STATUS_WAKE_SYSTEM_DEBUGGER
-# define STATUS_WAKE_SYSTEM_DEBUGGER ((NTSTATUS) 0x80000007L)
-#endif
-
-#ifndef STATUS_HANDLES_CLOSED
-# define STATUS_HANDLES_CLOSED ((NTSTATUS) 0x8000000AL)
-#endif
-
-#ifndef STATUS_NO_INHERITANCE
-# define STATUS_NO_INHERITANCE ((NTSTATUS) 0x8000000BL)
-#endif
-
-#ifndef STATUS_GUID_SUBSTITUTION_MADE
-# define STATUS_GUID_SUBSTITUTION_MADE ((NTSTATUS) 0x8000000CL)
-#endif
-
-#ifndef STATUS_PARTIAL_COPY
-# define STATUS_PARTIAL_COPY ((NTSTATUS) 0x8000000DL)
-#endif
-
-#ifndef STATUS_DEVICE_PAPER_EMPTY
-# define STATUS_DEVICE_PAPER_EMPTY ((NTSTATUS) 0x8000000EL)
-#endif
-
-#ifndef STATUS_DEVICE_POWERED_OFF
-# define STATUS_DEVICE_POWERED_OFF ((NTSTATUS) 0x8000000FL)
-#endif
-
-#ifndef STATUS_DEVICE_OFF_LINE
-# define STATUS_DEVICE_OFF_LINE ((NTSTATUS) 0x80000010L)
-#endif
-
-#ifndef STATUS_DEVICE_BUSY
-# define STATUS_DEVICE_BUSY ((NTSTATUS) 0x80000011L)
-#endif
-
-#ifndef STATUS_NO_MORE_EAS
-# define STATUS_NO_MORE_EAS ((NTSTATUS) 0x80000012L)
-#endif
-
-#ifndef STATUS_INVALID_EA_NAME
-# define STATUS_INVALID_EA_NAME ((NTSTATUS) 0x80000013L)
-#endif
-
-#ifndef STATUS_EA_LIST_INCONSISTENT
-# define STATUS_EA_LIST_INCONSISTENT ((NTSTATUS) 0x80000014L)
-#endif
-
-#ifndef STATUS_INVALID_EA_FLAG
-# define STATUS_INVALID_EA_FLAG ((NTSTATUS) 0x80000015L)
-#endif
-
-#ifndef STATUS_VERIFY_REQUIRED
-# define STATUS_VERIFY_REQUIRED ((NTSTATUS) 0x80000016L)
-#endif
-
-#ifndef STATUS_EXTRANEOUS_INFORMATION
-# define STATUS_EXTRANEOUS_INFORMATION ((NTSTATUS) 0x80000017L)
-#endif
-
-#ifndef STATUS_RXACT_COMMIT_NECESSARY
-# define STATUS_RXACT_COMMIT_NECESSARY ((NTSTATUS) 0x80000018L)
-#endif
-
-#ifndef STATUS_NO_MORE_ENTRIES
-# define STATUS_NO_MORE_ENTRIES ((NTSTATUS) 0x8000001AL)
-#endif
-
-#ifndef STATUS_FILEMARK_DETECTED
-# define STATUS_FILEMARK_DETECTED ((NTSTATUS) 0x8000001BL)
-#endif
-
-#ifndef STATUS_MEDIA_CHANGED
-# define STATUS_MEDIA_CHANGED ((NTSTATUS) 0x8000001CL)
-#endif
-
-#ifndef STATUS_BUS_RESET
-# define STATUS_BUS_RESET ((NTSTATUS) 0x8000001DL)
-#endif
-
-#ifndef STATUS_END_OF_MEDIA
-# define STATUS_END_OF_MEDIA ((NTSTATUS) 0x8000001EL)
-#endif
-
-#ifndef STATUS_BEGINNING_OF_MEDIA
-# define STATUS_BEGINNING_OF_MEDIA ((NTSTATUS) 0x8000001FL)
-#endif
-
-#ifndef STATUS_MEDIA_CHECK
-# define STATUS_MEDIA_CHECK ((NTSTATUS) 0x80000020L)
-#endif
-
-#ifndef STATUS_SETMARK_DETECTED
-# define STATUS_SETMARK_DETECTED ((NTSTATUS) 0x80000021L)
-#endif
-
-#ifndef STATUS_NO_DATA_DETECTED
-# define STATUS_NO_DATA_DETECTED ((NTSTATUS) 0x80000022L)
-#endif
-
-#ifndef STATUS_REDIRECTOR_HAS_OPEN_HANDLES
-# define STATUS_REDIRECTOR_HAS_OPEN_HANDLES ((NTSTATUS) 0x80000023L)
-#endif
-
-#ifndef STATUS_SERVER_HAS_OPEN_HANDLES
-# define STATUS_SERVER_HAS_OPEN_HANDLES ((NTSTATUS) 0x80000024L)
-#endif
-
-#ifndef STATUS_ALREADY_DISCONNECTED
-# define STATUS_ALREADY_DISCONNECTED ((NTSTATUS) 0x80000025L)
-#endif
-
-#ifndef STATUS_LONGJUMP
-# define STATUS_LONGJUMP ((NTSTATUS) 0x80000026L)
-#endif
-
-#ifndef STATUS_CLEANER_CARTRIDGE_INSTALLED
-# define STATUS_CLEANER_CARTRIDGE_INSTALLED ((NTSTATUS) 0x80000027L)
-#endif
-
-#ifndef STATUS_PLUGPLAY_QUERY_VETOED
-# define STATUS_PLUGPLAY_QUERY_VETOED ((NTSTATUS) 0x80000028L)
-#endif
-
-#ifndef STATUS_UNWIND_CONSOLIDATE
-# define STATUS_UNWIND_CONSOLIDATE ((NTSTATUS) 0x80000029L)
-#endif
-
-#ifndef STATUS_REGISTRY_HIVE_RECOVERED
-# define STATUS_REGISTRY_HIVE_RECOVERED ((NTSTATUS) 0x8000002AL)
-#endif
-
-#ifndef STATUS_DLL_MIGHT_BE_INSECURE
-# define STATUS_DLL_MIGHT_BE_INSECURE ((NTSTATUS) 0x8000002BL)
-#endif
-
-#ifndef STATUS_DLL_MIGHT_BE_INCOMPATIBLE
-# define STATUS_DLL_MIGHT_BE_INCOMPATIBLE ((NTSTATUS) 0x8000002CL)
-#endif
-
-#ifndef STATUS_STOPPED_ON_SYMLINK
-# define STATUS_STOPPED_ON_SYMLINK ((NTSTATUS) 0x8000002DL)
-#endif
-
-#ifndef STATUS_CANNOT_GRANT_REQUESTED_OPLOCK
-# define STATUS_CANNOT_GRANT_REQUESTED_OPLOCK ((NTSTATUS) 0x8000002EL)
-#endif
-
-#ifndef STATUS_NO_ACE_CONDITION
-# define STATUS_NO_ACE_CONDITION ((NTSTATUS) 0x8000002FL)
-#endif
-
-#ifndef STATUS_UNSUCCESSFUL
-# define STATUS_UNSUCCESSFUL ((NTSTATUS) 0xC0000001L)
-#endif
-
-#ifndef STATUS_NOT_IMPLEMENTED
-# define STATUS_NOT_IMPLEMENTED ((NTSTATUS) 0xC0000002L)
-#endif
-
-#ifndef STATUS_INVALID_INFO_CLASS
-# define STATUS_INVALID_INFO_CLASS ((NTSTATUS) 0xC0000003L)
-#endif
-
-#ifndef STATUS_INFO_LENGTH_MISMATCH
-# define STATUS_INFO_LENGTH_MISMATCH ((NTSTATUS) 0xC0000004L)
-#endif
-
-#ifndef STATUS_ACCESS_VIOLATION
-# define STATUS_ACCESS_VIOLATION ((NTSTATUS) 0xC0000005L)
-#endif
-
-#ifndef STATUS_IN_PAGE_ERROR
-# define STATUS_IN_PAGE_ERROR ((NTSTATUS) 0xC0000006L)
-#endif
-
-#ifndef STATUS_PAGEFILE_QUOTA
-# define STATUS_PAGEFILE_QUOTA ((NTSTATUS) 0xC0000007L)
-#endif
-
-#ifndef STATUS_INVALID_HANDLE
-# define STATUS_INVALID_HANDLE ((NTSTATUS) 0xC0000008L)
-#endif
-
-#ifndef STATUS_BAD_INITIAL_STACK
-# define STATUS_BAD_INITIAL_STACK ((NTSTATUS) 0xC0000009L)
-#endif
-
-#ifndef STATUS_BAD_INITIAL_PC
-# define STATUS_BAD_INITIAL_PC ((NTSTATUS) 0xC000000AL)
-#endif
-
-#ifndef STATUS_INVALID_CID
-# define STATUS_INVALID_CID ((NTSTATUS) 0xC000000BL)
-#endif
-
-#ifndef STATUS_TIMER_NOT_CANCELED
-# define STATUS_TIMER_NOT_CANCELED ((NTSTATUS) 0xC000000CL)
-#endif
-
-#ifndef STATUS_INVALID_PARAMETER
-# define STATUS_INVALID_PARAMETER ((NTSTATUS) 0xC000000DL)
-#endif
-
-#ifndef STATUS_NO_SUCH_DEVICE
-# define STATUS_NO_SUCH_DEVICE ((NTSTATUS) 0xC000000EL)
-#endif
-
-#ifndef STATUS_NO_SUCH_FILE
-# define STATUS_NO_SUCH_FILE ((NTSTATUS) 0xC000000FL)
-#endif
-
-#ifndef STATUS_INVALID_DEVICE_REQUEST
-# define STATUS_INVALID_DEVICE_REQUEST ((NTSTATUS) 0xC0000010L)
-#endif
-
-#ifndef STATUS_END_OF_FILE
-# define STATUS_END_OF_FILE ((NTSTATUS) 0xC0000011L)
-#endif
-
-#ifndef STATUS_WRONG_VOLUME
-# define STATUS_WRONG_VOLUME ((NTSTATUS) 0xC0000012L)
-#endif
-
-#ifndef STATUS_NO_MEDIA_IN_DEVICE
-# define STATUS_NO_MEDIA_IN_DEVICE ((NTSTATUS) 0xC0000013L)
-#endif
-
-#ifndef STATUS_UNRECOGNIZED_MEDIA
-# define STATUS_UNRECOGNIZED_MEDIA ((NTSTATUS) 0xC0000014L)
-#endif
-
-#ifndef STATUS_NONEXISTENT_SECTOR
-# define STATUS_NONEXISTENT_SECTOR ((NTSTATUS) 0xC0000015L)
-#endif
-
-#ifndef STATUS_MORE_PROCESSING_REQUIRED
-# define STATUS_MORE_PROCESSING_REQUIRED ((NTSTATUS) 0xC0000016L)
-#endif
-
-#ifndef STATUS_NO_MEMORY
-# define STATUS_NO_MEMORY ((NTSTATUS) 0xC0000017L)
-#endif
-
-#ifndef STATUS_CONFLICTING_ADDRESSES
-# define STATUS_CONFLICTING_ADDRESSES ((NTSTATUS) 0xC0000018L)
-#endif
-
-#ifndef STATUS_NOT_MAPPED_VIEW
-# define STATUS_NOT_MAPPED_VIEW ((NTSTATUS) 0xC0000019L)
-#endif
-
-#ifndef STATUS_UNABLE_TO_FREE_VM
-# define STATUS_UNABLE_TO_FREE_VM ((NTSTATUS) 0xC000001AL)
-#endif
-
-#ifndef STATUS_UNABLE_TO_DELETE_SECTION
-# define STATUS_UNABLE_TO_DELETE_SECTION ((NTSTATUS) 0xC000001BL)
-#endif
-
-#ifndef STATUS_INVALID_SYSTEM_SERVICE
-# define STATUS_INVALID_SYSTEM_SERVICE ((NTSTATUS) 0xC000001CL)
-#endif
-
-#ifndef STATUS_ILLEGAL_INSTRUCTION
-# define STATUS_ILLEGAL_INSTRUCTION ((NTSTATUS) 0xC000001DL)
-#endif
-
-#ifndef STATUS_INVALID_LOCK_SEQUENCE
-# define STATUS_INVALID_LOCK_SEQUENCE ((NTSTATUS) 0xC000001EL)
-#endif
-
-#ifndef STATUS_INVALID_VIEW_SIZE
-# define STATUS_INVALID_VIEW_SIZE ((NTSTATUS) 0xC000001FL)
-#endif
-
-#ifndef STATUS_INVALID_FILE_FOR_SECTION
-# define STATUS_INVALID_FILE_FOR_SECTION ((NTSTATUS) 0xC0000020L)
-#endif
-
-#ifndef STATUS_ALREADY_COMMITTED
-# define STATUS_ALREADY_COMMITTED ((NTSTATUS) 0xC0000021L)
-#endif
-
-#ifndef STATUS_ACCESS_DENIED
-# define STATUS_ACCESS_DENIED ((NTSTATUS) 0xC0000022L)
-#endif
-
-#ifndef STATUS_BUFFER_TOO_SMALL
-# define STATUS_BUFFER_TOO_SMALL ((NTSTATUS) 0xC0000023L)
-#endif
-
-#ifndef STATUS_OBJECT_TYPE_MISMATCH
-# define STATUS_OBJECT_TYPE_MISMATCH ((NTSTATUS) 0xC0000024L)
-#endif
-
-#ifndef STATUS_NONCONTINUABLE_EXCEPTION
-# define STATUS_NONCONTINUABLE_EXCEPTION ((NTSTATUS) 0xC0000025L)
-#endif
-
-#ifndef STATUS_INVALID_DISPOSITION
-# define STATUS_INVALID_DISPOSITION ((NTSTATUS) 0xC0000026L)
-#endif
-
-#ifndef STATUS_UNWIND
-# define STATUS_UNWIND ((NTSTATUS) 0xC0000027L)
-#endif
-
-#ifndef STATUS_BAD_STACK
-# define STATUS_BAD_STACK ((NTSTATUS) 0xC0000028L)
-#endif
-
-#ifndef STATUS_INVALID_UNWIND_TARGET
-# define STATUS_INVALID_UNWIND_TARGET ((NTSTATUS) 0xC0000029L)
-#endif
-
-#ifndef STATUS_NOT_LOCKED
-# define STATUS_NOT_LOCKED ((NTSTATUS) 0xC000002AL)
-#endif
-
-#ifndef STATUS_PARITY_ERROR
-# define STATUS_PARITY_ERROR ((NTSTATUS) 0xC000002BL)
-#endif
-
-#ifndef STATUS_UNABLE_TO_DECOMMIT_VM
-# define STATUS_UNABLE_TO_DECOMMIT_VM ((NTSTATUS) 0xC000002CL)
-#endif
-
-#ifndef STATUS_NOT_COMMITTED
-# define STATUS_NOT_COMMITTED ((NTSTATUS) 0xC000002DL)
-#endif
-
-#ifndef STATUS_INVALID_PORT_ATTRIBUTES
-# define STATUS_INVALID_PORT_ATTRIBUTES ((NTSTATUS) 0xC000002EL)
-#endif
-
-#ifndef STATUS_PORT_MESSAGE_TOO_LONG
-# define STATUS_PORT_MESSAGE_TOO_LONG ((NTSTATUS) 0xC000002FL)
-#endif
-
-#ifndef STATUS_INVALID_PARAMETER_MIX
-# define STATUS_INVALID_PARAMETER_MIX ((NTSTATUS) 0xC0000030L)
-#endif
-
-#ifndef STATUS_INVALID_QUOTA_LOWER
-# define STATUS_INVALID_QUOTA_LOWER ((NTSTATUS) 0xC0000031L)
-#endif
-
-#ifndef STATUS_DISK_CORRUPT_ERROR
-# define STATUS_DISK_CORRUPT_ERROR ((NTSTATUS) 0xC0000032L)
-#endif
-
-#ifndef STATUS_OBJECT_NAME_INVALID
-# define STATUS_OBJECT_NAME_INVALID ((NTSTATUS) 0xC0000033L)
-#endif
-
-#ifndef STATUS_OBJECT_NAME_NOT_FOUND
-# define STATUS_OBJECT_NAME_NOT_FOUND ((NTSTATUS) 0xC0000034L)
-#endif
-
-#ifndef STATUS_OBJECT_NAME_COLLISION
-# define STATUS_OBJECT_NAME_COLLISION ((NTSTATUS) 0xC0000035L)
-#endif
-
-#ifndef STATUS_PORT_DISCONNECTED
-# define STATUS_PORT_DISCONNECTED ((NTSTATUS) 0xC0000037L)
-#endif
-
-#ifndef STATUS_DEVICE_ALREADY_ATTACHED
-# define STATUS_DEVICE_ALREADY_ATTACHED ((NTSTATUS) 0xC0000038L)
-#endif
-
-#ifndef STATUS_OBJECT_PATH_INVALID
-# define STATUS_OBJECT_PATH_INVALID ((NTSTATUS) 0xC0000039L)
-#endif
-
-#ifndef STATUS_OBJECT_PATH_NOT_FOUND
-# define STATUS_OBJECT_PATH_NOT_FOUND ((NTSTATUS) 0xC000003AL)
-#endif
-
-#ifndef STATUS_OBJECT_PATH_SYNTAX_BAD
-# define STATUS_OBJECT_PATH_SYNTAX_BAD ((NTSTATUS) 0xC000003BL)
-#endif
-
-#ifndef STATUS_DATA_OVERRUN
-# define STATUS_DATA_OVERRUN ((NTSTATUS) 0xC000003CL)
-#endif
-
-#ifndef STATUS_DATA_LATE_ERROR
-# define STATUS_DATA_LATE_ERROR ((NTSTATUS) 0xC000003DL)
-#endif
-
-#ifndef STATUS_DATA_ERROR
-# define STATUS_DATA_ERROR ((NTSTATUS) 0xC000003EL)
-#endif
-
-#ifndef STATUS_CRC_ERROR
-# define STATUS_CRC_ERROR ((NTSTATUS) 0xC000003FL)
-#endif
-
-#ifndef STATUS_SECTION_TOO_BIG
-# define STATUS_SECTION_TOO_BIG ((NTSTATUS) 0xC0000040L)
-#endif
-
-#ifndef STATUS_PORT_CONNECTION_REFUSED
-# define STATUS_PORT_CONNECTION_REFUSED ((NTSTATUS) 0xC0000041L)
-#endif
-
-#ifndef STATUS_INVALID_PORT_HANDLE
-# define STATUS_INVALID_PORT_HANDLE ((NTSTATUS) 0xC0000042L)
-#endif
-
-#ifndef STATUS_SHARING_VIOLATION
-# define STATUS_SHARING_VIOLATION ((NTSTATUS) 0xC0000043L)
-#endif
-
-#ifndef STATUS_QUOTA_EXCEEDED
-# define STATUS_QUOTA_EXCEEDED ((NTSTATUS) 0xC0000044L)
-#endif
-
-#ifndef STATUS_INVALID_PAGE_PROTECTION
-# define STATUS_INVALID_PAGE_PROTECTION ((NTSTATUS) 0xC0000045L)
-#endif
-
-#ifndef STATUS_MUTANT_NOT_OWNED
-# define STATUS_MUTANT_NOT_OWNED ((NTSTATUS) 0xC0000046L)
-#endif
-
-#ifndef STATUS_SEMAPHORE_LIMIT_EXCEEDED
-# define STATUS_SEMAPHORE_LIMIT_EXCEEDED ((NTSTATUS) 0xC0000047L)
-#endif
-
-#ifndef STATUS_PORT_ALREADY_SET
-# define STATUS_PORT_ALREADY_SET ((NTSTATUS) 0xC0000048L)
-#endif
-
-#ifndef STATUS_SECTION_NOT_IMAGE
-# define STATUS_SECTION_NOT_IMAGE ((NTSTATUS) 0xC0000049L)
-#endif
-
-#ifndef STATUS_SUSPEND_COUNT_EXCEEDED
-# define STATUS_SUSPEND_COUNT_EXCEEDED ((NTSTATUS) 0xC000004AL)
-#endif
-
-#ifndef STATUS_THREAD_IS_TERMINATING
-# define STATUS_THREAD_IS_TERMINATING ((NTSTATUS) 0xC000004BL)
-#endif
-
-#ifndef STATUS_BAD_WORKING_SET_LIMIT
-# define STATUS_BAD_WORKING_SET_LIMIT ((NTSTATUS) 0xC000004CL)
-#endif
-
-#ifndef STATUS_INCOMPATIBLE_FILE_MAP
-# define STATUS_INCOMPATIBLE_FILE_MAP ((NTSTATUS) 0xC000004DL)
-#endif
-
-#ifndef STATUS_SECTION_PROTECTION
-# define STATUS_SECTION_PROTECTION ((NTSTATUS) 0xC000004EL)
-#endif
-
-#ifndef STATUS_EAS_NOT_SUPPORTED
-# define STATUS_EAS_NOT_SUPPORTED ((NTSTATUS) 0xC000004FL)
-#endif
-
-#ifndef STATUS_EA_TOO_LARGE
-# define STATUS_EA_TOO_LARGE ((NTSTATUS) 0xC0000050L)
-#endif
-
-#ifndef STATUS_NONEXISTENT_EA_ENTRY
-# define STATUS_NONEXISTENT_EA_ENTRY ((NTSTATUS) 0xC0000051L)
-#endif
-
-#ifndef STATUS_NO_EAS_ON_FILE
-# define STATUS_NO_EAS_ON_FILE ((NTSTATUS) 0xC0000052L)
-#endif
-
-#ifndef STATUS_EA_CORRUPT_ERROR
-# define STATUS_EA_CORRUPT_ERROR ((NTSTATUS) 0xC0000053L)
-#endif
-
-#ifndef STATUS_FILE_LOCK_CONFLICT
-# define STATUS_FILE_LOCK_CONFLICT ((NTSTATUS) 0xC0000054L)
-#endif
-
-#ifndef STATUS_LOCK_NOT_GRANTED
-# define STATUS_LOCK_NOT_GRANTED ((NTSTATUS) 0xC0000055L)
-#endif
-
-#ifndef STATUS_DELETE_PENDING
-# define STATUS_DELETE_PENDING ((NTSTATUS) 0xC0000056L)
-#endif
-
-#ifndef STATUS_CTL_FILE_NOT_SUPPORTED
-# define STATUS_CTL_FILE_NOT_SUPPORTED ((NTSTATUS) 0xC0000057L)
-#endif
-
-#ifndef STATUS_UNKNOWN_REVISION
-# define STATUS_UNKNOWN_REVISION ((NTSTATUS) 0xC0000058L)
-#endif
-
-#ifndef STATUS_REVISION_MISMATCH
-# define STATUS_REVISION_MISMATCH ((NTSTATUS) 0xC0000059L)
-#endif
-
-#ifndef STATUS_INVALID_OWNER
-# define STATUS_INVALID_OWNER ((NTSTATUS) 0xC000005AL)
-#endif
-
-#ifndef STATUS_INVALID_PRIMARY_GROUP
-# define STATUS_INVALID_PRIMARY_GROUP ((NTSTATUS) 0xC000005BL)
-#endif
-
-#ifndef STATUS_NO_IMPERSONATION_TOKEN
-# define STATUS_NO_IMPERSONATION_TOKEN ((NTSTATUS) 0xC000005CL)
-#endif
-
-#ifndef STATUS_CANT_DISABLE_MANDATORY
-# define STATUS_CANT_DISABLE_MANDATORY ((NTSTATUS) 0xC000005DL)
-#endif
-
-#ifndef STATUS_NO_LOGON_SERVERS
-# define STATUS_NO_LOGON_SERVERS ((NTSTATUS) 0xC000005EL)
-#endif
-
-#ifndef STATUS_NO_SUCH_LOGON_SESSION
-# define STATUS_NO_SUCH_LOGON_SESSION ((NTSTATUS) 0xC000005FL)
-#endif
-
-#ifndef STATUS_NO_SUCH_PRIVILEGE
-# define STATUS_NO_SUCH_PRIVILEGE ((NTSTATUS) 0xC0000060L)
-#endif
-
-#ifndef STATUS_PRIVILEGE_NOT_HELD
-# define STATUS_PRIVILEGE_NOT_HELD ((NTSTATUS) 0xC0000061L)
-#endif
-
-#ifndef STATUS_INVALID_ACCOUNT_NAME
-# define STATUS_INVALID_ACCOUNT_NAME ((NTSTATUS) 0xC0000062L)
-#endif
-
-#ifndef STATUS_USER_EXISTS
-# define STATUS_USER_EXISTS ((NTSTATUS) 0xC0000063L)
-#endif
-
-#ifndef STATUS_NO_SUCH_USER
-# define STATUS_NO_SUCH_USER ((NTSTATUS) 0xC0000064L)
-#endif
-
-#ifndef STATUS_GROUP_EXISTS
-# define STATUS_GROUP_EXISTS ((NTSTATUS) 0xC0000065L)
-#endif
-
-#ifndef STATUS_NO_SUCH_GROUP
-# define STATUS_NO_SUCH_GROUP ((NTSTATUS) 0xC0000066L)
-#endif
-
-#ifndef STATUS_MEMBER_IN_GROUP
-# define STATUS_MEMBER_IN_GROUP ((NTSTATUS) 0xC0000067L)
-#endif
-
-#ifndef STATUS_MEMBER_NOT_IN_GROUP
-# define STATUS_MEMBER_NOT_IN_GROUP ((NTSTATUS) 0xC0000068L)
-#endif
-
-#ifndef STATUS_LAST_ADMIN
-# define STATUS_LAST_ADMIN ((NTSTATUS) 0xC0000069L)
-#endif
-
-#ifndef STATUS_WRONG_PASSWORD
-# define STATUS_WRONG_PASSWORD ((NTSTATUS) 0xC000006AL)
-#endif
-
-#ifndef STATUS_ILL_FORMED_PASSWORD
-# define STATUS_ILL_FORMED_PASSWORD ((NTSTATUS) 0xC000006BL)
-#endif
-
-#ifndef STATUS_PASSWORD_RESTRICTION
-# define STATUS_PASSWORD_RESTRICTION ((NTSTATUS) 0xC000006CL)
-#endif
-
-#ifndef STATUS_LOGON_FAILURE
-# define STATUS_LOGON_FAILURE ((NTSTATUS) 0xC000006DL)
-#endif
-
-#ifndef STATUS_ACCOUNT_RESTRICTION
-# define STATUS_ACCOUNT_RESTRICTION ((NTSTATUS) 0xC000006EL)
-#endif
-
-#ifndef STATUS_INVALID_LOGON_HOURS
-# define STATUS_INVALID_LOGON_HOURS ((NTSTATUS) 0xC000006FL)
-#endif
-
-#ifndef STATUS_INVALID_WORKSTATION
-# define STATUS_INVALID_WORKSTATION ((NTSTATUS) 0xC0000070L)
-#endif
-
-#ifndef STATUS_PASSWORD_EXPIRED
-# define STATUS_PASSWORD_EXPIRED ((NTSTATUS) 0xC0000071L)
-#endif
-
-#ifndef STATUS_ACCOUNT_DISABLED
-# define STATUS_ACCOUNT_DISABLED ((NTSTATUS) 0xC0000072L)
-#endif
-
-#ifndef STATUS_NONE_MAPPED
-# define STATUS_NONE_MAPPED ((NTSTATUS) 0xC0000073L)
-#endif
-
-#ifndef STATUS_TOO_MANY_LUIDS_REQUESTED
-# define STATUS_TOO_MANY_LUIDS_REQUESTED ((NTSTATUS) 0xC0000074L)
-#endif
-
-#ifndef STATUS_LUIDS_EXHAUSTED
-# define STATUS_LUIDS_EXHAUSTED ((NTSTATUS) 0xC0000075L)
-#endif
-
-#ifndef STATUS_INVALID_SUB_AUTHORITY
-# define STATUS_INVALID_SUB_AUTHORITY ((NTSTATUS) 0xC0000076L)
-#endif
-
-#ifndef STATUS_INVALID_ACL
-# define STATUS_INVALID_ACL ((NTSTATUS) 0xC0000077L)
-#endif
-
-#ifndef STATUS_INVALID_SID
-# define STATUS_INVALID_SID ((NTSTATUS) 0xC0000078L)
-#endif
-
-#ifndef STATUS_INVALID_SECURITY_DESCR
-# define STATUS_INVALID_SECURITY_DESCR ((NTSTATUS) 0xC0000079L)
-#endif
-
-#ifndef STATUS_PROCEDURE_NOT_FOUND
-# define STATUS_PROCEDURE_NOT_FOUND ((NTSTATUS) 0xC000007AL)
-#endif
-
-#ifndef STATUS_INVALID_IMAGE_FORMAT
-# define STATUS_INVALID_IMAGE_FORMAT ((NTSTATUS) 0xC000007BL)
-#endif
-
-#ifndef STATUS_NO_TOKEN
-# define STATUS_NO_TOKEN ((NTSTATUS) 0xC000007CL)
-#endif
-
-#ifndef STATUS_BAD_INHERITANCE_ACL
-# define STATUS_BAD_INHERITANCE_ACL ((NTSTATUS) 0xC000007DL)
-#endif
-
-#ifndef STATUS_RANGE_NOT_LOCKED
-# define STATUS_RANGE_NOT_LOCKED ((NTSTATUS) 0xC000007EL)
-#endif
-
-#ifndef STATUS_DISK_FULL
-# define STATUS_DISK_FULL ((NTSTATUS) 0xC000007FL)
-#endif
-
-#ifndef STATUS_SERVER_DISABLED
-# define STATUS_SERVER_DISABLED ((NTSTATUS) 0xC0000080L)
-#endif
-
-#ifndef STATUS_SERVER_NOT_DISABLED
-# define STATUS_SERVER_NOT_DISABLED ((NTSTATUS) 0xC0000081L)
-#endif
-
-#ifndef STATUS_TOO_MANY_GUIDS_REQUESTED
-# define STATUS_TOO_MANY_GUIDS_REQUESTED ((NTSTATUS) 0xC0000082L)
-#endif
-
-#ifndef STATUS_GUIDS_EXHAUSTED
-# define STATUS_GUIDS_EXHAUSTED ((NTSTATUS) 0xC0000083L)
-#endif
-
-#ifndef STATUS_INVALID_ID_AUTHORITY
-# define STATUS_INVALID_ID_AUTHORITY ((NTSTATUS) 0xC0000084L)
-#endif
-
-#ifndef STATUS_AGENTS_EXHAUSTED
-# define STATUS_AGENTS_EXHAUSTED ((NTSTATUS) 0xC0000085L)
-#endif
-
-#ifndef STATUS_INVALID_VOLUME_LABEL
-# define STATUS_INVALID_VOLUME_LABEL ((NTSTATUS) 0xC0000086L)
-#endif
-
-#ifndef STATUS_SECTION_NOT_EXTENDED
-# define STATUS_SECTION_NOT_EXTENDED ((NTSTATUS) 0xC0000087L)
-#endif
-
-#ifndef STATUS_NOT_MAPPED_DATA
-# define STATUS_NOT_MAPPED_DATA ((NTSTATUS) 0xC0000088L)
-#endif
-
-#ifndef STATUS_RESOURCE_DATA_NOT_FOUND
-# define STATUS_RESOURCE_DATA_NOT_FOUND ((NTSTATUS) 0xC0000089L)
-#endif
-
-#ifndef STATUS_RESOURCE_TYPE_NOT_FOUND
-# define STATUS_RESOURCE_TYPE_NOT_FOUND ((NTSTATUS) 0xC000008AL)
-#endif
-
-#ifndef STATUS_RESOURCE_NAME_NOT_FOUND
-# define STATUS_RESOURCE_NAME_NOT_FOUND ((NTSTATUS) 0xC000008BL)
-#endif
-
-#ifndef STATUS_ARRAY_BOUNDS_EXCEEDED
-# define STATUS_ARRAY_BOUNDS_EXCEEDED ((NTSTATUS) 0xC000008CL)
-#endif
-
-#ifndef STATUS_FLOAT_DENORMAL_OPERAND
-# define STATUS_FLOAT_DENORMAL_OPERAND ((NTSTATUS) 0xC000008DL)
-#endif
-
-#ifndef STATUS_FLOAT_DIVIDE_BY_ZERO
-# define STATUS_FLOAT_DIVIDE_BY_ZERO ((NTSTATUS) 0xC000008EL)
-#endif
-
-#ifndef STATUS_FLOAT_INEXACT_RESULT
-# define STATUS_FLOAT_INEXACT_RESULT ((NTSTATUS) 0xC000008FL)
-#endif
-
-#ifndef STATUS_FLOAT_INVALID_OPERATION
-# define STATUS_FLOAT_INVALID_OPERATION ((NTSTATUS) 0xC0000090L)
-#endif
-
-#ifndef STATUS_FLOAT_OVERFLOW
-# define STATUS_FLOAT_OVERFLOW ((NTSTATUS) 0xC0000091L)
-#endif
-
-#ifndef STATUS_FLOAT_STACK_CHECK
-# define STATUS_FLOAT_STACK_CHECK ((NTSTATUS) 0xC0000092L)
-#endif
-
-#ifndef STATUS_FLOAT_UNDERFLOW
-# define STATUS_FLOAT_UNDERFLOW ((NTSTATUS) 0xC0000093L)
-#endif
-
-#ifndef STATUS_INTEGER_DIVIDE_BY_ZERO
-# define STATUS_INTEGER_DIVIDE_BY_ZERO ((NTSTATUS) 0xC0000094L)
-#endif
-
-#ifndef STATUS_INTEGER_OVERFLOW
-# define STATUS_INTEGER_OVERFLOW ((NTSTATUS) 0xC0000095L)
-#endif
-
-#ifndef STATUS_PRIVILEGED_INSTRUCTION
-# define STATUS_PRIVILEGED_INSTRUCTION ((NTSTATUS) 0xC0000096L)
-#endif
-
-#ifndef STATUS_TOO_MANY_PAGING_FILES
-# define STATUS_TOO_MANY_PAGING_FILES ((NTSTATUS) 0xC0000097L)
-#endif
-
-#ifndef STATUS_FILE_INVALID
-# define STATUS_FILE_INVALID ((NTSTATUS) 0xC0000098L)
-#endif
-
-#ifndef STATUS_ALLOTTED_SPACE_EXCEEDED
-# define STATUS_ALLOTTED_SPACE_EXCEEDED ((NTSTATUS) 0xC0000099L)
-#endif
-
-#ifndef STATUS_INSUFFICIENT_RESOURCES
-# define STATUS_INSUFFICIENT_RESOURCES ((NTSTATUS) 0xC000009AL)
-#endif
-
-#ifndef STATUS_DFS_EXIT_PATH_FOUND
-# define STATUS_DFS_EXIT_PATH_FOUND ((NTSTATUS) 0xC000009BL)
-#endif
-
-#ifndef STATUS_DEVICE_DATA_ERROR
-# define STATUS_DEVICE_DATA_ERROR ((NTSTATUS) 0xC000009CL)
-#endif
-
-#ifndef STATUS_DEVICE_NOT_CONNECTED
-# define STATUS_DEVICE_NOT_CONNECTED ((NTSTATUS) 0xC000009DL)
-#endif
-
-#ifndef STATUS_DEVICE_POWER_FAILURE
-# define STATUS_DEVICE_POWER_FAILURE ((NTSTATUS) 0xC000009EL)
-#endif
-
-#ifndef STATUS_FREE_VM_NOT_AT_BASE
-# define STATUS_FREE_VM_NOT_AT_BASE ((NTSTATUS) 0xC000009FL)
-#endif
-
-#ifndef STATUS_MEMORY_NOT_ALLOCATED
-# define STATUS_MEMORY_NOT_ALLOCATED ((NTSTATUS) 0xC00000A0L)
-#endif
-
-#ifndef STATUS_WORKING_SET_QUOTA
-# define STATUS_WORKING_SET_QUOTA ((NTSTATUS) 0xC00000A1L)
-#endif
-
-#ifndef STATUS_MEDIA_WRITE_PROTECTED
-# define STATUS_MEDIA_WRITE_PROTECTED ((NTSTATUS) 0xC00000A2L)
-#endif
-
-#ifndef STATUS_DEVICE_NOT_READY
-# define STATUS_DEVICE_NOT_READY ((NTSTATUS) 0xC00000A3L)
-#endif
-
-#ifndef STATUS_INVALID_GROUP_ATTRIBUTES
-# define STATUS_INVALID_GROUP_ATTRIBUTES ((NTSTATUS) 0xC00000A4L)
-#endif
-
-#ifndef STATUS_BAD_IMPERSONATION_LEVEL
-# define STATUS_BAD_IMPERSONATION_LEVEL ((NTSTATUS) 0xC00000A5L)
-#endif
-
-#ifndef STATUS_CANT_OPEN_ANONYMOUS
-# define STATUS_CANT_OPEN_ANONYMOUS ((NTSTATUS) 0xC00000A6L)
-#endif
-
-#ifndef STATUS_BAD_VALIDATION_CLASS
-# define STATUS_BAD_VALIDATION_CLASS ((NTSTATUS) 0xC00000A7L)
-#endif
-
-#ifndef STATUS_BAD_TOKEN_TYPE
-# define STATUS_BAD_TOKEN_TYPE ((NTSTATUS) 0xC00000A8L)
-#endif
-
-#ifndef STATUS_BAD_MASTER_BOOT_RECORD
-# define STATUS_BAD_MASTER_BOOT_RECORD ((NTSTATUS) 0xC00000A9L)
-#endif
-
-#ifndef STATUS_INSTRUCTION_MISALIGNMENT
-# define STATUS_INSTRUCTION_MISALIGNMENT ((NTSTATUS) 0xC00000AAL)
-#endif
-
-#ifndef STATUS_INSTANCE_NOT_AVAILABLE
-# define STATUS_INSTANCE_NOT_AVAILABLE ((NTSTATUS) 0xC00000ABL)
-#endif
-
-#ifndef STATUS_PIPE_NOT_AVAILABLE
-# define STATUS_PIPE_NOT_AVAILABLE ((NTSTATUS) 0xC00000ACL)
-#endif
-
-#ifndef STATUS_INVALID_PIPE_STATE
-# define STATUS_INVALID_PIPE_STATE ((NTSTATUS) 0xC00000ADL)
-#endif
-
-#ifndef STATUS_PIPE_BUSY
-# define STATUS_PIPE_BUSY ((NTSTATUS) 0xC00000AEL)
-#endif
-
-#ifndef STATUS_ILLEGAL_FUNCTION
-# define STATUS_ILLEGAL_FUNCTION ((NTSTATUS) 0xC00000AFL)
-#endif
-
-#ifndef STATUS_PIPE_DISCONNECTED
-# define STATUS_PIPE_DISCONNECTED ((NTSTATUS) 0xC00000B0L)
-#endif
-
-#ifndef STATUS_PIPE_CLOSING
-# define STATUS_PIPE_CLOSING ((NTSTATUS) 0xC00000B1L)
-#endif
-
-#ifndef STATUS_PIPE_CONNECTED
-# define STATUS_PIPE_CONNECTED ((NTSTATUS) 0xC00000B2L)
-#endif
-
-#ifndef STATUS_PIPE_LISTENING
-# define STATUS_PIPE_LISTENING ((NTSTATUS) 0xC00000B3L)
-#endif
-
-#ifndef STATUS_INVALID_READ_MODE
-# define STATUS_INVALID_READ_MODE ((NTSTATUS) 0xC00000B4L)
-#endif
-
-#ifndef STATUS_IO_TIMEOUT
-# define STATUS_IO_TIMEOUT ((NTSTATUS) 0xC00000B5L)
-#endif
-
-#ifndef STATUS_FILE_FORCED_CLOSED
-# define STATUS_FILE_FORCED_CLOSED ((NTSTATUS) 0xC00000B6L)
-#endif
-
-#ifndef STATUS_PROFILING_NOT_STARTED
-# define STATUS_PROFILING_NOT_STARTED ((NTSTATUS) 0xC00000B7L)
-#endif
-
-#ifndef STATUS_PROFILING_NOT_STOPPED
-# define STATUS_PROFILING_NOT_STOPPED ((NTSTATUS) 0xC00000B8L)
-#endif
-
-#ifndef STATUS_COULD_NOT_INTERPRET
-# define STATUS_COULD_NOT_INTERPRET ((NTSTATUS) 0xC00000B9L)
-#endif
-
-#ifndef STATUS_FILE_IS_A_DIRECTORY
-# define STATUS_FILE_IS_A_DIRECTORY ((NTSTATUS) 0xC00000BAL)
-#endif
-
-#ifndef STATUS_NOT_SUPPORTED
-# define STATUS_NOT_SUPPORTED ((NTSTATUS) 0xC00000BBL)
-#endif
-
-#ifndef STATUS_REMOTE_NOT_LISTENING
-# define STATUS_REMOTE_NOT_LISTENING ((NTSTATUS) 0xC00000BCL)
-#endif
-
-#ifndef STATUS_DUPLICATE_NAME
-# define STATUS_DUPLICATE_NAME ((NTSTATUS) 0xC00000BDL)
-#endif
-
-#ifndef STATUS_BAD_NETWORK_PATH
-# define STATUS_BAD_NETWORK_PATH ((NTSTATUS) 0xC00000BEL)
-#endif
-
-#ifndef STATUS_NETWORK_BUSY
-# define STATUS_NETWORK_BUSY ((NTSTATUS) 0xC00000BFL)
-#endif
-
-#ifndef STATUS_DEVICE_DOES_NOT_EXIST
-# define STATUS_DEVICE_DOES_NOT_EXIST ((NTSTATUS) 0xC00000C0L)
-#endif
-
-#ifndef STATUS_TOO_MANY_COMMANDS
-# define STATUS_TOO_MANY_COMMANDS ((NTSTATUS) 0xC00000C1L)
-#endif
-
-#ifndef STATUS_ADAPTER_HARDWARE_ERROR
-# define STATUS_ADAPTER_HARDWARE_ERROR ((NTSTATUS) 0xC00000C2L)
-#endif
-
-#ifndef STATUS_INVALID_NETWORK_RESPONSE
-# define STATUS_INVALID_NETWORK_RESPONSE ((NTSTATUS) 0xC00000C3L)
-#endif
-
-#ifndef STATUS_UNEXPECTED_NETWORK_ERROR
-# define STATUS_UNEXPECTED_NETWORK_ERROR ((NTSTATUS) 0xC00000C4L)
-#endif
-
-#ifndef STATUS_BAD_REMOTE_ADAPTER
-# define STATUS_BAD_REMOTE_ADAPTER ((NTSTATUS) 0xC00000C5L)
-#endif
-
-#ifndef STATUS_PRINT_QUEUE_FULL
-# define STATUS_PRINT_QUEUE_FULL ((NTSTATUS) 0xC00000C6L)
-#endif
-
-#ifndef STATUS_NO_SPOOL_SPACE
-# define STATUS_NO_SPOOL_SPACE ((NTSTATUS) 0xC00000C7L)
-#endif
-
-#ifndef STATUS_PRINT_CANCELLED
-# define STATUS_PRINT_CANCELLED ((NTSTATUS) 0xC00000C8L)
-#endif
-
-#ifndef STATUS_NETWORK_NAME_DELETED
-# define STATUS_NETWORK_NAME_DELETED ((NTSTATUS) 0xC00000C9L)
-#endif
-
-#ifndef STATUS_NETWORK_ACCESS_DENIED
-# define STATUS_NETWORK_ACCESS_DENIED ((NTSTATUS) 0xC00000CAL)
-#endif
-
-#ifndef STATUS_BAD_DEVICE_TYPE
-# define STATUS_BAD_DEVICE_TYPE ((NTSTATUS) 0xC00000CBL)
-#endif
-
-#ifndef STATUS_BAD_NETWORK_NAME
-# define STATUS_BAD_NETWORK_NAME ((NTSTATUS) 0xC00000CCL)
-#endif
-
-#ifndef STATUS_TOO_MANY_NAMES
-# define STATUS_TOO_MANY_NAMES ((NTSTATUS) 0xC00000CDL)
-#endif
-
-#ifndef STATUS_TOO_MANY_SESSIONS
-# define STATUS_TOO_MANY_SESSIONS ((NTSTATUS) 0xC00000CEL)
-#endif
-
-#ifndef STATUS_SHARING_PAUSED
-# define STATUS_SHARING_PAUSED ((NTSTATUS) 0xC00000CFL)
-#endif
-
-#ifndef STATUS_REQUEST_NOT_ACCEPTED
-# define STATUS_REQUEST_NOT_ACCEPTED ((NTSTATUS) 0xC00000D0L)
-#endif
-
-#ifndef STATUS_REDIRECTOR_PAUSED
-# define STATUS_REDIRECTOR_PAUSED ((NTSTATUS) 0xC00000D1L)
-#endif
-
-#ifndef STATUS_NET_WRITE_FAULT
-# define STATUS_NET_WRITE_FAULT ((NTSTATUS) 0xC00000D2L)
-#endif
-
-#ifndef STATUS_PROFILING_AT_LIMIT
-# define STATUS_PROFILING_AT_LIMIT ((NTSTATUS) 0xC00000D3L)
-#endif
-
-#ifndef STATUS_NOT_SAME_DEVICE
-# define STATUS_NOT_SAME_DEVICE ((NTSTATUS) 0xC00000D4L)
-#endif
-
-#ifndef STATUS_FILE_RENAMED
-# define STATUS_FILE_RENAMED ((NTSTATUS) 0xC00000D5L)
-#endif
-
-#ifndef STATUS_VIRTUAL_CIRCUIT_CLOSED
-# define STATUS_VIRTUAL_CIRCUIT_CLOSED ((NTSTATUS) 0xC00000D6L)
-#endif
-
-#ifndef STATUS_NO_SECURITY_ON_OBJECT
-# define STATUS_NO_SECURITY_ON_OBJECT ((NTSTATUS) 0xC00000D7L)
-#endif
-
-#ifndef STATUS_CANT_WAIT
-# define STATUS_CANT_WAIT ((NTSTATUS) 0xC00000D8L)
-#endif
-
-#ifndef STATUS_PIPE_EMPTY
-# define STATUS_PIPE_EMPTY ((NTSTATUS) 0xC00000D9L)
-#endif
-
-#ifndef STATUS_CANT_ACCESS_DOMAIN_INFO
-# define STATUS_CANT_ACCESS_DOMAIN_INFO ((NTSTATUS) 0xC00000DAL)
-#endif
-
-#ifndef STATUS_CANT_TERMINATE_SELF
-# define STATUS_CANT_TERMINATE_SELF ((NTSTATUS) 0xC00000DBL)
-#endif
-
-#ifndef STATUS_INVALID_SERVER_STATE
-# define STATUS_INVALID_SERVER_STATE ((NTSTATUS) 0xC00000DCL)
-#endif
-
-#ifndef STATUS_INVALID_DOMAIN_STATE
-# define STATUS_INVALID_DOMAIN_STATE ((NTSTATUS) 0xC00000DDL)
-#endif
-
-#ifndef STATUS_INVALID_DOMAIN_ROLE
-# define STATUS_INVALID_DOMAIN_ROLE ((NTSTATUS) 0xC00000DEL)
-#endif
-
-#ifndef STATUS_NO_SUCH_DOMAIN
-# define STATUS_NO_SUCH_DOMAIN ((NTSTATUS) 0xC00000DFL)
-#endif
-
-#ifndef STATUS_DOMAIN_EXISTS
-# define STATUS_DOMAIN_EXISTS ((NTSTATUS) 0xC00000E0L)
-#endif
-
-#ifndef STATUS_DOMAIN_LIMIT_EXCEEDED
-# define STATUS_DOMAIN_LIMIT_EXCEEDED ((NTSTATUS) 0xC00000E1L)
-#endif
-
-#ifndef STATUS_OPLOCK_NOT_GRANTED
-# define STATUS_OPLOCK_NOT_GRANTED ((NTSTATUS) 0xC00000E2L)
-#endif
-
-#ifndef STATUS_INVALID_OPLOCK_PROTOCOL
-# define STATUS_INVALID_OPLOCK_PROTOCOL ((NTSTATUS) 0xC00000E3L)
-#endif
-
-#ifndef STATUS_INTERNAL_DB_CORRUPTION
-# define STATUS_INTERNAL_DB_CORRUPTION ((NTSTATUS) 0xC00000E4L)
-#endif
-
-#ifndef STATUS_INTERNAL_ERROR
-# define STATUS_INTERNAL_ERROR ((NTSTATUS) 0xC00000E5L)
-#endif
-
-#ifndef STATUS_GENERIC_NOT_MAPPED
-# define STATUS_GENERIC_NOT_MAPPED ((NTSTATUS) 0xC00000E6L)
-#endif
-
-#ifndef STATUS_BAD_DESCRIPTOR_FORMAT
-# define STATUS_BAD_DESCRIPTOR_FORMAT ((NTSTATUS) 0xC00000E7L)
-#endif
-
-#ifndef STATUS_INVALID_USER_BUFFER
-# define STATUS_INVALID_USER_BUFFER ((NTSTATUS) 0xC00000E8L)
-#endif
-
-#ifndef STATUS_UNEXPECTED_IO_ERROR
-# define STATUS_UNEXPECTED_IO_ERROR ((NTSTATUS) 0xC00000E9L)
-#endif
-
-#ifndef STATUS_UNEXPECTED_MM_CREATE_ERR
-# define STATUS_UNEXPECTED_MM_CREATE_ERR ((NTSTATUS) 0xC00000EAL)
-#endif
-
-#ifndef STATUS_UNEXPECTED_MM_MAP_ERROR
-# define STATUS_UNEXPECTED_MM_MAP_ERROR ((NTSTATUS) 0xC00000EBL)
-#endif
-
-#ifndef STATUS_UNEXPECTED_MM_EXTEND_ERR
-# define STATUS_UNEXPECTED_MM_EXTEND_ERR ((NTSTATUS) 0xC00000ECL)
-#endif
-
-#ifndef STATUS_NOT_LOGON_PROCESS
-# define STATUS_NOT_LOGON_PROCESS ((NTSTATUS) 0xC00000EDL)
-#endif
-
-#ifndef STATUS_LOGON_SESSION_EXISTS
-# define STATUS_LOGON_SESSION_EXISTS ((NTSTATUS) 0xC00000EEL)
-#endif
-
-#ifndef STATUS_INVALID_PARAMETER_1
-# define STATUS_INVALID_PARAMETER_1 ((NTSTATUS) 0xC00000EFL)
-#endif
-
-#ifndef STATUS_INVALID_PARAMETER_2
-# define STATUS_INVALID_PARAMETER_2 ((NTSTATUS) 0xC00000F0L)
-#endif
-
-#ifndef STATUS_INVALID_PARAMETER_3
-# define STATUS_INVALID_PARAMETER_3 ((NTSTATUS) 0xC00000F1L)
-#endif
-
-#ifndef STATUS_INVALID_PARAMETER_4
-# define STATUS_INVALID_PARAMETER_4 ((NTSTATUS) 0xC00000F2L)
-#endif
-
-#ifndef STATUS_INVALID_PARAMETER_5
-# define STATUS_INVALID_PARAMETER_5 ((NTSTATUS) 0xC00000F3L)
-#endif
-
-#ifndef STATUS_INVALID_PARAMETER_6
-# define STATUS_INVALID_PARAMETER_6 ((NTSTATUS) 0xC00000F4L)
-#endif
-
-#ifndef STATUS_INVALID_PARAMETER_7
-# define STATUS_INVALID_PARAMETER_7 ((NTSTATUS) 0xC00000F5L)
-#endif
-
-#ifndef STATUS_INVALID_PARAMETER_8
-# define STATUS_INVALID_PARAMETER_8 ((NTSTATUS) 0xC00000F6L)
-#endif
-
-#ifndef STATUS_INVALID_PARAMETER_9
-# define STATUS_INVALID_PARAMETER_9 ((NTSTATUS) 0xC00000F7L)
-#endif
-
-#ifndef STATUS_INVALID_PARAMETER_10
-# define STATUS_INVALID_PARAMETER_10 ((NTSTATUS) 0xC00000F8L)
-#endif
-
-#ifndef STATUS_INVALID_PARAMETER_11
-# define STATUS_INVALID_PARAMETER_11 ((NTSTATUS) 0xC00000F9L)
-#endif
-
-#ifndef STATUS_INVALID_PARAMETER_12
-# define STATUS_INVALID_PARAMETER_12 ((NTSTATUS) 0xC00000FAL)
-#endif
-
-#ifndef STATUS_REDIRECTOR_NOT_STARTED
-# define STATUS_REDIRECTOR_NOT_STARTED ((NTSTATUS) 0xC00000FBL)
-#endif
-
-#ifndef STATUS_REDIRECTOR_STARTED
-# define STATUS_REDIRECTOR_STARTED ((NTSTATUS) 0xC00000FCL)
-#endif
-
-#ifndef STATUS_STACK_OVERFLOW
-# define STATUS_STACK_OVERFLOW ((NTSTATUS) 0xC00000FDL)
-#endif
-
-#ifndef STATUS_NO_SUCH_PACKAGE
-# define STATUS_NO_SUCH_PACKAGE ((NTSTATUS) 0xC00000FEL)
-#endif
-
-#ifndef STATUS_BAD_FUNCTION_TABLE
-# define STATUS_BAD_FUNCTION_TABLE ((NTSTATUS) 0xC00000FFL)
-#endif
-
-#ifndef STATUS_VARIABLE_NOT_FOUND
-# define STATUS_VARIABLE_NOT_FOUND ((NTSTATUS) 0xC0000100L)
-#endif
-
-#ifndef STATUS_DIRECTORY_NOT_EMPTY
-# define STATUS_DIRECTORY_NOT_EMPTY ((NTSTATUS) 0xC0000101L)
-#endif
-
-#ifndef STATUS_FILE_CORRUPT_ERROR
-# define STATUS_FILE_CORRUPT_ERROR ((NTSTATUS) 0xC0000102L)
-#endif
-
-#ifndef STATUS_NOT_A_DIRECTORY
-# define STATUS_NOT_A_DIRECTORY ((NTSTATUS) 0xC0000103L)
-#endif
-
-#ifndef STATUS_BAD_LOGON_SESSION_STATE
-# define STATUS_BAD_LOGON_SESSION_STATE ((NTSTATUS) 0xC0000104L)
-#endif
-
-#ifndef STATUS_LOGON_SESSION_COLLISION
-# define STATUS_LOGON_SESSION_COLLISION ((NTSTATUS) 0xC0000105L)
-#endif
-
-#ifndef STATUS_NAME_TOO_LONG
-# define STATUS_NAME_TOO_LONG ((NTSTATUS) 0xC0000106L)
-#endif
-
-#ifndef STATUS_FILES_OPEN
-# define STATUS_FILES_OPEN ((NTSTATUS) 0xC0000107L)
-#endif
-
-#ifndef STATUS_CONNECTION_IN_USE
-# define STATUS_CONNECTION_IN_USE ((NTSTATUS) 0xC0000108L)
-#endif
-
-#ifndef STATUS_MESSAGE_NOT_FOUND
-# define STATUS_MESSAGE_NOT_FOUND ((NTSTATUS) 0xC0000109L)
-#endif
-
-#ifndef STATUS_PROCESS_IS_TERMINATING
-# define STATUS_PROCESS_IS_TERMINATING ((NTSTATUS) 0xC000010AL)
-#endif
-
-#ifndef STATUS_INVALID_LOGON_TYPE
-# define STATUS_INVALID_LOGON_TYPE ((NTSTATUS) 0xC000010BL)
-#endif
-
-#ifndef STATUS_NO_GUID_TRANSLATION
-# define STATUS_NO_GUID_TRANSLATION ((NTSTATUS) 0xC000010CL)
-#endif
-
-#ifndef STATUS_CANNOT_IMPERSONATE
-# define STATUS_CANNOT_IMPERSONATE ((NTSTATUS) 0xC000010DL)
-#endif
-
-#ifndef STATUS_IMAGE_ALREADY_LOADED
-# define STATUS_IMAGE_ALREADY_LOADED ((NTSTATUS) 0xC000010EL)
-#endif
-
-#ifndef STATUS_ABIOS_NOT_PRESENT
-# define STATUS_ABIOS_NOT_PRESENT ((NTSTATUS) 0xC000010FL)
-#endif
-
-#ifndef STATUS_ABIOS_LID_NOT_EXIST
-# define STATUS_ABIOS_LID_NOT_EXIST ((NTSTATUS) 0xC0000110L)
-#endif
-
-#ifndef STATUS_ABIOS_LID_ALREADY_OWNED
-# define STATUS_ABIOS_LID_ALREADY_OWNED ((NTSTATUS) 0xC0000111L)
-#endif
-
-#ifndef STATUS_ABIOS_NOT_LID_OWNER
-# define STATUS_ABIOS_NOT_LID_OWNER ((NTSTATUS) 0xC0000112L)
-#endif
-
-#ifndef STATUS_ABIOS_INVALID_COMMAND
-# define STATUS_ABIOS_INVALID_COMMAND ((NTSTATUS) 0xC0000113L)
-#endif
-
-#ifndef STATUS_ABIOS_INVALID_LID
-# define STATUS_ABIOS_INVALID_LID ((NTSTATUS) 0xC0000114L)
-#endif
-
-#ifndef STATUS_ABIOS_SELECTOR_NOT_AVAILABLE
-# define STATUS_ABIOS_SELECTOR_NOT_AVAILABLE ((NTSTATUS) 0xC0000115L)
-#endif
-
-#ifndef STATUS_ABIOS_INVALID_SELECTOR
-# define STATUS_ABIOS_INVALID_SELECTOR ((NTSTATUS) 0xC0000116L)
-#endif
-
-#ifndef STATUS_NO_LDT
-# define STATUS_NO_LDT ((NTSTATUS) 0xC0000117L)
-#endif
-
-#ifndef STATUS_INVALID_LDT_SIZE
-# define STATUS_INVALID_LDT_SIZE ((NTSTATUS) 0xC0000118L)
-#endif
-
-#ifndef STATUS_INVALID_LDT_OFFSET
-# define STATUS_INVALID_LDT_OFFSET ((NTSTATUS) 0xC0000119L)
-#endif
-
-#ifndef STATUS_INVALID_LDT_DESCRIPTOR
-# define STATUS_INVALID_LDT_DESCRIPTOR ((NTSTATUS) 0xC000011AL)
-#endif
-
-#ifndef STATUS_INVALID_IMAGE_NE_FORMAT
-# define STATUS_INVALID_IMAGE_NE_FORMAT ((NTSTATUS) 0xC000011BL)
-#endif
-
-#ifndef STATUS_RXACT_INVALID_STATE
-# define STATUS_RXACT_INVALID_STATE ((NTSTATUS) 0xC000011CL)
-#endif
-
-#ifndef STATUS_RXACT_COMMIT_FAILURE
-# define STATUS_RXACT_COMMIT_FAILURE ((NTSTATUS) 0xC000011DL)
-#endif
-
-#ifndef STATUS_MAPPED_FILE_SIZE_ZERO
-# define STATUS_MAPPED_FILE_SIZE_ZERO ((NTSTATUS) 0xC000011EL)
-#endif
-
-#ifndef STATUS_TOO_MANY_OPENED_FILES
-# define STATUS_TOO_MANY_OPENED_FILES ((NTSTATUS) 0xC000011FL)
-#endif
-
-#ifndef STATUS_CANCELLED
-# define STATUS_CANCELLED ((NTSTATUS) 0xC0000120L)
-#endif
-
-#ifndef STATUS_CANNOT_DELETE
-# define STATUS_CANNOT_DELETE ((NTSTATUS) 0xC0000121L)
-#endif
-
-#ifndef STATUS_INVALID_COMPUTER_NAME
-# define STATUS_INVALID_COMPUTER_NAME ((NTSTATUS) 0xC0000122L)
-#endif
-
-#ifndef STATUS_FILE_DELETED
-# define STATUS_FILE_DELETED ((NTSTATUS) 0xC0000123L)
-#endif
-
-#ifndef STATUS_SPECIAL_ACCOUNT
-# define STATUS_SPECIAL_ACCOUNT ((NTSTATUS) 0xC0000124L)
-#endif
-
-#ifndef STATUS_SPECIAL_GROUP
-# define STATUS_SPECIAL_GROUP ((NTSTATUS) 0xC0000125L)
-#endif
-
-#ifndef STATUS_SPECIAL_USER
-# define STATUS_SPECIAL_USER ((NTSTATUS) 0xC0000126L)
-#endif
-
-#ifndef STATUS_MEMBERS_PRIMARY_GROUP
-# define STATUS_MEMBERS_PRIMARY_GROUP ((NTSTATUS) 0xC0000127L)
-#endif
-
-#ifndef STATUS_FILE_CLOSED
-# define STATUS_FILE_CLOSED ((NTSTATUS) 0xC0000128L)
-#endif
-
-#ifndef STATUS_TOO_MANY_THREADS
-# define STATUS_TOO_MANY_THREADS ((NTSTATUS) 0xC0000129L)
-#endif
-
-#ifndef STATUS_THREAD_NOT_IN_PROCESS
-# define STATUS_THREAD_NOT_IN_PROCESS ((NTSTATUS) 0xC000012AL)
-#endif
-
-#ifndef STATUS_TOKEN_ALREADY_IN_USE
-# define STATUS_TOKEN_ALREADY_IN_USE ((NTSTATUS) 0xC000012BL)
-#endif
-
-#ifndef STATUS_PAGEFILE_QUOTA_EXCEEDED
-# define STATUS_PAGEFILE_QUOTA_EXCEEDED ((NTSTATUS) 0xC000012CL)
-#endif
-
-#ifndef STATUS_COMMITMENT_LIMIT
-# define STATUS_COMMITMENT_LIMIT ((NTSTATUS) 0xC000012DL)
-#endif
-
-#ifndef STATUS_INVALID_IMAGE_LE_FORMAT
-# define STATUS_INVALID_IMAGE_LE_FORMAT ((NTSTATUS) 0xC000012EL)
-#endif
-
-#ifndef STATUS_INVALID_IMAGE_NOT_MZ
-# define STATUS_INVALID_IMAGE_NOT_MZ ((NTSTATUS) 0xC000012FL)
-#endif
-
-#ifndef STATUS_INVALID_IMAGE_PROTECT
-# define STATUS_INVALID_IMAGE_PROTECT ((NTSTATUS) 0xC0000130L)
-#endif
-
-#ifndef STATUS_INVALID_IMAGE_WIN_16
-# define STATUS_INVALID_IMAGE_WIN_16 ((NTSTATUS) 0xC0000131L)
-#endif
-
-#ifndef STATUS_LOGON_SERVER_CONFLICT
-# define STATUS_LOGON_SERVER_CONFLICT ((NTSTATUS) 0xC0000132L)
-#endif
-
-#ifndef STATUS_TIME_DIFFERENCE_AT_DC
-# define STATUS_TIME_DIFFERENCE_AT_DC ((NTSTATUS) 0xC0000133L)
-#endif
-
-#ifndef STATUS_SYNCHRONIZATION_REQUIRED
-# define STATUS_SYNCHRONIZATION_REQUIRED ((NTSTATUS) 0xC0000134L)
-#endif
-
-#ifndef STATUS_DLL_NOT_FOUND
-# define STATUS_DLL_NOT_FOUND ((NTSTATUS) 0xC0000135L)
-#endif
-
-#ifndef STATUS_OPEN_FAILED
-# define STATUS_OPEN_FAILED ((NTSTATUS) 0xC0000136L)
-#endif
-
-#ifndef STATUS_IO_PRIVILEGE_FAILED
-# define STATUS_IO_PRIVILEGE_FAILED ((NTSTATUS) 0xC0000137L)
-#endif
-
-#ifndef STATUS_ORDINAL_NOT_FOUND
-# define STATUS_ORDINAL_NOT_FOUND ((NTSTATUS) 0xC0000138L)
-#endif
-
-#ifndef STATUS_ENTRYPOINT_NOT_FOUND
-# define STATUS_ENTRYPOINT_NOT_FOUND ((NTSTATUS) 0xC0000139L)
-#endif
-
-#ifndef STATUS_CONTROL_C_EXIT
-# define STATUS_CONTROL_C_EXIT ((NTSTATUS) 0xC000013AL)
-#endif
-
-#ifndef STATUS_LOCAL_DISCONNECT
-# define STATUS_LOCAL_DISCONNECT ((NTSTATUS) 0xC000013BL)
-#endif
-
-#ifndef STATUS_REMOTE_DISCONNECT
-# define STATUS_REMOTE_DISCONNECT ((NTSTATUS) 0xC000013CL)
-#endif
-
-#ifndef STATUS_REMOTE_RESOURCES
-# define STATUS_REMOTE_RESOURCES ((NTSTATUS) 0xC000013DL)
-#endif
-
-#ifndef STATUS_LINK_FAILED
-# define STATUS_LINK_FAILED ((NTSTATUS) 0xC000013EL)
-#endif
-
-#ifndef STATUS_LINK_TIMEOUT
-# define STATUS_LINK_TIMEOUT ((NTSTATUS) 0xC000013FL)
-#endif
-
-#ifndef STATUS_INVALID_CONNECTION
-# define STATUS_INVALID_CONNECTION ((NTSTATUS) 0xC0000140L)
-#endif
-
-#ifndef STATUS_INVALID_ADDRESS
-# define STATUS_INVALID_ADDRESS ((NTSTATUS) 0xC0000141L)
-#endif
-
-#ifndef STATUS_DLL_INIT_FAILED
-# define STATUS_DLL_INIT_FAILED ((NTSTATUS) 0xC0000142L)
-#endif
-
-#ifndef STATUS_MISSING_SYSTEMFILE
-# define STATUS_MISSING_SYSTEMFILE ((NTSTATUS) 0xC0000143L)
-#endif
-
-#ifndef STATUS_UNHANDLED_EXCEPTION
-# define STATUS_UNHANDLED_EXCEPTION ((NTSTATUS) 0xC0000144L)
-#endif
-
-#ifndef STATUS_APP_INIT_FAILURE
-# define STATUS_APP_INIT_FAILURE ((NTSTATUS) 0xC0000145L)
-#endif
-
-#ifndef STATUS_PAGEFILE_CREATE_FAILED
-# define STATUS_PAGEFILE_CREATE_FAILED ((NTSTATUS) 0xC0000146L)
-#endif
-
-#ifndef STATUS_NO_PAGEFILE
-# define STATUS_NO_PAGEFILE ((NTSTATUS) 0xC0000147L)
-#endif
-
-#ifndef STATUS_INVALID_LEVEL
-# define STATUS_INVALID_LEVEL ((NTSTATUS) 0xC0000148L)
-#endif
-
-#ifndef STATUS_WRONG_PASSWORD_CORE
-# define STATUS_WRONG_PASSWORD_CORE ((NTSTATUS) 0xC0000149L)
-#endif
-
-#ifndef STATUS_ILLEGAL_FLOAT_CONTEXT
-# define STATUS_ILLEGAL_FLOAT_CONTEXT ((NTSTATUS) 0xC000014AL)
-#endif
-
-#ifndef STATUS_PIPE_BROKEN
-# define STATUS_PIPE_BROKEN ((NTSTATUS) 0xC000014BL)
-#endif
-
-#ifndef STATUS_REGISTRY_CORRUPT
-# define STATUS_REGISTRY_CORRUPT ((NTSTATUS) 0xC000014CL)
-#endif
-
-#ifndef STATUS_REGISTRY_IO_FAILED
-# define STATUS_REGISTRY_IO_FAILED ((NTSTATUS) 0xC000014DL)
-#endif
-
-#ifndef STATUS_NO_EVENT_PAIR
-# define STATUS_NO_EVENT_PAIR ((NTSTATUS) 0xC000014EL)
-#endif
-
-#ifndef STATUS_UNRECOGNIZED_VOLUME
-# define STATUS_UNRECOGNIZED_VOLUME ((NTSTATUS) 0xC000014FL)
-#endif
-
-#ifndef STATUS_SERIAL_NO_DEVICE_INITED
-# define STATUS_SERIAL_NO_DEVICE_INITED ((NTSTATUS) 0xC0000150L)
-#endif
-
-#ifndef STATUS_NO_SUCH_ALIAS
-# define STATUS_NO_SUCH_ALIAS ((NTSTATUS) 0xC0000151L)
-#endif
-
-#ifndef STATUS_MEMBER_NOT_IN_ALIAS
-# define STATUS_MEMBER_NOT_IN_ALIAS ((NTSTATUS) 0xC0000152L)
-#endif
-
-#ifndef STATUS_MEMBER_IN_ALIAS
-# define STATUS_MEMBER_IN_ALIAS ((NTSTATUS) 0xC0000153L)
-#endif
-
-#ifndef STATUS_ALIAS_EXISTS
-# define STATUS_ALIAS_EXISTS ((NTSTATUS) 0xC0000154L)
-#endif
-
-#ifndef STATUS_LOGON_NOT_GRANTED
-# define STATUS_LOGON_NOT_GRANTED ((NTSTATUS) 0xC0000155L)
-#endif
-
-#ifndef STATUS_TOO_MANY_SECRETS
-# define STATUS_TOO_MANY_SECRETS ((NTSTATUS) 0xC0000156L)
-#endif
-
-#ifndef STATUS_SECRET_TOO_LONG
-# define STATUS_SECRET_TOO_LONG ((NTSTATUS) 0xC0000157L)
-#endif
-
-#ifndef STATUS_INTERNAL_DB_ERROR
-# define STATUS_INTERNAL_DB_ERROR ((NTSTATUS) 0xC0000158L)
-#endif
-
-#ifndef STATUS_FULLSCREEN_MODE
-# define STATUS_FULLSCREEN_MODE ((NTSTATUS) 0xC0000159L)
-#endif
-
-#ifndef STATUS_TOO_MANY_CONTEXT_IDS
-# define STATUS_TOO_MANY_CONTEXT_IDS ((NTSTATUS) 0xC000015AL)
-#endif
-
-#ifndef STATUS_LOGON_TYPE_NOT_GRANTED
-# define STATUS_LOGON_TYPE_NOT_GRANTED ((NTSTATUS) 0xC000015BL)
-#endif
-
-#ifndef STATUS_NOT_REGISTRY_FILE
-# define STATUS_NOT_REGISTRY_FILE ((NTSTATUS) 0xC000015CL)
-#endif
-
-#ifndef STATUS_NT_CROSS_ENCRYPTION_REQUIRED
-# define STATUS_NT_CROSS_ENCRYPTION_REQUIRED ((NTSTATUS) 0xC000015DL)
-#endif
-
-#ifndef STATUS_DOMAIN_CTRLR_CONFIG_ERROR
-# define STATUS_DOMAIN_CTRLR_CONFIG_ERROR ((NTSTATUS) 0xC000015EL)
-#endif
-
-#ifndef STATUS_FT_MISSING_MEMBER
-# define STATUS_FT_MISSING_MEMBER ((NTSTATUS) 0xC000015FL)
-#endif
-
-#ifndef STATUS_ILL_FORMED_SERVICE_ENTRY
-# define STATUS_ILL_FORMED_SERVICE_ENTRY ((NTSTATUS) 0xC0000160L)
-#endif
-
-#ifndef STATUS_ILLEGAL_CHARACTER
-# define STATUS_ILLEGAL_CHARACTER ((NTSTATUS) 0xC0000161L)
-#endif
-
-#ifndef STATUS_UNMAPPABLE_CHARACTER
-# define STATUS_UNMAPPABLE_CHARACTER ((NTSTATUS) 0xC0000162L)
-#endif
-
-#ifndef STATUS_UNDEFINED_CHARACTER
-# define STATUS_UNDEFINED_CHARACTER ((NTSTATUS) 0xC0000163L)
-#endif
-
-#ifndef STATUS_FLOPPY_VOLUME
-# define STATUS_FLOPPY_VOLUME ((NTSTATUS) 0xC0000164L)
-#endif
-
-#ifndef STATUS_FLOPPY_ID_MARK_NOT_FOUND
-# define STATUS_FLOPPY_ID_MARK_NOT_FOUND ((NTSTATUS) 0xC0000165L)
-#endif
-
-#ifndef STATUS_FLOPPY_WRONG_CYLINDER
-# define STATUS_FLOPPY_WRONG_CYLINDER ((NTSTATUS) 0xC0000166L)
-#endif
-
-#ifndef STATUS_FLOPPY_UNKNOWN_ERROR
-# define STATUS_FLOPPY_UNKNOWN_ERROR ((NTSTATUS) 0xC0000167L)
-#endif
-
-#ifndef STATUS_FLOPPY_BAD_REGISTERS
-# define STATUS_FLOPPY_BAD_REGISTERS ((NTSTATUS) 0xC0000168L)
-#endif
-
-#ifndef STATUS_DISK_RECALIBRATE_FAILED
-# define STATUS_DISK_RECALIBRATE_FAILED ((NTSTATUS) 0xC0000169L)
-#endif
-
-#ifndef STATUS_DISK_OPERATION_FAILED
-# define STATUS_DISK_OPERATION_FAILED ((NTSTATUS) 0xC000016AL)
-#endif
-
-#ifndef STATUS_DISK_RESET_FAILED
-# define STATUS_DISK_RESET_FAILED ((NTSTATUS) 0xC000016BL)
-#endif
-
-#ifndef STATUS_SHARED_IRQ_BUSY
-# define STATUS_SHARED_IRQ_BUSY ((NTSTATUS) 0xC000016CL)
-#endif
-
-#ifndef STATUS_FT_ORPHANING
-# define STATUS_FT_ORPHANING ((NTSTATUS) 0xC000016DL)
-#endif
-
-#ifndef STATUS_BIOS_FAILED_TO_CONNECT_INTERRUPT
-# define STATUS_BIOS_FAILED_TO_CONNECT_INTERRUPT ((NTSTATUS) 0xC000016EL)
-#endif
-
-#ifndef STATUS_PARTITION_FAILURE
-# define STATUS_PARTITION_FAILURE ((NTSTATUS) 0xC0000172L)
-#endif
-
-#ifndef STATUS_INVALID_BLOCK_LENGTH
-# define STATUS_INVALID_BLOCK_LENGTH ((NTSTATUS) 0xC0000173L)
-#endif
-
-#ifndef STATUS_DEVICE_NOT_PARTITIONED
-# define STATUS_DEVICE_NOT_PARTITIONED ((NTSTATUS) 0xC0000174L)
-#endif
-
-#ifndef STATUS_UNABLE_TO_LOCK_MEDIA
-# define STATUS_UNABLE_TO_LOCK_MEDIA ((NTSTATUS) 0xC0000175L)
-#endif
-
-#ifndef STATUS_UNABLE_TO_UNLOAD_MEDIA
-# define STATUS_UNABLE_TO_UNLOAD_MEDIA ((NTSTATUS) 0xC0000176L)
-#endif
-
-#ifndef STATUS_EOM_OVERFLOW
-# define STATUS_EOM_OVERFLOW ((NTSTATUS) 0xC0000177L)
-#endif
-
-#ifndef STATUS_NO_MEDIA
-# define STATUS_NO_MEDIA ((NTSTATUS) 0xC0000178L)
-#endif
-
-#ifndef STATUS_NO_SUCH_MEMBER
-# define STATUS_NO_SUCH_MEMBER ((NTSTATUS) 0xC000017AL)
-#endif
-
-#ifndef STATUS_INVALID_MEMBER
-# define STATUS_INVALID_MEMBER ((NTSTATUS) 0xC000017BL)
-#endif
-
-#ifndef STATUS_KEY_DELETED
-# define STATUS_KEY_DELETED ((NTSTATUS) 0xC000017CL)
-#endif
-
-#ifndef STATUS_NO_LOG_SPACE
-# define STATUS_NO_LOG_SPACE ((NTSTATUS) 0xC000017DL)
-#endif
-
-#ifndef STATUS_TOO_MANY_SIDS
-# define STATUS_TOO_MANY_SIDS ((NTSTATUS) 0xC000017EL)
-#endif
-
-#ifndef STATUS_LM_CROSS_ENCRYPTION_REQUIRED
-# define STATUS_LM_CROSS_ENCRYPTION_REQUIRED ((NTSTATUS) 0xC000017FL)
-#endif
-
-#ifndef STATUS_KEY_HAS_CHILDREN
-# define STATUS_KEY_HAS_CHILDREN ((NTSTATUS) 0xC0000180L)
-#endif
-
-#ifndef STATUS_CHILD_MUST_BE_VOLATILE
-# define STATUS_CHILD_MUST_BE_VOLATILE ((NTSTATUS) 0xC0000181L)
-#endif
-
-#ifndef STATUS_DEVICE_CONFIGURATION_ERROR
-# define STATUS_DEVICE_CONFIGURATION_ERROR ((NTSTATUS) 0xC0000182L)
-#endif
-
-#ifndef STATUS_DRIVER_INTERNAL_ERROR
-# define STATUS_DRIVER_INTERNAL_ERROR ((NTSTATUS) 0xC0000183L)
-#endif
-
-#ifndef STATUS_INVALID_DEVICE_STATE
-# define STATUS_INVALID_DEVICE_STATE ((NTSTATUS) 0xC0000184L)
-#endif
-
-#ifndef STATUS_IO_DEVICE_ERROR
-# define STATUS_IO_DEVICE_ERROR ((NTSTATUS) 0xC0000185L)
-#endif
-
-#ifndef STATUS_DEVICE_PROTOCOL_ERROR
-# define STATUS_DEVICE_PROTOCOL_ERROR ((NTSTATUS) 0xC0000186L)
-#endif
-
-#ifndef STATUS_BACKUP_CONTROLLER
-# define STATUS_BACKUP_CONTROLLER ((NTSTATUS) 0xC0000187L)
-#endif
-
-#ifndef STATUS_LOG_FILE_FULL
-# define STATUS_LOG_FILE_FULL ((NTSTATUS) 0xC0000188L)
-#endif
-
-#ifndef STATUS_TOO_LATE
-# define STATUS_TOO_LATE ((NTSTATUS) 0xC0000189L)
-#endif
-
-#ifndef STATUS_NO_TRUST_LSA_SECRET
-# define STATUS_NO_TRUST_LSA_SECRET ((NTSTATUS) 0xC000018AL)
-#endif
-
-#ifndef STATUS_NO_TRUST_SAM_ACCOUNT
-# define STATUS_NO_TRUST_SAM_ACCOUNT ((NTSTATUS) 0xC000018BL)
-#endif
-
-#ifndef STATUS_TRUSTED_DOMAIN_FAILURE
-# define STATUS_TRUSTED_DOMAIN_FAILURE ((NTSTATUS) 0xC000018CL)
-#endif
-
-#ifndef STATUS_TRUSTED_RELATIONSHIP_FAILURE
-# define STATUS_TRUSTED_RELATIONSHIP_FAILURE ((NTSTATUS) 0xC000018DL)
-#endif
-
-#ifndef STATUS_EVENTLOG_FILE_CORRUPT
-# define STATUS_EVENTLOG_FILE_CORRUPT ((NTSTATUS) 0xC000018EL)
-#endif
-
-#ifndef STATUS_EVENTLOG_CANT_START
-# define STATUS_EVENTLOG_CANT_START ((NTSTATUS) 0xC000018FL)
-#endif
-
-#ifndef STATUS_TRUST_FAILURE
-# define STATUS_TRUST_FAILURE ((NTSTATUS) 0xC0000190L)
-#endif
-
-#ifndef STATUS_MUTANT_LIMIT_EXCEEDED
-# define STATUS_MUTANT_LIMIT_EXCEEDED ((NTSTATUS) 0xC0000191L)
-#endif
-
-#ifndef STATUS_NETLOGON_NOT_STARTED
-# define STATUS_NETLOGON_NOT_STARTED ((NTSTATUS) 0xC0000192L)
-#endif
-
-#ifndef STATUS_ACCOUNT_EXPIRED
-# define STATUS_ACCOUNT_EXPIRED ((NTSTATUS) 0xC0000193L)
-#endif
-
-#ifndef STATUS_POSSIBLE_DEADLOCK
-# define STATUS_POSSIBLE_DEADLOCK ((NTSTATUS) 0xC0000194L)
-#endif
-
-#ifndef STATUS_NETWORK_CREDENTIAL_CONFLICT
-# define STATUS_NETWORK_CREDENTIAL_CONFLICT ((NTSTATUS) 0xC0000195L)
-#endif
-
-#ifndef STATUS_REMOTE_SESSION_LIMIT
-# define STATUS_REMOTE_SESSION_LIMIT ((NTSTATUS) 0xC0000196L)
-#endif
-
-#ifndef STATUS_EVENTLOG_FILE_CHANGED
-# define STATUS_EVENTLOG_FILE_CHANGED ((NTSTATUS) 0xC0000197L)
-#endif
-
-#ifndef STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT
-# define STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT ((NTSTATUS) 0xC0000198L)
-#endif
-
-#ifndef STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT
-# define STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT ((NTSTATUS) 0xC0000199L)
-#endif
-
-#ifndef STATUS_NOLOGON_SERVER_TRUST_ACCOUNT
-# define STATUS_NOLOGON_SERVER_TRUST_ACCOUNT ((NTSTATUS) 0xC000019AL)
-#endif
-
-#ifndef STATUS_DOMAIN_TRUST_INCONSISTENT
-# define STATUS_DOMAIN_TRUST_INCONSISTENT ((NTSTATUS) 0xC000019BL)
-#endif
-
-#ifndef STATUS_FS_DRIVER_REQUIRED
-# define STATUS_FS_DRIVER_REQUIRED ((NTSTATUS) 0xC000019CL)
-#endif
-
-#ifndef STATUS_IMAGE_ALREADY_LOADED_AS_DLL
-# define STATUS_IMAGE_ALREADY_LOADED_AS_DLL ((NTSTATUS) 0xC000019DL)
-#endif
-
-#ifndef STATUS_INCOMPATIBLE_WITH_GLOBAL_SHORT_NAME_REGISTRY_SETTING
-# define STATUS_INCOMPATIBLE_WITH_GLOBAL_SHORT_NAME_REGISTRY_SETTING ((NTSTATUS) 0xC000019EL)
-#endif
-
-#ifndef STATUS_SHORT_NAMES_NOT_ENABLED_ON_VOLUME
-# define STATUS_SHORT_NAMES_NOT_ENABLED_ON_VOLUME ((NTSTATUS) 0xC000019FL)
-#endif
-
-#ifndef STATUS_SECURITY_STREAM_IS_INCONSISTENT
-# define STATUS_SECURITY_STREAM_IS_INCONSISTENT ((NTSTATUS) 0xC00001A0L)
-#endif
-
-#ifndef STATUS_INVALID_LOCK_RANGE
-# define STATUS_INVALID_LOCK_RANGE ((NTSTATUS) 0xC00001A1L)
-#endif
-
-#ifndef STATUS_INVALID_ACE_CONDITION
-# define STATUS_INVALID_ACE_CONDITION ((NTSTATUS) 0xC00001A2L)
-#endif
-
-#ifndef STATUS_IMAGE_SUBSYSTEM_NOT_PRESENT
-# define STATUS_IMAGE_SUBSYSTEM_NOT_PRESENT ((NTSTATUS) 0xC00001A3L)
-#endif
-
-#ifndef STATUS_NOTIFICATION_GUID_ALREADY_DEFINED
-# define STATUS_NOTIFICATION_GUID_ALREADY_DEFINED ((NTSTATUS) 0xC00001A4L)
-#endif
-
-#ifndef STATUS_NETWORK_OPEN_RESTRICTION
-# define STATUS_NETWORK_OPEN_RESTRICTION ((NTSTATUS) 0xC0000201L)
-#endif
-
-#ifndef STATUS_NO_USER_SESSION_KEY
-# define STATUS_NO_USER_SESSION_KEY ((NTSTATUS) 0xC0000202L)
-#endif
-
-#ifndef STATUS_USER_SESSION_DELETED
-# define STATUS_USER_SESSION_DELETED ((NTSTATUS) 0xC0000203L)
-#endif
-
-#ifndef STATUS_RESOURCE_LANG_NOT_FOUND
-# define STATUS_RESOURCE_LANG_NOT_FOUND ((NTSTATUS) 0xC0000204L)
-#endif
-
-#ifndef STATUS_INSUFF_SERVER_RESOURCES
-# define STATUS_INSUFF_SERVER_RESOURCES ((NTSTATUS) 0xC0000205L)
-#endif
-
-#ifndef STATUS_INVALID_BUFFER_SIZE
-# define STATUS_INVALID_BUFFER_SIZE ((NTSTATUS) 0xC0000206L)
-#endif
-
-#ifndef STATUS_INVALID_ADDRESS_COMPONENT
-# define STATUS_INVALID_ADDRESS_COMPONENT ((NTSTATUS) 0xC0000207L)
-#endif
-
-#ifndef STATUS_INVALID_ADDRESS_WILDCARD
-# define STATUS_INVALID_ADDRESS_WILDCARD ((NTSTATUS) 0xC0000208L)
-#endif
-
-#ifndef STATUS_TOO_MANY_ADDRESSES
-# define STATUS_TOO_MANY_ADDRESSES ((NTSTATUS) 0xC0000209L)
-#endif
-
-#ifndef STATUS_ADDRESS_ALREADY_EXISTS
-# define STATUS_ADDRESS_ALREADY_EXISTS ((NTSTATUS) 0xC000020AL)
-#endif
-
-#ifndef STATUS_ADDRESS_CLOSED
-# define STATUS_ADDRESS_CLOSED ((NTSTATUS) 0xC000020BL)
-#endif
-
-#ifndef STATUS_CONNECTION_DISCONNECTED
-# define STATUS_CONNECTION_DISCONNECTED ((NTSTATUS) 0xC000020CL)
-#endif
-
-#ifndef STATUS_CONNECTION_RESET
-# define STATUS_CONNECTION_RESET ((NTSTATUS) 0xC000020DL)
-#endif
-
-#ifndef STATUS_TOO_MANY_NODES
-# define STATUS_TOO_MANY_NODES ((NTSTATUS) 0xC000020EL)
-#endif
-
-#ifndef STATUS_TRANSACTION_ABORTED
-# define STATUS_TRANSACTION_ABORTED ((NTSTATUS) 0xC000020FL)
-#endif
-
-#ifndef STATUS_TRANSACTION_TIMED_OUT
-# define STATUS_TRANSACTION_TIMED_OUT ((NTSTATUS) 0xC0000210L)
-#endif
-
-#ifndef STATUS_TRANSACTION_NO_RELEASE
-# define STATUS_TRANSACTION_NO_RELEASE ((NTSTATUS) 0xC0000211L)
-#endif
-
-#ifndef STATUS_TRANSACTION_NO_MATCH
-# define STATUS_TRANSACTION_NO_MATCH ((NTSTATUS) 0xC0000212L)
-#endif
-
-#ifndef STATUS_TRANSACTION_RESPONDED
-# define STATUS_TRANSACTION_RESPONDED ((NTSTATUS) 0xC0000213L)
-#endif
-
-#ifndef STATUS_TRANSACTION_INVALID_ID
-# define STATUS_TRANSACTION_INVALID_ID ((NTSTATUS) 0xC0000214L)
-#endif
-
-#ifndef STATUS_TRANSACTION_INVALID_TYPE
-# define STATUS_TRANSACTION_INVALID_TYPE ((NTSTATUS) 0xC0000215L)
-#endif
-
-#ifndef STATUS_NOT_SERVER_SESSION
-# define STATUS_NOT_SERVER_SESSION ((NTSTATUS) 0xC0000216L)
-#endif
-
-#ifndef STATUS_NOT_CLIENT_SESSION
-# define STATUS_NOT_CLIENT_SESSION ((NTSTATUS) 0xC0000217L)
-#endif
-
-#ifndef STATUS_CANNOT_LOAD_REGISTRY_FILE
-# define STATUS_CANNOT_LOAD_REGISTRY_FILE ((NTSTATUS) 0xC0000218L)
-#endif
-
-#ifndef STATUS_DEBUG_ATTACH_FAILED
-# define STATUS_DEBUG_ATTACH_FAILED ((NTSTATUS) 0xC0000219L)
-#endif
-
-#ifndef STATUS_SYSTEM_PROCESS_TERMINATED
-# define STATUS_SYSTEM_PROCESS_TERMINATED ((NTSTATUS) 0xC000021AL)
-#endif
-
-#ifndef STATUS_DATA_NOT_ACCEPTED
-# define STATUS_DATA_NOT_ACCEPTED ((NTSTATUS) 0xC000021BL)
-#endif
-
-#ifndef STATUS_NO_BROWSER_SERVERS_FOUND
-# define STATUS_NO_BROWSER_SERVERS_FOUND ((NTSTATUS) 0xC000021CL)
-#endif
-
-#ifndef STATUS_VDM_HARD_ERROR
-# define STATUS_VDM_HARD_ERROR ((NTSTATUS) 0xC000021DL)
-#endif
-
-#ifndef STATUS_DRIVER_CANCEL_TIMEOUT
-# define STATUS_DRIVER_CANCEL_TIMEOUT ((NTSTATUS) 0xC000021EL)
-#endif
-
-#ifndef STATUS_REPLY_MESSAGE_MISMATCH
-# define STATUS_REPLY_MESSAGE_MISMATCH ((NTSTATUS) 0xC000021FL)
-#endif
-
-#ifndef STATUS_MAPPED_ALIGNMENT
-# define STATUS_MAPPED_ALIGNMENT ((NTSTATUS) 0xC0000220L)
-#endif
-
-#ifndef STATUS_IMAGE_CHECKSUM_MISMATCH
-# define STATUS_IMAGE_CHECKSUM_MISMATCH ((NTSTATUS) 0xC0000221L)
-#endif
-
-#ifndef STATUS_LOST_WRITEBEHIND_DATA
-# define STATUS_LOST_WRITEBEHIND_DATA ((NTSTATUS) 0xC0000222L)
-#endif
-
-#ifndef STATUS_CLIENT_SERVER_PARAMETERS_INVALID
-# define STATUS_CLIENT_SERVER_PARAMETERS_INVALID ((NTSTATUS) 0xC0000223L)
-#endif
-
-#ifndef STATUS_PASSWORD_MUST_CHANGE
-# define STATUS_PASSWORD_MUST_CHANGE ((NTSTATUS) 0xC0000224L)
-#endif
-
-#ifndef STATUS_NOT_FOUND
-# define STATUS_NOT_FOUND ((NTSTATUS) 0xC0000225L)
-#endif
-
-#ifndef STATUS_NOT_TINY_STREAM
-# define STATUS_NOT_TINY_STREAM ((NTSTATUS) 0xC0000226L)
-#endif
-
-#ifndef STATUS_RECOVERY_FAILURE
-# define STATUS_RECOVERY_FAILURE ((NTSTATUS) 0xC0000227L)
-#endif
-
-#ifndef STATUS_STACK_OVERFLOW_READ
-# define STATUS_STACK_OVERFLOW_READ ((NTSTATUS) 0xC0000228L)
-#endif
-
-#ifndef STATUS_FAIL_CHECK
-# define STATUS_FAIL_CHECK ((NTSTATUS) 0xC0000229L)
-#endif
-
-#ifndef STATUS_DUPLICATE_OBJECTID
-# define STATUS_DUPLICATE_OBJECTID ((NTSTATUS) 0xC000022AL)
-#endif
-
-#ifndef STATUS_OBJECTID_EXISTS
-# define STATUS_OBJECTID_EXISTS ((NTSTATUS) 0xC000022BL)
-#endif
-
-#ifndef STATUS_CONVERT_TO_LARGE
-# define STATUS_CONVERT_TO_LARGE ((NTSTATUS) 0xC000022CL)
-#endif
-
-#ifndef STATUS_RETRY
-# define STATUS_RETRY ((NTSTATUS) 0xC000022DL)
-#endif
-
-#ifndef STATUS_FOUND_OUT_OF_SCOPE
-# define STATUS_FOUND_OUT_OF_SCOPE ((NTSTATUS) 0xC000022EL)
-#endif
-
-#ifndef STATUS_ALLOCATE_BUCKET
-# define STATUS_ALLOCATE_BUCKET ((NTSTATUS) 0xC000022FL)
-#endif
-
-#ifndef STATUS_PROPSET_NOT_FOUND
-# define STATUS_PROPSET_NOT_FOUND ((NTSTATUS) 0xC0000230L)
-#endif
-
-#ifndef STATUS_MARSHALL_OVERFLOW
-# define STATUS_MARSHALL_OVERFLOW ((NTSTATUS) 0xC0000231L)
-#endif
-
-#ifndef STATUS_INVALID_VARIANT
-# define STATUS_INVALID_VARIANT ((NTSTATUS) 0xC0000232L)
-#endif
-
-#ifndef STATUS_DOMAIN_CONTROLLER_NOT_FOUND
-# define STATUS_DOMAIN_CONTROLLER_NOT_FOUND ((NTSTATUS) 0xC0000233L)
-#endif
-
-#ifndef STATUS_ACCOUNT_LOCKED_OUT
-# define STATUS_ACCOUNT_LOCKED_OUT ((NTSTATUS) 0xC0000234L)
-#endif
-
-#ifndef STATUS_HANDLE_NOT_CLOSABLE
-# define STATUS_HANDLE_NOT_CLOSABLE ((NTSTATUS) 0xC0000235L)
-#endif
-
-#ifndef STATUS_CONNECTION_REFUSED
-# define STATUS_CONNECTION_REFUSED ((NTSTATUS) 0xC0000236L)
-#endif
-
-#ifndef STATUS_GRACEFUL_DISCONNECT
-# define STATUS_GRACEFUL_DISCONNECT ((NTSTATUS) 0xC0000237L)
-#endif
-
-#ifndef STATUS_ADDRESS_ALREADY_ASSOCIATED
-# define STATUS_ADDRESS_ALREADY_ASSOCIATED ((NTSTATUS) 0xC0000238L)
-#endif
-
-#ifndef STATUS_ADDRESS_NOT_ASSOCIATED
-# define STATUS_ADDRESS_NOT_ASSOCIATED ((NTSTATUS) 0xC0000239L)
-#endif
-
-#ifndef STATUS_CONNECTION_INVALID
-# define STATUS_CONNECTION_INVALID ((NTSTATUS) 0xC000023AL)
-#endif
-
-#ifndef STATUS_CONNECTION_ACTIVE
-# define STATUS_CONNECTION_ACTIVE ((NTSTATUS) 0xC000023BL)
-#endif
-
-#ifndef STATUS_NETWORK_UNREACHABLE
-# define STATUS_NETWORK_UNREACHABLE ((NTSTATUS) 0xC000023CL)
-#endif
-
-#ifndef STATUS_HOST_UNREACHABLE
-# define STATUS_HOST_UNREACHABLE ((NTSTATUS) 0xC000023DL)
-#endif
-
-#ifndef STATUS_PROTOCOL_UNREACHABLE
-# define STATUS_PROTOCOL_UNREACHABLE ((NTSTATUS) 0xC000023EL)
-#endif
-
-#ifndef STATUS_PORT_UNREACHABLE
-# define STATUS_PORT_UNREACHABLE ((NTSTATUS) 0xC000023FL)
-#endif
-
-#ifndef STATUS_REQUEST_ABORTED
-# define STATUS_REQUEST_ABORTED ((NTSTATUS) 0xC0000240L)
-#endif
-
-#ifndef STATUS_CONNECTION_ABORTED
-# define STATUS_CONNECTION_ABORTED ((NTSTATUS) 0xC0000241L)
-#endif
-
-#ifndef STATUS_BAD_COMPRESSION_BUFFER
-# define STATUS_BAD_COMPRESSION_BUFFER ((NTSTATUS) 0xC0000242L)
-#endif
-
-#ifndef STATUS_USER_MAPPED_FILE
-# define STATUS_USER_MAPPED_FILE ((NTSTATUS) 0xC0000243L)
-#endif
-
-#ifndef STATUS_AUDIT_FAILED
-# define STATUS_AUDIT_FAILED ((NTSTATUS) 0xC0000244L)
-#endif
-
-#ifndef STATUS_TIMER_RESOLUTION_NOT_SET
-# define STATUS_TIMER_RESOLUTION_NOT_SET ((NTSTATUS) 0xC0000245L)
-#endif
-
-#ifndef STATUS_CONNECTION_COUNT_LIMIT
-# define STATUS_CONNECTION_COUNT_LIMIT ((NTSTATUS) 0xC0000246L)
-#endif
-
-#ifndef STATUS_LOGIN_TIME_RESTRICTION
-# define STATUS_LOGIN_TIME_RESTRICTION ((NTSTATUS) 0xC0000247L)
-#endif
-
-#ifndef STATUS_LOGIN_WKSTA_RESTRICTION
-# define STATUS_LOGIN_WKSTA_RESTRICTION ((NTSTATUS) 0xC0000248L)
-#endif
-
-#ifndef STATUS_IMAGE_MP_UP_MISMATCH
-# define STATUS_IMAGE_MP_UP_MISMATCH ((NTSTATUS) 0xC0000249L)
-#endif
-
-#ifndef STATUS_INSUFFICIENT_LOGON_INFO
-# define STATUS_INSUFFICIENT_LOGON_INFO ((NTSTATUS) 0xC0000250L)
-#endif
-
-#ifndef STATUS_BAD_DLL_ENTRYPOINT
-# define STATUS_BAD_DLL_ENTRYPOINT ((NTSTATUS) 0xC0000251L)
-#endif
-
-#ifndef STATUS_BAD_SERVICE_ENTRYPOINT
-# define STATUS_BAD_SERVICE_ENTRYPOINT ((NTSTATUS) 0xC0000252L)
-#endif
-
-#ifndef STATUS_LPC_REPLY_LOST
-# define STATUS_LPC_REPLY_LOST ((NTSTATUS) 0xC0000253L)
-#endif
-
-#ifndef STATUS_IP_ADDRESS_CONFLICT1
-# define STATUS_IP_ADDRESS_CONFLICT1 ((NTSTATUS) 0xC0000254L)
-#endif
-
-#ifndef STATUS_IP_ADDRESS_CONFLICT2
-# define STATUS_IP_ADDRESS_CONFLICT2 ((NTSTATUS) 0xC0000255L)
-#endif
-
-#ifndef STATUS_REGISTRY_QUOTA_LIMIT
-# define STATUS_REGISTRY_QUOTA_LIMIT ((NTSTATUS) 0xC0000256L)
-#endif
-
-#ifndef STATUS_PATH_NOT_COVERED
-# define STATUS_PATH_NOT_COVERED ((NTSTATUS) 0xC0000257L)
-#endif
-
-#ifndef STATUS_NO_CALLBACK_ACTIVE
-# define STATUS_NO_CALLBACK_ACTIVE ((NTSTATUS) 0xC0000258L)
-#endif
-
-#ifndef STATUS_LICENSE_QUOTA_EXCEEDED
-# define STATUS_LICENSE_QUOTA_EXCEEDED ((NTSTATUS) 0xC0000259L)
-#endif
-
-#ifndef STATUS_PWD_TOO_SHORT
-# define STATUS_PWD_TOO_SHORT ((NTSTATUS) 0xC000025AL)
-#endif
-
-#ifndef STATUS_PWD_TOO_RECENT
-# define STATUS_PWD_TOO_RECENT ((NTSTATUS) 0xC000025BL)
-#endif
-
-#ifndef STATUS_PWD_HISTORY_CONFLICT
-# define STATUS_PWD_HISTORY_CONFLICT ((NTSTATUS) 0xC000025CL)
-#endif
-
-#ifndef STATUS_PLUGPLAY_NO_DEVICE
-# define STATUS_PLUGPLAY_NO_DEVICE ((NTSTATUS) 0xC000025EL)
-#endif
-
-#ifndef STATUS_UNSUPPORTED_COMPRESSION
-# define STATUS_UNSUPPORTED_COMPRESSION ((NTSTATUS) 0xC000025FL)
-#endif
-
-#ifndef STATUS_INVALID_HW_PROFILE
-# define STATUS_INVALID_HW_PROFILE ((NTSTATUS) 0xC0000260L)
-#endif
-
-#ifndef STATUS_INVALID_PLUGPLAY_DEVICE_PATH
-# define STATUS_INVALID_PLUGPLAY_DEVICE_PATH ((NTSTATUS) 0xC0000261L)
-#endif
-
-#ifndef STATUS_DRIVER_ORDINAL_NOT_FOUND
-# define STATUS_DRIVER_ORDINAL_NOT_FOUND ((NTSTATUS) 0xC0000262L)
-#endif
-
-#ifndef STATUS_DRIVER_ENTRYPOINT_NOT_FOUND
-# define STATUS_DRIVER_ENTRYPOINT_NOT_FOUND ((NTSTATUS) 0xC0000263L)
-#endif
-
-#ifndef STATUS_RESOURCE_NOT_OWNED
-# define STATUS_RESOURCE_NOT_OWNED ((NTSTATUS) 0xC0000264L)
-#endif
-
-#ifndef STATUS_TOO_MANY_LINKS
-# define STATUS_TOO_MANY_LINKS ((NTSTATUS) 0xC0000265L)
-#endif
-
-#ifndef STATUS_QUOTA_LIST_INCONSISTENT
-# define STATUS_QUOTA_LIST_INCONSISTENT ((NTSTATUS) 0xC0000266L)
-#endif
-
-#ifndef STATUS_FILE_IS_OFFLINE
-# define STATUS_FILE_IS_OFFLINE ((NTSTATUS) 0xC0000267L)
-#endif
-
-#ifndef STATUS_EVALUATION_EXPIRATION
-# define STATUS_EVALUATION_EXPIRATION ((NTSTATUS) 0xC0000268L)
-#endif
-
-#ifndef STATUS_ILLEGAL_DLL_RELOCATION
-# define STATUS_ILLEGAL_DLL_RELOCATION ((NTSTATUS) 0xC0000269L)
-#endif
-
-#ifndef STATUS_LICENSE_VIOLATION
-# define STATUS_LICENSE_VIOLATION ((NTSTATUS) 0xC000026AL)
-#endif
-
-#ifndef STATUS_DLL_INIT_FAILED_LOGOFF
-# define STATUS_DLL_INIT_FAILED_LOGOFF ((NTSTATUS) 0xC000026BL)
-#endif
-
-#ifndef STATUS_DRIVER_UNABLE_TO_LOAD
-# define STATUS_DRIVER_UNABLE_TO_LOAD ((NTSTATUS) 0xC000026CL)
-#endif
-
-#ifndef STATUS_DFS_UNAVAILABLE
-# define STATUS_DFS_UNAVAILABLE ((NTSTATUS) 0xC000026DL)
-#endif
-
-#ifndef STATUS_VOLUME_DISMOUNTED
-# define STATUS_VOLUME_DISMOUNTED ((NTSTATUS) 0xC000026EL)
-#endif
-
-#ifndef STATUS_WX86_INTERNAL_ERROR
-# define STATUS_WX86_INTERNAL_ERROR ((NTSTATUS) 0xC000026FL)
-#endif
-
-#ifndef STATUS_WX86_FLOAT_STACK_CHECK
-# define STATUS_WX86_FLOAT_STACK_CHECK ((NTSTATUS) 0xC0000270L)
-#endif
-
-#ifndef STATUS_VALIDATE_CONTINUE
-# define STATUS_VALIDATE_CONTINUE ((NTSTATUS) 0xC0000271L)
-#endif
-
-#ifndef STATUS_NO_MATCH
-# define STATUS_NO_MATCH ((NTSTATUS) 0xC0000272L)
-#endif
-
-#ifndef STATUS_NO_MORE_MATCHES
-# define STATUS_NO_MORE_MATCHES ((NTSTATUS) 0xC0000273L)
-#endif
-
-#ifndef STATUS_NOT_A_REPARSE_POINT
-# define STATUS_NOT_A_REPARSE_POINT ((NTSTATUS) 0xC0000275L)
-#endif
-
-#ifndef STATUS_IO_REPARSE_TAG_INVALID
-# define STATUS_IO_REPARSE_TAG_INVALID ((NTSTATUS) 0xC0000276L)
-#endif
-
-#ifndef STATUS_IO_REPARSE_TAG_MISMATCH
-# define STATUS_IO_REPARSE_TAG_MISMATCH ((NTSTATUS) 0xC0000277L)
-#endif
-
-#ifndef STATUS_IO_REPARSE_DATA_INVALID
-# define STATUS_IO_REPARSE_DATA_INVALID ((NTSTATUS) 0xC0000278L)
-#endif
-
-#ifndef STATUS_IO_REPARSE_TAG_NOT_HANDLED
-# define STATUS_IO_REPARSE_TAG_NOT_HANDLED ((NTSTATUS) 0xC0000279L)
-#endif
-
-#ifndef STATUS_REPARSE_POINT_NOT_RESOLVED
-# define STATUS_REPARSE_POINT_NOT_RESOLVED ((NTSTATUS) 0xC0000280L)
-#endif
-
-#ifndef STATUS_DIRECTORY_IS_A_REPARSE_POINT
-# define STATUS_DIRECTORY_IS_A_REPARSE_POINT ((NTSTATUS) 0xC0000281L)
-#endif
-
-#ifndef STATUS_RANGE_LIST_CONFLICT
-# define STATUS_RANGE_LIST_CONFLICT ((NTSTATUS) 0xC0000282L)
-#endif
-
-#ifndef STATUS_SOURCE_ELEMENT_EMPTY
-# define STATUS_SOURCE_ELEMENT_EMPTY ((NTSTATUS) 0xC0000283L)
-#endif
-
-#ifndef STATUS_DESTINATION_ELEMENT_FULL
-# define STATUS_DESTINATION_ELEMENT_FULL ((NTSTATUS) 0xC0000284L)
-#endif
-
-#ifndef STATUS_ILLEGAL_ELEMENT_ADDRESS
-# define STATUS_ILLEGAL_ELEMENT_ADDRESS ((NTSTATUS) 0xC0000285L)
-#endif
-
-#ifndef STATUS_MAGAZINE_NOT_PRESENT
-# define STATUS_MAGAZINE_NOT_PRESENT ((NTSTATUS) 0xC0000286L)
-#endif
-
-#ifndef STATUS_REINITIALIZATION_NEEDED
-# define STATUS_REINITIALIZATION_NEEDED ((NTSTATUS) 0xC0000287L)
-#endif
-
-#ifndef STATUS_DEVICE_REQUIRES_CLEANING
-# define STATUS_DEVICE_REQUIRES_CLEANING ((NTSTATUS) 0x80000288L)
-#endif
-
-#ifndef STATUS_DEVICE_DOOR_OPEN
-# define STATUS_DEVICE_DOOR_OPEN ((NTSTATUS) 0x80000289L)
-#endif
-
-#ifndef STATUS_ENCRYPTION_FAILED
-# define STATUS_ENCRYPTION_FAILED ((NTSTATUS) 0xC000028AL)
-#endif
-
-#ifndef STATUS_DECRYPTION_FAILED
-# define STATUS_DECRYPTION_FAILED ((NTSTATUS) 0xC000028BL)
-#endif
-
-#ifndef STATUS_RANGE_NOT_FOUND
-# define STATUS_RANGE_NOT_FOUND ((NTSTATUS) 0xC000028CL)
-#endif
-
-#ifndef STATUS_NO_RECOVERY_POLICY
-# define STATUS_NO_RECOVERY_POLICY ((NTSTATUS) 0xC000028DL)
-#endif
-
-#ifndef STATUS_NO_EFS
-# define STATUS_NO_EFS ((NTSTATUS) 0xC000028EL)
-#endif
-
-#ifndef STATUS_WRONG_EFS
-# define STATUS_WRONG_EFS ((NTSTATUS) 0xC000028FL)
-#endif
-
-#ifndef STATUS_NO_USER_KEYS
-# define STATUS_NO_USER_KEYS ((NTSTATUS) 0xC0000290L)
-#endif
-
-#ifndef STATUS_FILE_NOT_ENCRYPTED
-# define STATUS_FILE_NOT_ENCRYPTED ((NTSTATUS) 0xC0000291L)
-#endif
-
-#ifndef STATUS_NOT_EXPORT_FORMAT
-# define STATUS_NOT_EXPORT_FORMAT ((NTSTATUS) 0xC0000292L)
-#endif
-
-#ifndef STATUS_FILE_ENCRYPTED
-# define STATUS_FILE_ENCRYPTED ((NTSTATUS) 0xC0000293L)
-#endif
-
-#ifndef STATUS_WAKE_SYSTEM
-# define STATUS_WAKE_SYSTEM ((NTSTATUS) 0x40000294L)
-#endif
-
-#ifndef STATUS_WMI_GUID_NOT_FOUND
-# define STATUS_WMI_GUID_NOT_FOUND ((NTSTATUS) 0xC0000295L)
-#endif
-
-#ifndef STATUS_WMI_INSTANCE_NOT_FOUND
-# define STATUS_WMI_INSTANCE_NOT_FOUND ((NTSTATUS) 0xC0000296L)
-#endif
-
-#ifndef STATUS_WMI_ITEMID_NOT_FOUND
-# define STATUS_WMI_ITEMID_NOT_FOUND ((NTSTATUS) 0xC0000297L)
-#endif
-
-#ifndef STATUS_WMI_TRY_AGAIN
-# define STATUS_WMI_TRY_AGAIN ((NTSTATUS) 0xC0000298L)
-#endif
-
-#ifndef STATUS_SHARED_POLICY
-# define STATUS_SHARED_POLICY ((NTSTATUS) 0xC0000299L)
-#endif
-
-#ifndef STATUS_POLICY_OBJECT_NOT_FOUND
-# define STATUS_POLICY_OBJECT_NOT_FOUND ((NTSTATUS) 0xC000029AL)
-#endif
-
-#ifndef STATUS_POLICY_ONLY_IN_DS
-# define STATUS_POLICY_ONLY_IN_DS ((NTSTATUS) 0xC000029BL)
-#endif
-
-#ifndef STATUS_VOLUME_NOT_UPGRADED
-# define STATUS_VOLUME_NOT_UPGRADED ((NTSTATUS) 0xC000029CL)
-#endif
-
-#ifndef STATUS_REMOTE_STORAGE_NOT_ACTIVE
-# define STATUS_REMOTE_STORAGE_NOT_ACTIVE ((NTSTATUS) 0xC000029DL)
-#endif
-
-#ifndef STATUS_REMOTE_STORAGE_MEDIA_ERROR
-# define STATUS_REMOTE_STORAGE_MEDIA_ERROR ((NTSTATUS) 0xC000029EL)
-#endif
-
-#ifndef STATUS_NO_TRACKING_SERVICE
-# define STATUS_NO_TRACKING_SERVICE ((NTSTATUS) 0xC000029FL)
-#endif
-
-#ifndef STATUS_SERVER_SID_MISMATCH
-# define STATUS_SERVER_SID_MISMATCH ((NTSTATUS) 0xC00002A0L)
-#endif
-
-#ifndef STATUS_DS_NO_ATTRIBUTE_OR_VALUE
-# define STATUS_DS_NO_ATTRIBUTE_OR_VALUE ((NTSTATUS) 0xC00002A1L)
-#endif
-
-#ifndef STATUS_DS_INVALID_ATTRIBUTE_SYNTAX
-# define STATUS_DS_INVALID_ATTRIBUTE_SYNTAX ((NTSTATUS) 0xC00002A2L)
-#endif
-
-#ifndef STATUS_DS_ATTRIBUTE_TYPE_UNDEFINED
-# define STATUS_DS_ATTRIBUTE_TYPE_UNDEFINED ((NTSTATUS) 0xC00002A3L)
-#endif
-
-#ifndef STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS
-# define STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS ((NTSTATUS) 0xC00002A4L)
-#endif
-
-#ifndef STATUS_DS_BUSY
-# define STATUS_DS_BUSY ((NTSTATUS) 0xC00002A5L)
-#endif
-
-#ifndef STATUS_DS_UNAVAILABLE
-# define STATUS_DS_UNAVAILABLE ((NTSTATUS) 0xC00002A6L)
-#endif
-
-#ifndef STATUS_DS_NO_RIDS_ALLOCATED
-# define STATUS_DS_NO_RIDS_ALLOCATED ((NTSTATUS) 0xC00002A7L)
-#endif
-
-#ifndef STATUS_DS_NO_MORE_RIDS
-# define STATUS_DS_NO_MORE_RIDS ((NTSTATUS) 0xC00002A8L)
-#endif
-
-#ifndef STATUS_DS_INCORRECT_ROLE_OWNER
-# define STATUS_DS_INCORRECT_ROLE_OWNER ((NTSTATUS) 0xC00002A9L)
-#endif
-
-#ifndef STATUS_DS_RIDMGR_INIT_ERROR
-# define STATUS_DS_RIDMGR_INIT_ERROR ((NTSTATUS) 0xC00002AAL)
-#endif
-
-#ifndef STATUS_DS_OBJ_CLASS_VIOLATION
-# define STATUS_DS_OBJ_CLASS_VIOLATION ((NTSTATUS) 0xC00002ABL)
-#endif
-
-#ifndef STATUS_DS_CANT_ON_NON_LEAF
-# define STATUS_DS_CANT_ON_NON_LEAF ((NTSTATUS) 0xC00002ACL)
-#endif
-
-#ifndef STATUS_DS_CANT_ON_RDN
-# define STATUS_DS_CANT_ON_RDN ((NTSTATUS) 0xC00002ADL)
-#endif
-
-#ifndef STATUS_DS_CANT_MOD_OBJ_CLASS
-# define STATUS_DS_CANT_MOD_OBJ_CLASS ((NTSTATUS) 0xC00002AEL)
-#endif
-
-#ifndef STATUS_DS_CROSS_DOM_MOVE_FAILED
-# define STATUS_DS_CROSS_DOM_MOVE_FAILED ((NTSTATUS) 0xC00002AFL)
-#endif
-
-#ifndef STATUS_DS_GC_NOT_AVAILABLE
-# define STATUS_DS_GC_NOT_AVAILABLE ((NTSTATUS) 0xC00002B0L)
-#endif
-
-#ifndef STATUS_DIRECTORY_SERVICE_REQUIRED
-# define STATUS_DIRECTORY_SERVICE_REQUIRED ((NTSTATUS) 0xC00002B1L)
-#endif
-
-#ifndef STATUS_REPARSE_ATTRIBUTE_CONFLICT
-# define STATUS_REPARSE_ATTRIBUTE_CONFLICT ((NTSTATUS) 0xC00002B2L)
-#endif
-
-#ifndef STATUS_CANT_ENABLE_DENY_ONLY
-# define STATUS_CANT_ENABLE_DENY_ONLY ((NTSTATUS) 0xC00002B3L)
-#endif
-
-#ifndef STATUS_FLOAT_MULTIPLE_FAULTS
-# define STATUS_FLOAT_MULTIPLE_FAULTS ((NTSTATUS) 0xC00002B4L)
-#endif
-
-#ifndef STATUS_FLOAT_MULTIPLE_TRAPS
-# define STATUS_FLOAT_MULTIPLE_TRAPS ((NTSTATUS) 0xC00002B5L)
-#endif
-
-#ifndef STATUS_DEVICE_REMOVED
-# define STATUS_DEVICE_REMOVED ((NTSTATUS) 0xC00002B6L)
-#endif
-
-#ifndef STATUS_JOURNAL_DELETE_IN_PROGRESS
-# define STATUS_JOURNAL_DELETE_IN_PROGRESS ((NTSTATUS) 0xC00002B7L)
-#endif
-
-#ifndef STATUS_JOURNAL_NOT_ACTIVE
-# define STATUS_JOURNAL_NOT_ACTIVE ((NTSTATUS) 0xC00002B8L)
-#endif
-
-#ifndef STATUS_NOINTERFACE
-# define STATUS_NOINTERFACE ((NTSTATUS) 0xC00002B9L)
-#endif
-
-#ifndef STATUS_DS_ADMIN_LIMIT_EXCEEDED
-# define STATUS_DS_ADMIN_LIMIT_EXCEEDED ((NTSTATUS) 0xC00002C1L)
-#endif
-
-#ifndef STATUS_DRIVER_FAILED_SLEEP
-# define STATUS_DRIVER_FAILED_SLEEP ((NTSTATUS) 0xC00002C2L)
-#endif
-
-#ifndef STATUS_MUTUAL_AUTHENTICATION_FAILED
-# define STATUS_MUTUAL_AUTHENTICATION_FAILED ((NTSTATUS) 0xC00002C3L)
-#endif
-
-#ifndef STATUS_CORRUPT_SYSTEM_FILE
-# define STATUS_CORRUPT_SYSTEM_FILE ((NTSTATUS) 0xC00002C4L)
-#endif
-
-#ifndef STATUS_DATATYPE_MISALIGNMENT_ERROR
-# define STATUS_DATATYPE_MISALIGNMENT_ERROR ((NTSTATUS) 0xC00002C5L)
-#endif
-
-#ifndef STATUS_WMI_READ_ONLY
-# define STATUS_WMI_READ_ONLY ((NTSTATUS) 0xC00002C6L)
-#endif
-
-#ifndef STATUS_WMI_SET_FAILURE
-# define STATUS_WMI_SET_FAILURE ((NTSTATUS) 0xC00002C7L)
-#endif
-
-#ifndef STATUS_COMMITMENT_MINIMUM
-# define STATUS_COMMITMENT_MINIMUM ((NTSTATUS) 0xC00002C8L)
-#endif
-
-#ifndef STATUS_REG_NAT_CONSUMPTION
-# define STATUS_REG_NAT_CONSUMPTION ((NTSTATUS) 0xC00002C9L)
-#endif
-
-#ifndef STATUS_TRANSPORT_FULL
-# define STATUS_TRANSPORT_FULL ((NTSTATUS) 0xC00002CAL)
-#endif
-
-#ifndef STATUS_DS_SAM_INIT_FAILURE
-# define STATUS_DS_SAM_INIT_FAILURE ((NTSTATUS) 0xC00002CBL)
-#endif
-
-#ifndef STATUS_ONLY_IF_CONNECTED
-# define STATUS_ONLY_IF_CONNECTED ((NTSTATUS) 0xC00002CCL)
-#endif
-
-#ifndef STATUS_DS_SENSITIVE_GROUP_VIOLATION
-# define STATUS_DS_SENSITIVE_GROUP_VIOLATION ((NTSTATUS) 0xC00002CDL)
-#endif
-
-#ifndef STATUS_PNP_RESTART_ENUMERATION
-# define STATUS_PNP_RESTART_ENUMERATION ((NTSTATUS) 0xC00002CEL)
-#endif
-
-#ifndef STATUS_JOURNAL_ENTRY_DELETED
-# define STATUS_JOURNAL_ENTRY_DELETED ((NTSTATUS) 0xC00002CFL)
-#endif
-
-#ifndef STATUS_DS_CANT_MOD_PRIMARYGROUPID
-# define STATUS_DS_CANT_MOD_PRIMARYGROUPID ((NTSTATUS) 0xC00002D0L)
-#endif
-
-#ifndef STATUS_SYSTEM_IMAGE_BAD_SIGNATURE
-# define STATUS_SYSTEM_IMAGE_BAD_SIGNATURE ((NTSTATUS) 0xC00002D1L)
-#endif
-
-#ifndef STATUS_PNP_REBOOT_REQUIRED
-# define STATUS_PNP_REBOOT_REQUIRED ((NTSTATUS) 0xC00002D2L)
-#endif
-
-#ifndef STATUS_POWER_STATE_INVALID
-# define STATUS_POWER_STATE_INVALID ((NTSTATUS) 0xC00002D3L)
-#endif
-
-#ifndef STATUS_DS_INVALID_GROUP_TYPE
-# define STATUS_DS_INVALID_GROUP_TYPE ((NTSTATUS) 0xC00002D4L)
-#endif
-
-#ifndef STATUS_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN
-# define STATUS_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN ((NTSTATUS) 0xC00002D5L)
-#endif
-
-#ifndef STATUS_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN
-# define STATUS_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN ((NTSTATUS) 0xC00002D6L)
-#endif
-
-#ifndef STATUS_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER
-# define STATUS_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER ((NTSTATUS) 0xC00002D7L)
-#endif
-
-#ifndef STATUS_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER
-# define STATUS_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER ((NTSTATUS) 0xC00002D8L)
-#endif
-
-#ifndef STATUS_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER
-# define STATUS_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER ((NTSTATUS) 0xC00002D9L)
-#endif
-
-#ifndef STATUS_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER
-# define STATUS_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER ((NTSTATUS) 0xC00002DAL)
-#endif
-
-#ifndef STATUS_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER
-# define STATUS_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER ((NTSTATUS) 0xC00002DBL)
-#endif
-
-#ifndef STATUS_DS_HAVE_PRIMARY_MEMBERS
-# define STATUS_DS_HAVE_PRIMARY_MEMBERS ((NTSTATUS) 0xC00002DCL)
-#endif
-
-#ifndef STATUS_WMI_NOT_SUPPORTED
-# define STATUS_WMI_NOT_SUPPORTED ((NTSTATUS) 0xC00002DDL)
-#endif
-
-#ifndef STATUS_INSUFFICIENT_POWER
-# define STATUS_INSUFFICIENT_POWER ((NTSTATUS) 0xC00002DEL)
-#endif
-
-#ifndef STATUS_SAM_NEED_BOOTKEY_PASSWORD
-# define STATUS_SAM_NEED_BOOTKEY_PASSWORD ((NTSTATUS) 0xC00002DFL)
-#endif
-
-#ifndef STATUS_SAM_NEED_BOOTKEY_FLOPPY
-# define STATUS_SAM_NEED_BOOTKEY_FLOPPY ((NTSTATUS) 0xC00002E0L)
-#endif
-
-#ifndef STATUS_DS_CANT_START
-# define STATUS_DS_CANT_START ((NTSTATUS) 0xC00002E1L)
-#endif
-
-#ifndef STATUS_DS_INIT_FAILURE
-# define STATUS_DS_INIT_FAILURE ((NTSTATUS) 0xC00002E2L)
-#endif
-
-#ifndef STATUS_SAM_INIT_FAILURE
-# define STATUS_SAM_INIT_FAILURE ((NTSTATUS) 0xC00002E3L)
-#endif
-
-#ifndef STATUS_DS_GC_REQUIRED
-# define STATUS_DS_GC_REQUIRED ((NTSTATUS) 0xC00002E4L)
-#endif
-
-#ifndef STATUS_DS_LOCAL_MEMBER_OF_LOCAL_ONLY
-# define STATUS_DS_LOCAL_MEMBER_OF_LOCAL_ONLY ((NTSTATUS) 0xC00002E5L)
-#endif
-
-#ifndef STATUS_DS_NO_FPO_IN_UNIVERSAL_GROUPS
-# define STATUS_DS_NO_FPO_IN_UNIVERSAL_GROUPS ((NTSTATUS) 0xC00002E6L)
-#endif
-
-#ifndef STATUS_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED
-# define STATUS_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED ((NTSTATUS) 0xC00002E7L)
-#endif
-
-#ifndef STATUS_MULTIPLE_FAULT_VIOLATION
-# define STATUS_MULTIPLE_FAULT_VIOLATION ((NTSTATUS) 0xC00002E8L)
-#endif
-
-#ifndef STATUS_CURRENT_DOMAIN_NOT_ALLOWED
-# define STATUS_CURRENT_DOMAIN_NOT_ALLOWED ((NTSTATUS) 0xC00002E9L)
-#endif
-
-#ifndef STATUS_CANNOT_MAKE
-# define STATUS_CANNOT_MAKE ((NTSTATUS) 0xC00002EAL)
-#endif
-
-#ifndef STATUS_SYSTEM_SHUTDOWN
-# define STATUS_SYSTEM_SHUTDOWN ((NTSTATUS) 0xC00002EBL)
-#endif
-
-#ifndef STATUS_DS_INIT_FAILURE_CONSOLE
-# define STATUS_DS_INIT_FAILURE_CONSOLE ((NTSTATUS) 0xC00002ECL)
-#endif
-
-#ifndef STATUS_DS_SAM_INIT_FAILURE_CONSOLE
-# define STATUS_DS_SAM_INIT_FAILURE_CONSOLE ((NTSTATUS) 0xC00002EDL)
-#endif
-
-#ifndef STATUS_UNFINISHED_CONTEXT_DELETED
-# define STATUS_UNFINISHED_CONTEXT_DELETED ((NTSTATUS) 0xC00002EEL)
-#endif
-
-#ifndef STATUS_NO_TGT_REPLY
-# define STATUS_NO_TGT_REPLY ((NTSTATUS) 0xC00002EFL)
-#endif
-
-#ifndef STATUS_OBJECTID_NOT_FOUND
-# define STATUS_OBJECTID_NOT_FOUND ((NTSTATUS) 0xC00002F0L)
-#endif
-
-#ifndef STATUS_NO_IP_ADDRESSES
-# define STATUS_NO_IP_ADDRESSES ((NTSTATUS) 0xC00002F1L)
-#endif
-
-#ifndef STATUS_WRONG_CREDENTIAL_HANDLE
-# define STATUS_WRONG_CREDENTIAL_HANDLE ((NTSTATUS) 0xC00002F2L)
-#endif
-
-#ifndef STATUS_CRYPTO_SYSTEM_INVALID
-# define STATUS_CRYPTO_SYSTEM_INVALID ((NTSTATUS) 0xC00002F3L)
-#endif
-
-#ifndef STATUS_MAX_REFERRALS_EXCEEDED
-# define STATUS_MAX_REFERRALS_EXCEEDED ((NTSTATUS) 0xC00002F4L)
-#endif
-
-#ifndef STATUS_MUST_BE_KDC
-# define STATUS_MUST_BE_KDC ((NTSTATUS) 0xC00002F5L)
-#endif
-
-#ifndef STATUS_STRONG_CRYPTO_NOT_SUPPORTED
-# define STATUS_STRONG_CRYPTO_NOT_SUPPORTED ((NTSTATUS) 0xC00002F6L)
-#endif
-
-#ifndef STATUS_TOO_MANY_PRINCIPALS
-# define STATUS_TOO_MANY_PRINCIPALS ((NTSTATUS) 0xC00002F7L)
-#endif
-
-#ifndef STATUS_NO_PA_DATA
-# define STATUS_NO_PA_DATA ((NTSTATUS) 0xC00002F8L)
-#endif
-
-#ifndef STATUS_PKINIT_NAME_MISMATCH
-# define STATUS_PKINIT_NAME_MISMATCH ((NTSTATUS) 0xC00002F9L)
-#endif
-
-#ifndef STATUS_SMARTCARD_LOGON_REQUIRED
-# define STATUS_SMARTCARD_LOGON_REQUIRED ((NTSTATUS) 0xC00002FAL)
-#endif
-
-#ifndef STATUS_KDC_INVALID_REQUEST
-# define STATUS_KDC_INVALID_REQUEST ((NTSTATUS) 0xC00002FBL)
-#endif
-
-#ifndef STATUS_KDC_UNABLE_TO_REFER
-# define STATUS_KDC_UNABLE_TO_REFER ((NTSTATUS) 0xC00002FCL)
-#endif
-
-#ifndef STATUS_KDC_UNKNOWN_ETYPE
-# define STATUS_KDC_UNKNOWN_ETYPE ((NTSTATUS) 0xC00002FDL)
-#endif
-
-#ifndef STATUS_SHUTDOWN_IN_PROGRESS
-# define STATUS_SHUTDOWN_IN_PROGRESS ((NTSTATUS) 0xC00002FEL)
-#endif
-
-#ifndef STATUS_SERVER_SHUTDOWN_IN_PROGRESS
-# define STATUS_SERVER_SHUTDOWN_IN_PROGRESS ((NTSTATUS) 0xC00002FFL)
-#endif
-
-#ifndef STATUS_NOT_SUPPORTED_ON_SBS
-# define STATUS_NOT_SUPPORTED_ON_SBS ((NTSTATUS) 0xC0000300L)
-#endif
-
-#ifndef STATUS_WMI_GUID_DISCONNECTED
-# define STATUS_WMI_GUID_DISCONNECTED ((NTSTATUS) 0xC0000301L)
-#endif
-
-#ifndef STATUS_WMI_ALREADY_DISABLED
-# define STATUS_WMI_ALREADY_DISABLED ((NTSTATUS) 0xC0000302L)
-#endif
-
-#ifndef STATUS_WMI_ALREADY_ENABLED
-# define STATUS_WMI_ALREADY_ENABLED ((NTSTATUS) 0xC0000303L)
-#endif
-
-#ifndef STATUS_MFT_TOO_FRAGMENTED
-# define STATUS_MFT_TOO_FRAGMENTED ((NTSTATUS) 0xC0000304L)
-#endif
-
-#ifndef STATUS_COPY_PROTECTION_FAILURE
-# define STATUS_COPY_PROTECTION_FAILURE ((NTSTATUS) 0xC0000305L)
-#endif
-
-#ifndef STATUS_CSS_AUTHENTICATION_FAILURE
-# define STATUS_CSS_AUTHENTICATION_FAILURE ((NTSTATUS) 0xC0000306L)
-#endif
-
-#ifndef STATUS_CSS_KEY_NOT_PRESENT
-# define STATUS_CSS_KEY_NOT_PRESENT ((NTSTATUS) 0xC0000307L)
-#endif
-
-#ifndef STATUS_CSS_KEY_NOT_ESTABLISHED
-# define STATUS_CSS_KEY_NOT_ESTABLISHED ((NTSTATUS) 0xC0000308L)
-#endif
-
-#ifndef STATUS_CSS_SCRAMBLED_SECTOR
-# define STATUS_CSS_SCRAMBLED_SECTOR ((NTSTATUS) 0xC0000309L)
-#endif
-
-#ifndef STATUS_CSS_REGION_MISMATCH
-# define STATUS_CSS_REGION_MISMATCH ((NTSTATUS) 0xC000030AL)
-#endif
-
-#ifndef STATUS_CSS_RESETS_EXHAUSTED
-# define STATUS_CSS_RESETS_EXHAUSTED ((NTSTATUS) 0xC000030BL)
-#endif
-
-#ifndef STATUS_PKINIT_FAILURE
-# define STATUS_PKINIT_FAILURE ((NTSTATUS) 0xC0000320L)
-#endif
-
-#ifndef STATUS_SMARTCARD_SUBSYSTEM_FAILURE
-# define STATUS_SMARTCARD_SUBSYSTEM_FAILURE ((NTSTATUS) 0xC0000321L)
-#endif
-
-#ifndef STATUS_NO_KERB_KEY
-# define STATUS_NO_KERB_KEY ((NTSTATUS) 0xC0000322L)
-#endif
-
-#ifndef STATUS_HOST_DOWN
-# define STATUS_HOST_DOWN ((NTSTATUS) 0xC0000350L)
-#endif
-
-#ifndef STATUS_UNSUPPORTED_PREAUTH
-# define STATUS_UNSUPPORTED_PREAUTH ((NTSTATUS) 0xC0000351L)
-#endif
-
-#ifndef STATUS_EFS_ALG_BLOB_TOO_BIG
-# define STATUS_EFS_ALG_BLOB_TOO_BIG ((NTSTATUS) 0xC0000352L)
-#endif
-
-#ifndef STATUS_PORT_NOT_SET
-# define STATUS_PORT_NOT_SET ((NTSTATUS) 0xC0000353L)
-#endif
-
-#ifndef STATUS_DEBUGGER_INACTIVE
-# define STATUS_DEBUGGER_INACTIVE ((NTSTATUS) 0xC0000354L)
-#endif
-
-#ifndef STATUS_DS_VERSION_CHECK_FAILURE
-# define STATUS_DS_VERSION_CHECK_FAILURE ((NTSTATUS) 0xC0000355L)
-#endif
-
-#ifndef STATUS_AUDITING_DISABLED
-# define STATUS_AUDITING_DISABLED ((NTSTATUS) 0xC0000356L)
-#endif
-
-#ifndef STATUS_PRENT4_MACHINE_ACCOUNT
-# define STATUS_PRENT4_MACHINE_ACCOUNT ((NTSTATUS) 0xC0000357L)
-#endif
-
-#ifndef STATUS_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER
-# define STATUS_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER ((NTSTATUS) 0xC0000358L)
-#endif
-
-#ifndef STATUS_INVALID_IMAGE_WIN_32
-# define STATUS_INVALID_IMAGE_WIN_32 ((NTSTATUS) 0xC0000359L)
-#endif
-
-#ifndef STATUS_INVALID_IMAGE_WIN_64
-# define STATUS_INVALID_IMAGE_WIN_64 ((NTSTATUS) 0xC000035AL)
-#endif
-
-#ifndef STATUS_BAD_BINDINGS
-# define STATUS_BAD_BINDINGS ((NTSTATUS) 0xC000035BL)
-#endif
-
-#ifndef STATUS_NETWORK_SESSION_EXPIRED
-# define STATUS_NETWORK_SESSION_EXPIRED ((NTSTATUS) 0xC000035CL)
-#endif
-
-#ifndef STATUS_APPHELP_BLOCK
-# define STATUS_APPHELP_BLOCK ((NTSTATUS) 0xC000035DL)
-#endif
-
-#ifndef STATUS_ALL_SIDS_FILTERED
-# define STATUS_ALL_SIDS_FILTERED ((NTSTATUS) 0xC000035EL)
-#endif
-
-#ifndef STATUS_NOT_SAFE_MODE_DRIVER
-# define STATUS_NOT_SAFE_MODE_DRIVER ((NTSTATUS) 0xC000035FL)
-#endif
-
-#ifndef STATUS_ACCESS_DISABLED_BY_POLICY_DEFAULT
-# define STATUS_ACCESS_DISABLED_BY_POLICY_DEFAULT ((NTSTATUS) 0xC0000361L)
-#endif
-
-#ifndef STATUS_ACCESS_DISABLED_BY_POLICY_PATH
-# define STATUS_ACCESS_DISABLED_BY_POLICY_PATH ((NTSTATUS) 0xC0000362L)
-#endif
-
-#ifndef STATUS_ACCESS_DISABLED_BY_POLICY_PUBLISHER
-# define STATUS_ACCESS_DISABLED_BY_POLICY_PUBLISHER ((NTSTATUS) 0xC0000363L)
-#endif
-
-#ifndef STATUS_ACCESS_DISABLED_BY_POLICY_OTHER
-# define STATUS_ACCESS_DISABLED_BY_POLICY_OTHER ((NTSTATUS) 0xC0000364L)
-#endif
-
-#ifndef STATUS_FAILED_DRIVER_ENTRY
-# define STATUS_FAILED_DRIVER_ENTRY ((NTSTATUS) 0xC0000365L)
-#endif
-
-#ifndef STATUS_DEVICE_ENUMERATION_ERROR
-# define STATUS_DEVICE_ENUMERATION_ERROR ((NTSTATUS) 0xC0000366L)
-#endif
-
-#ifndef STATUS_MOUNT_POINT_NOT_RESOLVED
-# define STATUS_MOUNT_POINT_NOT_RESOLVED ((NTSTATUS) 0xC0000368L)
-#endif
-
-#ifndef STATUS_INVALID_DEVICE_OBJECT_PARAMETER
-# define STATUS_INVALID_DEVICE_OBJECT_PARAMETER ((NTSTATUS) 0xC0000369L)
-#endif
-
-#ifndef STATUS_MCA_OCCURED
-# define STATUS_MCA_OCCURED ((NTSTATUS) 0xC000036AL)
-#endif
-
-#ifndef STATUS_DRIVER_BLOCKED_CRITICAL
-# define STATUS_DRIVER_BLOCKED_CRITICAL ((NTSTATUS) 0xC000036BL)
-#endif
-
-#ifndef STATUS_DRIVER_BLOCKED
-# define STATUS_DRIVER_BLOCKED ((NTSTATUS) 0xC000036CL)
-#endif
-
-#ifndef STATUS_DRIVER_DATABASE_ERROR
-# define STATUS_DRIVER_DATABASE_ERROR ((NTSTATUS) 0xC000036DL)
-#endif
-
-#ifndef STATUS_SYSTEM_HIVE_TOO_LARGE
-# define STATUS_SYSTEM_HIVE_TOO_LARGE ((NTSTATUS) 0xC000036EL)
-#endif
-
-#ifndef STATUS_INVALID_IMPORT_OF_NON_DLL
-# define STATUS_INVALID_IMPORT_OF_NON_DLL ((NTSTATUS) 0xC000036FL)
-#endif
-
-#ifndef STATUS_DS_SHUTTING_DOWN
-# define STATUS_DS_SHUTTING_DOWN ((NTSTATUS) 0x40000370L)
-#endif
-
-#ifndef STATUS_NO_SECRETS
-# define STATUS_NO_SECRETS ((NTSTATUS) 0xC0000371L)
-#endif
-
-#ifndef STATUS_ACCESS_DISABLED_NO_SAFER_UI_BY_POLICY
-# define STATUS_ACCESS_DISABLED_NO_SAFER_UI_BY_POLICY ((NTSTATUS) 0xC0000372L)
-#endif
-
-#ifndef STATUS_FAILED_STACK_SWITCH
-# define STATUS_FAILED_STACK_SWITCH ((NTSTATUS) 0xC0000373L)
-#endif
-
-#ifndef STATUS_HEAP_CORRUPTION
-# define STATUS_HEAP_CORRUPTION ((NTSTATUS) 0xC0000374L)
-#endif
-
-#ifndef STATUS_SMARTCARD_WRONG_PIN
-# define STATUS_SMARTCARD_WRONG_PIN ((NTSTATUS) 0xC0000380L)
-#endif
-
-#ifndef STATUS_SMARTCARD_CARD_BLOCKED
-# define STATUS_SMARTCARD_CARD_BLOCKED ((NTSTATUS) 0xC0000381L)
-#endif
-
-#ifndef STATUS_SMARTCARD_CARD_NOT_AUTHENTICATED
-# define STATUS_SMARTCARD_CARD_NOT_AUTHENTICATED ((NTSTATUS) 0xC0000382L)
-#endif
-
-#ifndef STATUS_SMARTCARD_NO_CARD
-# define STATUS_SMARTCARD_NO_CARD ((NTSTATUS) 0xC0000383L)
-#endif
-
-#ifndef STATUS_SMARTCARD_NO_KEY_CONTAINER
-# define STATUS_SMARTCARD_NO_KEY_CONTAINER ((NTSTATUS) 0xC0000384L)
-#endif
-
-#ifndef STATUS_SMARTCARD_NO_CERTIFICATE
-# define STATUS_SMARTCARD_NO_CERTIFICATE ((NTSTATUS) 0xC0000385L)
-#endif
-
-#ifndef STATUS_SMARTCARD_NO_KEYSET
-# define STATUS_SMARTCARD_NO_KEYSET ((NTSTATUS) 0xC0000386L)
-#endif
-
-#ifndef STATUS_SMARTCARD_IO_ERROR
-# define STATUS_SMARTCARD_IO_ERROR ((NTSTATUS) 0xC0000387L)
-#endif
-
-#ifndef STATUS_DOWNGRADE_DETECTED
-# define STATUS_DOWNGRADE_DETECTED ((NTSTATUS) 0xC0000388L)
-#endif
-
-#ifndef STATUS_SMARTCARD_CERT_REVOKED
-# define STATUS_SMARTCARD_CERT_REVOKED ((NTSTATUS) 0xC0000389L)
-#endif
-
-#ifndef STATUS_ISSUING_CA_UNTRUSTED
-# define STATUS_ISSUING_CA_UNTRUSTED ((NTSTATUS) 0xC000038AL)
-#endif
-
-#ifndef STATUS_REVOCATION_OFFLINE_C
-# define STATUS_REVOCATION_OFFLINE_C ((NTSTATUS) 0xC000038BL)
-#endif
-
-#ifndef STATUS_PKINIT_CLIENT_FAILURE
-# define STATUS_PKINIT_CLIENT_FAILURE ((NTSTATUS) 0xC000038CL)
-#endif
-
-#ifndef STATUS_SMARTCARD_CERT_EXPIRED
-# define STATUS_SMARTCARD_CERT_EXPIRED ((NTSTATUS) 0xC000038DL)
-#endif
-
-#ifndef STATUS_DRIVER_FAILED_PRIOR_UNLOAD
-# define STATUS_DRIVER_FAILED_PRIOR_UNLOAD ((NTSTATUS) 0xC000038EL)
-#endif
-
-#ifndef STATUS_SMARTCARD_SILENT_CONTEXT
-# define STATUS_SMARTCARD_SILENT_CONTEXT ((NTSTATUS) 0xC000038FL)
-#endif
-
-#ifndef STATUS_PER_USER_TRUST_QUOTA_EXCEEDED
-# define STATUS_PER_USER_TRUST_QUOTA_EXCEEDED ((NTSTATUS) 0xC0000401L)
-#endif
-
-#ifndef STATUS_ALL_USER_TRUST_QUOTA_EXCEEDED
-# define STATUS_ALL_USER_TRUST_QUOTA_EXCEEDED ((NTSTATUS) 0xC0000402L)
-#endif
-
-#ifndef STATUS_USER_DELETE_TRUST_QUOTA_EXCEEDED
-# define STATUS_USER_DELETE_TRUST_QUOTA_EXCEEDED ((NTSTATUS) 0xC0000403L)
-#endif
-
-#ifndef STATUS_DS_NAME_NOT_UNIQUE
-# define STATUS_DS_NAME_NOT_UNIQUE ((NTSTATUS) 0xC0000404L)
-#endif
-
-#ifndef STATUS_DS_DUPLICATE_ID_FOUND
-# define STATUS_DS_DUPLICATE_ID_FOUND ((NTSTATUS) 0xC0000405L)
-#endif
-
-#ifndef STATUS_DS_GROUP_CONVERSION_ERROR
-# define STATUS_DS_GROUP_CONVERSION_ERROR ((NTSTATUS) 0xC0000406L)
-#endif
-
-#ifndef STATUS_VOLSNAP_PREPARE_HIBERNATE
-# define STATUS_VOLSNAP_PREPARE_HIBERNATE ((NTSTATUS) 0xC0000407L)
-#endif
-
-#ifndef STATUS_USER2USER_REQUIRED
-# define STATUS_USER2USER_REQUIRED ((NTSTATUS) 0xC0000408L)
-#endif
-
-#ifndef STATUS_STACK_BUFFER_OVERRUN
-# define STATUS_STACK_BUFFER_OVERRUN ((NTSTATUS) 0xC0000409L)
-#endif
-
-#ifndef STATUS_NO_S4U_PROT_SUPPORT
-# define STATUS_NO_S4U_PROT_SUPPORT ((NTSTATUS) 0xC000040AL)
-#endif
-
-#ifndef STATUS_CROSSREALM_DELEGATION_FAILURE
-# define STATUS_CROSSREALM_DELEGATION_FAILURE ((NTSTATUS) 0xC000040BL)
-#endif
-
-#ifndef STATUS_REVOCATION_OFFLINE_KDC
-# define STATUS_REVOCATION_OFFLINE_KDC ((NTSTATUS) 0xC000040CL)
-#endif
-
-#ifndef STATUS_ISSUING_CA_UNTRUSTED_KDC
-# define STATUS_ISSUING_CA_UNTRUSTED_KDC ((NTSTATUS) 0xC000040DL)
-#endif
-
-#ifndef STATUS_KDC_CERT_EXPIRED
-# define STATUS_KDC_CERT_EXPIRED ((NTSTATUS) 0xC000040EL)
-#endif
-
-#ifndef STATUS_KDC_CERT_REVOKED
-# define STATUS_KDC_CERT_REVOKED ((NTSTATUS) 0xC000040FL)
-#endif
-
-#ifndef STATUS_PARAMETER_QUOTA_EXCEEDED
-# define STATUS_PARAMETER_QUOTA_EXCEEDED ((NTSTATUS) 0xC0000410L)
-#endif
-
-#ifndef STATUS_HIBERNATION_FAILURE
-# define STATUS_HIBERNATION_FAILURE ((NTSTATUS) 0xC0000411L)
-#endif
-
-#ifndef STATUS_DELAY_LOAD_FAILED
-# define STATUS_DELAY_LOAD_FAILED ((NTSTATUS) 0xC0000412L)
-#endif
-
-#ifndef STATUS_AUTHENTICATION_FIREWALL_FAILED
-# define STATUS_AUTHENTICATION_FIREWALL_FAILED ((NTSTATUS) 0xC0000413L)
-#endif
-
-#ifndef STATUS_VDM_DISALLOWED
-# define STATUS_VDM_DISALLOWED ((NTSTATUS) 0xC0000414L)
-#endif
-
-#ifndef STATUS_HUNG_DISPLAY_DRIVER_THREAD
-# define STATUS_HUNG_DISPLAY_DRIVER_THREAD ((NTSTATUS) 0xC0000415L)
-#endif
-
-#ifndef STATUS_INSUFFICIENT_RESOURCE_FOR_SPECIFIED_SHARED_SECTION_SIZE
-# define STATUS_INSUFFICIENT_RESOURCE_FOR_SPECIFIED_SHARED_SECTION_SIZE ((NTSTATUS) 0xC0000416L)
-#endif
-
-#ifndef STATUS_INVALID_CRUNTIME_PARAMETER
-# define STATUS_INVALID_CRUNTIME_PARAMETER ((NTSTATUS) 0xC0000417L)
-#endif
-
-#ifndef STATUS_NTLM_BLOCKED
-# define STATUS_NTLM_BLOCKED ((NTSTATUS) 0xC0000418L)
-#endif
-
-#ifndef STATUS_DS_SRC_SID_EXISTS_IN_FOREST
-# define STATUS_DS_SRC_SID_EXISTS_IN_FOREST ((NTSTATUS) 0xC0000419L)
-#endif
-
-#ifndef STATUS_DS_DOMAIN_NAME_EXISTS_IN_FOREST
-# define STATUS_DS_DOMAIN_NAME_EXISTS_IN_FOREST ((NTSTATUS) 0xC000041AL)
-#endif
-
-#ifndef STATUS_DS_FLAT_NAME_EXISTS_IN_FOREST
-# define STATUS_DS_FLAT_NAME_EXISTS_IN_FOREST ((NTSTATUS) 0xC000041BL)
-#endif
-
-#ifndef STATUS_INVALID_USER_PRINCIPAL_NAME
-# define STATUS_INVALID_USER_PRINCIPAL_NAME ((NTSTATUS) 0xC000041CL)
-#endif
-
-#ifndef STATUS_FATAL_USER_CALLBACK_EXCEPTION
-# define STATUS_FATAL_USER_CALLBACK_EXCEPTION ((NTSTATUS) 0xC000041DL)
-#endif
-
-#ifndef STATUS_ASSERTION_FAILURE
-# define STATUS_ASSERTION_FAILURE ((NTSTATUS) 0xC0000420L)
-#endif
-
-#ifndef STATUS_VERIFIER_STOP
-# define STATUS_VERIFIER_STOP ((NTSTATUS) 0xC0000421L)
-#endif
-
-#ifndef STATUS_CALLBACK_POP_STACK
-# define STATUS_CALLBACK_POP_STACK ((NTSTATUS) 0xC0000423L)
-#endif
-
-#ifndef STATUS_INCOMPATIBLE_DRIVER_BLOCKED
-# define STATUS_INCOMPATIBLE_DRIVER_BLOCKED ((NTSTATUS) 0xC0000424L)
-#endif
-
-#ifndef STATUS_HIVE_UNLOADED
-# define STATUS_HIVE_UNLOADED ((NTSTATUS) 0xC0000425L)
-#endif
-
-#ifndef STATUS_COMPRESSION_DISABLED
-# define STATUS_COMPRESSION_DISABLED ((NTSTATUS) 0xC0000426L)
-#endif
-
-#ifndef STATUS_FILE_SYSTEM_LIMITATION
-# define STATUS_FILE_SYSTEM_LIMITATION ((NTSTATUS) 0xC0000427L)
-#endif
-
-#ifndef STATUS_INVALID_IMAGE_HASH
-# define STATUS_INVALID_IMAGE_HASH ((NTSTATUS) 0xC0000428L)
-#endif
-
-#ifndef STATUS_NOT_CAPABLE
-# define STATUS_NOT_CAPABLE ((NTSTATUS) 0xC0000429L)
-#endif
-
-#ifndef STATUS_REQUEST_OUT_OF_SEQUENCE
-# define STATUS_REQUEST_OUT_OF_SEQUENCE ((NTSTATUS) 0xC000042AL)
-#endif
-
-#ifndef STATUS_IMPLEMENTATION_LIMIT
-# define STATUS_IMPLEMENTATION_LIMIT ((NTSTATUS) 0xC000042BL)
-#endif
-
-#ifndef STATUS_ELEVATION_REQUIRED
-# define STATUS_ELEVATION_REQUIRED ((NTSTATUS) 0xC000042CL)
-#endif
-
-#ifndef STATUS_NO_SECURITY_CONTEXT
-# define STATUS_NO_SECURITY_CONTEXT ((NTSTATUS) 0xC000042DL)
-#endif
-
-#ifndef STATUS_PKU2U_CERT_FAILURE
-# define STATUS_PKU2U_CERT_FAILURE ((NTSTATUS) 0xC000042FL)
-#endif
-
-#ifndef STATUS_BEYOND_VDL
-# define STATUS_BEYOND_VDL ((NTSTATUS) 0xC0000432L)
-#endif
-
-#ifndef STATUS_ENCOUNTERED_WRITE_IN_PROGRESS
-# define STATUS_ENCOUNTERED_WRITE_IN_PROGRESS ((NTSTATUS) 0xC0000433L)
-#endif
-
-#ifndef STATUS_PTE_CHANGED
-# define STATUS_PTE_CHANGED ((NTSTATUS) 0xC0000434L)
-#endif
-
-#ifndef STATUS_PURGE_FAILED
-# define STATUS_PURGE_FAILED ((NTSTATUS) 0xC0000435L)
-#endif
-
-#ifndef STATUS_CRED_REQUIRES_CONFIRMATION
-# define STATUS_CRED_REQUIRES_CONFIRMATION ((NTSTATUS) 0xC0000440L)
-#endif
-
-#ifndef STATUS_CS_ENCRYPTION_INVALID_SERVER_RESPONSE
-# define STATUS_CS_ENCRYPTION_INVALID_SERVER_RESPONSE ((NTSTATUS) 0xC0000441L)
-#endif
-
-#ifndef STATUS_CS_ENCRYPTION_UNSUPPORTED_SERVER
-# define STATUS_CS_ENCRYPTION_UNSUPPORTED_SERVER ((NTSTATUS) 0xC0000442L)
-#endif
-
-#ifndef STATUS_CS_ENCRYPTION_EXISTING_ENCRYPTED_FILE
-# define STATUS_CS_ENCRYPTION_EXISTING_ENCRYPTED_FILE ((NTSTATUS) 0xC0000443L)
-#endif
-
-#ifndef STATUS_CS_ENCRYPTION_NEW_ENCRYPTED_FILE
-# define STATUS_CS_ENCRYPTION_NEW_ENCRYPTED_FILE ((NTSTATUS) 0xC0000444L)
-#endif
-
-#ifndef STATUS_CS_ENCRYPTION_FILE_NOT_CSE
-# define STATUS_CS_ENCRYPTION_FILE_NOT_CSE ((NTSTATUS) 0xC0000445L)
-#endif
-
-#ifndef STATUS_INVALID_LABEL
-# define STATUS_INVALID_LABEL ((NTSTATUS) 0xC0000446L)
-#endif
-
-#ifndef STATUS_DRIVER_PROCESS_TERMINATED
-# define STATUS_DRIVER_PROCESS_TERMINATED ((NTSTATUS) 0xC0000450L)
-#endif
-
-#ifndef STATUS_AMBIGUOUS_SYSTEM_DEVICE
-# define STATUS_AMBIGUOUS_SYSTEM_DEVICE ((NTSTATUS) 0xC0000451L)
-#endif
-
-#ifndef STATUS_SYSTEM_DEVICE_NOT_FOUND
-# define STATUS_SYSTEM_DEVICE_NOT_FOUND ((NTSTATUS) 0xC0000452L)
-#endif
-
-#ifndef STATUS_RESTART_BOOT_APPLICATION
-# define STATUS_RESTART_BOOT_APPLICATION ((NTSTATUS) 0xC0000453L)
-#endif
-
-#ifndef STATUS_INSUFFICIENT_NVRAM_RESOURCES
-# define STATUS_INSUFFICIENT_NVRAM_RESOURCES ((NTSTATUS) 0xC0000454L)
-#endif
-
-#ifndef STATUS_INVALID_TASK_NAME
-# define STATUS_INVALID_TASK_NAME ((NTSTATUS) 0xC0000500L)
-#endif
-
-#ifndef STATUS_INVALID_TASK_INDEX
-# define STATUS_INVALID_TASK_INDEX ((NTSTATUS) 0xC0000501L)
-#endif
-
-#ifndef STATUS_THREAD_ALREADY_IN_TASK
-# define STATUS_THREAD_ALREADY_IN_TASK ((NTSTATUS) 0xC0000502L)
-#endif
-
-#ifndef STATUS_CALLBACK_BYPASS
-# define STATUS_CALLBACK_BYPASS ((NTSTATUS) 0xC0000503L)
-#endif
-
-#ifndef STATUS_FAIL_FAST_EXCEPTION
-# define STATUS_FAIL_FAST_EXCEPTION ((NTSTATUS) 0xC0000602L)
-#endif
-
-#ifndef STATUS_IMAGE_CERT_REVOKED
-# define STATUS_IMAGE_CERT_REVOKED ((NTSTATUS) 0xC0000603L)
-#endif
-
-#ifndef STATUS_PORT_CLOSED
-# define STATUS_PORT_CLOSED ((NTSTATUS) 0xC0000700L)
-#endif
-
-#ifndef STATUS_MESSAGE_LOST
-# define STATUS_MESSAGE_LOST ((NTSTATUS) 0xC0000701L)
-#endif
-
-#ifndef STATUS_INVALID_MESSAGE
-# define STATUS_INVALID_MESSAGE ((NTSTATUS) 0xC0000702L)
-#endif
-
-#ifndef STATUS_REQUEST_CANCELED
-# define STATUS_REQUEST_CANCELED ((NTSTATUS) 0xC0000703L)
-#endif
-
-#ifndef STATUS_RECURSIVE_DISPATCH
-# define STATUS_RECURSIVE_DISPATCH ((NTSTATUS) 0xC0000704L)
-#endif
-
-#ifndef STATUS_LPC_RECEIVE_BUFFER_EXPECTED
-# define STATUS_LPC_RECEIVE_BUFFER_EXPECTED ((NTSTATUS) 0xC0000705L)
-#endif
-
-#ifndef STATUS_LPC_INVALID_CONNECTION_USAGE
-# define STATUS_LPC_INVALID_CONNECTION_USAGE ((NTSTATUS) 0xC0000706L)
-#endif
-
-#ifndef STATUS_LPC_REQUESTS_NOT_ALLOWED
-# define STATUS_LPC_REQUESTS_NOT_ALLOWED ((NTSTATUS) 0xC0000707L)
-#endif
-
-#ifndef STATUS_RESOURCE_IN_USE
-# define STATUS_RESOURCE_IN_USE ((NTSTATUS) 0xC0000708L)
-#endif
-
-#ifndef STATUS_HARDWARE_MEMORY_ERROR
-# define STATUS_HARDWARE_MEMORY_ERROR ((NTSTATUS) 0xC0000709L)
-#endif
-
-#ifndef STATUS_THREADPOOL_HANDLE_EXCEPTION
-# define STATUS_THREADPOOL_HANDLE_EXCEPTION ((NTSTATUS) 0xC000070AL)
-#endif
-
-#ifndef STATUS_THREADPOOL_SET_EVENT_ON_COMPLETION_FAILED
-# define STATUS_THREADPOOL_SET_EVENT_ON_COMPLETION_FAILED ((NTSTATUS) 0xC000070BL)
-#endif
-
-#ifndef STATUS_THREADPOOL_RELEASE_SEMAPHORE_ON_COMPLETION_FAILED
-# define STATUS_THREADPOOL_RELEASE_SEMAPHORE_ON_COMPLETION_FAILED ((NTSTATUS) 0xC000070CL)
-#endif
-
-#ifndef STATUS_THREADPOOL_RELEASE_MUTEX_ON_COMPLETION_FAILED
-# define STATUS_THREADPOOL_RELEASE_MUTEX_ON_COMPLETION_FAILED ((NTSTATUS) 0xC000070DL)
-#endif
-
-#ifndef STATUS_THREADPOOL_FREE_LIBRARY_ON_COMPLETION_FAILED
-# define STATUS_THREADPOOL_FREE_LIBRARY_ON_COMPLETION_FAILED ((NTSTATUS) 0xC000070EL)
-#endif
-
-#ifndef STATUS_THREADPOOL_RELEASED_DURING_OPERATION
-# define STATUS_THREADPOOL_RELEASED_DURING_OPERATION ((NTSTATUS) 0xC000070FL)
-#endif
-
-#ifndef STATUS_CALLBACK_RETURNED_WHILE_IMPERSONATING
-# define STATUS_CALLBACK_RETURNED_WHILE_IMPERSONATING ((NTSTATUS) 0xC0000710L)
-#endif
-
-#ifndef STATUS_APC_RETURNED_WHILE_IMPERSONATING
-# define STATUS_APC_RETURNED_WHILE_IMPERSONATING ((NTSTATUS) 0xC0000711L)
-#endif
-
-#ifndef STATUS_PROCESS_IS_PROTECTED
-# define STATUS_PROCESS_IS_PROTECTED ((NTSTATUS) 0xC0000712L)
-#endif
-
-#ifndef STATUS_MCA_EXCEPTION
-# define STATUS_MCA_EXCEPTION ((NTSTATUS) 0xC0000713L)
-#endif
-
-#ifndef STATUS_CERTIFICATE_MAPPING_NOT_UNIQUE
-# define STATUS_CERTIFICATE_MAPPING_NOT_UNIQUE ((NTSTATUS) 0xC0000714L)
-#endif
-
-#ifndef STATUS_SYMLINK_CLASS_DISABLED
-# define STATUS_SYMLINK_CLASS_DISABLED ((NTSTATUS) 0xC0000715L)
-#endif
-
-#ifndef STATUS_INVALID_IDN_NORMALIZATION
-# define STATUS_INVALID_IDN_NORMALIZATION ((NTSTATUS) 0xC0000716L)
-#endif
-
-#ifndef STATUS_NO_UNICODE_TRANSLATION
-# define STATUS_NO_UNICODE_TRANSLATION ((NTSTATUS) 0xC0000717L)
-#endif
-
-#ifndef STATUS_ALREADY_REGISTERED
-# define STATUS_ALREADY_REGISTERED ((NTSTATUS) 0xC0000718L)
-#endif
-
-#ifndef STATUS_CONTEXT_MISMATCH
-# define STATUS_CONTEXT_MISMATCH ((NTSTATUS) 0xC0000719L)
-#endif
-
-#ifndef STATUS_PORT_ALREADY_HAS_COMPLETION_LIST
-# define STATUS_PORT_ALREADY_HAS_COMPLETION_LIST ((NTSTATUS) 0xC000071AL)
-#endif
-
-#ifndef STATUS_CALLBACK_RETURNED_THREAD_PRIORITY
-# define STATUS_CALLBACK_RETURNED_THREAD_PRIORITY ((NTSTATUS) 0xC000071BL)
-#endif
-
-#ifndef STATUS_INVALID_THREAD
-# define STATUS_INVALID_THREAD ((NTSTATUS) 0xC000071CL)
-#endif
-
-#ifndef STATUS_CALLBACK_RETURNED_TRANSACTION
-# define STATUS_CALLBACK_RETURNED_TRANSACTION ((NTSTATUS) 0xC000071DL)
-#endif
-
-#ifndef STATUS_CALLBACK_RETURNED_LDR_LOCK
-# define STATUS_CALLBACK_RETURNED_LDR_LOCK ((NTSTATUS) 0xC000071EL)
-#endif
-
-#ifndef STATUS_CALLBACK_RETURNED_LANG
-# define STATUS_CALLBACK_RETURNED_LANG ((NTSTATUS) 0xC000071FL)
-#endif
-
-#ifndef STATUS_CALLBACK_RETURNED_PRI_BACK
-# define STATUS_CALLBACK_RETURNED_PRI_BACK ((NTSTATUS) 0xC0000720L)
-#endif
-
-#ifndef STATUS_CALLBACK_RETURNED_THREAD_AFFINITY
-# define STATUS_CALLBACK_RETURNED_THREAD_AFFINITY ((NTSTATUS) 0xC0000721L)
-#endif
-
-#ifndef STATUS_DISK_REPAIR_DISABLED
-# define STATUS_DISK_REPAIR_DISABLED ((NTSTATUS) 0xC0000800L)
-#endif
-
-#ifndef STATUS_DS_DOMAIN_RENAME_IN_PROGRESS
-# define STATUS_DS_DOMAIN_RENAME_IN_PROGRESS ((NTSTATUS) 0xC0000801L)
-#endif
-
-#ifndef STATUS_DISK_QUOTA_EXCEEDED
-# define STATUS_DISK_QUOTA_EXCEEDED ((NTSTATUS) 0xC0000802L)
-#endif
-
-#ifndef STATUS_DATA_LOST_REPAIR
-# define STATUS_DATA_LOST_REPAIR ((NTSTATUS) 0x80000803L)
-#endif
-
-#ifndef STATUS_CONTENT_BLOCKED
-# define STATUS_CONTENT_BLOCKED ((NTSTATUS) 0xC0000804L)
-#endif
-
-#ifndef STATUS_BAD_CLUSTERS
-# define STATUS_BAD_CLUSTERS ((NTSTATUS) 0xC0000805L)
-#endif
-
-#ifndef STATUS_VOLUME_DIRTY
-# define STATUS_VOLUME_DIRTY ((NTSTATUS) 0xC0000806L)
-#endif
-
-#ifndef STATUS_FILE_CHECKED_OUT
-# define STATUS_FILE_CHECKED_OUT ((NTSTATUS) 0xC0000901L)
-#endif
-
-#ifndef STATUS_CHECKOUT_REQUIRED
-# define STATUS_CHECKOUT_REQUIRED ((NTSTATUS) 0xC0000902L)
-#endif
-
-#ifndef STATUS_BAD_FILE_TYPE
-# define STATUS_BAD_FILE_TYPE ((NTSTATUS) 0xC0000903L)
-#endif
-
-#ifndef STATUS_FILE_TOO_LARGE
-# define STATUS_FILE_TOO_LARGE ((NTSTATUS) 0xC0000904L)
-#endif
-
-#ifndef STATUS_FORMS_AUTH_REQUIRED
-# define STATUS_FORMS_AUTH_REQUIRED ((NTSTATUS) 0xC0000905L)
-#endif
-
-#ifndef STATUS_VIRUS_INFECTED
-# define STATUS_VIRUS_INFECTED ((NTSTATUS) 0xC0000906L)
-#endif
-
-#ifndef STATUS_VIRUS_DELETED
-# define STATUS_VIRUS_DELETED ((NTSTATUS) 0xC0000907L)
-#endif
-
-#ifndef STATUS_BAD_MCFG_TABLE
-# define STATUS_BAD_MCFG_TABLE ((NTSTATUS) 0xC0000908L)
-#endif
-
-#ifndef STATUS_CANNOT_BREAK_OPLOCK
-# define STATUS_CANNOT_BREAK_OPLOCK ((NTSTATUS) 0xC0000909L)
-#endif
-
-#ifndef STATUS_WOW_ASSERTION
-# define STATUS_WOW_ASSERTION ((NTSTATUS) 0xC0009898L)
-#endif
-
-#ifndef STATUS_INVALID_SIGNATURE
-# define STATUS_INVALID_SIGNATURE ((NTSTATUS) 0xC000A000L)
-#endif
-
-#ifndef STATUS_HMAC_NOT_SUPPORTED
-# define STATUS_HMAC_NOT_SUPPORTED ((NTSTATUS) 0xC000A001L)
-#endif
-
-#ifndef STATUS_AUTH_TAG_MISMATCH
-# define STATUS_AUTH_TAG_MISMATCH ((NTSTATUS) 0xC000A002L)
-#endif
-
-#ifndef STATUS_IPSEC_QUEUE_OVERFLOW
-# define STATUS_IPSEC_QUEUE_OVERFLOW ((NTSTATUS) 0xC000A010L)
-#endif
-
-#ifndef STATUS_ND_QUEUE_OVERFLOW
-# define STATUS_ND_QUEUE_OVERFLOW ((NTSTATUS) 0xC000A011L)
-#endif
-
-#ifndef STATUS_HOPLIMIT_EXCEEDED
-# define STATUS_HOPLIMIT_EXCEEDED ((NTSTATUS) 0xC000A012L)
-#endif
-
-#ifndef STATUS_PROTOCOL_NOT_SUPPORTED
-# define STATUS_PROTOCOL_NOT_SUPPORTED ((NTSTATUS) 0xC000A013L)
-#endif
-
-#ifndef STATUS_FASTPATH_REJECTED
-# define STATUS_FASTPATH_REJECTED ((NTSTATUS) 0xC000A014L)
-#endif
-
-#ifndef STATUS_LOST_WRITEBEHIND_DATA_NETWORK_DISCONNECTED
-# define STATUS_LOST_WRITEBEHIND_DATA_NETWORK_DISCONNECTED ((NTSTATUS) 0xC000A080L)
-#endif
-
-#ifndef STATUS_LOST_WRITEBEHIND_DATA_NETWORK_SERVER_ERROR
-# define STATUS_LOST_WRITEBEHIND_DATA_NETWORK_SERVER_ERROR ((NTSTATUS) 0xC000A081L)
-#endif
-
-#ifndef STATUS_LOST_WRITEBEHIND_DATA_LOCAL_DISK_ERROR
-# define STATUS_LOST_WRITEBEHIND_DATA_LOCAL_DISK_ERROR ((NTSTATUS) 0xC000A082L)
-#endif
-
-#ifndef STATUS_XML_PARSE_ERROR
-# define STATUS_XML_PARSE_ERROR ((NTSTATUS) 0xC000A083L)
-#endif
-
-#ifndef STATUS_XMLDSIG_ERROR
-# define STATUS_XMLDSIG_ERROR ((NTSTATUS) 0xC000A084L)
-#endif
-
-#ifndef STATUS_WRONG_COMPARTMENT
-# define STATUS_WRONG_COMPARTMENT ((NTSTATUS) 0xC000A085L)
-#endif
-
-#ifndef STATUS_AUTHIP_FAILURE
-# define STATUS_AUTHIP_FAILURE ((NTSTATUS) 0xC000A086L)
-#endif
-
-#ifndef STATUS_DS_OID_MAPPED_GROUP_CANT_HAVE_MEMBERS
-# define STATUS_DS_OID_MAPPED_GROUP_CANT_HAVE_MEMBERS ((NTSTATUS) 0xC000A087L)
-#endif
-
-#ifndef STATUS_DS_OID_NOT_FOUND
-# define STATUS_DS_OID_NOT_FOUND ((NTSTATUS) 0xC000A088L)
-#endif
-
-#ifndef STATUS_HASH_NOT_SUPPORTED
-# define STATUS_HASH_NOT_SUPPORTED ((NTSTATUS) 0xC000A100L)
-#endif
-
-#ifndef STATUS_HASH_NOT_PRESENT
-# define STATUS_HASH_NOT_PRESENT ((NTSTATUS) 0xC000A101L)
-#endif
-
-/* This is not the NTSTATUS_FROM_WIN32 that the DDK provides, because the */
-/* DDK got it wrong! */
-#ifdef NTSTATUS_FROM_WIN32
-# undef NTSTATUS_FROM_WIN32
-#endif
-#define NTSTATUS_FROM_WIN32(error) ((NTSTATUS) (error) <= 0 ? \
-        ((NTSTATUS) (error)) : ((NTSTATUS) (((error) & 0x0000FFFF) | \
-        (FACILITY_NTWIN32 << 16) | ERROR_SEVERITY_WARNING)))
-
-#ifndef JOB_OBJECT_LIMIT_PROCESS_MEMORY
-# define JOB_OBJECT_LIMIT_PROCESS_MEMORY             0x00000100
-#endif
-#ifndef JOB_OBJECT_LIMIT_JOB_MEMORY
-# define JOB_OBJECT_LIMIT_JOB_MEMORY                 0x00000200
-#endif
-#ifndef JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION
-# define JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION 0x00000400
-#endif
-#ifndef JOB_OBJECT_LIMIT_BREAKAWAY_OK
-# define JOB_OBJECT_LIMIT_BREAKAWAY_OK               0x00000800
-#endif
-#ifndef JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK
-# define JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK        0x00001000
-#endif
-#ifndef JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE
-# define JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE          0x00002000
-#endif
-
-/* from winternl.h */
-typedef struct _UNICODE_STRING {
-  USHORT Length;
-  USHORT MaximumLength;
-  PWSTR  Buffer;
-} UNICODE_STRING, *PUNICODE_STRING;
-
-typedef const UNICODE_STRING *PCUNICODE_STRING;
-
-/* from ntifs.h */
-#ifndef DEVICE_TYPE
-# define DEVICE_TYPE DWORD
-#endif
-
-/* MinGW already has a definition for REPARSE_DATA_BUFFER, but mingw-w64 does
- * not.
- */
-#if defined(_MSC_VER) || defined(__MINGW64_VERSION_MAJOR)
-  typedef struct _REPARSE_DATA_BUFFER {
-    ULONG  ReparseTag;
-    USHORT ReparseDataLength;
-    USHORT Reserved;
-    union {
-      struct {
-        USHORT SubstituteNameOffset;
-        USHORT SubstituteNameLength;
-        USHORT PrintNameOffset;
-        USHORT PrintNameLength;
-        ULONG Flags;
-        WCHAR PathBuffer[1];
-      } SymbolicLinkReparseBuffer;
-      struct {
-        USHORT SubstituteNameOffset;
-        USHORT SubstituteNameLength;
-        USHORT PrintNameOffset;
-        USHORT PrintNameLength;
-        WCHAR PathBuffer[1];
-      } MountPointReparseBuffer;
-      struct {
-        UCHAR  DataBuffer[1];
-      } GenericReparseBuffer;
-    };
-  } REPARSE_DATA_BUFFER, *PREPARSE_DATA_BUFFER;
-#endif
-
-typedef struct _IO_STATUS_BLOCK {
-  union {
-    NTSTATUS Status;
-    PVOID Pointer;
-  };
-  ULONG_PTR Information;
-} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;
-
-typedef enum _FILE_INFORMATION_CLASS {
-  FileDirectoryInformation = 1,
-  FileFullDirectoryInformation,
-  FileBothDirectoryInformation,
-  FileBasicInformation,
-  FileStandardInformation,
-  FileInternalInformation,
-  FileEaInformation,
-  FileAccessInformation,
-  FileNameInformation,
-  FileRenameInformation,
-  FileLinkInformation,
-  FileNamesInformation,
-  FileDispositionInformation,
-  FilePositionInformation,
-  FileFullEaInformation,
-  FileModeInformation,
-  FileAlignmentInformation,
-  FileAllInformation,
-  FileAllocationInformation,
-  FileEndOfFileInformation,
-  FileAlternateNameInformation,
-  FileStreamInformation,
-  FilePipeInformation,
-  FilePipeLocalInformation,
-  FilePipeRemoteInformation,
-  FileMailslotQueryInformation,
-  FileMailslotSetInformation,
-  FileCompressionInformation,
-  FileObjectIdInformation,
-  FileCompletionInformation,
-  FileMoveClusterInformation,
-  FileQuotaInformation,
-  FileReparsePointInformation,
-  FileNetworkOpenInformation,
-  FileAttributeTagInformation,
-  FileTrackingInformation,
-  FileIdBothDirectoryInformation,
-  FileIdFullDirectoryInformation,
-  FileValidDataLengthInformation,
-  FileShortNameInformation,
-  FileIoCompletionNotificationInformation,
-  FileIoStatusBlockRangeInformation,
-  FileIoPriorityHintInformation,
-  FileSfioReserveInformation,
-  FileSfioVolumeInformation,
-  FileHardLinkInformation,
-  FileProcessIdsUsingFileInformation,
-  FileNormalizedNameInformation,
-  FileNetworkPhysicalNameInformation,
-  FileIdGlobalTxDirectoryInformation,
-  FileIsRemoteDeviceInformation,
-  FileAttributeCacheInformation,
-  FileNumaNodeInformation,
-  FileStandardLinkInformation,
-  FileRemoteProtocolInformation,
-  FileMaximumInformation
-} FILE_INFORMATION_CLASS, *PFILE_INFORMATION_CLASS;
-
-typedef struct _FILE_DIRECTORY_INFORMATION {
-  ULONG NextEntryOffset;
-  ULONG FileIndex;
-  LARGE_INTEGER CreationTime;
-  LARGE_INTEGER LastAccessTime;
-  LARGE_INTEGER LastWriteTime;
-  LARGE_INTEGER ChangeTime;
-  LARGE_INTEGER EndOfFile;
-  LARGE_INTEGER AllocationSize;
-  ULONG FileAttributes;
-  ULONG FileNameLength;
-  WCHAR FileName[1];
-} FILE_DIRECTORY_INFORMATION, *PFILE_DIRECTORY_INFORMATION;
-
-typedef struct _FILE_BOTH_DIR_INFORMATION {
-  ULONG NextEntryOffset;
-  ULONG FileIndex;
-  LARGE_INTEGER CreationTime;
-  LARGE_INTEGER LastAccessTime;
-  LARGE_INTEGER LastWriteTime;
-  LARGE_INTEGER ChangeTime;
-  LARGE_INTEGER EndOfFile;
-  LARGE_INTEGER AllocationSize;
-  ULONG FileAttributes;
-  ULONG FileNameLength;
-  ULONG EaSize;
-  CCHAR ShortNameLength;
-  WCHAR ShortName[12];
-  WCHAR FileName[1];
-} FILE_BOTH_DIR_INFORMATION, *PFILE_BOTH_DIR_INFORMATION;
-
-typedef struct _FILE_BASIC_INFORMATION {
-  LARGE_INTEGER CreationTime;
-  LARGE_INTEGER LastAccessTime;
-  LARGE_INTEGER LastWriteTime;
-  LARGE_INTEGER ChangeTime;
-  DWORD FileAttributes;
-} FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;
-
-typedef struct _FILE_STANDARD_INFORMATION {
-  LARGE_INTEGER AllocationSize;
-  LARGE_INTEGER EndOfFile;
-  ULONG         NumberOfLinks;
-  BOOLEAN       DeletePending;
-  BOOLEAN       Directory;
-} FILE_STANDARD_INFORMATION, *PFILE_STANDARD_INFORMATION;
-
-typedef struct _FILE_INTERNAL_INFORMATION {
-  LARGE_INTEGER IndexNumber;
-} FILE_INTERNAL_INFORMATION, *PFILE_INTERNAL_INFORMATION;
-
-typedef struct _FILE_EA_INFORMATION {
-  ULONG EaSize;
-} FILE_EA_INFORMATION, *PFILE_EA_INFORMATION;
-
-typedef struct _FILE_ACCESS_INFORMATION {
-  ACCESS_MASK AccessFlags;
-} FILE_ACCESS_INFORMATION, *PFILE_ACCESS_INFORMATION;
-
-typedef struct _FILE_POSITION_INFORMATION {
-  LARGE_INTEGER CurrentByteOffset;
-} FILE_POSITION_INFORMATION, *PFILE_POSITION_INFORMATION;
-
-typedef struct _FILE_MODE_INFORMATION {
-  ULONG Mode;
-} FILE_MODE_INFORMATION, *PFILE_MODE_INFORMATION;
-
-typedef struct _FILE_ALIGNMENT_INFORMATION {
-  ULONG AlignmentRequirement;
-} FILE_ALIGNMENT_INFORMATION, *PFILE_ALIGNMENT_INFORMATION;
-
-typedef struct _FILE_NAME_INFORMATION {
-  ULONG FileNameLength;
-  WCHAR FileName[1];
-} FILE_NAME_INFORMATION, *PFILE_NAME_INFORMATION;
-
-typedef struct _FILE_END_OF_FILE_INFORMATION {
-  LARGE_INTEGER  EndOfFile;
-} FILE_END_OF_FILE_INFORMATION, *PFILE_END_OF_FILE_INFORMATION;
-
-typedef struct _FILE_ALL_INFORMATION {
-  FILE_BASIC_INFORMATION     BasicInformation;
-  FILE_STANDARD_INFORMATION  StandardInformation;
-  FILE_INTERNAL_INFORMATION  InternalInformation;
-  FILE_EA_INFORMATION        EaInformation;
-  FILE_ACCESS_INFORMATION    AccessInformation;
-  FILE_POSITION_INFORMATION  PositionInformation;
-  FILE_MODE_INFORMATION      ModeInformation;
-  FILE_ALIGNMENT_INFORMATION AlignmentInformation;
-  FILE_NAME_INFORMATION      NameInformation;
-} FILE_ALL_INFORMATION, *PFILE_ALL_INFORMATION;
-
-typedef struct _FILE_DISPOSITION_INFORMATION {
-  BOOLEAN DeleteFile;
-} FILE_DISPOSITION_INFORMATION, *PFILE_DISPOSITION_INFORMATION;
-
-typedef struct _FILE_PIPE_LOCAL_INFORMATION {
-  ULONG NamedPipeType;
-  ULONG NamedPipeConfiguration;
-  ULONG MaximumInstances;
-  ULONG CurrentInstances;
-  ULONG InboundQuota;
-  ULONG ReadDataAvailable;
-  ULONG OutboundQuota;
-  ULONG WriteQuotaAvailable;
-  ULONG NamedPipeState;
-  ULONG NamedPipeEnd;
-} FILE_PIPE_LOCAL_INFORMATION, *PFILE_PIPE_LOCAL_INFORMATION;
-
-#define FILE_SYNCHRONOUS_IO_ALERT               0x00000010
-#define FILE_SYNCHRONOUS_IO_NONALERT            0x00000020
-
-typedef enum _FS_INFORMATION_CLASS {
-  FileFsVolumeInformation       = 1,
-  FileFsLabelInformation        = 2,
-  FileFsSizeInformation         = 3,
-  FileFsDeviceInformation       = 4,
-  FileFsAttributeInformation    = 5,
-  FileFsControlInformation      = 6,
-  FileFsFullSizeInformation     = 7,
-  FileFsObjectIdInformation     = 8,
-  FileFsDriverPathInformation   = 9,
-  FileFsVolumeFlagsInformation  = 10,
-  FileFsSectorSizeInformation   = 11
-} FS_INFORMATION_CLASS, *PFS_INFORMATION_CLASS;
-
-typedef struct _FILE_FS_VOLUME_INFORMATION {
-  LARGE_INTEGER VolumeCreationTime;
-  ULONG         VolumeSerialNumber;
-  ULONG         VolumeLabelLength;
-  BOOLEAN       SupportsObjects;
-  WCHAR         VolumeLabel[1];
-} FILE_FS_VOLUME_INFORMATION, *PFILE_FS_VOLUME_INFORMATION;
-
-typedef struct _FILE_FS_LABEL_INFORMATION {
-  ULONG VolumeLabelLength;
-  WCHAR VolumeLabel[1];
-} FILE_FS_LABEL_INFORMATION, *PFILE_FS_LABEL_INFORMATION;
-
-typedef struct _FILE_FS_SIZE_INFORMATION {
-  LARGE_INTEGER TotalAllocationUnits;
-  LARGE_INTEGER AvailableAllocationUnits;
-  ULONG         SectorsPerAllocationUnit;
-  ULONG         BytesPerSector;
-} FILE_FS_SIZE_INFORMATION, *PFILE_FS_SIZE_INFORMATION;
-
-typedef struct _FILE_FS_DEVICE_INFORMATION {
-  DEVICE_TYPE DeviceType;
-  ULONG       Characteristics;
-} FILE_FS_DEVICE_INFORMATION, *PFILE_FS_DEVICE_INFORMATION;
-
-typedef struct _FILE_FS_ATTRIBUTE_INFORMATION {
-  ULONG FileSystemAttributes;
-  LONG  MaximumComponentNameLength;
-  ULONG FileSystemNameLength;
-  WCHAR FileSystemName[1];
-} FILE_FS_ATTRIBUTE_INFORMATION, *PFILE_FS_ATTRIBUTE_INFORMATION;
-
-typedef struct _FILE_FS_CONTROL_INFORMATION {
-  LARGE_INTEGER FreeSpaceStartFiltering;
-  LARGE_INTEGER FreeSpaceThreshold;
-  LARGE_INTEGER FreeSpaceStopFiltering;
-  LARGE_INTEGER DefaultQuotaThreshold;
-  LARGE_INTEGER DefaultQuotaLimit;
-  ULONG         FileSystemControlFlags;
-} FILE_FS_CONTROL_INFORMATION, *PFILE_FS_CONTROL_INFORMATION;
-
-typedef struct _FILE_FS_FULL_SIZE_INFORMATION {
-  LARGE_INTEGER TotalAllocationUnits;
-  LARGE_INTEGER CallerAvailableAllocationUnits;
-  LARGE_INTEGER ActualAvailableAllocationUnits;
-  ULONG         SectorsPerAllocationUnit;
-  ULONG         BytesPerSector;
-} FILE_FS_FULL_SIZE_INFORMATION, *PFILE_FS_FULL_SIZE_INFORMATION;
-
-typedef struct _FILE_FS_OBJECTID_INFORMATION {
-  UCHAR ObjectId[16];
-  UCHAR ExtendedInfo[48];
-} FILE_FS_OBJECTID_INFORMATION, *PFILE_FS_OBJECTID_INFORMATION;
-
-typedef struct _FILE_FS_DRIVER_PATH_INFORMATION {
-  BOOLEAN DriverInPath;
-  ULONG   DriverNameLength;
-  WCHAR   DriverName[1];
-} FILE_FS_DRIVER_PATH_INFORMATION, *PFILE_FS_DRIVER_PATH_INFORMATION;
-
-typedef struct _FILE_FS_VOLUME_FLAGS_INFORMATION {
-  ULONG Flags;
-} FILE_FS_VOLUME_FLAGS_INFORMATION, *PFILE_FS_VOLUME_FLAGS_INFORMATION;
-
-typedef struct _FILE_FS_SECTOR_SIZE_INFORMATION {
-  ULONG LogicalBytesPerSector;
-  ULONG PhysicalBytesPerSectorForAtomicity;
-  ULONG PhysicalBytesPerSectorForPerformance;
-  ULONG FileSystemEffectivePhysicalBytesPerSectorForAtomicity;
-  ULONG Flags;
-  ULONG ByteOffsetForSectorAlignment;
-  ULONG ByteOffsetForPartitionAlignment;
-} FILE_FS_SECTOR_SIZE_INFORMATION, *PFILE_FS_SECTOR_SIZE_INFORMATION;
-
-typedef struct _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION {
-    LARGE_INTEGER IdleTime;
-    LARGE_INTEGER KernelTime;
-    LARGE_INTEGER UserTime;
-    LARGE_INTEGER DpcTime;
-    LARGE_INTEGER InterruptTime;
-    ULONG InterruptCount;
-} SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION, *PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION;
-
-#ifndef SystemProcessorPerformanceInformation
-# define SystemProcessorPerformanceInformation 8
-#endif
-
-#ifndef FILE_DEVICE_FILE_SYSTEM
-# define FILE_DEVICE_FILE_SYSTEM 0x00000009
-#endif
-
-#ifndef FILE_DEVICE_NETWORK
-# define FILE_DEVICE_NETWORK 0x00000012
-#endif
-
-#ifndef METHOD_BUFFERED
-# define METHOD_BUFFERED 0
-#endif
-
-#ifndef METHOD_IN_DIRECT
-# define METHOD_IN_DIRECT 1
-#endif
-
-#ifndef METHOD_OUT_DIRECT
-# define METHOD_OUT_DIRECT 2
-#endif
-
-#ifndef METHOD_NEITHER
-#define METHOD_NEITHER 3
-#endif
-
-#ifndef METHOD_DIRECT_TO_HARDWARE
-# define METHOD_DIRECT_TO_HARDWARE METHOD_IN_DIRECT
-#endif
-
-#ifndef METHOD_DIRECT_FROM_HARDWARE
-# define METHOD_DIRECT_FROM_HARDWARE METHOD_OUT_DIRECT
-#endif
-
-#ifndef FILE_ANY_ACCESS
-# define FILE_ANY_ACCESS 0
-#endif
-
-#ifndef FILE_SPECIAL_ACCESS
-# define FILE_SPECIAL_ACCESS (FILE_ANY_ACCESS)
-#endif
-
-#ifndef FILE_READ_ACCESS
-# define FILE_READ_ACCESS 0x0001
-#endif
-
-#ifndef FILE_WRITE_ACCESS
-# define FILE_WRITE_ACCESS 0x0002
-#endif
-
-#ifndef CTL_CODE
-# define CTL_CODE(device_type, function, method, access)                      \
-    (((device_type) << 16) | ((access) << 14) | ((function) << 2) | (method))
-#endif
-
-#ifndef FSCTL_SET_REPARSE_POINT
-# define FSCTL_SET_REPARSE_POINT CTL_CODE(FILE_DEVICE_FILE_SYSTEM,            \
-                                          41,                                 \
-                                          METHOD_BUFFERED,                    \
-                                          FILE_SPECIAL_ACCESS)
-#endif
-
-#ifndef FSCTL_GET_REPARSE_POINT
-# define FSCTL_GET_REPARSE_POINT CTL_CODE(FILE_DEVICE_FILE_SYSTEM,            \
-                                          42,                                 \
-                                          METHOD_BUFFERED,                    \
-                                          FILE_ANY_ACCESS)
-#endif
-
-#ifndef FSCTL_DELETE_REPARSE_POINT
-# define FSCTL_DELETE_REPARSE_POINT CTL_CODE(FILE_DEVICE_FILE_SYSTEM,         \
-                                             43,                              \
-                                             METHOD_BUFFERED,                 \
-                                             FILE_SPECIAL_ACCESS)
-#endif
-
-#ifndef IO_REPARSE_TAG_SYMLINK
-# define IO_REPARSE_TAG_SYMLINK (0xA000000CL)
-#endif
-
-typedef VOID (NTAPI *PIO_APC_ROUTINE)
-             (PVOID ApcContext,
-              PIO_STATUS_BLOCK IoStatusBlock,
-              ULONG Reserved);
-
-typedef ULONG (NTAPI *sRtlNtStatusToDosError)
-              (NTSTATUS Status);
-
-typedef NTSTATUS (NTAPI *sNtDeviceIoControlFile)
-                 (HANDLE FileHandle,
-                  HANDLE Event,
-                  PIO_APC_ROUTINE ApcRoutine,
-                  PVOID ApcContext,
-                  PIO_STATUS_BLOCK IoStatusBlock,
-                  ULONG IoControlCode,
-                  PVOID InputBuffer,
-                  ULONG InputBufferLength,
-                  PVOID OutputBuffer,
-                  ULONG OutputBufferLength);
-
-typedef NTSTATUS (NTAPI *sNtQueryInformationFile)
-                 (HANDLE FileHandle,
-                  PIO_STATUS_BLOCK IoStatusBlock,
-                  PVOID FileInformation,
-                  ULONG Length,
-                  FILE_INFORMATION_CLASS FileInformationClass);
-
-typedef NTSTATUS (NTAPI *sNtSetInformationFile)
-                 (HANDLE FileHandle,
-                  PIO_STATUS_BLOCK IoStatusBlock,
-                  PVOID FileInformation,
-                  ULONG Length,
-                  FILE_INFORMATION_CLASS FileInformationClass);
-
-typedef NTSTATUS (NTAPI *sNtQueryVolumeInformationFile)
-                 (HANDLE FileHandle,
-                  PIO_STATUS_BLOCK IoStatusBlock,
-                  PVOID FsInformation,
-                  ULONG Length,
-                  FS_INFORMATION_CLASS FsInformationClass);
-
-typedef NTSTATUS (NTAPI *sNtQuerySystemInformation)
-                 (UINT SystemInformationClass,
-                  PVOID SystemInformation,
-                  ULONG SystemInformationLength,
-                  PULONG ReturnLength);
-
-typedef NTSTATUS (NTAPI *sNtQueryDirectoryFile)
-                 (HANDLE FileHandle,
-                  HANDLE Event,
-                  PIO_APC_ROUTINE ApcRoutine,
-                  PVOID ApcContext,
-                  PIO_STATUS_BLOCK IoStatusBlock,
-                  PVOID FileInformation,
-                  ULONG Length,
-                  FILE_INFORMATION_CLASS FileInformationClass,
-                  BOOLEAN ReturnSingleEntry,
-                  PUNICODE_STRING FileName,
-                  BOOLEAN RestartScan
-                );
-
-/*
- * Kernel32 headers
- */
-#ifndef FILE_SKIP_COMPLETION_PORT_ON_SUCCESS
-# define FILE_SKIP_COMPLETION_PORT_ON_SUCCESS 0x1
-#endif
-
-#ifndef FILE_SKIP_SET_EVENT_ON_HANDLE
-# define FILE_SKIP_SET_EVENT_ON_HANDLE 0x2
-#endif
-
-#ifndef SYMBOLIC_LINK_FLAG_DIRECTORY
-# define SYMBOLIC_LINK_FLAG_DIRECTORY 0x1
-#endif
-
-#if defined(__MINGW32__) && !defined(__MINGW64_VERSION_MAJOR)
-  typedef struct _OVERLAPPED_ENTRY {
-      ULONG_PTR lpCompletionKey;
-      LPOVERLAPPED lpOverlapped;
-      ULONG_PTR Internal;
-      DWORD dwNumberOfBytesTransferred;
-  } OVERLAPPED_ENTRY, *LPOVERLAPPED_ENTRY;
-#endif
-
-/* from wincon.h */
-#ifndef ENABLE_INSERT_MODE
-# define ENABLE_INSERT_MODE 0x20
-#endif
-
-#ifndef ENABLE_QUICK_EDIT_MODE
-# define ENABLE_QUICK_EDIT_MODE 0x40
-#endif
-
-#ifndef ENABLE_EXTENDED_FLAGS
-# define ENABLE_EXTENDED_FLAGS 0x80
-#endif
-
-/* from winerror.h */
-#ifndef ERROR_ELEVATION_REQUIRED
-# define ERROR_ELEVATION_REQUIRED 740
-#endif
-
-#ifndef ERROR_SYMLINK_NOT_SUPPORTED
-# define ERROR_SYMLINK_NOT_SUPPORTED 1464
-#endif
-
-#ifndef ERROR_MUI_FILE_NOT_FOUND
-# define ERROR_MUI_FILE_NOT_FOUND 15100
-#endif
-
-#ifndef ERROR_MUI_INVALID_FILE
-# define ERROR_MUI_INVALID_FILE 15101
-#endif
-
-#ifndef ERROR_MUI_INVALID_RC_CONFIG
-# define ERROR_MUI_INVALID_RC_CONFIG 15102
-#endif
-
-#ifndef ERROR_MUI_INVALID_LOCALE_NAME
-# define ERROR_MUI_INVALID_LOCALE_NAME 15103
-#endif
-
-#ifndef ERROR_MUI_INVALID_ULTIMATEFALLBACK_NAME
-# define ERROR_MUI_INVALID_ULTIMATEFALLBACK_NAME 15104
-#endif
-
-#ifndef ERROR_MUI_FILE_NOT_LOADED
-# define ERROR_MUI_FILE_NOT_LOADED 15105
-#endif
-
-typedef BOOL (WINAPI *sGetQueuedCompletionStatusEx)
-             (HANDLE CompletionPort,
-              LPOVERLAPPED_ENTRY lpCompletionPortEntries,
-              ULONG ulCount,
-              PULONG ulNumEntriesRemoved,
-              DWORD dwMilliseconds,
-              BOOL fAlertable);
-
-typedef BOOL (WINAPI* sSetFileCompletionNotificationModes)
-             (HANDLE FileHandle,
-              UCHAR Flags);
-
-typedef BOOLEAN (WINAPI* sCreateSymbolicLinkW)
-                (LPCWSTR lpSymlinkFileName,
-                 LPCWSTR lpTargetFileName,
-                 DWORD dwFlags);
-
-typedef BOOL (WINAPI* sCancelIoEx)
-             (HANDLE hFile,
-              LPOVERLAPPED lpOverlapped);
-
-typedef VOID (WINAPI* sInitializeConditionVariable)
-             (PCONDITION_VARIABLE ConditionVariable);
-
-typedef BOOL (WINAPI* sSleepConditionVariableCS)
-             (PCONDITION_VARIABLE ConditionVariable,
-              PCRITICAL_SECTION CriticalSection,
-              DWORD dwMilliseconds);
-
-typedef BOOL (WINAPI* sSleepConditionVariableSRW)
-             (PCONDITION_VARIABLE ConditionVariable,
-              PSRWLOCK SRWLock,
-              DWORD dwMilliseconds,
-              ULONG Flags);
-
-typedef VOID (WINAPI* sWakeAllConditionVariable)
-             (PCONDITION_VARIABLE ConditionVariable);
-
-typedef VOID (WINAPI* sWakeConditionVariable)
-             (PCONDITION_VARIABLE ConditionVariable);
-
-typedef BOOL (WINAPI* sCancelSynchronousIo)
-             (HANDLE hThread);
-
-typedef DWORD (WINAPI* sGetFinalPathNameByHandleW)
-             (HANDLE hFile,
-              LPWSTR lpszFilePath,
-              DWORD cchFilePath,
-              DWORD dwFlags);
-
-/* from powerbase.h */
-#ifndef DEVICE_NOTIFY_CALLBACK
-# define DEVICE_NOTIFY_CALLBACK 2
-#endif
-
-#ifndef PBT_APMRESUMEAUTOMATIC
-# define PBT_APMRESUMEAUTOMATIC 18
-#endif
-
-#ifndef PBT_APMRESUMESUSPEND
-# define PBT_APMRESUMESUSPEND 7
-#endif
-
-typedef ULONG CALLBACK _DEVICE_NOTIFY_CALLBACK_ROUTINE(
-  PVOID Context,
-  ULONG Type,
-  PVOID Setting
-);
-typedef _DEVICE_NOTIFY_CALLBACK_ROUTINE* _PDEVICE_NOTIFY_CALLBACK_ROUTINE;
-
-typedef struct _DEVICE_NOTIFY_SUBSCRIBE_PARAMETERS {
-  _PDEVICE_NOTIFY_CALLBACK_ROUTINE Callback;
-  PVOID Context;
-} _DEVICE_NOTIFY_SUBSCRIBE_PARAMETERS, *_PDEVICE_NOTIFY_SUBSCRIBE_PARAMETERS;
-
-typedef PVOID _HPOWERNOTIFY;
-typedef _HPOWERNOTIFY *_PHPOWERNOTIFY;
-
-typedef DWORD (WINAPI *sPowerRegisterSuspendResumeNotification)
-              (DWORD         Flags,
-               HANDLE        Recipient,
-               _PHPOWERNOTIFY RegistrationHandle);
-
-
-/* Ntdll function pointers */
-extern sRtlNtStatusToDosError pRtlNtStatusToDosError;
-extern sNtDeviceIoControlFile pNtDeviceIoControlFile;
-extern sNtQueryInformationFile pNtQueryInformationFile;
-extern sNtSetInformationFile pNtSetInformationFile;
-extern sNtQueryVolumeInformationFile pNtQueryVolumeInformationFile;
-extern sNtQueryDirectoryFile pNtQueryDirectoryFile;
-extern sNtQuerySystemInformation pNtQuerySystemInformation;
-
-
-/* Kernel32 function pointers */
-extern sGetQueuedCompletionStatusEx pGetQueuedCompletionStatusEx;
-extern sSetFileCompletionNotificationModes pSetFileCompletionNotificationModes;
-extern sCreateSymbolicLinkW pCreateSymbolicLinkW;
-extern sCancelIoEx pCancelIoEx;
-extern sInitializeConditionVariable pInitializeConditionVariable;
-extern sSleepConditionVariableCS pSleepConditionVariableCS;
-extern sSleepConditionVariableSRW pSleepConditionVariableSRW;
-extern sWakeAllConditionVariable pWakeAllConditionVariable;
-extern sWakeConditionVariable pWakeConditionVariable;
-extern sCancelSynchronousIo pCancelSynchronousIo;
-extern sGetFinalPathNameByHandleW pGetFinalPathNameByHandleW;
-
-
-/* Powrprof.dll function pointer */
-extern sPowerRegisterSuspendResumeNotification pPowerRegisterSuspendResumeNotification;
-
-#endif /* UV_WIN_WINAPI_H_ */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/src/win/winsock.h
+++ /dev/null
@@ -1,190 +0,0 @@
-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef UV_WIN_WINSOCK_H_
-#define UV_WIN_WINSOCK_H_
-
-#include <winsock2.h>
-#include <iptypes.h>
-#include <mswsock.h>
-#include <ws2tcpip.h>
-#include <windows.h>
-
-#include "winapi.h"
-
-
-/*
- * MinGW is missing these too
- */
-#ifndef SO_UPDATE_CONNECT_CONTEXT
-# define SO_UPDATE_CONNECT_CONTEXT 0x7010
-#endif
-
-#ifndef TCP_KEEPALIVE
-# define TCP_KEEPALIVE 3
-#endif
-
-#ifndef IPV6_V6ONLY
-# define IPV6_V6ONLY 27
-#endif
-
-#ifndef IPV6_HOPLIMIT
-# define IPV6_HOPLIMIT 21
-#endif
-
-#ifndef SIO_BASE_HANDLE
-# define SIO_BASE_HANDLE 0x48000022
-#endif
-
-/*
- * TDI defines that are only in the DDK.
- * We only need receive flags so far.
- */
-#ifndef TDI_RECEIVE_NORMAL
-  #define TDI_RECEIVE_BROADCAST           0x00000004
-  #define TDI_RECEIVE_MULTICAST           0x00000008
-  #define TDI_RECEIVE_PARTIAL             0x00000010
-  #define TDI_RECEIVE_NORMAL              0x00000020
-  #define TDI_RECEIVE_EXPEDITED           0x00000040
-  #define TDI_RECEIVE_PEEK                0x00000080
-  #define TDI_RECEIVE_NO_RESPONSE_EXP     0x00000100
-  #define TDI_RECEIVE_COPY_LOOKAHEAD      0x00000200
-  #define TDI_RECEIVE_ENTIRE_MESSAGE      0x00000400
-  #define TDI_RECEIVE_AT_DISPATCH_LEVEL   0x00000800
-  #define TDI_RECEIVE_CONTROL_INFO        0x00001000
-  #define TDI_RECEIVE_FORCE_INDICATION    0x00002000
-  #define TDI_RECEIVE_NO_PUSH             0x00004000
-#endif
-
-/*
- * The "Auxiliary Function Driver" is the windows kernel-mode driver that does
- * TCP, UDP etc. Winsock is just a layer that dispatches requests to it.
- * Having these definitions allows us to bypass winsock and make an AFD kernel
- * call directly, avoiding a bug in winsock's recvfrom implementation.
- */
-
-#define AFD_NO_FAST_IO   0x00000001
-#define AFD_OVERLAPPED   0x00000002
-#define AFD_IMMEDIATE    0x00000004
-
-#define AFD_POLL_RECEIVE_BIT            0
-#define AFD_POLL_RECEIVE                (1 << AFD_POLL_RECEIVE_BIT)
-#define AFD_POLL_RECEIVE_EXPEDITED_BIT  1
-#define AFD_POLL_RECEIVE_EXPEDITED      (1 << AFD_POLL_RECEIVE_EXPEDITED_BIT)
-#define AFD_POLL_SEND_BIT               2
-#define AFD_POLL_SEND                   (1 << AFD_POLL_SEND_BIT)
-#define AFD_POLL_DISCONNECT_BIT         3
-#define AFD_POLL_DISCONNECT             (1 << AFD_POLL_DISCONNECT_BIT)
-#define AFD_POLL_ABORT_BIT              4
-#define AFD_POLL_ABORT                  (1 << AFD_POLL_ABORT_BIT)
-#define AFD_POLL_LOCAL_CLOSE_BIT        5
-#define AFD_POLL_LOCAL_CLOSE            (1 << AFD_POLL_LOCAL_CLOSE_BIT)
-#define AFD_POLL_CONNECT_BIT            6
-#define AFD_POLL_CONNECT                (1 << AFD_POLL_CONNECT_BIT)
-#define AFD_POLL_ACCEPT_BIT             7
-#define AFD_POLL_ACCEPT                 (1 << AFD_POLL_ACCEPT_BIT)
-#define AFD_POLL_CONNECT_FAIL_BIT       8
-#define AFD_POLL_CONNECT_FAIL           (1 << AFD_POLL_CONNECT_FAIL_BIT)
-#define AFD_POLL_QOS_BIT                9
-#define AFD_POLL_QOS                    (1 << AFD_POLL_QOS_BIT)
-#define AFD_POLL_GROUP_QOS_BIT          10
-#define AFD_POLL_GROUP_QOS              (1 << AFD_POLL_GROUP_QOS_BIT)
-
-#define AFD_NUM_POLL_EVENTS             11
-#define AFD_POLL_ALL                    ((1 << AFD_NUM_POLL_EVENTS) - 1)
-
-typedef struct _AFD_RECV_DATAGRAM_INFO {
-    LPWSABUF BufferArray;
-    ULONG BufferCount;
-    ULONG AfdFlags;
-    ULONG TdiFlags;
-    struct sockaddr* Address;
-    int* AddressLength;
-} AFD_RECV_DATAGRAM_INFO, *PAFD_RECV_DATAGRAM_INFO;
-
-typedef struct _AFD_RECV_INFO {
-    LPWSABUF BufferArray;
-    ULONG BufferCount;
-    ULONG AfdFlags;
-    ULONG TdiFlags;
-} AFD_RECV_INFO, *PAFD_RECV_INFO;
-
-
-#define _AFD_CONTROL_CODE(operation, method) \
-    ((FSCTL_AFD_BASE) << 12 | (operation << 2) | method)
-
-#define FSCTL_AFD_BASE FILE_DEVICE_NETWORK
-
-#define AFD_RECEIVE            5
-#define AFD_RECEIVE_DATAGRAM   6
-#define AFD_POLL               9
-
-#define IOCTL_AFD_RECEIVE \
-    _AFD_CONTROL_CODE(AFD_RECEIVE, METHOD_NEITHER)
-
-#define IOCTL_AFD_RECEIVE_DATAGRAM \
-    _AFD_CONTROL_CODE(AFD_RECEIVE_DATAGRAM, METHOD_NEITHER)
-
-#define IOCTL_AFD_POLL \
-    _AFD_CONTROL_CODE(AFD_POLL, METHOD_BUFFERED)
-
-#if defined(__MINGW32__) && !defined(__MINGW64_VERSION_MAJOR)
-typedef struct _IP_ADAPTER_UNICAST_ADDRESS_XP {
-  /* FIXME: __C89_NAMELESS was removed */
-  /* __C89_NAMELESS */ union {
-    ULONGLONG Alignment;
-    /* __C89_NAMELESS */ struct {
-      ULONG Length;
-      DWORD Flags;
-    };
-  };
-  struct _IP_ADAPTER_UNICAST_ADDRESS_XP *Next;
-  SOCKET_ADDRESS Address;
-  IP_PREFIX_ORIGIN PrefixOrigin;
-  IP_SUFFIX_ORIGIN SuffixOrigin;
-  IP_DAD_STATE DadState;
-  ULONG ValidLifetime;
-  ULONG PreferredLifetime;
-  ULONG LeaseLifetime;
-} IP_ADAPTER_UNICAST_ADDRESS_XP,*PIP_ADAPTER_UNICAST_ADDRESS_XP;
-
-typedef struct _IP_ADAPTER_UNICAST_ADDRESS_LH {
-  union {
-    ULONGLONG Alignment;
-    struct {
-      ULONG Length;
-      DWORD Flags;
-    };
-  };
-  struct _IP_ADAPTER_UNICAST_ADDRESS_LH *Next;
-  SOCKET_ADDRESS Address;
-  IP_PREFIX_ORIGIN PrefixOrigin;
-  IP_SUFFIX_ORIGIN SuffixOrigin;
-  IP_DAD_STATE DadState;
-  ULONG ValidLifetime;
-  ULONG PreferredLifetime;
-  ULONG LeaseLifetime;
-  UINT8 OnLinkPrefixLength;
-} IP_ADAPTER_UNICAST_ADDRESS_LH,*PIP_ADAPTER_UNICAST_ADDRESS_LH;
-
-#endif
-
-#endif /* UV_WIN_WINSOCK_H_ */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/test/benchmark-list.h
+++ /dev/null
@@ -1,163 +0,0 @@
-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-BENCHMARK_DECLARE (sizes)
-BENCHMARK_DECLARE (loop_count)
-BENCHMARK_DECLARE (loop_count_timed)
-BENCHMARK_DECLARE (ping_pongs)
-BENCHMARK_DECLARE (tcp_write_batch)
-BENCHMARK_DECLARE (tcp4_pound_100)
-BENCHMARK_DECLARE (tcp4_pound_1000)
-BENCHMARK_DECLARE (pipe_pound_100)
-BENCHMARK_DECLARE (pipe_pound_1000)
-BENCHMARK_DECLARE (tcp_pump100_client)
-BENCHMARK_DECLARE (tcp_pump1_client)
-BENCHMARK_DECLARE (pipe_pump100_client)
-BENCHMARK_DECLARE (pipe_pump1_client)
-
-BENCHMARK_DECLARE (tcp_multi_accept2)
-BENCHMARK_DECLARE (tcp_multi_accept4)
-BENCHMARK_DECLARE (tcp_multi_accept8)
-
-/* Run until X packets have been sent/received. */
-BENCHMARK_DECLARE (udp_pummel_1v1)
-BENCHMARK_DECLARE (udp_pummel_1v10)
-BENCHMARK_DECLARE (udp_pummel_1v100)
-BENCHMARK_DECLARE (udp_pummel_1v1000)
-BENCHMARK_DECLARE (udp_pummel_10v10)
-BENCHMARK_DECLARE (udp_pummel_10v100)
-BENCHMARK_DECLARE (udp_pummel_10v1000)
-BENCHMARK_DECLARE (udp_pummel_100v100)
-BENCHMARK_DECLARE (udp_pummel_100v1000)
-BENCHMARK_DECLARE (udp_pummel_1000v1000)
-
-/* Run until X seconds have elapsed. */
-BENCHMARK_DECLARE (udp_timed_pummel_1v1)
-BENCHMARK_DECLARE (udp_timed_pummel_1v10)
-BENCHMARK_DECLARE (udp_timed_pummel_1v100)
-BENCHMARK_DECLARE (udp_timed_pummel_1v1000)
-BENCHMARK_DECLARE (udp_timed_pummel_10v10)
-BENCHMARK_DECLARE (udp_timed_pummel_10v100)
-BENCHMARK_DECLARE (udp_timed_pummel_10v1000)
-BENCHMARK_DECLARE (udp_timed_pummel_100v100)
-BENCHMARK_DECLARE (udp_timed_pummel_100v1000)
-BENCHMARK_DECLARE (udp_timed_pummel_1000v1000)
-
-BENCHMARK_DECLARE (getaddrinfo)
-BENCHMARK_DECLARE (fs_stat)
-BENCHMARK_DECLARE (async1)
-BENCHMARK_DECLARE (async2)
-BENCHMARK_DECLARE (async4)
-BENCHMARK_DECLARE (async8)
-BENCHMARK_DECLARE (async_pummel_1)
-BENCHMARK_DECLARE (async_pummel_2)
-BENCHMARK_DECLARE (async_pummel_4)
-BENCHMARK_DECLARE (async_pummel_8)
-BENCHMARK_DECLARE (spawn)
-BENCHMARK_DECLARE (thread_create)
-BENCHMARK_DECLARE (million_async)
-BENCHMARK_DECLARE (million_timers)
-HELPER_DECLARE    (tcp4_blackhole_server)
-HELPER_DECLARE    (tcp_pump_server)
-HELPER_DECLARE    (pipe_pump_server)
-HELPER_DECLARE    (tcp4_echo_server)
-HELPER_DECLARE    (pipe_echo_server)
-HELPER_DECLARE    (dns_server)
-
-TASK_LIST_START
-  BENCHMARK_ENTRY  (sizes)
-  BENCHMARK_ENTRY  (loop_count)
-  BENCHMARK_ENTRY  (loop_count_timed)
-
-  BENCHMARK_ENTRY  (ping_pongs)
-  BENCHMARK_HELPER (ping_pongs, tcp4_echo_server)
-
-  BENCHMARK_ENTRY  (tcp_write_batch)
-  BENCHMARK_HELPER (tcp_write_batch, tcp4_blackhole_server)
-
-  BENCHMARK_ENTRY  (tcp_pump100_client)
-  BENCHMARK_HELPER (tcp_pump100_client, tcp_pump_server)
-
-  BENCHMARK_ENTRY  (tcp_pump1_client)
-  BENCHMARK_HELPER (tcp_pump1_client, tcp_pump_server)
-
-  BENCHMARK_ENTRY  (tcp4_pound_100)
-  BENCHMARK_HELPER (tcp4_pound_100, tcp4_echo_server)
-
-  BENCHMARK_ENTRY  (tcp4_pound_1000)
-  BENCHMARK_HELPER (tcp4_pound_1000, tcp4_echo_server)
-
-  BENCHMARK_ENTRY  (pipe_pump100_client)
-  BENCHMARK_HELPER (pipe_pump100_client, pipe_pump_server)
-
-  BENCHMARK_ENTRY  (pipe_pump1_client)
-  BENCHMARK_HELPER (pipe_pump1_client, pipe_pump_server)
-
-  BENCHMARK_ENTRY  (pipe_pound_100)
-  BENCHMARK_HELPER (pipe_pound_100, pipe_echo_server)
-
-  BENCHMARK_ENTRY  (pipe_pound_1000)
-  BENCHMARK_HELPER (pipe_pound_1000, pipe_echo_server)
-
-  BENCHMARK_ENTRY  (tcp_multi_accept2)
-  BENCHMARK_ENTRY  (tcp_multi_accept4)
-  BENCHMARK_ENTRY  (tcp_multi_accept8)
-
-  BENCHMARK_ENTRY  (udp_pummel_1v1)
-  BENCHMARK_ENTRY  (udp_pummel_1v10)
-  BENCHMARK_ENTRY  (udp_pummel_1v100)
-  BENCHMARK_ENTRY  (udp_pummel_1v1000)
-  BENCHMARK_ENTRY  (udp_pummel_10v10)
-  BENCHMARK_ENTRY  (udp_pummel_10v100)
-  BENCHMARK_ENTRY  (udp_pummel_10v1000)
-  BENCHMARK_ENTRY  (udp_pummel_100v100)
-  BENCHMARK_ENTRY  (udp_pummel_100v1000)
-  BENCHMARK_ENTRY  (udp_pummel_1000v1000)
-
-  BENCHMARK_ENTRY  (udp_timed_pummel_1v1)
-  BENCHMARK_ENTRY  (udp_timed_pummel_1v10)
-  BENCHMARK_ENTRY  (udp_timed_pummel_1v100)
-  BENCHMARK_ENTRY  (udp_timed_pummel_1v1000)
-  BENCHMARK_ENTRY  (udp_timed_pummel_10v10)
-  BENCHMARK_ENTRY  (udp_timed_pummel_10v100)
-  BENCHMARK_ENTRY  (udp_timed_pummel_10v1000)
-  BENCHMARK_ENTRY  (udp_timed_pummel_100v100)
-  BENCHMARK_ENTRY  (udp_timed_pummel_100v1000)
-  BENCHMARK_ENTRY  (udp_timed_pummel_1000v1000)
-
-  BENCHMARK_ENTRY  (getaddrinfo)
-
-  BENCHMARK_ENTRY  (fs_stat)
-
-  BENCHMARK_ENTRY  (async1)
-  BENCHMARK_ENTRY  (async2)
-  BENCHMARK_ENTRY  (async4)
-  BENCHMARK_ENTRY  (async8)
-  BENCHMARK_ENTRY  (async_pummel_1)
-  BENCHMARK_ENTRY  (async_pummel_2)
-  BENCHMARK_ENTRY  (async_pummel_4)
-  BENCHMARK_ENTRY  (async_pummel_8)
-
-  BENCHMARK_ENTRY  (spawn)
-  BENCHMARK_ENTRY  (thread_create)
-  BENCHMARK_ENTRY  (million_async)
-  BENCHMARK_ENTRY  (million_timers)
-TASK_LIST_END
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/test/runner-unix.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef TEST_RUNNER_UNIX_H
-#define TEST_RUNNER_UNIX_H
-
-#include <sys/types.h>
-#include <stdio.h> /* FILE */
-
-typedef struct {
-  FILE* stdout_file;
-  pid_t pid;
-  char* name;
-  int status;
-  int terminated;
-} process_info_t;
-
-#endif  /* TEST_RUNNER_UNIX_H */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/test/runner-win.h
+++ /dev/null
@@ -1,39 +0,0 @@
-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-/* Don't complain about write(), fileno() etc. being deprecated. */
-#pragma warning(disable : 4996)
-
-
-#include <winsock2.h>
-#include <windows.h>
-#include <stdio.h>
-
-#if !defined(snprintf) && defined(_MSC_VER) && _MSC_VER < 1900
-extern int snprintf(char*, size_t, const char*, ...);
-#endif
-
-typedef struct {
-  HANDLE process;
-  HANDLE stdio_in;
-  HANDLE stdio_out;
-  char *name;
-} process_info_t;
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/test/runner.h
+++ /dev/null
@@ -1,177 +0,0 @@
-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef RUNNER_H_
-#define RUNNER_H_
-
-#include <limits.h> /* PATH_MAX */
-#include <stdio.h> /* FILE */
-
-
-/*
- * The maximum number of processes (main + helpers) that a test / benchmark
- * can have.
- */
-#define MAX_PROCESSES 8
-
-
-/*
- * Struct to store both tests and to define helper processes for tasks.
- */
-typedef struct {
-  char *task_name;
-  char *process_name;
-  int (*main)(void);
-  int is_helper;
-  int show_output;
-
-  /*
-   * The time in milliseconds after which a single test or benchmark times out.
-   */
-  int timeout;
-} task_entry_t, bench_entry_t;
-
-
-/*
- * Macros used by test-list.h and benchmark-list.h.
- */
-#define TASK_LIST_START                             \
-  task_entry_t TASKS[] = {
-
-#define TASK_LIST_END                               \
-    { 0, 0, 0, 0, 0, 0 }                               \
-  };
-
-#define TEST_DECLARE(name)                          \
-  int run_test_##name(void);
-
-#define TEST_ENTRY(name)                            \
-    { #name, #name, &run_test_##name, 0, 0, 5000 },
-
-#define TEST_ENTRY_CUSTOM(name, is_helper, show_output, timeout) \
-    { #name, #name, &run_test_##name, is_helper, show_output, timeout },
-
-#define BENCHMARK_DECLARE(name)                     \
-  int run_benchmark_##name(void);
-
-#define BENCHMARK_ENTRY(name)                       \
-    { #name, #name, &run_benchmark_##name, 0, 0, 60000 },
-
-#define HELPER_DECLARE(name)                        \
-  int run_helper_##name(void);
-
-#define HELPER_ENTRY(task_name, name)               \
-    { #task_name, #name, &run_helper_##name, 1, 0, 0 },
-
-#define TEST_HELPER       HELPER_ENTRY
-#define BENCHMARK_HELPER  HELPER_ENTRY
-
-#ifdef PATH_MAX
-extern char executable_path[PATH_MAX];
-#else
-extern char executable_path[4096];
-#endif
-
-/*
- * Include platform-dependent definitions
- */
-#ifdef _WIN32
-# include "runner-win.h"
-#else
-# include "runner-unix.h"
-#endif
-
-
-/* The array that is filled by test-list.h or benchmark-list.h */
-extern task_entry_t TASKS[];
-
-/*
- * Run all tests.
- */
-int run_tests(int benchmark_output);
-
-/*
- * Run a single test. Starts up any helpers.
- */
-int run_test(const char* test,
-             int benchmark_output,
-             int test_count);
-
-/*
- * Run a test part, i.e. the test or one of its helpers.
- */
-int run_test_part(const char* test, const char* part);
-
-
-/*
- * Print tests in sorted order to `stream`. Used by `./run-tests --list`.
- */
-void print_tests(FILE* stream);
-
-/* Print lines in |buffer| as TAP diagnostics to |stream|. */
-void print_lines(const char* buffer, size_t size, FILE* stream);
-
-/*
- * Stuff that should be implemented by test-runner-<platform>.h
- * All functions return 0 on success, -1 on failure, unless specified
- * otherwise.
- */
-
-/* Do platform-specific initialization. */
-int platform_init(int argc, char** argv);
-
-/* Invoke "argv[0] test-name [test-part]". Store process info in *p. */
-/* Make sure that all stdio output of the processes is buffered up. */
-int process_start(char *name, char* part, process_info_t *p, int is_helper);
-
-/* Wait for all `n` processes in `vec` to terminate. */
-/* Time out after `timeout` msec, or never if timeout == -1 */
-/* Return 0 if all processes are terminated, -1 on error, -2 on timeout. */
-int process_wait(process_info_t *vec, int n, int timeout);
-
-/* Returns the number of bytes in the stdio output buffer for process `p`. */
-long int process_output_size(process_info_t *p);
-
-/* Copy the contents of the stdio output buffer to `stream`. */
-int process_copy_output(process_info_t* p, FILE* stream);
-
-/* Copy the last line of the stdio output buffer to `buffer` */
-int process_read_last_line(process_info_t *p,
-                           char * buffer,
-                           size_t buffer_len);
-
-/* Return the name that was specified when `p` was started by process_start */
-char* process_get_name(process_info_t *p);
-
-/* Terminate process `p`. */
-int process_terminate(process_info_t *p);
-
-/* Return the exit code of process p. */
-/* On error, return -1. */
-int process_reap(process_info_t *p);
-
-/* Clean up after terminating process `p` (e.g. free the output buffer etc.). */
-void process_cleanup(process_info_t *p);
-
-/* Move the console cursor one line up and back to the first column. */
-void rewind_cursor(void);
-
-#endif /* RUNNER_H_ */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/test/task.h
+++ /dev/null
@@ -1,212 +0,0 @@
-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef TASK_H_
-#define TASK_H_
-
-#include "uv.h"
-
-#include <stdio.h>
-#include <stddef.h>
-#include <stdlib.h>
-
-#if defined(_MSC_VER) && _MSC_VER < 1600
-# include "stdint-msvc2008.h"
-#else
-# include <stdint.h>
-#endif
-
-#if !defined(_WIN32)
-# include <sys/time.h>
-# include <sys/resource.h>  /* setrlimit() */
-#endif
-
-#ifdef __clang__
-# pragma clang diagnostic ignored "-Wvariadic-macros"
-# pragma clang diagnostic ignored "-Wc99-extensions"
-#endif
-
-#define TEST_PORT 9123
-#define TEST_PORT_2 9124
-
-#ifdef _WIN32
-# define TEST_PIPENAME "\\\\?\\pipe\\uv-test"
-# define TEST_PIPENAME_2 "\\\\?\\pipe\\uv-test2"
-# define TEST_PIPENAME_3 "\\\\?\\pipe\\uv-test3"
-#else
-# define TEST_PIPENAME "/tmp/uv-test-sock"
-# define TEST_PIPENAME_2 "/tmp/uv-test-sock2"
-# define TEST_PIPENAME_3 "/tmp/uv-test-sock3"
-#endif
-
-#ifdef _WIN32
-# include <io.h>
-# ifndef S_IRUSR
-#  define S_IRUSR _S_IREAD
-# endif
-# ifndef S_IWUSR
-#  define S_IWUSR _S_IWRITE
-# endif
-#endif
-
-#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))
-
-#define container_of(ptr, type, member) \
-  ((type *) ((char *) (ptr) - offsetof(type, member)))
-
-typedef enum {
-  TCP = 0,
-  UDP,
-  PIPE
-} stream_type;
-
-/* Die with fatal error. */
-#define FATAL(msg)                                        \
-  do {                                                    \
-    fprintf(stderr,                                       \
-            "Fatal error in %s on line %d: %s\n",         \
-            __FILE__,                                     \
-            __LINE__,                                     \
-            msg);                                         \
-    fflush(stderr);                                       \
-    abort();                                              \
-  } while (0)
-
-/* Have our own assert, so we are sure it does not get optimized away in
- * a release build.
- */
-#define ASSERT(expr)                                      \
- do {                                                     \
-  if (!(expr)) {                                          \
-    fprintf(stderr,                                       \
-            "Assertion failed in %s on line %d: %s\n",    \
-            __FILE__,                                     \
-            __LINE__,                                     \
-            #expr);                                       \
-    abort();                                              \
-  }                                                       \
- } while (0)
-
-/* This macro cleans up the main loop. This is used to avoid valgrind
- * warnings about memory being "leaked" by the main event loop.
- */
-#define MAKE_VALGRIND_HAPPY()                       \
-  do {                                              \
-    close_loop(uv_default_loop());                  \
-    ASSERT(0 == uv_loop_close(uv_default_loop()));  \
-  } while (0)
-
-/* Just sugar for wrapping the main() for a task or helper. */
-#define TEST_IMPL(name)                                                       \
-  int run_test_##name(void);                                                  \
-  int run_test_##name(void)
-
-#define BENCHMARK_IMPL(name)                                                  \
-  int run_benchmark_##name(void);                                             \
-  int run_benchmark_##name(void)
-
-#define HELPER_IMPL(name)                                                     \
-  int run_helper_##name(void);                                                \
-  int run_helper_##name(void)
-
-/* Pause the calling thread for a number of milliseconds. */
-void uv_sleep(int msec);
-
-/* Format big numbers nicely. WARNING: leaks memory. */
-const char* fmt(double d);
-
-/* Reserved test exit codes. */
-enum test_status {
-  TEST_OK = 0,
-  TEST_SKIP
-};
-
-#define RETURN_OK()                                                           \
-  do {                                                                        \
-    return TEST_OK;                                                           \
-  } while (0)
-
-#define RETURN_SKIP(explanation)                                              \
-  do {                                                                        \
-    fprintf(stderr, "%s\n", explanation);                                     \
-    fflush(stderr);                                                           \
-    return TEST_SKIP;                                                         \
-  } while (0)
-
-#if !defined(_WIN32)
-
-# define TEST_FILE_LIMIT(num)                                                 \
-    do {                                                                      \
-      struct rlimit lim;                                                      \
-      lim.rlim_cur = (num);                                                   \
-      lim.rlim_max = lim.rlim_cur;                                            \
-      if (setrlimit(RLIMIT_NOFILE, &lim))                                     \
-        RETURN_SKIP("File descriptor limit too low.");                        \
-    } while (0)
-
-#else  /* defined(_WIN32) */
-
-# define TEST_FILE_LIMIT(num) do {} while (0)
-
-#endif
-
-#if !defined(snprintf) && defined(_MSC_VER) && _MSC_VER < 1900
-extern int snprintf(char*, size_t, const char*, ...);
-#endif
-
-#if defined(__clang__) ||                                \
-    defined(__GNUC__) ||                                 \
-    defined(__INTEL_COMPILER) ||                         \
-    defined(__SUNPRO_C)
-# define UNUSED __attribute__((unused))
-#else
-# define UNUSED
-#endif
-
-/* Fully close a loop */
-static void close_walk_cb(uv_handle_t* handle, void* arg) {
-  if (!uv_is_closing(handle))
-    uv_close(handle, NULL);
-}
-
-UNUSED static void close_loop(uv_loop_t* loop) {
-  uv_walk(loop, close_walk_cb, NULL);
-  uv_run(loop, UV_RUN_DEFAULT);
-}
-
-UNUSED static int can_ipv6(void) {
-  uv_interface_address_t* addr;
-  int supported;
-  int count;
-  int i;
-
-  if (uv_interface_addresses(&addr, &count))
-    return 0;  /* Assume no IPv6 support on failure. */
-
-  supported = 0;
-  for (i = 0; supported == 0 && i < count; i += 1)
-    supported = (AF_INET6 == addr[i].address.address6.sin6_family);
-
-  uv_free_interface_addresses(addr, count);
-  return supported;
-}
-
-#endif /* TASK_H_ */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/uv/test/test-list.h
+++ /dev/null
@@ -1,798 +0,0 @@
-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#include "uv.h"
-
-TEST_DECLARE   (platform_output)
-TEST_DECLARE   (callback_order)
-TEST_DECLARE   (close_order)
-TEST_DECLARE   (run_once)
-TEST_DECLARE   (run_nowait)
-TEST_DECLARE   (loop_alive)
-TEST_DECLARE   (loop_close)
-TEST_DECLARE   (loop_stop)
-TEST_DECLARE   (loop_update_time)
-TEST_DECLARE   (loop_backend_timeout)
-TEST_DECLARE   (loop_configure)
-TEST_DECLARE   (default_loop_close)
-TEST_DECLARE   (barrier_1)
-TEST_DECLARE   (barrier_2)
-TEST_DECLARE   (barrier_3)
-TEST_DECLARE   (condvar_1)
-TEST_DECLARE   (condvar_2)
-TEST_DECLARE   (condvar_3)
-TEST_DECLARE   (condvar_4)
-TEST_DECLARE   (condvar_5)
-TEST_DECLARE   (semaphore_1)
-TEST_DECLARE   (semaphore_2)
-TEST_DECLARE   (semaphore_3)
-TEST_DECLARE   (tty)
-#ifdef _WIN32
-TEST_DECLARE   (tty_raw)
-TEST_DECLARE   (tty_empty_write)
-TEST_DECLARE   (tty_large_write)
-#endif
-TEST_DECLARE   (tty_file)
-TEST_DECLARE   (tty_pty)
-TEST_DECLARE   (stdio_over_pipes)
-TEST_DECLARE   (ip6_pton)
-TEST_DECLARE   (ipc_listen_before_write)
-TEST_DECLARE   (ipc_listen_after_write)
-#ifndef _WIN32
-TEST_DECLARE   (ipc_send_recv_pipe)
-TEST_DECLARE   (ipc_send_recv_pipe_inprocess)
-#endif
-TEST_DECLARE   (ipc_send_recv_tcp)
-TEST_DECLARE   (ipc_send_recv_tcp_inprocess)
-TEST_DECLARE   (ipc_tcp_connection)
-TEST_DECLARE   (tcp_alloc_cb_fail)
-TEST_DECLARE   (tcp_ping_pong)
-TEST_DECLARE   (tcp_ping_pong_v6)
-TEST_DECLARE   (pipe_ping_pong)
-TEST_DECLARE   (delayed_accept)
-TEST_DECLARE   (multiple_listen)
-#ifndef _WIN32
-TEST_DECLARE   (tcp_write_after_connect)
-#endif
-TEST_DECLARE   (tcp_writealot)
-TEST_DECLARE   (tcp_write_fail)
-TEST_DECLARE   (tcp_try_write)
-TEST_DECLARE   (tcp_write_queue_order)
-TEST_DECLARE   (tcp_open)
-TEST_DECLARE   (tcp_open_twice)
-TEST_DECLARE   (tcp_connect_error_after_write)
-TEST_DECLARE   (tcp_shutdown_after_write)
-TEST_DECLARE   (tcp_bind_error_addrinuse)
-TEST_DECLARE   (tcp_bind_error_addrnotavail_1)
-TEST_DECLARE   (tcp_bind_error_addrnotavail_2)
-TEST_DECLARE   (tcp_bind_error_fault)
-TEST_DECLARE   (tcp_bind_error_inval)
-TEST_DECLARE   (tcp_bind_localhost_ok)
-TEST_DECLARE   (tcp_bind_invalid_flags)
-TEST_DECLARE   (tcp_listen_without_bind)
-TEST_DECLARE   (tcp_connect_error_fault)
-TEST_DECLARE   (tcp_connect_timeout)
-TEST_DECLARE   (tcp_close_while_connecting)
-TEST_DECLARE   (tcp_close)
-TEST_DECLARE   (tcp_create_early)
-TEST_DECLARE   (tcp_create_early_bad_bind)
-TEST_DECLARE   (tcp_create_early_bad_domain)
-TEST_DECLARE   (tcp_create_early_accept)
-#ifndef _WIN32
-TEST_DECLARE   (tcp_close_accept)
-TEST_DECLARE   (tcp_oob)
-#endif
-TEST_DECLARE   (tcp_flags)
-TEST_DECLARE   (tcp_write_to_half_open_connection)
-TEST_DECLARE   (tcp_unexpected_read)
-TEST_DECLARE   (tcp_read_stop)
-TEST_DECLARE   (tcp_bind6_error_addrinuse)
-TEST_DECLARE   (tcp_bind6_error_addrnotavail)
-TEST_DECLARE   (tcp_bind6_error_fault)
-TEST_DECLARE   (tcp_bind6_error_inval)
-TEST_DECLARE   (tcp_bind6_localhost_ok)
-TEST_DECLARE   (udp_alloc_cb_fail)
-TEST_DECLARE   (udp_bind)
-TEST_DECLARE   (udp_bind_reuseaddr)
-TEST_DECLARE   (udp_create_early)
-TEST_DECLARE   (udp_create_early_bad_bind)
-TEST_DECLARE   (udp_create_early_bad_domain)
-TEST_DECLARE   (udp_send_and_recv)
-TEST_DECLARE   (udp_send_immediate)
-TEST_DECLARE   (udp_send_unreachable)
-TEST_DECLARE   (udp_multicast_join)
-TEST_DECLARE   (udp_multicast_join6)
-TEST_DECLARE   (udp_multicast_ttl)
-TEST_DECLARE   (udp_multicast_interface)
-TEST_DECLARE   (udp_multicast_interface6)
-TEST_DECLARE   (udp_dgram_too_big)
-TEST_DECLARE   (udp_dual_stack)
-TEST_DECLARE   (udp_ipv6_only)
-TEST_DECLARE   (udp_options)
-TEST_DECLARE   (udp_options6)
-TEST_DECLARE   (udp_no_autobind)
-TEST_DECLARE   (udp_open)
-TEST_DECLARE   (udp_open_twice)
-TEST_DECLARE   (udp_try_send)
-TEST_DECLARE   (pipe_bind_error_addrinuse)
-TEST_DECLARE   (pipe_bind_error_addrnotavail)
-TEST_DECLARE   (pipe_bind_error_inval)
-TEST_DECLARE   (pipe_connect_multiple)
-TEST_DECLARE   (pipe_listen_without_bind)
-TEST_DECLARE   (pipe_connect_bad_name)
-TEST_DECLARE   (pipe_connect_to_file)
-TEST_DECLARE   (pipe_connect_on_prepare)
-TEST_DECLARE   (pipe_getsockname)
-TEST_DECLARE   (pipe_getsockname_abstract)
-TEST_DECLARE   (pipe_getsockname_blocking)
-TEST_DECLARE   (pipe_pending_instances)
-TEST_DECLARE   (pipe_sendmsg)
-TEST_DECLARE   (pipe_server_close)
-TEST_DECLARE   (connection_fail)
-TEST_DECLARE   (connection_fail_doesnt_auto_close)
-TEST_DECLARE   (shutdown_close_tcp)
-TEST_DECLARE   (shutdown_close_pipe)
-TEST_DECLARE   (shutdown_eof)
-TEST_DECLARE   (shutdown_twice)
-TEST_DECLARE   (callback_stack)
-TEST_DECLARE   (error_message)
-TEST_DECLARE   (sys_error)
-TEST_DECLARE   (timer)
-TEST_DECLARE   (timer_init)
-TEST_DECLARE   (timer_again)
-TEST_DECLARE   (timer_start_twice)
-TEST_DECLARE   (timer_order)
-TEST_DECLARE   (timer_huge_timeout)
-TEST_DECLARE   (timer_huge_repeat)
-TEST_DECLARE   (timer_run_once)
-TEST_DECLARE   (timer_from_check)
-TEST_DECLARE   (timer_null_callback)
-TEST_DECLARE   (timer_early_check)
-TEST_DECLARE   (idle_starvation)
-TEST_DECLARE   (loop_handles)
-TEST_DECLARE   (get_loadavg)
-TEST_DECLARE   (walk_handles)
-TEST_DECLARE   (watcher_cross_stop)
-TEST_DECLARE   (ref)
-TEST_DECLARE   (idle_ref)
-TEST_DECLARE   (async_ref)
-TEST_DECLARE   (prepare_ref)
-TEST_DECLARE   (check_ref)
-TEST_DECLARE   (unref_in_prepare_cb)
-TEST_DECLARE   (timer_ref)
-TEST_DECLARE   (timer_ref2)
-TEST_DECLARE   (fs_event_ref)
-TEST_DECLARE   (fs_poll_ref)
-TEST_DECLARE   (tcp_ref)
-TEST_DECLARE   (tcp_ref2)
-TEST_DECLARE   (tcp_ref2b)
-TEST_DECLARE   (tcp_ref3)
-TEST_DECLARE   (tcp_ref4)
-TEST_DECLARE   (udp_ref)
-TEST_DECLARE   (udp_ref2)
-TEST_DECLARE   (udp_ref3)
-TEST_DECLARE   (pipe_ref)
-TEST_DECLARE   (pipe_ref2)
-TEST_DECLARE   (pipe_ref3)
-TEST_DECLARE   (pipe_ref4)
-#ifndef _WIN32
-TEST_DECLARE   (pipe_close_stdout_read_stdin)
-#endif
-TEST_DECLARE   (pipe_set_non_blocking)
-TEST_DECLARE   (process_ref)
-TEST_DECLARE   (has_ref)
-TEST_DECLARE   (active)
-TEST_DECLARE   (embed)
-TEST_DECLARE   (async)
-TEST_DECLARE   (async_null_cb)
-TEST_DECLARE   (eintr_handling)
-TEST_DECLARE   (get_currentexe)
-TEST_DECLARE   (process_title)
-TEST_DECLARE   (cwd_and_chdir)
-TEST_DECLARE   (get_memory)
-TEST_DECLARE   (get_passwd)
-TEST_DECLARE   (handle_fileno)
-TEST_DECLARE   (homedir)
-TEST_DECLARE   (tmpdir)
-TEST_DECLARE   (hrtime)
-TEST_DECLARE   (getaddrinfo_fail)
-TEST_DECLARE   (getaddrinfo_fail_sync)
-TEST_DECLARE   (getaddrinfo_basic)
-TEST_DECLARE   (getaddrinfo_basic_sync)
-TEST_DECLARE   (getaddrinfo_concurrent)
-TEST_DECLARE   (getnameinfo_basic_ip4)
-TEST_DECLARE   (getnameinfo_basic_ip4_sync)
-TEST_DECLARE   (getnameinfo_basic_ip6)
-TEST_DECLARE   (getsockname_tcp)
-TEST_DECLARE   (getsockname_udp)
-TEST_DECLARE   (fail_always)
-TEST_DECLARE   (pass_always)
-TEST_DECLARE   (socket_buffer_size)
-TEST_DECLARE   (spawn_fails)
-#ifndef _WIN32
-TEST_DECLARE   (spawn_fails_check_for_waitpid_cleanup)
-#endif
-TEST_DECLARE   (spawn_exit_code)
-TEST_DECLARE   (spawn_stdout)
-TEST_DECLARE   (spawn_stdin)
-TEST_DECLARE   (spawn_stdio_greater_than_3)
-TEST_DECLARE   (spawn_ignored_stdio)
-TEST_DECLARE   (spawn_and_kill)
-TEST_DECLARE   (spawn_detached)
-TEST_DECLARE   (spawn_and_kill_with_std)
-TEST_DECLARE   (spawn_and_ping)
-TEST_DECLARE   (spawn_preserve_env)
-TEST_DECLARE   (spawn_setuid_fails)
-TEST_DECLARE   (spawn_setgid_fails)
-TEST_DECLARE   (spawn_stdout_to_file)
-TEST_DECLARE   (spawn_stdout_and_stderr_to_file)
-TEST_DECLARE   (spawn_stdout_and_stderr_to_file2)
-TEST_DECLARE   (spawn_stdout_and_stderr_to_file_swap)
-TEST_DECLARE   (spawn_auto_unref)
-TEST_DECLARE   (spawn_closed_process_io)
-TEST_DECLARE   (spawn_reads_child_path)
-TEST_DECLARE   (spawn_inherit_streams)
-TEST_DECLARE   (fs_poll)
-TEST_DECLARE   (fs_poll_getpath)
-TEST_DECLARE   (kill)
-TEST_DECLARE   (fs_file_noent)
-TEST_DECLARE   (fs_file_nametoolong)
-TEST_DECLARE   (fs_file_loop)
-TEST_DECLARE   (fs_file_async)
-TEST_DECLARE   (fs_file_sync)
-TEST_DECLARE   (fs_file_write_null_buffer)
-TEST_DECLARE   (fs_async_dir)
-TEST_DECLARE   (fs_async_sendfile)
-TEST_DECLARE   (fs_mkdtemp)
-TEST_DECLARE   (fs_fstat)
-TEST_DECLARE   (fs_access)
-TEST_DECLARE   (fs_chmod)
-TEST_DECLARE   (fs_unlink_readonly)
-TEST_DECLARE   (fs_chown)
-TEST_DECLARE   (fs_link)
-TEST_DECLARE   (fs_readlink)
-TEST_DECLARE   (fs_realpath)
-TEST_DECLARE   (fs_symlink)
-TEST_DECLARE   (fs_symlink_dir)
-TEST_DECLARE   (fs_utime)
-TEST_DECLARE   (fs_futime)
-TEST_DECLARE   (fs_file_open_append)
-TEST_DECLARE   (fs_stat_missing_path)
-TEST_DECLARE   (fs_read_file_eof)
-TEST_DECLARE   (fs_event_watch_dir)
-TEST_DECLARE   (fs_event_watch_dir_recursive)
-TEST_DECLARE   (fs_event_watch_file)
-TEST_DECLARE   (fs_event_watch_file_exact_path)
-TEST_DECLARE   (fs_event_watch_file_twice)
-TEST_DECLARE   (fs_event_watch_file_current_dir)
-#ifdef _WIN32
-TEST_DECLARE   (fs_event_watch_file_root_dir)
-#endif
-TEST_DECLARE   (fs_event_no_callback_after_close)
-TEST_DECLARE   (fs_event_no_callback_on_close)
-TEST_DECLARE   (fs_event_immediate_close)
-TEST_DECLARE   (fs_event_close_with_pending_event)
-TEST_DECLARE   (fs_event_close_in_callback)
-TEST_DECLARE   (fs_event_start_and_close)
-TEST_DECLARE   (fs_event_error_reporting)
-TEST_DECLARE   (fs_event_getpath)
-TEST_DECLARE   (fs_scandir_empty_dir)
-TEST_DECLARE   (fs_scandir_non_existent_dir)
-TEST_DECLARE   (fs_scandir_file)
-TEST_DECLARE   (fs_open_dir)
-TEST_DECLARE   (fs_rename_to_existing_file)
-TEST_DECLARE   (fs_write_multiple_bufs)
-TEST_DECLARE   (fs_read_write_null_arguments)
-TEST_DECLARE   (fs_write_alotof_bufs)
-TEST_DECLARE   (fs_write_alotof_bufs_with_offset)
-TEST_DECLARE   (threadpool_queue_work_simple)
-TEST_DECLARE   (threadpool_queue_work_einval)
-TEST_DECLARE   (threadpool_multiple_event_loops)
-TEST_DECLARE   (threadpool_cancel_getaddrinfo)
-TEST_DECLARE   (threadpool_cancel_getnameinfo)
-TEST_DECLARE   (threadpool_cancel_work)
-TEST_DECLARE   (threadpool_cancel_fs)
-TEST_DECLARE   (threadpool_cancel_single)
-TEST_DECLARE   (thread_local_storage)
-TEST_DECLARE   (thread_stack_size)
-TEST_DECLARE   (thread_mutex)
-TEST_DECLARE   (thread_rwlock)
-TEST_DECLARE   (thread_rwlock_trylock)
-TEST_DECLARE   (thread_create)
-TEST_DECLARE   (thread_equal)
-TEST_DECLARE   (dlerror)
-TEST_DECLARE   (poll_duplex)
-TEST_DECLARE   (poll_unidirectional)
-TEST_DECLARE   (poll_close)
-TEST_DECLARE   (poll_bad_fdtype)
-#ifdef __linux__
-TEST_DECLARE   (poll_nested_epoll)
-#endif
-#ifdef UV_HAVE_KQUEUE
-TEST_DECLARE   (poll_nested_kqueue)
-#endif
-
-TEST_DECLARE   (ip4_addr)
-TEST_DECLARE   (ip6_addr_link_local)
-
-TEST_DECLARE   (poll_close_doesnt_corrupt_stack)
-TEST_DECLARE   (poll_closesocket)
-#ifdef _WIN32
-TEST_DECLARE   (spawn_detect_pipe_name_collisions_on_windows)
-#if !defined(USING_UV_SHARED)
-TEST_DECLARE   (argument_escaping)
-TEST_DECLARE   (environment_creation)
-#endif
-TEST_DECLARE   (listen_with_simultaneous_accepts)
-TEST_DECLARE   (listen_no_simultaneous_accepts)
-TEST_DECLARE   (fs_stat_root)
-TEST_DECLARE   (spawn_with_an_odd_path)
-TEST_DECLARE   (ipc_listen_after_bind_twice)
-TEST_DECLARE   (win32_signum_number)
-#else
-TEST_DECLARE   (emfile)
-TEST_DECLARE   (close_fd)
-TEST_DECLARE   (spawn_fs_open)
-TEST_DECLARE   (spawn_setuid_setgid)
-TEST_DECLARE   (we_get_signal)
-TEST_DECLARE   (we_get_signals)
-TEST_DECLARE   (signal_multiple_loops)
-TEST_DECLARE   (closed_fd_events)
-#endif
-#ifdef __APPLE__
-TEST_DECLARE   (osx_select)
-TEST_DECLARE   (osx_select_many_fds)
-#endif
-HELPER_DECLARE (tcp4_echo_server)
-HELPER_DECLARE (tcp6_echo_server)
-HELPER_DECLARE (udp4_echo_server)
-HELPER_DECLARE (pipe_echo_server)
-
-TEST_DECLARE   (queue_foreach_delete)
-
-TASK_LIST_START
-  TEST_ENTRY_CUSTOM (platform_output, 0, 1, 5000)
-
-#if 0
-  TEST_ENTRY  (callback_order)
-#endif
-  TEST_ENTRY  (close_order)
-  TEST_ENTRY  (run_once)
-  TEST_ENTRY  (run_nowait)
-  TEST_ENTRY  (loop_alive)
-  TEST_ENTRY  (loop_close)
-  TEST_ENTRY  (loop_stop)
-  TEST_ENTRY  (loop_update_time)
-  TEST_ENTRY  (loop_backend_timeout)
-  TEST_ENTRY  (loop_configure)
-  TEST_ENTRY  (default_loop_close)
-  TEST_ENTRY  (barrier_1)
-  TEST_ENTRY  (barrier_2)
-  TEST_ENTRY  (barrier_3)
-  TEST_ENTRY  (condvar_1)
-  TEST_ENTRY  (condvar_2)
-  TEST_ENTRY  (condvar_3)
-  TEST_ENTRY  (condvar_4)
-  TEST_ENTRY  (condvar_5)
-  TEST_ENTRY  (semaphore_1)
-  TEST_ENTRY  (semaphore_2)
-  TEST_ENTRY  (semaphore_3)
-
-  TEST_ENTRY  (pipe_connect_bad_name)
-  TEST_ENTRY  (pipe_connect_to_file)
-  TEST_ENTRY  (pipe_connect_on_prepare)
-
-  TEST_ENTRY  (pipe_server_close)
-#ifndef _WIN32
-  TEST_ENTRY  (pipe_close_stdout_read_stdin)
-#endif
-  TEST_ENTRY  (pipe_set_non_blocking)
-  TEST_ENTRY  (tty)
-#ifdef _WIN32
-  TEST_ENTRY  (tty_raw)
-  TEST_ENTRY  (tty_empty_write)
-  TEST_ENTRY  (tty_large_write)
-#endif
-  TEST_ENTRY  (tty_file)
-  TEST_ENTRY  (tty_pty)
-  TEST_ENTRY  (stdio_over_pipes)
-  TEST_ENTRY  (ip6_pton)
-  TEST_ENTRY  (ipc_listen_before_write)
-  TEST_ENTRY  (ipc_listen_after_write)
-#ifndef _WIN32
-  TEST_ENTRY  (ipc_send_recv_pipe)
-  TEST_ENTRY  (ipc_send_recv_pipe_inprocess)
-#endif
-  TEST_ENTRY  (ipc_send_recv_tcp)
-  TEST_ENTRY  (ipc_send_recv_tcp_inprocess)
-  TEST_ENTRY  (ipc_tcp_connection)
-
-  TEST_ENTRY  (tcp_alloc_cb_fail)
-
-  TEST_ENTRY  (tcp_ping_pong)
-  TEST_HELPER (tcp_ping_pong, tcp4_echo_server)
-
-  TEST_ENTRY  (tcp_ping_pong_v6)
-  TEST_HELPER (tcp_ping_pong_v6, tcp6_echo_server)
-
-  TEST_ENTRY  (pipe_ping_pong)
-  TEST_HELPER (pipe_ping_pong, pipe_echo_server)
-
-  TEST_ENTRY  (delayed_accept)
-  TEST_ENTRY  (multiple_listen)
-
-#ifndef _WIN32
-  TEST_ENTRY  (tcp_write_after_connect)
-#endif
-
-  TEST_ENTRY  (tcp_writealot)
-  TEST_HELPER (tcp_writealot, tcp4_echo_server)
-
-  TEST_ENTRY  (tcp_write_fail)
-  TEST_HELPER (tcp_write_fail, tcp4_echo_server)
-
-  TEST_ENTRY  (tcp_try_write)
-
-  TEST_ENTRY  (tcp_write_queue_order)
-
-  TEST_ENTRY  (tcp_open)
-  TEST_HELPER (tcp_open, tcp4_echo_server)
-  TEST_ENTRY  (tcp_open_twice)
-
-  TEST_ENTRY  (tcp_shutdown_after_write)
-  TEST_HELPER (tcp_shutdown_after_write, tcp4_echo_server)
-
-  TEST_ENTRY  (tcp_connect_error_after_write)
-  TEST_ENTRY  (tcp_bind_error_addrinuse)
-  TEST_ENTRY  (tcp_bind_error_addrnotavail_1)
-  TEST_ENTRY  (tcp_bind_error_addrnotavail_2)
-  TEST_ENTRY  (tcp_bind_error_fault)
-  TEST_ENTRY  (tcp_bind_error_inval)
-  TEST_ENTRY  (tcp_bind_localhost_ok)
-  TEST_ENTRY  (tcp_bind_invalid_flags)
-  TEST_ENTRY  (tcp_listen_without_bind)
-  TEST_ENTRY  (tcp_connect_error_fault)
-  TEST_ENTRY  (tcp_connect_timeout)
-  TEST_ENTRY  (tcp_close_while_connecting)
-  TEST_ENTRY  (tcp_close)
-  TEST_ENTRY  (tcp_create_early)
-  TEST_ENTRY  (tcp_create_early_bad_bind)
-  TEST_ENTRY  (tcp_create_early_bad_domain)
-  TEST_ENTRY  (tcp_create_early_accept)
-#ifndef _WIN32
-  TEST_ENTRY  (tcp_close_accept)
-  TEST_ENTRY  (tcp_oob)
-#endif
-  TEST_ENTRY  (tcp_flags)
-  TEST_ENTRY  (tcp_write_to_half_open_connection)
-  TEST_ENTRY  (tcp_unexpected_read)
-
-  TEST_ENTRY  (tcp_read_stop)
-  TEST_HELPER (tcp_read_stop, tcp4_echo_server)
-
-  TEST_ENTRY  (tcp_bind6_error_addrinuse)
-  TEST_ENTRY  (tcp_bind6_error_addrnotavail)
-  TEST_ENTRY  (tcp_bind6_error_fault)
-  TEST_ENTRY  (tcp_bind6_error_inval)
-  TEST_ENTRY  (tcp_bind6_localhost_ok)
-
-  TEST_ENTRY  (udp_alloc_cb_fail)
-  TEST_ENTRY  (udp_bind)
-  TEST_ENTRY  (udp_bind_reuseaddr)
-  TEST_ENTRY  (udp_create_early)
-  TEST_ENTRY  (udp_create_early_bad_bind)
-  TEST_ENTRY  (udp_create_early_bad_domain)
-  TEST_ENTRY  (udp_send_and_recv)
-  TEST_ENTRY  (udp_send_immediate)
-  TEST_ENTRY  (udp_send_unreachable)
-  TEST_ENTRY  (udp_dgram_too_big)
-  TEST_ENTRY  (udp_dual_stack)
-  TEST_ENTRY  (udp_ipv6_only)
-  TEST_ENTRY  (udp_options)
-  TEST_ENTRY  (udp_options6)
-  TEST_ENTRY  (udp_no_autobind)
-  TEST_ENTRY  (udp_multicast_interface)
-  TEST_ENTRY  (udp_multicast_interface6)
-  TEST_ENTRY  (udp_multicast_join)
-  TEST_ENTRY  (udp_multicast_join6)
-  TEST_ENTRY  (udp_multicast_ttl)
-  TEST_ENTRY  (udp_try_send)
-
-  TEST_ENTRY  (udp_open)
-  TEST_HELPER (udp_open, udp4_echo_server)
-  TEST_ENTRY  (udp_open_twice)
-
-  TEST_ENTRY  (pipe_bind_error_addrinuse)
-  TEST_ENTRY  (pipe_bind_error_addrnotavail)
-  TEST_ENTRY  (pipe_bind_error_inval)
-  TEST_ENTRY  (pipe_connect_multiple)
-  TEST_ENTRY  (pipe_listen_without_bind)
-  TEST_ENTRY  (pipe_getsockname)
-  TEST_ENTRY  (pipe_getsockname_abstract)
-  TEST_ENTRY  (pipe_getsockname_blocking)
-  TEST_ENTRY  (pipe_pending_instances)
-  TEST_ENTRY  (pipe_sendmsg)
-
-  TEST_ENTRY  (connection_fail)
-  TEST_ENTRY  (connection_fail_doesnt_auto_close)
-
-  TEST_ENTRY  (shutdown_close_tcp)
-  TEST_HELPER (shutdown_close_tcp, tcp4_echo_server)
-  TEST_ENTRY  (shutdown_close_pipe)
-  TEST_HELPER (shutdown_close_pipe, pipe_echo_server)
-
-  TEST_ENTRY  (shutdown_eof)
-  TEST_HELPER (shutdown_eof, tcp4_echo_server)
-
-  TEST_ENTRY  (shutdown_twice)
-  TEST_HELPER (shutdown_twice, tcp4_echo_server)
-
-  TEST_ENTRY  (callback_stack)
-  TEST_HELPER (callback_stack, tcp4_echo_server)
-
-  TEST_ENTRY  (error_message)
-  TEST_ENTRY  (sys_error)
-
-  TEST_ENTRY  (timer)
-  TEST_ENTRY  (timer_init)
-  TEST_ENTRY  (timer_again)
-  TEST_ENTRY  (timer_start_twice)
-  TEST_ENTRY  (timer_order)
-  TEST_ENTRY  (timer_huge_timeout)
-  TEST_ENTRY  (timer_huge_repeat)
-  TEST_ENTRY  (timer_run_once)
-  TEST_ENTRY  (timer_from_check)
-  TEST_ENTRY  (timer_null_callback)
-  TEST_ENTRY  (timer_early_check)
-
-  TEST_ENTRY  (idle_starvation)
-
-  TEST_ENTRY  (ref)
-  TEST_ENTRY  (idle_ref)
-  TEST_ENTRY  (fs_poll_ref)
-  TEST_ENTRY  (async_ref)
-  TEST_ENTRY  (prepare_ref)
-  TEST_ENTRY  (check_ref)
-  TEST_ENTRY  (unref_in_prepare_cb)
-  TEST_ENTRY  (timer_ref)
-  TEST_ENTRY  (timer_ref2)
-  TEST_ENTRY  (fs_event_ref)
-  TEST_ENTRY  (tcp_ref)
-  TEST_ENTRY  (tcp_ref2)
-  TEST_ENTRY  (tcp_ref2b)
-  TEST_ENTRY  (tcp_ref3)
-  TEST_HELPER (tcp_ref3, tcp4_echo_server)
-  TEST_ENTRY  (tcp_ref4)
-  TEST_HELPER (tcp_ref4, tcp4_echo_server)
-  TEST_ENTRY  (udp_ref)
-  TEST_ENTRY  (udp_ref2)
-  TEST_ENTRY  (udp_ref3)
-  TEST_HELPER (udp_ref3, udp4_echo_server)
-  TEST_ENTRY  (pipe_ref)
-  TEST_ENTRY  (pipe_ref2)
-  TEST_ENTRY  (pipe_ref3)
-  TEST_HELPER (pipe_ref3, pipe_echo_server)
-  TEST_ENTRY  (pipe_ref4)
-  TEST_HELPER (pipe_ref4, pipe_echo_server)
-  TEST_ENTRY  (process_ref)
-  TEST_ENTRY  (has_ref)
-
-  TEST_ENTRY  (loop_handles)
-  TEST_ENTRY  (walk_handles)
-
-  TEST_ENTRY  (watcher_cross_stop)
-
-  TEST_ENTRY  (active)
-
-  TEST_ENTRY  (embed)
-
-  TEST_ENTRY  (async)
-  TEST_ENTRY  (async_null_cb)
-  TEST_ENTRY  (eintr_handling)
-
-  TEST_ENTRY  (get_currentexe)
-
-  TEST_ENTRY  (process_title)
-
-  TEST_ENTRY  (cwd_and_chdir)
-
-  TEST_ENTRY  (get_memory)
-
-  TEST_ENTRY  (get_passwd)
-
-  TEST_ENTRY  (get_loadavg)
-
-  TEST_ENTRY  (handle_fileno)
-
-  TEST_ENTRY  (homedir)
-
-  TEST_ENTRY  (tmpdir)
-
-  TEST_ENTRY  (hrtime)
-
-  TEST_ENTRY_CUSTOM (getaddrinfo_fail, 0, 0, 10000)
-  TEST_ENTRY  (getaddrinfo_fail_sync)
-
-  TEST_ENTRY  (getaddrinfo_basic)
-  TEST_ENTRY  (getaddrinfo_basic_sync)
-  TEST_ENTRY  (getaddrinfo_concurrent)
-
-  TEST_ENTRY  (getnameinfo_basic_ip4)
-  TEST_ENTRY  (getnameinfo_basic_ip4_sync)
-  TEST_ENTRY  (getnameinfo_basic_ip6)
-
-  TEST_ENTRY  (getsockname_tcp)
-  TEST_ENTRY  (getsockname_udp)
-
-  TEST_ENTRY  (poll_duplex)
-  TEST_ENTRY  (poll_unidirectional)
-  TEST_ENTRY  (poll_close)
-  TEST_ENTRY  (poll_bad_fdtype)
-#ifdef __linux__
-  TEST_ENTRY  (poll_nested_epoll)
-#endif
-#ifdef UV_HAVE_KQUEUE
-  TEST_ENTRY  (poll_nested_kqueue)
-#endif
-
-  TEST_ENTRY  (socket_buffer_size)
-
-  TEST_ENTRY  (spawn_fails)
-#ifndef _WIN32
-  TEST_ENTRY  (spawn_fails_check_for_waitpid_cleanup)
-#endif
-  TEST_ENTRY  (spawn_exit_code)
-  TEST_ENTRY  (spawn_stdout)
-  TEST_ENTRY  (spawn_stdin)
-  TEST_ENTRY  (spawn_stdio_greater_than_3)
-  TEST_ENTRY  (spawn_ignored_stdio)
-  TEST_ENTRY  (spawn_and_kill)
-  TEST_ENTRY  (spawn_detached)
-  TEST_ENTRY  (spawn_and_kill_with_std)
-  TEST_ENTRY  (spawn_and_ping)
-  TEST_ENTRY  (spawn_preserve_env)
-  TEST_ENTRY  (spawn_setuid_fails)
-  TEST_ENTRY  (spawn_setgid_fails)
-  TEST_ENTRY  (spawn_stdout_to_file)
-  TEST_ENTRY  (spawn_stdout_and_stderr_to_file)
-  TEST_ENTRY  (spawn_stdout_and_stderr_to_file2)
-  TEST_ENTRY  (spawn_stdout_and_stderr_to_file_swap)
-  TEST_ENTRY  (spawn_auto_unref)
-  TEST_ENTRY  (spawn_closed_process_io)
-  TEST_ENTRY  (spawn_reads_child_path)
-  TEST_ENTRY  (spawn_inherit_streams)
-  TEST_ENTRY  (fs_poll)
-  TEST_ENTRY  (fs_poll_getpath)
-  TEST_ENTRY  (kill)
-
-  TEST_ENTRY  (poll_close_doesnt_corrupt_stack)
-  TEST_ENTRY  (poll_closesocket)
-#ifdef _WIN32
-  TEST_ENTRY  (spawn_detect_pipe_name_collisions_on_windows)
-#if !defined(USING_UV_SHARED)
-  TEST_ENTRY  (argument_escaping)
-  TEST_ENTRY  (environment_creation)
-# endif
-  TEST_ENTRY  (listen_with_simultaneous_accepts)
-  TEST_ENTRY  (listen_no_simultaneous_accepts)
-  TEST_ENTRY  (fs_stat_root)
-  TEST_ENTRY  (spawn_with_an_odd_path)
-  TEST_ENTRY  (ipc_listen_after_bind_twice)
-  TEST_ENTRY  (win32_signum_number)
-#else
-  TEST_ENTRY  (emfile)
-  TEST_ENTRY  (close_fd)
-  TEST_ENTRY  (spawn_fs_open)
-  TEST_ENTRY  (spawn_setuid_setgid)
-  TEST_ENTRY  (we_get_signal)
-  TEST_ENTRY  (we_get_signals)
-  TEST_ENTRY  (signal_multiple_loops)
-  TEST_ENTRY  (closed_fd_events)
-#endif
-
-#ifdef __APPLE__
-  TEST_ENTRY (osx_select)
-  TEST_ENTRY (osx_select_many_fds)
-#endif
-
-  TEST_ENTRY  (fs_file_noent)
-  TEST_ENTRY  (fs_file_nametoolong)
-  TEST_ENTRY  (fs_file_loop)
-  TEST_ENTRY  (fs_file_async)
-  TEST_ENTRY  (fs_file_sync)
-  TEST_ENTRY  (fs_file_write_null_buffer)
-  TEST_ENTRY  (fs_async_dir)
-  TEST_ENTRY  (fs_async_sendfile)
-  TEST_ENTRY  (fs_mkdtemp)
-  TEST_ENTRY  (fs_fstat)
-  TEST_ENTRY  (fs_access)
-  TEST_ENTRY  (fs_chmod)
-  TEST_ENTRY  (fs_unlink_readonly)
-  TEST_ENTRY  (fs_chown)
-  TEST_ENTRY  (fs_utime)
-  TEST_ENTRY  (fs_futime)
-  TEST_ENTRY  (fs_readlink)
-  TEST_ENTRY  (fs_realpath)
-  TEST_ENTRY  (fs_symlink)
-  TEST_ENTRY  (fs_symlink_dir)
-  TEST_ENTRY  (fs_stat_missing_path)
-  TEST_ENTRY  (fs_read_file_eof)
-  TEST_ENTRY  (fs_file_open_append)
-  TEST_ENTRY  (fs_event_watch_dir)
-  TEST_ENTRY  (fs_event_watch_dir_recursive)
-  TEST_ENTRY  (fs_event_watch_file)
-  TEST_ENTRY  (fs_event_watch_file_exact_path)
-  TEST_ENTRY  (fs_event_watch_file_twice)
-  TEST_ENTRY  (fs_event_watch_file_current_dir)
-#ifdef _WIN32
-  TEST_ENTRY  (fs_event_watch_file_root_dir)
-#endif
-  TEST_ENTRY  (fs_event_no_callback_after_close)
-  TEST_ENTRY  (fs_event_no_callback_on_close)
-  TEST_ENTRY  (fs_event_immediate_close)
-  TEST_ENTRY  (fs_event_close_with_pending_event)
-  TEST_ENTRY  (fs_event_close_in_callback)
-  TEST_ENTRY  (fs_event_start_and_close)
-  TEST_ENTRY  (fs_event_error_reporting)
-  TEST_ENTRY  (fs_event_getpath)
-  TEST_ENTRY  (fs_scandir_empty_dir)
-  TEST_ENTRY  (fs_scandir_non_existent_dir)
-  TEST_ENTRY  (fs_scandir_file)
-  TEST_ENTRY  (fs_open_dir)
-  TEST_ENTRY  (fs_rename_to_existing_file)
-  TEST_ENTRY  (fs_write_multiple_bufs)
-  TEST_ENTRY  (fs_write_alotof_bufs)
-  TEST_ENTRY  (fs_write_alotof_bufs_with_offset)
-  TEST_ENTRY  (fs_read_write_null_arguments)
-  TEST_ENTRY  (threadpool_queue_work_simple)
-  TEST_ENTRY  (threadpool_queue_work_einval)
-#if defined(__PPC__) || defined(__PPC64__)  /* For linux PPC and AIX */
-  /* pthread_join takes a while, especially on AIX.
-   * Therefore being gratuitous with timeout.
-   */
-  TEST_ENTRY_CUSTOM (threadpool_multiple_event_loops, 0, 0, 120000)
-#else
-  TEST_ENTRY  (threadpool_multiple_event_loops)
-#endif
-  TEST_ENTRY  (threadpool_cancel_getaddrinfo)
-  TEST_ENTRY  (threadpool_cancel_getnameinfo)
-  TEST_ENTRY  (threadpool_cancel_work)
-  TEST_ENTRY  (threadpool_cancel_fs)
-  TEST_ENTRY  (threadpool_cancel_single)
-  TEST_ENTRY  (thread_local_storage)
-  TEST_ENTRY  (thread_stack_size)
-  TEST_ENTRY  (thread_mutex)
-  TEST_ENTRY  (thread_rwlock)
-  TEST_ENTRY  (thread_rwlock_trylock)
-  TEST_ENTRY  (thread_create)
-  TEST_ENTRY  (thread_equal)
-  TEST_ENTRY  (dlerror)
-  TEST_ENTRY  (ip4_addr)
-  TEST_ENTRY  (ip6_addr_link_local)
-
-  TEST_ENTRY  (queue_foreach_delete)
-
-#if 0
-  /* These are for testing the test runner. */
-  TEST_ENTRY  (fail_always)
-  TEST_ENTRY  (pass_always)
-#endif
-TASK_LIST_END
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/v8/include/libplatform/libplatform-export.h
+++ /dev/null
@@ -1,29 +0,0 @@
-// Copyright 2016 the V8 project authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef V8_LIBPLATFORM_LIBPLATFORM_EXPORT_H_
-#define V8_LIBPLATFORM_LIBPLATFORM_EXPORT_H_
-
-#if defined(_WIN32)
-
-#ifdef BUILDING_V8_PLATFORM_SHARED
-#define V8_PLATFORM_EXPORT __declspec(dllexport)
-#elif USING_V8_PLATFORM_SHARED
-#define V8_PLATFORM_EXPORT __declspec(dllimport)
-#else
-#define V8_PLATFORM_EXPORT
-#endif  // BUILDING_V8_PLATFORM_SHARED
-
-#else  // defined(_WIN32)
-
-// Setup for Linux shared library export.
-#ifdef BUILDING_V8_PLATFORM_SHARED
-#define V8_PLATFORM_EXPORT __attribute__((visibility("default")))
-#else
-#define V8_PLATFORM_EXPORT
-#endif
-
-#endif  // defined(_WIN32)
-
-#endif  // V8_LIBPLATFORM_LIBPLATFORM_EXPORT_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/v8/include/libplatform/libplatform.h
+++ /dev/null
@@ -1,60 +0,0 @@
-// Copyright 2014 the V8 project authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef V8_LIBPLATFORM_LIBPLATFORM_H_
-#define V8_LIBPLATFORM_LIBPLATFORM_H_
-
-#include "libplatform/libplatform-export.h"
-#include "libplatform/v8-tracing.h"
-#include "v8-platform.h"  // NOLINT(build/include)
-
-namespace v8 {
-namespace platform {
-
-/**
- * Returns a new instance of the default v8::Platform implementation.
- *
- * The caller will take ownership of the returned pointer. |thread_pool_size|
- * is the number of worker threads to allocate for background jobs. If a value
- * of zero is passed, a suitable default based on the current number of
- * processors online will be chosen.
- */
-V8_PLATFORM_EXPORT v8::Platform* CreateDefaultPlatform(
-    int thread_pool_size = 0);
-
-/**
- * Pumps the message loop for the given isolate.
- *
- * The caller has to make sure that this is called from the right thread.
- * Returns true if a task was executed, and false otherwise. This call does
- * not block if no task is pending. The |platform| has to be created using
- * |CreateDefaultPlatform|.
- */
-V8_PLATFORM_EXPORT bool PumpMessageLoop(v8::Platform* platform,
-                                        v8::Isolate* isolate);
-
-/**
- * Runs pending idle tasks for at most |idle_time_in_seconds| seconds.
- *
- * The caller has to make sure that this is called from the right thread.
- * This call does not block if no task is pending. The |platform| has to be
- * created using |CreateDefaultPlatform|.
- */
-V8_PLATFORM_EXPORT void RunIdleTasks(v8::Platform* platform,
-                                     v8::Isolate* isolate,
-                                     double idle_time_in_seconds);
-
-/**
- * Attempts to set the tracing controller for the given platform.
- *
- * The |platform| has to be created using |CreateDefaultPlatform|.
- */
-V8_PLATFORM_EXPORT void SetTracingController(
-    v8::Platform* platform,
-    v8::platform::tracing::TracingController* tracing_controller);
-
-}  // namespace platform
-}  // namespace v8
-
-#endif  // V8_LIBPLATFORM_LIBPLATFORM_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/v8/include/libplatform/v8-tracing.h
+++ /dev/null
@@ -1,270 +0,0 @@
-// Copyright 2016 the V8 project authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef V8_LIBPLATFORM_V8_TRACING_H_
-#define V8_LIBPLATFORM_V8_TRACING_H_
-
-#include <fstream>
-#include <memory>
-#include <unordered_set>
-#include <vector>
-
-#include "libplatform/libplatform-export.h"
-#include "v8-platform.h"  // NOLINT(build/include)
-
-namespace v8 {
-
-namespace base {
-class Mutex;
-}  // namespace base
-
-namespace platform {
-namespace tracing {
-
-const int kTraceMaxNumArgs = 2;
-
-class V8_PLATFORM_EXPORT TraceObject {
- public:
-  union ArgValue {
-    bool as_bool;
-    uint64_t as_uint;
-    int64_t as_int;
-    double as_double;
-    const void* as_pointer;
-    const char* as_string;
-  };
-
-  TraceObject() {}
-  ~TraceObject();
-  void Initialize(
-      char phase, const uint8_t* category_enabled_flag, const char* name,
-      const char* scope, uint64_t id, uint64_t bind_id, int num_args,
-      const char** arg_names, const uint8_t* arg_types,
-      const uint64_t* arg_values,
-      std::unique_ptr<v8::ConvertableToTraceFormat>* arg_convertables,
-      unsigned int flags);
-  void UpdateDuration();
-  void InitializeForTesting(
-      char phase, const uint8_t* category_enabled_flag, const char* name,
-      const char* scope, uint64_t id, uint64_t bind_id, int num_args,
-      const char** arg_names, const uint8_t* arg_types,
-      const uint64_t* arg_values,
-      std::unique_ptr<v8::ConvertableToTraceFormat>* arg_convertables,
-      unsigned int flags, int pid, int tid, int64_t ts, int64_t tts,
-      uint64_t duration, uint64_t cpu_duration);
-
-  int pid() const { return pid_; }
-  int tid() const { return tid_; }
-  char phase() const { return phase_; }
-  const uint8_t* category_enabled_flag() const {
-    return category_enabled_flag_;
-  }
-  const char* name() const { return name_; }
-  const char* scope() const { return scope_; }
-  uint64_t id() const { return id_; }
-  uint64_t bind_id() const { return bind_id_; }
-  int num_args() const { return num_args_; }
-  const char** arg_names() { return arg_names_; }
-  uint8_t* arg_types() { return arg_types_; }
-  ArgValue* arg_values() { return arg_values_; }
-  std::unique_ptr<v8::ConvertableToTraceFormat>* arg_convertables() {
-    return arg_convertables_;
-  }
-  unsigned int flags() const { return flags_; }
-  int64_t ts() { return ts_; }
-  int64_t tts() { return tts_; }
-  uint64_t duration() { return duration_; }
-  uint64_t cpu_duration() { return cpu_duration_; }
-
- private:
-  int pid_;
-  int tid_;
-  char phase_;
-  const char* name_;
-  const char* scope_;
-  const uint8_t* category_enabled_flag_;
-  uint64_t id_;
-  uint64_t bind_id_;
-  int num_args_ = 0;
-  const char* arg_names_[kTraceMaxNumArgs];
-  uint8_t arg_types_[kTraceMaxNumArgs];
-  ArgValue arg_values_[kTraceMaxNumArgs];
-  std::unique_ptr<v8::ConvertableToTraceFormat>
-      arg_convertables_[kTraceMaxNumArgs];
-  char* parameter_copy_storage_ = nullptr;
-  unsigned int flags_;
-  int64_t ts_;
-  int64_t tts_;
-  uint64_t duration_;
-  uint64_t cpu_duration_;
-
-  // Disallow copy and assign
-  TraceObject(const TraceObject&) = delete;
-  void operator=(const TraceObject&) = delete;
-};
-
-class V8_PLATFORM_EXPORT TraceWriter {
- public:
-  TraceWriter() {}
-  virtual ~TraceWriter() {}
-  virtual void AppendTraceEvent(TraceObject* trace_event) = 0;
-  virtual void Flush() = 0;
-
-  static TraceWriter* CreateJSONTraceWriter(std::ostream& stream);
-
- private:
-  // Disallow copy and assign
-  TraceWriter(const TraceWriter&) = delete;
-  void operator=(const TraceWriter&) = delete;
-};
-
-class V8_PLATFORM_EXPORT TraceBufferChunk {
- public:
-  explicit TraceBufferChunk(uint32_t seq);
-
-  void Reset(uint32_t new_seq);
-  bool IsFull() const { return next_free_ == kChunkSize; }
-  TraceObject* AddTraceEvent(size_t* event_index);
-  TraceObject* GetEventAt(size_t index) { return &chunk_[index]; }
-
-  uint32_t seq() const { return seq_; }
-  size_t size() const { return next_free_; }
-
-  static const size_t kChunkSize = 64;
-
- private:
-  size_t next_free_ = 0;
-  TraceObject chunk_[kChunkSize];
-  uint32_t seq_;
-
-  // Disallow copy and assign
-  TraceBufferChunk(const TraceBufferChunk&) = delete;
-  void operator=(const TraceBufferChunk&) = delete;
-};
-
-class V8_PLATFORM_EXPORT TraceBuffer {
- public:
-  TraceBuffer() {}
-  virtual ~TraceBuffer() {}
-
-  virtual TraceObject* AddTraceEvent(uint64_t* handle) = 0;
-  virtual TraceObject* GetEventByHandle(uint64_t handle) = 0;
-  virtual bool Flush() = 0;
-
-  static const size_t kRingBufferChunks = 1024;
-
-  static TraceBuffer* CreateTraceBufferRingBuffer(size_t max_chunks,
-                                                  TraceWriter* trace_writer);
-
- private:
-  // Disallow copy and assign
-  TraceBuffer(const TraceBuffer&) = delete;
-  void operator=(const TraceBuffer&) = delete;
-};
-
-// Options determines how the trace buffer stores data.
-enum TraceRecordMode {
-  // Record until the trace buffer is full.
-  RECORD_UNTIL_FULL,
-
-  // Record until the user ends the trace. The trace buffer is a fixed size
-  // and we use it as a ring buffer during recording.
-  RECORD_CONTINUOUSLY,
-
-  // Record until the trace buffer is full, but with a huge buffer size.
-  RECORD_AS_MUCH_AS_POSSIBLE,
-
-  // Echo to console. Events are discarded.
-  ECHO_TO_CONSOLE,
-};
-
-class V8_PLATFORM_EXPORT TraceConfig {
- public:
-  typedef std::vector<std::string> StringList;
-
-  static TraceConfig* CreateDefaultTraceConfig();
-
-  TraceConfig() : enable_systrace_(false), enable_argument_filter_(false) {}
-  TraceRecordMode GetTraceRecordMode() const { return record_mode_; }
-  bool IsSystraceEnabled() const { return enable_systrace_; }
-  bool IsArgumentFilterEnabled() const { return enable_argument_filter_; }
-
-  void SetTraceRecordMode(TraceRecordMode mode) { record_mode_ = mode; }
-  void EnableSystrace() { enable_systrace_ = true; }
-  void EnableArgumentFilter() { enable_argument_filter_ = true; }
-
-  void AddIncludedCategory(const char* included_category);
-
-  bool IsCategoryGroupEnabled(const char* category_group) const;
-
- private:
-  TraceRecordMode record_mode_;
-  bool enable_systrace_ : 1;
-  bool enable_argument_filter_ : 1;
-  StringList included_categories_;
-
-  // Disallow copy and assign
-  TraceConfig(const TraceConfig&) = delete;
-  void operator=(const TraceConfig&) = delete;
-};
-
-class V8_PLATFORM_EXPORT TracingController {
- public:
-  enum Mode { DISABLED = 0, RECORDING_MODE };
-
-  // The pointer returned from GetCategoryGroupEnabledInternal() points to a
-  // value with zero or more of the following bits. Used in this class only.
-  // The TRACE_EVENT macros should only use the value as a bool.
-  // These values must be in sync with macro values in TraceEvent.h in Blink.
-  enum CategoryGroupEnabledFlags {
-    // Category group enabled for the recording mode.
-    ENABLED_FOR_RECORDING = 1 << 0,
-    // Category group enabled by SetEventCallbackEnabled().
-    ENABLED_FOR_EVENT_CALLBACK = 1 << 2,
-    // Category group enabled to export events to ETW.
-    ENABLED_FOR_ETW_EXPORT = 1 << 3
-  };
-
-  TracingController();
-  ~TracingController();
-  void Initialize(TraceBuffer* trace_buffer);
-  const uint8_t* GetCategoryGroupEnabled(const char* category_group);
-  static const char* GetCategoryGroupName(const uint8_t* category_enabled_flag);
-  uint64_t AddTraceEvent(
-      char phase, const uint8_t* category_enabled_flag, const char* name,
-      const char* scope, uint64_t id, uint64_t bind_id, int32_t num_args,
-      const char** arg_names, const uint8_t* arg_types,
-      const uint64_t* arg_values,
-      std::unique_ptr<v8::ConvertableToTraceFormat>* arg_convertables,
-      unsigned int flags);
-  void UpdateTraceEventDuration(const uint8_t* category_enabled_flag,
-                                const char* name, uint64_t handle);
-
-  void StartTracing(TraceConfig* trace_config);
-  void StopTracing();
-
-  void AddTraceStateObserver(Platform::TraceStateObserver* observer);
-  void RemoveTraceStateObserver(Platform::TraceStateObserver* observer);
-
- private:
-  const uint8_t* GetCategoryGroupEnabledInternal(const char* category_group);
-  void UpdateCategoryGroupEnabledFlag(size_t category_index);
-  void UpdateCategoryGroupEnabledFlags();
-
-  std::unique_ptr<TraceBuffer> trace_buffer_;
-  std::unique_ptr<TraceConfig> trace_config_;
-  std::unique_ptr<base::Mutex> mutex_;
-  std::unordered_set<Platform::TraceStateObserver*> observers_;
-  Mode mode_ = DISABLED;
-
-  // Disallow copy and assign
-  TracingController(const TracingController&) = delete;
-  void operator=(const TracingController&) = delete;
-};
-
-}  // namespace tracing
-}  // namespace platform
-}  // namespace v8
-
-#endif  // V8_LIBPLATFORM_V8_TRACING_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/v8/include/v8-debug.h
+++ /dev/null
@@ -1,250 +0,0 @@
-// Copyright 2008 the V8 project authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef V8_V8_DEBUG_H_
-#define V8_V8_DEBUG_H_
-
-#include "v8.h"  // NOLINT(build/include)
-
-/**
- * Debugger support for the V8 JavaScript engine.
- */
-namespace v8 {
-
-// Debug events which can occur in the V8 JavaScript engine.
-enum DebugEvent {
-  Break = 1,
-  Exception = 2,
-  AfterCompile = 3,
-  CompileError = 4,
-  AsyncTaskEvent = 5,
-};
-
-class V8_EXPORT Debug {
- public:
-  /**
-   * A client object passed to the v8 debugger whose ownership will be taken by
-   * it. v8 is always responsible for deleting the object.
-   */
-  class ClientData {
-   public:
-    virtual ~ClientData() {}
-  };
-
-
-  /**
-   * A message object passed to the debug message handler.
-   */
-  class Message {
-   public:
-    /**
-     * Check type of message.
-     */
-    virtual bool IsEvent() const = 0;
-    virtual bool IsResponse() const = 0;
-    virtual DebugEvent GetEvent() const = 0;
-
-    /**
-     * Indicate whether this is a response to a continue command which will
-     * start the VM running after this is processed.
-     */
-    virtual bool WillStartRunning() const = 0;
-
-    /**
-     * Access to execution state and event data. Don't store these cross
-     * callbacks as their content becomes invalid. These objects are from the
-     * debugger event that started the debug message loop.
-     */
-    virtual Local<Object> GetExecutionState() const = 0;
-    virtual Local<Object> GetEventData() const = 0;
-
-    /**
-     * Get the debugger protocol JSON.
-     */
-    virtual Local<String> GetJSON() const = 0;
-
-    /**
-     * Get the context active when the debug event happened. Note this is not
-     * the current active context as the JavaScript part of the debugger is
-     * running in its own context which is entered at this point.
-     */
-    virtual Local<Context> GetEventContext() const = 0;
-
-    /**
-     * Client data passed with the corresponding request if any. This is the
-     * client_data data value passed into Debug::SendCommand along with the
-     * request that led to the message or NULL if the message is an event. The
-     * debugger takes ownership of the data and will delete it even if there is
-     * no message handler.
-     */
-    virtual ClientData* GetClientData() const = 0;
-
-    virtual Isolate* GetIsolate() const = 0;
-
-    virtual ~Message() {}
-  };
-
-  /**
-   * An event details object passed to the debug event listener.
-   */
-  class EventDetails {
-   public:
-    /**
-     * Event type.
-     */
-    virtual DebugEvent GetEvent() const = 0;
-
-    /**
-     * Access to execution state and event data of the debug event. Don't store
-     * these cross callbacks as their content becomes invalid.
-     */
-    virtual Local<Object> GetExecutionState() const = 0;
-    virtual Local<Object> GetEventData() const = 0;
-
-    /**
-     * Get the context active when the debug event happened. Note this is not
-     * the current active context as the JavaScript part of the debugger is
-     * running in its own context which is entered at this point.
-     */
-    virtual Local<Context> GetEventContext() const = 0;
-
-    /**
-     * Client data passed with the corresponding callback when it was
-     * registered.
-     */
-    virtual Local<Value> GetCallbackData() const = 0;
-
-    /**
-     * This is now a dummy that returns nullptr.
-     */
-    virtual ClientData* GetClientData() const = 0;
-
-    virtual Isolate* GetIsolate() const = 0;
-
-    virtual ~EventDetails() {}
-  };
-
-  /**
-   * Debug event callback function.
-   *
-   * \param event_details object providing information about the debug event
-   *
-   * A EventCallback does not take possession of the event data,
-   * and must not rely on the data persisting after the handler returns.
-   */
-  typedef void (*EventCallback)(const EventDetails& event_details);
-
-  /**
-   * This is now a no-op.
-   */
-  typedef void (*MessageHandler)(const Message& message);
-
-  /**
-   * This is now a no-op.
-   */
-  typedef void (*DebugMessageDispatchHandler)();
-
-  static bool SetDebugEventListener(Isolate* isolate, EventCallback that,
-                                    Local<Value> data = Local<Value>());
-
-  // Schedule a debugger break to happen when JavaScript code is run
-  // in the given isolate.
-  static void DebugBreak(Isolate* isolate);
-
-  // Remove scheduled debugger break in given isolate if it has not
-  // happened yet.
-  static void CancelDebugBreak(Isolate* isolate);
-
-  // Check if a debugger break is scheduled in the given isolate.
-  V8_DEPRECATED("No longer supported",
-                static bool CheckDebugBreak(Isolate* isolate));
-
-  // This is now a no-op.
-  V8_DEPRECATED("No longer supported",
-                static void SetMessageHandler(Isolate* isolate,
-                                              MessageHandler handler));
-
-  // This is now a no-op.
-  V8_DEPRECATED("No longer supported",
-                static void SendCommand(Isolate* isolate,
-                                        const uint16_t* command, int length,
-                                        ClientData* client_data = NULL));
-
-  /**
-   * Run a JavaScript function in the debugger.
-   * \param fun the function to call
-   * \param data passed as second argument to the function
-   * With this call the debugger is entered and the function specified is called
-   * with the execution state as the first argument. This makes it possible to
-   * get access to information otherwise not available during normal JavaScript
-   * execution e.g. details on stack frames. Receiver of the function call will
-   * be the debugger context global object, however this is a subject to change.
-   * The following example shows a JavaScript function which when passed to
-   * v8::Debug::Call will return the current line of JavaScript execution.
-   *
-   * \code
-   *   function frame_source_line(exec_state) {
-   *     return exec_state.frame(0).sourceLine();
-   *   }
-   * \endcode
-   */
-  // TODO(dcarney): data arg should be a MaybeLocal
-  static MaybeLocal<Value> Call(Local<Context> context,
-                                v8::Local<v8::Function> fun,
-                                Local<Value> data = Local<Value>());
-
-  // This is now a no-op.
-  V8_DEPRECATED("No longer supported",
-                static void ProcessDebugMessages(Isolate* isolate));
-
-  /**
-   * Debugger is running in its own context which is entered while debugger
-   * messages are being dispatched. This is an explicit getter for this
-   * debugger context. Note that the content of the debugger context is subject
-   * to change. The Context exists only when the debugger is active, i.e. at
-   * least one DebugEventListener or MessageHandler is set.
-   */
-  V8_DEPRECATED("Use v8-inspector",
-                static Local<Context> GetDebugContext(Isolate* isolate));
-
-  /**
-   * While in the debug context, this method returns the top-most non-debug
-   * context, if it exists.
-   */
-  V8_DEPRECATED(
-      "No longer supported",
-      static MaybeLocal<Context> GetDebuggedContext(Isolate* isolate));
-
-  /**
-   * Enable/disable LiveEdit functionality for the given Isolate
-   * (default Isolate if not provided). V8 will abort if LiveEdit is
-   * unexpectedly used. LiveEdit is enabled by default.
-   */
-  static void SetLiveEditEnabled(Isolate* isolate, bool enable);
-
-  /**
-   * Returns array of internal properties specific to the value type. Result has
-   * the following format: [<name>, <value>,...,<name>, <value>]. Result array
-   * will be allocated in the current context.
-   */
-  static MaybeLocal<Array> GetInternalProperties(Isolate* isolate,
-                                                 Local<Value> value);
-
-  /**
-   * Defines if the ES2015 tail call elimination feature is enabled or not.
-   * The change of this flag triggers deoptimization of all functions that
-   * contain calls at tail position.
-   */
-  static bool IsTailCallEliminationEnabled(Isolate* isolate);
-  static void SetTailCallEliminationEnabled(Isolate* isolate, bool enabled);
-};
-
-
-}  // namespace v8
-
-
-#undef EXPORT
-
-
-#endif  // V8_V8_DEBUG_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/v8/include/v8-experimental.h
+++ /dev/null
@@ -1,58 +0,0 @@
-// Copyright 2015 the V8 project authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-/**
- * This header contains a set of experimental V8 APIs. We hope these will
- * become a part of standard V8, but they may also be removed if we deem the
- * experiment to not be successul.
- */
-#ifndef V8_INCLUDE_V8_EXPERIMENTAL_H_
-#define V8_INCLUDE_V8_EXPERIMENTAL_H_
-
-#include "v8.h"  // NOLINT(build/include)
-
-namespace v8 {
-namespace experimental {
-
-// Allow the embedder to construct accessors that V8 can compile and use
-// directly, without jumping into the runtime.
-class V8_EXPORT FastAccessorBuilder {
- public:
-  struct ValueId {
-    size_t value_id;
-  };
-  struct LabelId {
-    size_t label_id;
-  };
-
-  static FastAccessorBuilder* New(Isolate* isolate);
-
-  ValueId IntegerConstant(int int_constant);
-  ValueId GetReceiver();
-  ValueId LoadInternalField(ValueId value_id, int field_no);
-  ValueId LoadInternalFieldUnchecked(ValueId value_id, int field_no);
-  ValueId LoadValue(ValueId value_id, int offset);
-  ValueId LoadObject(ValueId value_id, int offset);
-  ValueId ToSmi(ValueId value_id);
-
-  void ReturnValue(ValueId value_id);
-  void CheckFlagSetOrReturnNull(ValueId value_id, int mask);
-  void CheckNotZeroOrReturnNull(ValueId value_id);
-  LabelId MakeLabel();
-  void SetLabel(LabelId label_id);
-  void Goto(LabelId label_id);
-  void CheckNotZeroOrJump(ValueId value_id, LabelId label_id);
-  ValueId Call(v8::FunctionCallback callback, ValueId value_id);
-
- private:
-  FastAccessorBuilder() = delete;
-  FastAccessorBuilder(const FastAccessorBuilder&) = delete;
-  ~FastAccessorBuilder() = delete;
-  void operator=(const FastAccessorBuilder&) = delete;
-};
-
-}  // namespace experimental
-}  // namespace v8
-
-#endif  // V8_INCLUDE_V8_EXPERIMENTAL_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/v8/include/v8-inspector-protocol.h
+++ /dev/null
@@ -1,13 +0,0 @@
-// Copyright 2016 the V8 project authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef V8_V8_INSPECTOR_PROTOCOL_H_
-#define V8_V8_INSPECTOR_PROTOCOL_H_
-
-#include "inspector/Debugger.h"  // NOLINT(build/include)
-#include "inspector/Runtime.h"   // NOLINT(build/include)
-#include "inspector/Schema.h"    // NOLINT(build/include)
-#include "v8-inspector.h"        // NOLINT(build/include)
-
-#endif  // V8_V8_INSPECTOR_PROTOCOL_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/v8/include/v8-inspector.h
+++ /dev/null
@@ -1,269 +0,0 @@
-// Copyright 2016 the V8 project authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef V8_V8_INSPECTOR_H_
-#define V8_V8_INSPECTOR_H_
-
-#include <stdint.h>
-#include <cctype>
-
-#include <memory>
-
-#include "v8.h"  // NOLINT(build/include)
-
-namespace v8_inspector {
-
-namespace protocol {
-namespace Debugger {
-namespace API {
-class SearchMatch;
-}
-}
-namespace Runtime {
-namespace API {
-class RemoteObject;
-class StackTrace;
-}
-}
-namespace Schema {
-namespace API {
-class Domain;
-}
-}
-}  // namespace protocol
-
-class V8_EXPORT StringView {
- public:
-  StringView() : m_is8Bit(true), m_length(0), m_characters8(nullptr) {}
-
-  StringView(const uint8_t* characters, size_t length)
-      : m_is8Bit(true), m_length(length), m_characters8(characters) {}
-
-  StringView(const uint16_t* characters, size_t length)
-      : m_is8Bit(false), m_length(length), m_characters16(characters) {}
-
-  bool is8Bit() const { return m_is8Bit; }
-  size_t length() const { return m_length; }
-
-  // TODO(dgozman): add DCHECK(m_is8Bit) to accessors once platform can be used
-  // here.
-  const uint8_t* characters8() const { return m_characters8; }
-  const uint16_t* characters16() const { return m_characters16; }
-
- private:
-  bool m_is8Bit;
-  size_t m_length;
-  union {
-    const uint8_t* m_characters8;
-    const uint16_t* m_characters16;
-  };
-};
-
-class V8_EXPORT StringBuffer {
- public:
-  virtual ~StringBuffer() {}
-  virtual const StringView& string() = 0;
-  // This method copies contents.
-  static std::unique_ptr<StringBuffer> create(const StringView&);
-};
-
-class V8_EXPORT V8ContextInfo {
- public:
-  V8ContextInfo(v8::Local<v8::Context> context, int contextGroupId,
-                const StringView& humanReadableName)
-      : context(context),
-        contextGroupId(contextGroupId),
-        humanReadableName(humanReadableName),
-        hasMemoryOnConsole(false) {}
-
-  v8::Local<v8::Context> context;
-  // Each v8::Context is a part of a group. The group id must be non-zero.
-  int contextGroupId;
-  StringView humanReadableName;
-  StringView origin;
-  StringView auxData;
-  bool hasMemoryOnConsole;
-
-  static int executionContextId(v8::Local<v8::Context> context);
-
- private:
-  // Disallow copying and allocating this one.
-  enum NotNullTagEnum { NotNullLiteral };
-  void* operator new(size_t) = delete;
-  void* operator new(size_t, NotNullTagEnum, void*) = delete;
-  void* operator new(size_t, void*) = delete;
-  V8ContextInfo(const V8ContextInfo&) = delete;
-  V8ContextInfo& operator=(const V8ContextInfo&) = delete;
-};
-
-class V8_EXPORT V8StackTrace {
- public:
-  virtual bool isEmpty() const = 0;
-  virtual StringView topSourceURL() const = 0;
-  virtual int topLineNumber() const = 0;
-  virtual int topColumnNumber() const = 0;
-  virtual StringView topScriptId() const = 0;
-  virtual StringView topFunctionName() const = 0;
-
-  virtual ~V8StackTrace() {}
-  virtual std::unique_ptr<protocol::Runtime::API::StackTrace>
-  buildInspectorObject() const = 0;
-  virtual std::unique_ptr<StringBuffer> toString() const = 0;
-
-  // Safe to pass between threads, drops async chain.
-  virtual std::unique_ptr<V8StackTrace> clone() = 0;
-};
-
-class V8_EXPORT V8InspectorSession {
- public:
-  virtual ~V8InspectorSession() {}
-
-  // Cross-context inspectable values (DOM nodes in different worlds, etc.).
-  class V8_EXPORT Inspectable {
-   public:
-    virtual v8::Local<v8::Value> get(v8::Local<v8::Context>) = 0;
-    virtual ~Inspectable() {}
-  };
-  virtual void addInspectedObject(std::unique_ptr<Inspectable>) = 0;
-
-  // Dispatching protocol messages.
-  static bool canDispatchMethod(const StringView& method);
-  virtual void dispatchProtocolMessage(const StringView& message) = 0;
-  virtual std::unique_ptr<StringBuffer> stateJSON() = 0;
-  virtual std::vector<std::unique_ptr<protocol::Schema::API::Domain>>
-  supportedDomains() = 0;
-
-  // Debugger actions.
-  virtual void schedulePauseOnNextStatement(const StringView& breakReason,
-                                            const StringView& breakDetails) = 0;
-  virtual void cancelPauseOnNextStatement() = 0;
-  virtual void breakProgram(const StringView& breakReason,
-                            const StringView& breakDetails) = 0;
-  virtual void setSkipAllPauses(bool) = 0;
-  virtual void resume() = 0;
-  virtual void stepOver() = 0;
-  virtual std::vector<std::unique_ptr<protocol::Debugger::API::SearchMatch>>
-  searchInTextByLines(const StringView& text, const StringView& query,
-                      bool caseSensitive, bool isRegex) = 0;
-
-  // Remote objects.
-  virtual std::unique_ptr<protocol::Runtime::API::RemoteObject> wrapObject(
-      v8::Local<v8::Context>, v8::Local<v8::Value>,
-      const StringView& groupName) = 0;
-  virtual bool unwrapObject(std::unique_ptr<StringBuffer>* error,
-                            const StringView& objectId, v8::Local<v8::Value>*,
-                            v8::Local<v8::Context>*,
-                            std::unique_ptr<StringBuffer>* objectGroup) = 0;
-  virtual void releaseObjectGroup(const StringView&) = 0;
-};
-
-class V8_EXPORT V8InspectorClient {
- public:
-  virtual ~V8InspectorClient() {}
-
-  virtual void runMessageLoopOnPause(int contextGroupId) {}
-  virtual void quitMessageLoopOnPause() {}
-  virtual void runIfWaitingForDebugger(int contextGroupId) {}
-
-  virtual void muteMetrics(int contextGroupId) {}
-  virtual void unmuteMetrics(int contextGroupId) {}
-
-  virtual void beginUserGesture() {}
-  virtual void endUserGesture() {}
-
-  virtual std::unique_ptr<StringBuffer> valueSubtype(v8::Local<v8::Value>) {
-    return nullptr;
-  }
-  virtual bool formatAccessorsAsProperties(v8::Local<v8::Value>) {
-    return false;
-  }
-  virtual bool isInspectableHeapObject(v8::Local<v8::Object>) { return true; }
-
-  virtual v8::Local<v8::Context> ensureDefaultContextInGroup(
-      int contextGroupId) {
-    return v8::Local<v8::Context>();
-  }
-  virtual void beginEnsureAllContextsInGroup(int contextGroupId) {}
-  virtual void endEnsureAllContextsInGroup(int contextGroupId) {}
-
-  virtual void installAdditionalCommandLineAPI(v8::Local<v8::Context>,
-                                               v8::Local<v8::Object>) {}
-  virtual void consoleAPIMessage(int contextGroupId,
-                                 v8::Isolate::MessageErrorLevel level,
-                                 const StringView& message,
-                                 const StringView& url, unsigned lineNumber,
-                                 unsigned columnNumber, V8StackTrace*) {}
-  virtual v8::MaybeLocal<v8::Value> memoryInfo(v8::Isolate*,
-                                               v8::Local<v8::Context>) {
-    return v8::MaybeLocal<v8::Value>();
-  }
-
-  virtual void consoleTime(const StringView& title) {}
-  virtual void consoleTimeEnd(const StringView& title) {}
-  virtual void consoleTimeStamp(const StringView& title) {}
-  virtual void consoleClear(int contextGroupId) {}
-  virtual double currentTimeMS() { return 0; }
-  typedef void (*TimerCallback)(void*);
-  virtual void startRepeatingTimer(double, TimerCallback, void* data) {}
-  virtual void cancelTimer(void* data) {}
-
-  // TODO(dgozman): this was added to support service worker shadow page. We
-  // should not connect at all.
-  virtual bool canExecuteScripts(int contextGroupId) { return true; }
-};
-
-class V8_EXPORT V8Inspector {
- public:
-  static std::unique_ptr<V8Inspector> create(v8::Isolate*, V8InspectorClient*);
-  virtual ~V8Inspector() {}
-
-  // Contexts instrumentation.
-  virtual void contextCreated(const V8ContextInfo&) = 0;
-  virtual void contextDestroyed(v8::Local<v8::Context>) = 0;
-  virtual void resetContextGroup(int contextGroupId) = 0;
-
-  // Various instrumentation.
-  virtual void willExecuteScript(v8::Local<v8::Context>, int scriptId) = 0;
-  virtual void didExecuteScript(v8::Local<v8::Context>) = 0;
-  virtual void idleStarted() = 0;
-  virtual void idleFinished() = 0;
-
-  // Async stack traces instrumentation.
-  virtual void asyncTaskScheduled(const StringView& taskName, void* task,
-                                  bool recurring) = 0;
-  virtual void asyncTaskCanceled(void* task) = 0;
-  virtual void asyncTaskStarted(void* task) = 0;
-  virtual void asyncTaskFinished(void* task) = 0;
-  virtual void allAsyncTasksCanceled() = 0;
-
-  // Exceptions instrumentation.
-  virtual unsigned exceptionThrown(
-      v8::Local<v8::Context>, const StringView& message,
-      v8::Local<v8::Value> exception, const StringView& detailedMessage,
-      const StringView& url, unsigned lineNumber, unsigned columnNumber,
-      std::unique_ptr<V8StackTrace>, int scriptId) = 0;
-  virtual void exceptionRevoked(v8::Local<v8::Context>, unsigned exceptionId,
-                                const StringView& message) = 0;
-
-  // Connection.
-  class V8_EXPORT Channel {
-   public:
-    virtual ~Channel() {}
-    virtual void sendResponse(int callId,
-                              std::unique_ptr<StringBuffer> message) = 0;
-    virtual void sendNotification(std::unique_ptr<StringBuffer> message) = 0;
-    virtual void flushProtocolNotifications() = 0;
-  };
-  virtual std::unique_ptr<V8InspectorSession> connect(
-      int contextGroupId, Channel*, const StringView& state) = 0;
-
-  // API methods.
-  virtual std::unique_ptr<V8StackTrace> createStackTrace(
-      v8::Local<v8::StackTrace>) = 0;
-  virtual std::unique_ptr<V8StackTrace> captureStackTrace(bool fullStack) = 0;
-};
-
-}  // namespace v8_inspector
-
-#endif  // V8_V8_INSPECTOR_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/v8/include/v8-platform.h
+++ /dev/null
@@ -1,219 +0,0 @@
-// Copyright 2013 the V8 project authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef V8_V8_PLATFORM_H_
-#define V8_V8_PLATFORM_H_
-
-#include <stddef.h>
-#include <stdint.h>
-#include <memory>
-#include <string>
-
-namespace v8 {
-
-class Isolate;
-
-/**
- * A Task represents a unit of work.
- */
-class Task {
- public:
-  virtual ~Task() = default;
-
-  virtual void Run() = 0;
-};
-
-/**
- * An IdleTask represents a unit of work to be performed in idle time.
- * The Run method is invoked with an argument that specifies the deadline in
- * seconds returned by MonotonicallyIncreasingTime().
- * The idle task is expected to complete by this deadline.
- */
-class IdleTask {
- public:
-  virtual ~IdleTask() = default;
-  virtual void Run(double deadline_in_seconds) = 0;
-};
-
-/**
- * The interface represents complex arguments to trace events.
- */
-class ConvertableToTraceFormat {
- public:
-  virtual ~ConvertableToTraceFormat() = default;
-
-  /**
-   * Append the class info to the provided |out| string. The appended
-   * data must be a valid JSON object. Strings must be properly quoted, and
-   * escaped. There is no processing applied to the content after it is
-   * appended.
-   */
-  virtual void AppendAsTraceFormat(std::string* out) const = 0;
-};
-
-/**
- * V8 Platform abstraction layer.
- *
- * The embedder has to provide an implementation of this interface before
- * initializing the rest of V8.
- */
-class Platform {
- public:
-  /**
-   * This enum is used to indicate whether a task is potentially long running,
-   * or causes a long wait. The embedder might want to use this hint to decide
-   * whether to execute the task on a dedicated thread.
-   */
-  enum ExpectedRuntime {
-    kShortRunningTask,
-    kLongRunningTask
-  };
-
-  virtual ~Platform() = default;
-
-  /**
-   * Gets the number of threads that are used to execute background tasks. Is
-   * used to estimate the number of tasks a work package should be split into.
-   * A return value of 0 means that there are no background threads available.
-   * Note that a value of 0 won't prohibit V8 from posting tasks using
-   * |CallOnBackgroundThread|.
-   */
-  virtual size_t NumberOfAvailableBackgroundThreads() { return 0; }
-
-  /**
-   * Schedules a task to be invoked on a background thread. |expected_runtime|
-   * indicates that the task will run a long time. The Platform implementation
-   * takes ownership of |task|. There is no guarantee about order of execution
-   * of tasks wrt order of scheduling, nor is there a guarantee about the
-   * thread the task will be run on.
-   */
-  virtual void CallOnBackgroundThread(Task* task,
-                                      ExpectedRuntime expected_runtime) = 0;
-
-  /**
-   * Schedules a task to be invoked on a foreground thread wrt a specific
-   * |isolate|. Tasks posted for the same isolate should be execute in order of
-   * scheduling. The definition of "foreground" is opaque to V8.
-   */
-  virtual void CallOnForegroundThread(Isolate* isolate, Task* task) = 0;
-
-  /**
-   * Schedules a task to be invoked on a foreground thread wrt a specific
-   * |isolate| after the given number of seconds |delay_in_seconds|.
-   * Tasks posted for the same isolate should be execute in order of
-   * scheduling. The definition of "foreground" is opaque to V8.
-   */
-  virtual void CallDelayedOnForegroundThread(Isolate* isolate, Task* task,
-                                             double delay_in_seconds) = 0;
-
-  /**
-   * Schedules a task to be invoked on a foreground thread wrt a specific
-   * |isolate| when the embedder is idle.
-   * Requires that SupportsIdleTasks(isolate) is true.
-   * Idle tasks may be reordered relative to other task types and may be
-   * starved for an arbitrarily long time if no idle time is available.
-   * The definition of "foreground" is opaque to V8.
-   */
-  virtual void CallIdleOnForegroundThread(Isolate* isolate, IdleTask* task) {
-    // TODO(ulan): Make this function abstract after V8 roll in Chromium.
-  }
-
-  /**
-   * Returns true if idle tasks are enabled for the given |isolate|.
-   */
-  virtual bool IdleTasksEnabled(Isolate* isolate) {
-    // TODO(ulan): Make this function abstract after V8 roll in Chromium.
-    return false;
-  }
-
-  /**
-   * Monotonically increasing time in seconds from an arbitrary fixed point in
-   * the past. This function is expected to return at least
-   * millisecond-precision values. For this reason,
-   * it is recommended that the fixed point be no further in the past than
-   * the epoch.
-   **/
-  virtual double MonotonicallyIncreasingTime() = 0;
-
-  /**
-   * Called by TRACE_EVENT* macros, don't call this directly.
-   * The name parameter is a category group for example:
-   * TRACE_EVENT0("v8,parse", "V8.Parse")
-   * The pointer returned points to a value with zero or more of the bits
-   * defined in CategoryGroupEnabledFlags.
-   **/
-  virtual const uint8_t* GetCategoryGroupEnabled(const char* name) {
-    static uint8_t no = 0;
-    return &no;
-  }
-
-  /**
-   * Gets the category group name of the given category_enabled_flag pointer.
-   * Usually used while serliazing TRACE_EVENTs.
-   **/
-  virtual const char* GetCategoryGroupName(
-      const uint8_t* category_enabled_flag) {
-    static const char dummy[] = "dummy";
-    return dummy;
-  }
-
-  /**
-   * Adds a trace event to the platform tracing system. This function call is
-   * usually the result of a TRACE_* macro from trace_event_common.h when
-   * tracing and the category of the particular trace are enabled. It is not
-   * advisable to call this function on its own; it is really only meant to be
-   * used by the trace macros. The returned handle can be used by
-   * UpdateTraceEventDuration to update the duration of COMPLETE events.
-   */
-  virtual uint64_t AddTraceEvent(
-      char phase, const uint8_t* category_enabled_flag, const char* name,
-      const char* scope, uint64_t id, uint64_t bind_id, int32_t num_args,
-      const char** arg_names, const uint8_t* arg_types,
-      const uint64_t* arg_values, unsigned int flags) {
-    return 0;
-  }
-
-  /**
-   * Adds a trace event to the platform tracing system. This function call is
-   * usually the result of a TRACE_* macro from trace_event_common.h when
-   * tracing and the category of the particular trace are enabled. It is not
-   * advisable to call this function on its own; it is really only meant to be
-   * used by the trace macros. The returned handle can be used by
-   * UpdateTraceEventDuration to update the duration of COMPLETE events.
-   */
-  virtual uint64_t AddTraceEvent(
-      char phase, const uint8_t* category_enabled_flag, const char* name,
-      const char* scope, uint64_t id, uint64_t bind_id, int32_t num_args,
-      const char** arg_names, const uint8_t* arg_types,
-      const uint64_t* arg_values,
-      std::unique_ptr<ConvertableToTraceFormat>* arg_convertables,
-      unsigned int flags) {
-    return AddTraceEvent(phase, category_enabled_flag, name, scope, id, bind_id,
-                         num_args, arg_names, arg_types, arg_values, flags);
-  }
-
-  /**
-   * Sets the duration field of a COMPLETE trace event. It must be called with
-   * the handle returned from AddTraceEvent().
-   **/
-  virtual void UpdateTraceEventDuration(const uint8_t* category_enabled_flag,
-                                        const char* name, uint64_t handle) {}
-
-  class TraceStateObserver {
-   public:
-    virtual ~TraceStateObserver() = default;
-    virtual void OnTraceEnabled() = 0;
-    virtual void OnTraceDisabled() = 0;
-  };
-
-  /** Adds tracing state change observer. */
-  virtual void AddTraceStateObserver(TraceStateObserver*) {}
-
-  /** Removes tracing state change observer. */
-  virtual void RemoveTraceStateObserver(TraceStateObserver*) {}
-};
-
-}  // namespace v8
-
-#endif  // V8_V8_PLATFORM_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/v8/include/v8-profiler.h
+++ /dev/null
@@ -1,917 +0,0 @@
-// Copyright 2010 the V8 project authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef V8_V8_PROFILER_H_
-#define V8_V8_PROFILER_H_
-
-#include <unordered_set>
-#include <vector>
-#include "v8.h"  // NOLINT(build/include)
-
-/**
- * Profiler support for the V8 JavaScript engine.
- */
-namespace v8 {
-
-class HeapGraphNode;
-struct HeapStatsUpdate;
-
-typedef uint32_t SnapshotObjectId;
-
-
-struct CpuProfileDeoptFrame {
-  int script_id;
-  size_t position;
-};
-
-}  // namespace v8
-
-#ifdef V8_OS_WIN
-template class V8_EXPORT std::vector<v8::CpuProfileDeoptFrame>;
-#endif
-
-namespace v8 {
-
-struct V8_EXPORT CpuProfileDeoptInfo {
-  /** A pointer to a static string owned by v8. */
-  const char* deopt_reason;
-  std::vector<CpuProfileDeoptFrame> stack;
-};
-
-}  // namespace v8
-
-#ifdef V8_OS_WIN
-template class V8_EXPORT std::vector<v8::CpuProfileDeoptInfo>;
-#endif
-
-namespace v8 {
-
-/**
- * TracingCpuProfiler monitors tracing being enabled/disabled
- * and emits CpuProfile trace events once v8.cpu_profiler tracing category
- * is enabled. It has no overhead unless the category is enabled.
- */
-class V8_EXPORT TracingCpuProfiler {
- public:
-  static std::unique_ptr<TracingCpuProfiler> Create(Isolate*);
-  virtual ~TracingCpuProfiler() = default;
-
- protected:
-  TracingCpuProfiler() = default;
-};
-
-// TickSample captures the information collected for each sample.
-struct TickSample {
-  // Internal profiling (with --prof + tools/$OS-tick-processor) wants to
-  // include the runtime function we're calling. Externally exposed tick
-  // samples don't care.
-  enum RecordCEntryFrame { kIncludeCEntryFrame, kSkipCEntryFrame };
-
-  TickSample()
-      : state(OTHER),
-        pc(nullptr),
-        external_callback_entry(nullptr),
-        frames_count(0),
-        has_external_callback(false),
-        update_stats(true) {}
-
-  /**
-   * Initialize a tick sample from the isolate.
-   * \param isolate The isolate.
-   * \param state Execution state.
-   * \param record_c_entry_frame Include or skip the runtime function.
-   * \param update_stats Whether update the sample to the aggregated stats.
-   * \param use_simulator_reg_state When set to true and V8 is running under a
-   *                                simulator, the method will use the simulator
-   *                                register state rather than the one provided
-   *                                with |state| argument. Otherwise the method
-   *                                will use provided register |state| as is.
-   */
-  void Init(Isolate* isolate, const v8::RegisterState& state,
-            RecordCEntryFrame record_c_entry_frame, bool update_stats,
-            bool use_simulator_reg_state = true);
-  /**
-   * Get a call stack sample from the isolate.
-   * \param isolate The isolate.
-   * \param state Register state.
-   * \param record_c_entry_frame Include or skip the runtime function.
-   * \param frames Caller allocated buffer to store stack frames.
-   * \param frames_limit Maximum number of frames to capture. The buffer must
-   *                     be large enough to hold the number of frames.
-   * \param sample_info The sample info is filled up by the function
-   *                    provides number of actual captured stack frames and
-   *                    the current VM state.
-   * \param use_simulator_reg_state When set to true and V8 is running under a
-   *                                simulator, the method will use the simulator
-   *                                register state rather than the one provided
-   *                                with |state| argument. Otherwise the method
-   *                                will use provided register |state| as is.
-   * \note GetStackSample is thread and signal safe and should only be called
-   *                      when the JS thread is paused or interrupted.
-   *                      Otherwise the behavior is undefined.
-   */
-  static bool GetStackSample(Isolate* isolate, v8::RegisterState* state,
-                             RecordCEntryFrame record_c_entry_frame,
-                             void** frames, size_t frames_limit,
-                             v8::SampleInfo* sample_info,
-                             bool use_simulator_reg_state = true);
-  StateTag state;  // The state of the VM.
-  void* pc;        // Instruction pointer.
-  union {
-    void* tos;  // Top stack value (*sp).
-    void* external_callback_entry;
-  };
-  static const unsigned kMaxFramesCountLog2 = 8;
-  static const unsigned kMaxFramesCount = (1 << kMaxFramesCountLog2) - 1;
-  void* stack[kMaxFramesCount];                 // Call stack.
-  unsigned frames_count : kMaxFramesCountLog2;  // Number of captured frames.
-  bool has_external_callback : 1;
-  bool update_stats : 1;  // Whether the sample should update aggregated stats.
-};
-
-/**
- * CpuProfileNode represents a node in a call graph.
- */
-class V8_EXPORT CpuProfileNode {
- public:
-  struct LineTick {
-    /** The 1-based number of the source line where the function originates. */
-    int line;
-
-    /** The count of samples associated with the source line. */
-    unsigned int hit_count;
-  };
-
-  /** Returns function name (empty string for anonymous functions.) */
-  Local<String> GetFunctionName() const;
-
-  /**
-   * Returns function name (empty string for anonymous functions.)
-   * The string ownership is *not* passed to the caller. It stays valid until
-   * profile is deleted. The function is thread safe.
-   */
-  const char* GetFunctionNameStr() const;
-
-  /** Returns id of the script where function is located. */
-  int GetScriptId() const;
-
-  /** Returns resource name for script from where the function originates. */
-  Local<String> GetScriptResourceName() const;
-
-  /**
-   * Returns resource name for script from where the function originates.
-   * The string ownership is *not* passed to the caller. It stays valid until
-   * profile is deleted. The function is thread safe.
-   */
-  const char* GetScriptResourceNameStr() const;
-
-  /**
-   * Returns the number, 1-based, of the line where the function originates.
-   * kNoLineNumberInfo if no line number information is available.
-   */
-  int GetLineNumber() const;
-
-  /**
-   * Returns 1-based number of the column where the function originates.
-   * kNoColumnNumberInfo if no column number information is available.
-   */
-  int GetColumnNumber() const;
-
-  /**
-   * Returns the number of the function's source lines that collect the samples.
-   */
-  unsigned int GetHitLineCount() const;
-
-  /** Returns the set of source lines that collect the samples.
-   *  The caller allocates buffer and responsible for releasing it.
-   *  True if all available entries are copied, otherwise false.
-   *  The function copies nothing if buffer is not large enough.
-   */
-  bool GetLineTicks(LineTick* entries, unsigned int length) const;
-
-  /** Returns bailout reason for the function
-    * if the optimization was disabled for it.
-    */
-  const char* GetBailoutReason() const;
-
-  /**
-    * Returns the count of samples where the function was currently executing.
-    */
-  unsigned GetHitCount() const;
-
-  /** Returns function entry UID. */
-  V8_DEPRECATE_SOON(
-      "Use GetScriptId, GetLineNumber, and GetColumnNumber instead.",
-      unsigned GetCallUid() const);
-
-  /** Returns id of the node. The id is unique within the tree */
-  unsigned GetNodeId() const;
-
-  /** Returns child nodes count of the node. */
-  int GetChildrenCount() const;
-
-  /** Retrieves a child node by index. */
-  const CpuProfileNode* GetChild(int index) const;
-
-  /** Retrieves deopt infos for the node. */
-  const std::vector<CpuProfileDeoptInfo>& GetDeoptInfos() const;
-
-  static const int kNoLineNumberInfo = Message::kNoLineNumberInfo;
-  static const int kNoColumnNumberInfo = Message::kNoColumnInfo;
-};
-
-
-/**
- * CpuProfile contains a CPU profile in a form of top-down call tree
- * (from main() down to functions that do all the work).
- */
-class V8_EXPORT CpuProfile {
- public:
-  /** Returns CPU profile title. */
-  Local<String> GetTitle() const;
-
-  /** Returns the root node of the top down call tree. */
-  const CpuProfileNode* GetTopDownRoot() const;
-
-  /**
-   * Returns number of samples recorded. The samples are not recorded unless
-   * |record_samples| parameter of CpuProfiler::StartCpuProfiling is true.
-   */
-  int GetSamplesCount() const;
-
-  /**
-   * Returns profile node corresponding to the top frame the sample at
-   * the given index.
-   */
-  const CpuProfileNode* GetSample(int index) const;
-
-  /**
-   * Returns the timestamp of the sample. The timestamp is the number of
-   * microseconds since some unspecified starting point.
-   * The point is equal to the starting point used by GetStartTime.
-   */
-  int64_t GetSampleTimestamp(int index) const;
-
-  /**
-   * Returns time when the profile recording was started (in microseconds)
-   * since some unspecified starting point.
-   */
-  int64_t GetStartTime() const;
-
-  /**
-   * Returns time when the profile recording was stopped (in microseconds)
-   * since some unspecified starting point.
-   * The point is equal to the starting point used by GetStartTime.
-   */
-  int64_t GetEndTime() const;
-
-  /**
-   * Deletes the profile and removes it from CpuProfiler's list.
-   * All pointers to nodes previously returned become invalid.
-   */
-  void Delete();
-};
-
-/**
- * Interface for controlling CPU profiling. Instance of the
- * profiler can be created using v8::CpuProfiler::New method.
- */
-class V8_EXPORT CpuProfiler {
- public:
-  /**
-   * Creates a new CPU profiler for the |isolate|. The isolate must be
-   * initialized. The profiler object must be disposed after use by calling
-   * |Dispose| method.
-   */
-  static CpuProfiler* New(Isolate* isolate);
-
-  /**
-   * Disposes the CPU profiler object.
-   */
-  void Dispose();
-
-  /**
-   * Changes default CPU profiler sampling interval to the specified number
-   * of microseconds. Default interval is 1000us. This method must be called
-   * when there are no profiles being recorded.
-   */
-  void SetSamplingInterval(int us);
-
-  /**
-   * Starts collecting CPU profile. Title may be an empty string. It
-   * is allowed to have several profiles being collected at
-   * once. Attempts to start collecting several profiles with the same
-   * title are silently ignored. While collecting a profile, functions
-   * from all security contexts are included in it. The token-based
-   * filtering is only performed when querying for a profile.
-   *
-   * |record_samples| parameter controls whether individual samples should
-   * be recorded in addition to the aggregated tree.
-   */
-  void StartProfiling(Local<String> title, bool record_samples = false);
-
-  /**
-   * Stops collecting CPU profile with a given title and returns it.
-   * If the title given is empty, finishes the last profile started.
-   */
-  CpuProfile* StopProfiling(Local<String> title);
-
-  /**
-   * Force collection of a sample. Must be called on the VM thread.
-   * Recording the forced sample does not contribute to the aggregated
-   * profile statistics.
-   */
-  void CollectSample();
-
-  /**
-   * Tells the profiler whether the embedder is idle.
-   */
-  void SetIdle(bool is_idle);
-
- private:
-  CpuProfiler();
-  ~CpuProfiler();
-  CpuProfiler(const CpuProfiler&);
-  CpuProfiler& operator=(const CpuProfiler&);
-};
-
-
-/**
- * HeapSnapshotEdge represents a directed connection between heap
- * graph nodes: from retainers to retained nodes.
- */
-class V8_EXPORT HeapGraphEdge {
- public:
-  enum Type {
-    kContextVariable = 0,  // A variable from a function context.
-    kElement = 1,          // An element of an array.
-    kProperty = 2,         // A named object property.
-    kInternal = 3,         // A link that can't be accessed from JS,
-                           // thus, its name isn't a real property name
-                           // (e.g. parts of a ConsString).
-    kHidden = 4,           // A link that is needed for proper sizes
-                           // calculation, but may be hidden from user.
-    kShortcut = 5,         // A link that must not be followed during
-                           // sizes calculation.
-    kWeak = 6              // A weak reference (ignored by the GC).
-  };
-
-  /** Returns edge type (see HeapGraphEdge::Type). */
-  Type GetType() const;
-
-  /**
-   * Returns edge name. This can be a variable name, an element index, or
-   * a property name.
-   */
-  Local<Value> GetName() const;
-
-  /** Returns origin node. */
-  const HeapGraphNode* GetFromNode() const;
-
-  /** Returns destination node. */
-  const HeapGraphNode* GetToNode() const;
-};
-
-
-/**
- * HeapGraphNode represents a node in a heap graph.
- */
-class V8_EXPORT HeapGraphNode {
- public:
-  enum Type {
-    kHidden = 0,         // Hidden node, may be filtered when shown to user.
-    kArray = 1,          // An array of elements.
-    kString = 2,         // A string.
-    kObject = 3,         // A JS object (except for arrays and strings).
-    kCode = 4,           // Compiled code.
-    kClosure = 5,        // Function closure.
-    kRegExp = 6,         // RegExp.
-    kHeapNumber = 7,     // Number stored in the heap.
-    kNative = 8,         // Native object (not from V8 heap).
-    kSynthetic = 9,      // Synthetic object, usualy used for grouping
-                         // snapshot items together.
-    kConsString = 10,    // Concatenated string. A pair of pointers to strings.
-    kSlicedString = 11,  // Sliced string. A fragment of another string.
-    kSymbol = 12         // A Symbol (ES6).
-  };
-
-  /** Returns node type (see HeapGraphNode::Type). */
-  Type GetType() const;
-
-  /**
-   * Returns node name. Depending on node's type this can be the name
-   * of the constructor (for objects), the name of the function (for
-   * closures), string value, or an empty string (for compiled code).
-   */
-  Local<String> GetName() const;
-
-  /**
-   * Returns node id. For the same heap object, the id remains the same
-   * across all snapshots.
-   */
-  SnapshotObjectId GetId() const;
-
-  /** Returns node's own size, in bytes. */
-  size_t GetShallowSize() const;
-
-  /** Returns child nodes count of the node. */
-  int GetChildrenCount() const;
-
-  /** Retrieves a child by index. */
-  const HeapGraphEdge* GetChild(int index) const;
-};
-
-
-/**
- * An interface for exporting data from V8, using "push" model.
- */
-class V8_EXPORT OutputStream {  // NOLINT
- public:
-  enum WriteResult {
-    kContinue = 0,
-    kAbort = 1
-  };
-  virtual ~OutputStream() {}
-  /** Notify about the end of stream. */
-  virtual void EndOfStream() = 0;
-  /** Get preferred output chunk size. Called only once. */
-  virtual int GetChunkSize() { return 1024; }
-  /**
-   * Writes the next chunk of snapshot data into the stream. Writing
-   * can be stopped by returning kAbort as function result. EndOfStream
-   * will not be called in case writing was aborted.
-   */
-  virtual WriteResult WriteAsciiChunk(char* data, int size) = 0;
-  /**
-   * Writes the next chunk of heap stats data into the stream. Writing
-   * can be stopped by returning kAbort as function result. EndOfStream
-   * will not be called in case writing was aborted.
-   */
-  virtual WriteResult WriteHeapStatsChunk(HeapStatsUpdate* data, int count) {
-    return kAbort;
-  }
-};
-
-
-/**
- * HeapSnapshots record the state of the JS heap at some moment.
- */
-class V8_EXPORT HeapSnapshot {
- public:
-  enum SerializationFormat {
-    kJSON = 0  // See format description near 'Serialize' method.
-  };
-
-  /** Returns the root node of the heap graph. */
-  const HeapGraphNode* GetRoot() const;
-
-  /** Returns a node by its id. */
-  const HeapGraphNode* GetNodeById(SnapshotObjectId id) const;
-
-  /** Returns total nodes count in the snapshot. */
-  int GetNodesCount() const;
-
-  /** Returns a node by index. */
-  const HeapGraphNode* GetNode(int index) const;
-
-  /** Returns a max seen JS object Id. */
-  SnapshotObjectId GetMaxSnapshotJSObjectId() const;
-
-  /**
-   * Deletes the snapshot and removes it from HeapProfiler's list.
-   * All pointers to nodes, edges and paths previously returned become
-   * invalid.
-   */
-  void Delete();
-
-  /**
-   * Prepare a serialized representation of the snapshot. The result
-   * is written into the stream provided in chunks of specified size.
-   * The total length of the serialized snapshot is unknown in
-   * advance, it can be roughly equal to JS heap size (that means,
-   * it can be really big - tens of megabytes).
-   *
-   * For the JSON format, heap contents are represented as an object
-   * with the following structure:
-   *
-   *  {
-   *    snapshot: {
-   *      title: "...",
-   *      uid: nnn,
-   *      meta: { meta-info },
-   *      node_count: nnn,
-   *      edge_count: nnn
-   *    },
-   *    nodes: [nodes array],
-   *    edges: [edges array],
-   *    strings: [strings array]
-   *  }
-   *
-   * Nodes reference strings, other nodes, and edges by their indexes
-   * in corresponding arrays.
-   */
-  void Serialize(OutputStream* stream,
-                 SerializationFormat format = kJSON) const;
-};
-
-
-/**
- * An interface for reporting progress and controlling long-running
- * activities.
- */
-class V8_EXPORT ActivityControl {  // NOLINT
- public:
-  enum ControlOption {
-    kContinue = 0,
-    kAbort = 1
-  };
-  virtual ~ActivityControl() {}
-  /**
-   * Notify about current progress. The activity can be stopped by
-   * returning kAbort as the callback result.
-   */
-  virtual ControlOption ReportProgressValue(int done, int total) = 0;
-};
-
-
-/**
- * AllocationProfile is a sampled profile of allocations done by the program.
- * This is structured as a call-graph.
- */
-class V8_EXPORT AllocationProfile {
- public:
-  struct Allocation {
-    /**
-     * Size of the sampled allocation object.
-     */
-    size_t size;
-
-    /**
-     * The number of objects of such size that were sampled.
-     */
-    unsigned int count;
-  };
-
-  /**
-   * Represents a node in the call-graph.
-   */
-  struct Node {
-    /**
-     * Name of the function. May be empty for anonymous functions or if the
-     * script corresponding to this function has been unloaded.
-     */
-    Local<String> name;
-
-    /**
-     * Name of the script containing the function. May be empty if the script
-     * name is not available, or if the script has been unloaded.
-     */
-    Local<String> script_name;
-
-    /**
-     * id of the script where the function is located. May be equal to
-     * v8::UnboundScript::kNoScriptId in cases where the script doesn't exist.
-     */
-    int script_id;
-
-    /**
-     * Start position of the function in the script.
-     */
-    int start_position;
-
-    /**
-     * 1-indexed line number where the function starts. May be
-     * kNoLineNumberInfo if no line number information is available.
-     */
-    int line_number;
-
-    /**
-     * 1-indexed column number where the function starts. May be
-     * kNoColumnNumberInfo if no line number information is available.
-     */
-    int column_number;
-
-    /**
-     * List of callees called from this node for which we have sampled
-     * allocations. The lifetime of the children is scoped to the containing
-     * AllocationProfile.
-     */
-    std::vector<Node*> children;
-
-    /**
-     * List of self allocations done by this node in the call-graph.
-     */
-    std::vector<Allocation> allocations;
-  };
-
-  /**
-   * Returns the root node of the call-graph. The root node corresponds to an
-   * empty JS call-stack. The lifetime of the returned Node* is scoped to the
-   * containing AllocationProfile.
-   */
-  virtual Node* GetRootNode() = 0;
-
-  virtual ~AllocationProfile() {}
-
-  static const int kNoLineNumberInfo = Message::kNoLineNumberInfo;
-  static const int kNoColumnNumberInfo = Message::kNoColumnInfo;
-};
-
-
-/**
- * Interface for controlling heap profiling. Instance of the
- * profiler can be retrieved using v8::Isolate::GetHeapProfiler.
- */
-class V8_EXPORT HeapProfiler {
- public:
-  enum SamplingFlags {
-    kSamplingNoFlags = 0,
-    kSamplingForceGC = 1 << 0,
-  };
-
-  typedef std::unordered_set<const v8::PersistentBase<v8::Value>*>
-      RetainerChildren;
-  typedef std::vector<std::pair<v8::RetainedObjectInfo*, RetainerChildren>>
-      RetainerGroups;
-  typedef std::vector<std::pair<const v8::PersistentBase<v8::Value>*,
-                                const v8::PersistentBase<v8::Value>*>>
-      RetainerEdges;
-
-  struct RetainerInfos {
-    RetainerGroups groups;
-    RetainerEdges edges;
-  };
-
-  /**
-   * Callback function invoked to retrieve all RetainerInfos from the embedder.
-   */
-  typedef RetainerInfos (*GetRetainerInfosCallback)(v8::Isolate* isolate);
-
-  /**
-   * Callback function invoked for obtaining RetainedObjectInfo for
-   * the given JavaScript wrapper object. It is prohibited to enter V8
-   * while the callback is running: only getters on the handle and
-   * GetPointerFromInternalField on the objects are allowed.
-   */
-  typedef RetainedObjectInfo* (*WrapperInfoCallback)(uint16_t class_id,
-                                                     Local<Value> wrapper);
-
-  /** Returns the number of snapshots taken. */
-  int GetSnapshotCount();
-
-  /** Returns a snapshot by index. */
-  const HeapSnapshot* GetHeapSnapshot(int index);
-
-  /**
-   * Returns SnapshotObjectId for a heap object referenced by |value| if
-   * it has been seen by the heap profiler, kUnknownObjectId otherwise.
-   */
-  SnapshotObjectId GetObjectId(Local<Value> value);
-
-  /**
-   * Returns heap object with given SnapshotObjectId if the object is alive,
-   * otherwise empty handle is returned.
-   */
-  Local<Value> FindObjectById(SnapshotObjectId id);
-
-  /**
-   * Clears internal map from SnapshotObjectId to heap object. The new objects
-   * will not be added into it unless a heap snapshot is taken or heap object
-   * tracking is kicked off.
-   */
-  void ClearObjectIds();
-
-  /**
-   * A constant for invalid SnapshotObjectId. GetSnapshotObjectId will return
-   * it in case heap profiler cannot find id  for the object passed as
-   * parameter. HeapSnapshot::GetNodeById will always return NULL for such id.
-   */
-  static const SnapshotObjectId kUnknownObjectId = 0;
-
-  /**
-   * Callback interface for retrieving user friendly names of global objects.
-   */
-  class ObjectNameResolver {
-   public:
-    /**
-     * Returns name to be used in the heap snapshot for given node. Returned
-     * string must stay alive until snapshot collection is completed.
-     */
-    virtual const char* GetName(Local<Object> object) = 0;
-
-   protected:
-    virtual ~ObjectNameResolver() {}
-  };
-
-  /**
-   * Takes a heap snapshot and returns it.
-   */
-  const HeapSnapshot* TakeHeapSnapshot(
-      ActivityControl* control = NULL,
-      ObjectNameResolver* global_object_name_resolver = NULL);
-
-  /**
-   * Starts tracking of heap objects population statistics. After calling
-   * this method, all heap objects relocations done by the garbage collector
-   * are being registered.
-   *
-   * |track_allocations| parameter controls whether stack trace of each
-   * allocation in the heap will be recorded and reported as part of
-   * HeapSnapshot.
-   */
-  void StartTrackingHeapObjects(bool track_allocations = false);
-
-  /**
-   * Adds a new time interval entry to the aggregated statistics array. The
-   * time interval entry contains information on the current heap objects
-   * population size. The method also updates aggregated statistics and
-   * reports updates for all previous time intervals via the OutputStream
-   * object. Updates on each time interval are provided as a stream of the
-   * HeapStatsUpdate structure instances.
-   * If |timestamp_us| is supplied, timestamp of the new entry will be written
-   * into it. The return value of the function is the last seen heap object Id.
-   *
-   * StartTrackingHeapObjects must be called before the first call to this
-   * method.
-   */
-  SnapshotObjectId GetHeapStats(OutputStream* stream,
-                                int64_t* timestamp_us = NULL);
-
-  /**
-   * Stops tracking of heap objects population statistics, cleans up all
-   * collected data. StartHeapObjectsTracking must be called again prior to
-   * calling GetHeapStats next time.
-   */
-  void StopTrackingHeapObjects();
-
-  /**
-   * Starts gathering a sampling heap profile. A sampling heap profile is
-   * similar to tcmalloc's heap profiler and Go's mprof. It samples object
-   * allocations and builds an online 'sampling' heap profile. At any point in
-   * time, this profile is expected to be a representative sample of objects
-   * currently live in the system. Each sampled allocation includes the stack
-   * trace at the time of allocation, which makes this really useful for memory
-   * leak detection.
-   *
-   * This mechanism is intended to be cheap enough that it can be used in
-   * production with minimal performance overhead.
-   *
-   * Allocations are sampled using a randomized Poisson process. On average, one
-   * allocation will be sampled every |sample_interval| bytes allocated. The
-   * |stack_depth| parameter controls the maximum number of stack frames to be
-   * captured on each allocation.
-   *
-   * NOTE: This is a proof-of-concept at this point. Right now we only sample
-   * newspace allocations. Support for paged space allocation (e.g. pre-tenured
-   * objects, large objects, code objects, etc.) and native allocations
-   * doesn't exist yet, but is anticipated in the future.
-   *
-   * Objects allocated before the sampling is started will not be included in
-   * the profile.
-   *
-   * Returns false if a sampling heap profiler is already running.
-   */
-  bool StartSamplingHeapProfiler(uint64_t sample_interval = 512 * 1024,
-                                 int stack_depth = 16,
-                                 SamplingFlags flags = kSamplingNoFlags);
-
-  /**
-   * Stops the sampling heap profile and discards the current profile.
-   */
-  void StopSamplingHeapProfiler();
-
-  /**
-   * Returns the sampled profile of allocations allocated (and still live) since
-   * StartSamplingHeapProfiler was called. The ownership of the pointer is
-   * transfered to the caller. Returns nullptr if sampling heap profiler is not
-   * active.
-   */
-  AllocationProfile* GetAllocationProfile();
-
-  /**
-   * Deletes all snapshots taken. All previously returned pointers to
-   * snapshots and their contents become invalid after this call.
-   */
-  void DeleteAllHeapSnapshots();
-
-  /** Binds a callback to embedder's class ID. */
-  void SetWrapperClassInfoProvider(
-      uint16_t class_id,
-      WrapperInfoCallback callback);
-
-  void SetGetRetainerInfosCallback(GetRetainerInfosCallback callback);
-
-  /**
-   * Default value of persistent handle class ID. Must not be used to
-   * define a class. Can be used to reset a class of a persistent
-   * handle.
-   */
-  static const uint16_t kPersistentHandleNoClassId = 0;
-
-  /** Returns memory used for profiler internal data and snapshots. */
-  size_t GetProfilerMemorySize();
-
-  /**
-   * Sets a RetainedObjectInfo for an object group (see V8::SetObjectGroupId).
-   */
-  void SetRetainedObjectInfo(UniqueId id, RetainedObjectInfo* info);
-
- private:
-  HeapProfiler();
-  ~HeapProfiler();
-  HeapProfiler(const HeapProfiler&);
-  HeapProfiler& operator=(const HeapProfiler&);
-};
-
-/**
- * Interface for providing information about embedder's objects
- * held by global handles. This information is reported in two ways:
- *
- *  1. When calling AddObjectGroup, an embedder may pass
- *     RetainedObjectInfo instance describing the group.  To collect
- *     this information while taking a heap snapshot, V8 calls GC
- *     prologue and epilogue callbacks.
- *
- *  2. When a heap snapshot is collected, V8 additionally
- *     requests RetainedObjectInfos for persistent handles that
- *     were not previously reported via AddObjectGroup.
- *
- * Thus, if an embedder wants to provide information about native
- * objects for heap snapshots, it can do it in a GC prologue
- * handler, and / or by assigning wrapper class ids in the following way:
- *
- *  1. Bind a callback to class id by calling SetWrapperClassInfoProvider.
- *  2. Call SetWrapperClassId on certain persistent handles.
- *
- * V8 takes ownership of RetainedObjectInfo instances passed to it and
- * keeps them alive only during snapshot collection. Afterwards, they
- * are freed by calling the Dispose class function.
- */
-class V8_EXPORT RetainedObjectInfo {  // NOLINT
- public:
-  /** Called by V8 when it no longer needs an instance. */
-  virtual void Dispose() = 0;
-
-  /** Returns whether two instances are equivalent. */
-  virtual bool IsEquivalent(RetainedObjectInfo* other) = 0;
-
-  /**
-   * Returns hash value for the instance. Equivalent instances
-   * must have the same hash value.
-   */
-  virtual intptr_t GetHash() = 0;
-
-  /**
-   * Returns human-readable label. It must be a null-terminated UTF-8
-   * encoded string. V8 copies its contents during a call to GetLabel.
-   */
-  virtual const char* GetLabel() = 0;
-
-  /**
-   * Returns human-readable group label. It must be a null-terminated UTF-8
-   * encoded string. V8 copies its contents during a call to GetGroupLabel.
-   * Heap snapshot generator will collect all the group names, create
-   * top level entries with these names and attach the objects to the
-   * corresponding top level group objects. There is a default
-   * implementation which is required because embedders don't have their
-   * own implementation yet.
-   */
-  virtual const char* GetGroupLabel() { return GetLabel(); }
-
-  /**
-   * Returns element count in case if a global handle retains
-   * a subgraph by holding one of its nodes.
-   */
-  virtual intptr_t GetElementCount() { return -1; }
-
-  /** Returns embedder's object size in bytes. */
-  virtual intptr_t GetSizeInBytes() { return -1; }
-
- protected:
-  RetainedObjectInfo() {}
-  virtual ~RetainedObjectInfo() {}
-
- private:
-  RetainedObjectInfo(const RetainedObjectInfo&);
-  RetainedObjectInfo& operator=(const RetainedObjectInfo&);
-};
-
-
-/**
- * A struct for exporting HeapStats data from V8, using "push" model.
- * See HeapProfiler::GetHeapStats.
- */
-struct HeapStatsUpdate {
-  HeapStatsUpdate(uint32_t index, uint32_t count, uint32_t size)
-    : index(index), count(count), size(size) { }
-  uint32_t index;  // Index of the time interval that was changed.
-  uint32_t count;  // New value of count field for the interval with this index.
-  uint32_t size;  // New value of size field for the interval with this index.
-};
-
-
-}  // namespace v8
-
-
-#endif  // V8_V8_PROFILER_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/v8/include/v8-testing.h
+++ /dev/null
@@ -1,48 +0,0 @@
-// Copyright 2010 the V8 project authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef V8_V8_TEST_H_
-#define V8_V8_TEST_H_
-
-#include "v8.h"  // NOLINT(build/include)
-
-/**
- * Testing support for the V8 JavaScript engine.
- */
-namespace v8 {
-
-class V8_EXPORT Testing {
- public:
-  enum StressType {
-    kStressTypeOpt,
-    kStressTypeDeopt
-  };
-
-  /**
-   * Set the type of stressing to do. The default if not set is kStressTypeOpt.
-   */
-  static void SetStressRunType(StressType type);
-
-  /**
-   * Get the number of runs of a given test that is required to get the full
-   * stress coverage.
-   */
-  static int GetStressRuns();
-
-  /**
-   * Indicate the number of the run which is about to start. The value of run
-   * should be between 0 and one less than the result from GetStressRuns()
-   */
-  static void PrepareStressRun(int run);
-
-  /**
-   * Force deoptimization of all functions.
-   */
-  static void DeoptimizeAll(Isolate* isolate);
-};
-
-
-}  // namespace v8
-
-#endif  // V8_V8_TEST_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/v8/include/v8-util.h
+++ /dev/null
@@ -1,655 +0,0 @@
-// Copyright 2014 the V8 project authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef V8_UTIL_H_
-#define V8_UTIL_H_
-
-#include "v8.h"  // NOLINT(build/include)
-#include <assert.h>
-#include <map>
-#include <vector>
-
-/**
- * Support for Persistent containers.
- *
- * C++11 embedders can use STL containers with Global values,
- * but pre-C++11 does not support the required move semantic and hence
- * may want these container classes.
- */
-namespace v8 {
-
-typedef uintptr_t PersistentContainerValue;
-static const uintptr_t kPersistentContainerNotFound = 0;
-enum PersistentContainerCallbackType {
-  kNotWeak,
-  // These correspond to v8::WeakCallbackType
-  kWeakWithParameter,
-  kWeakWithInternalFields,
-  kWeak = kWeakWithParameter  // For backwards compatibility.  Deprecate.
-};
-
-
-/**
- * A default trait implemenation for PersistentValueMap which uses std::map
- * as a backing map.
- *
- * Users will have to implement their own weak callbacks & dispose traits.
- */
-template<typename K, typename V>
-class StdMapTraits {
- public:
-  // STL map & related:
-  typedef std::map<K, PersistentContainerValue> Impl;
-  typedef typename Impl::iterator Iterator;
-
-  static bool Empty(Impl* impl) { return impl->empty(); }
-  static size_t Size(Impl* impl) { return impl->size(); }
-  static void Swap(Impl& a, Impl& b) { std::swap(a, b); }  // NOLINT
-  static Iterator Begin(Impl* impl) { return impl->begin(); }
-  static Iterator End(Impl* impl) { return impl->end(); }
-  static K Key(Iterator it) { return it->first; }
-  static PersistentContainerValue Value(Iterator it) { return it->second; }
-  static PersistentContainerValue Set(Impl* impl, K key,
-      PersistentContainerValue value) {
-    std::pair<Iterator, bool> res = impl->insert(std::make_pair(key, value));
-    PersistentContainerValue old_value = kPersistentContainerNotFound;
-    if (!res.second) {
-      old_value = res.first->second;
-      res.first->second = value;
-    }
-    return old_value;
-  }
-  static PersistentContainerValue Get(Impl* impl, K key) {
-    Iterator it = impl->find(key);
-    if (it == impl->end()) return kPersistentContainerNotFound;
-    return it->second;
-  }
-  static PersistentContainerValue Remove(Impl* impl, K key) {
-    Iterator it = impl->find(key);
-    if (it == impl->end()) return kPersistentContainerNotFound;
-    PersistentContainerValue value = it->second;
-    impl->erase(it);
-    return value;
-  }
-};
-
-
-/**
- * A default trait implementation for PersistentValueMap, which inherits
- * a std:map backing map from StdMapTraits and holds non-weak persistent
- * objects and has no special Dispose handling.
- *
- * You should not derive from this class, since MapType depends on the
- * surrounding class, and hence a subclass cannot simply inherit the methods.
- */
-template<typename K, typename V>
-class DefaultPersistentValueMapTraits : public StdMapTraits<K, V> {
- public:
-  // Weak callback & friends:
-  static const PersistentContainerCallbackType kCallbackType = kNotWeak;
-  typedef PersistentValueMap<K, V, DefaultPersistentValueMapTraits<K, V> >
-      MapType;
-  typedef void WeakCallbackDataType;
-
-  static WeakCallbackDataType* WeakCallbackParameter(
-      MapType* map, const K& key, Local<V> value) {
-    return NULL;
-  }
-  static MapType* MapFromWeakCallbackInfo(
-      const WeakCallbackInfo<WeakCallbackDataType>& data) {
-    return NULL;
-  }
-  static K KeyFromWeakCallbackInfo(
-      const WeakCallbackInfo<WeakCallbackDataType>& data) {
-    return K();
-  }
-  static void DisposeCallbackData(WeakCallbackDataType* data) { }
-  static void Dispose(Isolate* isolate, Global<V> value, K key) {}
-};
-
-
-template <typename K, typename V>
-class DefaultGlobalMapTraits : public StdMapTraits<K, V> {
- private:
-  template <typename T>
-  struct RemovePointer;
-
- public:
-  // Weak callback & friends:
-  static const PersistentContainerCallbackType kCallbackType = kNotWeak;
-  typedef GlobalValueMap<K, V, DefaultGlobalMapTraits<K, V> > MapType;
-  typedef void WeakCallbackDataType;
-
-  static WeakCallbackDataType* WeakCallbackParameter(MapType* map, const K& key,
-                                                     Local<V> value) {
-    return nullptr;
-  }
-  static MapType* MapFromWeakCallbackInfo(
-      const WeakCallbackInfo<WeakCallbackDataType>& data) {
-    return nullptr;
-  }
-  static K KeyFromWeakCallbackInfo(
-      const WeakCallbackInfo<WeakCallbackDataType>& data) {
-    return K();
-  }
-  static void DisposeCallbackData(WeakCallbackDataType* data) {}
-  static void OnWeakCallback(
-      const WeakCallbackInfo<WeakCallbackDataType>& data) {}
-  static void Dispose(Isolate* isolate, Global<V> value, K key) {}
-  // This is a second pass callback, so SetSecondPassCallback cannot be called.
-  static void DisposeWeak(const WeakCallbackInfo<WeakCallbackDataType>& data) {}
-
- private:
-  template <typename T>
-  struct RemovePointer<T*> {
-    typedef T Type;
-  };
-};
-
-
-/**
- * A map wrapper that allows using Global as a mapped value.
- * C++11 embedders don't need this class, as they can use Global
- * directly in std containers.
- *
- * The map relies on a backing map, whose type and accessors are described
- * by the Traits class. The backing map will handle values of type
- * PersistentContainerValue, with all conversion into and out of V8
- * handles being transparently handled by this class.
- */
-template <typename K, typename V, typename Traits>
-class PersistentValueMapBase {
- public:
-  Isolate* GetIsolate() { return isolate_; }
-
-  /**
-   * Return size of the map.
-   */
-  size_t Size() { return Traits::Size(&impl_); }
-
-  /**
-   * Return whether the map holds weak persistents.
-   */
-  bool IsWeak() { return Traits::kCallbackType != kNotWeak; }
-
-  /**
-   * Get value stored in map.
-   */
-  Local<V> Get(const K& key) {
-    return Local<V>::New(isolate_, FromVal(Traits::Get(&impl_, key)));
-  }
-
-  /**
-   * Check whether a value is contained in the map.
-   */
-  bool Contains(const K& key) {
-    return Traits::Get(&impl_, key) != kPersistentContainerNotFound;
-  }
-
-  /**
-   * Get value stored in map and set it in returnValue.
-   * Return true if a value was found.
-   */
-  bool SetReturnValue(const K& key,
-      ReturnValue<Value> returnValue) {
-    return SetReturnValueFromVal(&returnValue, Traits::Get(&impl_, key));
-  }
-
-  /**
-   * Call Isolate::SetReference with the given parent and the map value.
-   */
-  void SetReference(const K& key,
-      const Persistent<Object>& parent) {
-    GetIsolate()->SetReference(
-      reinterpret_cast<internal::Object**>(parent.val_),
-      reinterpret_cast<internal::Object**>(FromVal(Traits::Get(&impl_, key))));
-  }
-
-  /**
-   * Call V8::RegisterExternallyReferencedObject with the map value for given
-   * key.
-   */
-  void RegisterExternallyReferencedObject(K& key) {
-    assert(Contains(key));
-    V8::RegisterExternallyReferencedObject(
-        reinterpret_cast<internal::Object**>(FromVal(Traits::Get(&impl_, key))),
-        reinterpret_cast<internal::Isolate*>(GetIsolate()));
-  }
-
-  /**
-   * Return value for key and remove it from the map.
-   */
-  Global<V> Remove(const K& key) {
-    return Release(Traits::Remove(&impl_, key)).Pass();
-  }
-
-  /**
-  * Traverses the map repeatedly,
-  * in case side effects of disposal cause insertions.
-  **/
-  void Clear() {
-    typedef typename Traits::Iterator It;
-    HandleScope handle_scope(isolate_);
-    // TODO(dcarney): figure out if this swap and loop is necessary.
-    while (!Traits::Empty(&impl_)) {
-      typename Traits::Impl impl;
-      Traits::Swap(impl_, impl);
-      for (It i = Traits::Begin(&impl); i != Traits::End(&impl); ++i) {
-        Traits::Dispose(isolate_, Release(Traits::Value(i)).Pass(),
-                        Traits::Key(i));
-      }
-    }
-  }
-
-  /**
-   * Helper class for GetReference/SetWithReference. Do not use outside
-   * that context.
-   */
-  class PersistentValueReference {
-   public:
-    PersistentValueReference() : value_(kPersistentContainerNotFound) { }
-    PersistentValueReference(const PersistentValueReference& other)
-        : value_(other.value_) { }
-
-    Local<V> NewLocal(Isolate* isolate) const {
-      return Local<V>::New(isolate, FromVal(value_));
-    }
-    bool IsEmpty() const {
-      return value_ == kPersistentContainerNotFound;
-    }
-    template<typename T>
-    bool SetReturnValue(ReturnValue<T> returnValue) {
-      return SetReturnValueFromVal(&returnValue, value_);
-    }
-    void Reset() {
-      value_ = kPersistentContainerNotFound;
-    }
-    void operator=(const PersistentValueReference& other) {
-      value_ = other.value_;
-    }
-
-   private:
-    friend class PersistentValueMapBase;
-    friend class PersistentValueMap<K, V, Traits>;
-    friend class GlobalValueMap<K, V, Traits>;
-
-    explicit PersistentValueReference(PersistentContainerValue value)
-        : value_(value) { }
-
-    void operator=(PersistentContainerValue value) {
-      value_ = value;
-    }
-
-    PersistentContainerValue value_;
-  };
-
-  /**
-   * Get a reference to a map value. This enables fast, repeated access
-   * to a value stored in the map while the map remains unchanged.
-   *
-   * Careful: This is potentially unsafe, so please use with care.
-   * The value will become invalid if the value for this key changes
-   * in the underlying map, as a result of Set or Remove for the same
-   * key; as a result of the weak callback for the same key; or as a
-   * result of calling Clear() or destruction of the map.
-   */
-  PersistentValueReference GetReference(const K& key) {
-    return PersistentValueReference(Traits::Get(&impl_, key));
-  }
-
- protected:
-  explicit PersistentValueMapBase(Isolate* isolate) : isolate_(isolate) {}
-
-  ~PersistentValueMapBase() { Clear(); }
-
-  Isolate* isolate() { return isolate_; }
-  typename Traits::Impl* impl() { return &impl_; }
-
-  static V* FromVal(PersistentContainerValue v) {
-    return reinterpret_cast<V*>(v);
-  }
-
-  static PersistentContainerValue ClearAndLeak(Global<V>* persistent) {
-    V* v = persistent->val_;
-    persistent->val_ = 0;
-    return reinterpret_cast<PersistentContainerValue>(v);
-  }
-
-  static PersistentContainerValue Leak(Global<V>* persistent) {
-    return reinterpret_cast<PersistentContainerValue>(persistent->val_);
-  }
-
-  /**
-   * Return a container value as Global and make sure the weak
-   * callback is properly disposed of. All remove functionality should go
-   * through this.
-   */
-  static Global<V> Release(PersistentContainerValue v) {
-    Global<V> p;
-    p.val_ = FromVal(v);
-    if (Traits::kCallbackType != kNotWeak && p.IsWeak()) {
-      Traits::DisposeCallbackData(
-          p.template ClearWeak<typename Traits::WeakCallbackDataType>());
-    }
-    return p.Pass();
-  }
-
-  void RemoveWeak(const K& key) {
-    Global<V> p;
-    p.val_ = FromVal(Traits::Remove(&impl_, key));
-    p.Reset();
-  }
-
- private:
-  PersistentValueMapBase(PersistentValueMapBase&);
-  void operator=(PersistentValueMapBase&);
-
-  static bool SetReturnValueFromVal(ReturnValue<Value>* returnValue,
-                                    PersistentContainerValue value) {
-    bool hasValue = value != kPersistentContainerNotFound;
-    if (hasValue) {
-      returnValue->SetInternal(
-          *reinterpret_cast<internal::Object**>(FromVal(value)));
-    }
-    return hasValue;
-  }
-
-  Isolate* isolate_;
-  typename Traits::Impl impl_;
-};
-
-
-template <typename K, typename V, typename Traits>
-class PersistentValueMap : public PersistentValueMapBase<K, V, Traits> {
- public:
-  explicit PersistentValueMap(Isolate* isolate)
-      : PersistentValueMapBase<K, V, Traits>(isolate) {}
-
-  typedef
-      typename PersistentValueMapBase<K, V, Traits>::PersistentValueReference
-          PersistentValueReference;
-
-  /**
-   * Put value into map. Depending on Traits::kIsWeak, the value will be held
-   * by the map strongly or weakly.
-   * Returns old value as Global.
-   */
-  Global<V> Set(const K& key, Local<V> value) {
-    Global<V> persistent(this->isolate(), value);
-    return SetUnique(key, &persistent);
-  }
-
-  /**
-   * Put value into map, like Set(const K&, Local<V>).
-   */
-  Global<V> Set(const K& key, Global<V> value) {
-    return SetUnique(key, &value);
-  }
-
-  /**
-   * Put the value into the map, and set the 'weak' callback when demanded
-   * by the Traits class.
-   */
-  Global<V> SetUnique(const K& key, Global<V>* persistent) {
-    if (Traits::kCallbackType != kNotWeak) {
-      Local<V> value(Local<V>::New(this->isolate(), *persistent));
-      persistent->template SetWeak<typename Traits::WeakCallbackDataType>(
-        Traits::WeakCallbackParameter(this, key, value), WeakCallback);
-    }
-    PersistentContainerValue old_value =
-        Traits::Set(this->impl(), key, this->ClearAndLeak(persistent));
-    return this->Release(old_value).Pass();
-  }
-
-  /**
-   * Put a value into the map and update the reference.
-   * Restrictions of GetReference apply here as well.
-   */
-  Global<V> Set(const K& key, Global<V> value,
-                PersistentValueReference* reference) {
-    *reference = this->Leak(&value);
-    return SetUnique(key, &value);
-  }
-
- private:
-  static void WeakCallback(
-      const WeakCallbackInfo<typename Traits::WeakCallbackDataType>& data) {
-    if (Traits::kCallbackType != kNotWeak) {
-      PersistentValueMap<K, V, Traits>* persistentValueMap =
-          Traits::MapFromWeakCallbackInfo(data);
-      K key = Traits::KeyFromWeakCallbackInfo(data);
-      Traits::Dispose(data.GetIsolate(),
-                      persistentValueMap->Remove(key).Pass(), key);
-      Traits::DisposeCallbackData(data.GetParameter());
-    }
-  }
-};
-
-
-template <typename K, typename V, typename Traits>
-class GlobalValueMap : public PersistentValueMapBase<K, V, Traits> {
- public:
-  explicit GlobalValueMap(Isolate* isolate)
-      : PersistentValueMapBase<K, V, Traits>(isolate) {}
-
-  typedef
-      typename PersistentValueMapBase<K, V, Traits>::PersistentValueReference
-          PersistentValueReference;
-
-  /**
-   * Put value into map. Depending on Traits::kIsWeak, the value will be held
-   * by the map strongly or weakly.
-   * Returns old value as Global.
-   */
-  Global<V> Set(const K& key, Local<V> value) {
-    Global<V> persistent(this->isolate(), value);
-    return SetUnique(key, &persistent);
-  }
-
-  /**
-   * Put value into map, like Set(const K&, Local<V>).
-   */
-  Global<V> Set(const K& key, Global<V> value) {
-    return SetUnique(key, &value);
-  }
-
-  /**
-   * Put the value into the map, and set the 'weak' callback when demanded
-   * by the Traits class.
-   */
-  Global<V> SetUnique(const K& key, Global<V>* persistent) {
-    if (Traits::kCallbackType != kNotWeak) {
-      WeakCallbackType callback_type =
-          Traits::kCallbackType == kWeakWithInternalFields
-              ? WeakCallbackType::kInternalFields
-              : WeakCallbackType::kParameter;
-      Local<V> value(Local<V>::New(this->isolate(), *persistent));
-      persistent->template SetWeak<typename Traits::WeakCallbackDataType>(
-          Traits::WeakCallbackParameter(this, key, value), OnWeakCallback,
-          callback_type);
-    }
-    PersistentContainerValue old_value =
-        Traits::Set(this->impl(), key, this->ClearAndLeak(persistent));
-    return this->Release(old_value).Pass();
-  }
-
-  /**
-   * Put a value into the map and update the reference.
-   * Restrictions of GetReference apply here as well.
-   */
-  Global<V> Set(const K& key, Global<V> value,
-                PersistentValueReference* reference) {
-    *reference = this->Leak(&value);
-    return SetUnique(key, &value);
-  }
-
- private:
-  static void OnWeakCallback(
-      const WeakCallbackInfo<typename Traits::WeakCallbackDataType>& data) {
-    if (Traits::kCallbackType != kNotWeak) {
-      auto map = Traits::MapFromWeakCallbackInfo(data);
-      K key = Traits::KeyFromWeakCallbackInfo(data);
-      map->RemoveWeak(key);
-      Traits::OnWeakCallback(data);
-      data.SetSecondPassCallback(SecondWeakCallback);
-    }
-  }
-
-  static void SecondWeakCallback(
-      const WeakCallbackInfo<typename Traits::WeakCallbackDataType>& data) {
-    Traits::DisposeWeak(data);
-  }
-};
-
-
-/**
- * A map that uses Global as value and std::map as the backing
- * implementation. Persistents are held non-weak.
- *
- * C++11 embedders don't need this class, as they can use
- * Global directly in std containers.
- */
-template<typename K, typename V,
-    typename Traits = DefaultPersistentValueMapTraits<K, V> >
-class StdPersistentValueMap : public PersistentValueMap<K, V, Traits> {
- public:
-  explicit StdPersistentValueMap(Isolate* isolate)
-      : PersistentValueMap<K, V, Traits>(isolate) {}
-};
-
-
-/**
- * A map that uses Global as value and std::map as the backing
- * implementation. Globals are held non-weak.
- *
- * C++11 embedders don't need this class, as they can use
- * Global directly in std containers.
- */
-template <typename K, typename V,
-          typename Traits = DefaultGlobalMapTraits<K, V> >
-class StdGlobalValueMap : public GlobalValueMap<K, V, Traits> {
- public:
-  explicit StdGlobalValueMap(Isolate* isolate)
-      : GlobalValueMap<K, V, Traits>(isolate) {}
-};
-
-
-class DefaultPersistentValueVectorTraits {
- public:
-  typedef std::vector<PersistentContainerValue> Impl;
-
-  static void Append(Impl* impl, PersistentContainerValue value) {
-    impl->push_back(value);
-  }
-  static bool IsEmpty(const Impl* impl) {
-    return impl->empty();
-  }
-  static size_t Size(const Impl* impl) {
-    return impl->size();
-  }
-  static PersistentContainerValue Get(const Impl* impl, size_t i) {
-    return (i < impl->size()) ? impl->at(i) : kPersistentContainerNotFound;
-  }
-  static void ReserveCapacity(Impl* impl, size_t capacity) {
-    impl->reserve(capacity);
-  }
-  static void Clear(Impl* impl) {
-    impl->clear();
-  }
-};
-
-
-/**
- * A vector wrapper that safely stores Global values.
- * C++11 embedders don't need this class, as they can use Global
- * directly in std containers.
- *
- * This class relies on a backing vector implementation, whose type and methods
- * are described by the Traits class. The backing map will handle values of type
- * PersistentContainerValue, with all conversion into and out of V8
- * handles being transparently handled by this class.
- */
-template<typename V, typename Traits = DefaultPersistentValueVectorTraits>
-class PersistentValueVector {
- public:
-  explicit PersistentValueVector(Isolate* isolate) : isolate_(isolate) { }
-
-  ~PersistentValueVector() {
-    Clear();
-  }
-
-  /**
-   * Append a value to the vector.
-   */
-  void Append(Local<V> value) {
-    Global<V> persistent(isolate_, value);
-    Traits::Append(&impl_, ClearAndLeak(&persistent));
-  }
-
-  /**
-   * Append a persistent's value to the vector.
-   */
-  void Append(Global<V> persistent) {
-    Traits::Append(&impl_, ClearAndLeak(&persistent));
-  }
-
-  /**
-   * Are there any values in the vector?
-   */
-  bool IsEmpty() const {
-    return Traits::IsEmpty(&impl_);
-  }
-
-  /**
-   * How many elements are in the vector?
-   */
-  size_t Size() const {
-    return Traits::Size(&impl_);
-  }
-
-  /**
-   * Retrieve the i-th value in the vector.
-   */
-  Local<V> Get(size_t index) const {
-    return Local<V>::New(isolate_, FromVal(Traits::Get(&impl_, index)));
-  }
-
-  /**
-   * Remove all elements from the vector.
-   */
-  void Clear() {
-    size_t length = Traits::Size(&impl_);
-    for (size_t i = 0; i < length; i++) {
-      Global<V> p;
-      p.val_ = FromVal(Traits::Get(&impl_, i));
-    }
-    Traits::Clear(&impl_);
-  }
-
-  /**
-   * Reserve capacity in the vector.
-   * (Efficiency gains depend on the backing implementation.)
-   */
-  void ReserveCapacity(size_t capacity) {
-    Traits::ReserveCapacity(&impl_, capacity);
-  }
-
- private:
-  static PersistentContainerValue ClearAndLeak(Global<V>* persistent) {
-    V* v = persistent->val_;
-    persistent->val_ = 0;
-    return reinterpret_cast<PersistentContainerValue>(v);
-  }
-
-  static V* FromVal(PersistentContainerValue v) {
-    return reinterpret_cast<V*>(v);
-  }
-
-  Isolate* isolate_;
-  typename Traits::Impl impl_;
-};
-
-}  // namespace v8
-
-#endif  // V8_UTIL_H
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/v8/include/v8-version-string.h
+++ /dev/null
@@ -1,33 +0,0 @@
-// Copyright 2017 the V8 project authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef V8_VERSION_STRING_H_
-#define V8_VERSION_STRING_H_
-
-#include "v8-version.h"  // NOLINT(build/include)
-
-// This is here rather than v8-version.h to keep that file simple and
-// machine-processable.
-
-#if V8_IS_CANDIDATE_VERSION
-#define V8_CANDIDATE_STRING " (candidate)"
-#else
-#define V8_CANDIDATE_STRING ""
-#endif
-
-#define V8_SX(x) #x
-#define V8_S(x) V8_SX(x)
-
-#if V8_PATCH_LEVEL > 0
-#define V8_VERSION_STRING                                        \
-  V8_S(V8_MAJOR_VERSION)                                         \
-  "." V8_S(V8_MINOR_VERSION) "." V8_S(V8_BUILD_NUMBER) "." V8_S( \
-      V8_PATCH_LEVEL) V8_CANDIDATE_STRING
-#else
-#define V8_VERSION_STRING \
-  V8_S(V8_MAJOR_VERSION)  \
-  "." V8_S(V8_MINOR_VERSION) "." V8_S(V8_BUILD_NUMBER) V8_CANDIDATE_STRING
-#endif
-
-#endif  // V8_VERSION_STRING_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/v8/include/v8-version.h
+++ /dev/null
@@ -1,20 +0,0 @@
-// Copyright 2015 the V8 project authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef V8_INCLUDE_VERSION_H_  // V8_VERSION_H_ conflicts with src/version.h
-#define V8_INCLUDE_VERSION_H_
-
-// These macros define the version number for the current version.
-// NOTE these macros are used by some of the tool scripts and the build
-// system so their names cannot be changed without changing the scripts.
-#define V8_MAJOR_VERSION 5
-#define V8_MINOR_VERSION 8
-#define V8_BUILD_NUMBER 283
-#define V8_PATCH_LEVEL 38
-
-// Use 1 for candidates and 0 otherwise.
-// (Boolean macro values are not supported by all preprocessors.)
-#define V8_IS_CANDIDATE_VERSION 0
-
-#endif  // V8_INCLUDE_VERSION_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/v8/include/v8.h
+++ /dev/null
@@ -1,9913 +0,0 @@
-// Copyright 2012 the V8 project authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-/** \mainpage V8 API Reference Guide
- *
- * V8 is Google's open source JavaScript engine.
- *
- * This set of documents provides reference material generated from the
- * V8 header file, include/v8.h.
- *
- * For other documentation see http://code.google.com/apis/v8/
- */
-
-#ifndef INCLUDE_V8_H_
-#define INCLUDE_V8_H_
-
-#include <stddef.h>
-#include <stdint.h>
-#include <stdio.h>
-#include <memory>
-#include <utility>
-#include <vector>
-
-#include "v8-version.h"  // NOLINT(build/include)
-#include "v8config.h"    // NOLINT(build/include)
-
-// We reserve the V8_* prefix for macros defined in V8 public API and
-// assume there are no name conflicts with the embedder's code.
-
-#ifdef V8_OS_WIN
-
-// Setup for Windows DLL export/import. When building the V8 DLL the
-// BUILDING_V8_SHARED needs to be defined. When building a program which uses
-// the V8 DLL USING_V8_SHARED needs to be defined. When either building the V8
-// static library or building a program which uses the V8 static library neither
-// BUILDING_V8_SHARED nor USING_V8_SHARED should be defined.
-#ifdef BUILDING_V8_SHARED
-# define V8_EXPORT __declspec(dllexport)
-#elif USING_V8_SHARED
-# define V8_EXPORT __declspec(dllimport)
-#else
-# define V8_EXPORT
-#endif  // BUILDING_V8_SHARED
-
-#else  // V8_OS_WIN
-
-// Setup for Linux shared library export.
-#if V8_HAS_ATTRIBUTE_VISIBILITY
-# ifdef BUILDING_V8_SHARED
-#  define V8_EXPORT __attribute__ ((visibility("default")))
-# else
-#  define V8_EXPORT
-# endif
-#else
-# define V8_EXPORT
-#endif
-
-#endif  // V8_OS_WIN
-
-/**
- * The v8 JavaScript engine.
- */
-namespace v8 {
-
-class AccessorSignature;
-class Array;
-class ArrayBuffer;
-class Boolean;
-class BooleanObject;
-class Context;
-class CpuProfiler;
-class Data;
-class Date;
-class External;
-class Function;
-class FunctionTemplate;
-class HeapProfiler;
-class ImplementationUtilities;
-class Int32;
-class Integer;
-class Isolate;
-template <class T>
-class Maybe;
-class Name;
-class Number;
-class NumberObject;
-class Object;
-class ObjectOperationDescriptor;
-class ObjectTemplate;
-class Platform;
-class Primitive;
-class Promise;
-class PropertyDescriptor;
-class Proxy;
-class RawOperationDescriptor;
-class Script;
-class SharedArrayBuffer;
-class Signature;
-class StartupData;
-class StackFrame;
-class StackTrace;
-class String;
-class StringObject;
-class Symbol;
-class SymbolObject;
-class Private;
-class Uint32;
-class Utils;
-class Value;
-template <class T> class Local;
-template <class T>
-class MaybeLocal;
-template <class T> class Eternal;
-template<class T> class NonCopyablePersistentTraits;
-template<class T> class PersistentBase;
-template <class T, class M = NonCopyablePersistentTraits<T> >
-class Persistent;
-template <class T>
-class Global;
-template<class K, class V, class T> class PersistentValueMap;
-template <class K, class V, class T>
-class PersistentValueMapBase;
-template <class K, class V, class T>
-class GlobalValueMap;
-template<class V, class T> class PersistentValueVector;
-template<class T, class P> class WeakCallbackObject;
-class FunctionTemplate;
-class ObjectTemplate;
-class Data;
-template<typename T> class FunctionCallbackInfo;
-template<typename T> class PropertyCallbackInfo;
-class StackTrace;
-class StackFrame;
-class Isolate;
-class CallHandlerHelper;
-class EscapableHandleScope;
-template<typename T> class ReturnValue;
-
-namespace experimental {
-class FastAccessorBuilder;
-}  // namespace experimental
-
-namespace internal {
-class Arguments;
-class Heap;
-class HeapObject;
-class Isolate;
-class Object;
-struct StreamedSource;
-template<typename T> class CustomArguments;
-class PropertyCallbackArguments;
-class FunctionCallbackArguments;
-class GlobalHandles;
-}  // namespace internal
-
-
-/**
- * General purpose unique identifier.
- */
-class UniqueId {
- public:
-  explicit UniqueId(intptr_t data)
-      : data_(data) {}
-
-  bool operator==(const UniqueId& other) const {
-    return data_ == other.data_;
-  }
-
-  bool operator!=(const UniqueId& other) const {
-    return data_ != other.data_;
-  }
-
-  bool operator<(const UniqueId& other) const {
-    return data_ < other.data_;
-  }
-
- private:
-  intptr_t data_;
-};
-
-// --- Handles ---
-
-#define TYPE_CHECK(T, S)                                       \
-  while (false) {                                              \
-    *(static_cast<T* volatile*>(0)) = static_cast<S*>(0);      \
-  }
-
-
-/**
- * An object reference managed by the v8 garbage collector.
- *
- * All objects returned from v8 have to be tracked by the garbage
- * collector so that it knows that the objects are still alive.  Also,
- * because the garbage collector may move objects, it is unsafe to
- * point directly to an object.  Instead, all objects are stored in
- * handles which are known by the garbage collector and updated
- * whenever an object moves.  Handles should always be passed by value
- * (except in cases like out-parameters) and they should never be
- * allocated on the heap.
- *
- * There are two types of handles: local and persistent handles.
- * Local handles are light-weight and transient and typically used in
- * local operations.  They are managed by HandleScopes.  Persistent
- * handles can be used when storing objects across several independent
- * operations and have to be explicitly deallocated when they're no
- * longer used.
- *
- * It is safe to extract the object stored in the handle by
- * dereferencing the handle (for instance, to extract the Object* from
- * a Local<Object>); the value will still be governed by a handle
- * behind the scenes and the same rules apply to these values as to
- * their handles.
- */
-template <class T>
-class Local {
- public:
-  V8_INLINE Local() : val_(0) {}
-  template <class S>
-  V8_INLINE Local(Local<S> that)
-      : val_(reinterpret_cast<T*>(*that)) {
-    /**
-     * This check fails when trying to convert between incompatible
-     * handles. For example, converting from a Local<String> to a
-     * Local<Number>.
-     */
-    TYPE_CHECK(T, S);
-  }
-
-  /**
-   * Returns true if the handle is empty.
-   */
-  V8_INLINE bool IsEmpty() const { return val_ == 0; }
-
-  /**
-   * Sets the handle to be empty. IsEmpty() will then return true.
-   */
-  V8_INLINE void Clear() { val_ = 0; }
-
-  V8_INLINE T* operator->() const { return val_; }
-
-  V8_INLINE T* operator*() const { return val_; }
-
-  /**
-   * Checks whether two handles are the same.
-   * Returns true if both are empty, or if the objects
-   * to which they refer are identical.
-   * The handles' references are not checked.
-   */
-  template <class S>
-  V8_INLINE bool operator==(const Local<S>& that) const {
-    internal::Object** a = reinterpret_cast<internal::Object**>(this->val_);
-    internal::Object** b = reinterpret_cast<internal::Object**>(that.val_);
-    if (a == 0) return b == 0;
-    if (b == 0) return false;
-    return *a == *b;
-  }
-
-  template <class S> V8_INLINE bool operator==(
-      const PersistentBase<S>& that) const {
-    internal::Object** a = reinterpret_cast<internal::Object**>(this->val_);
-    internal::Object** b = reinterpret_cast<internal::Object**>(that.val_);
-    if (a == 0) return b == 0;
-    if (b == 0) return false;
-    return *a == *b;
-  }
-
-  /**
-   * Checks whether two handles are different.
-   * Returns true if only one of the handles is empty, or if
-   * the objects to which they refer are different.
-   * The handles' references are not checked.
-   */
-  template <class S>
-  V8_INLINE bool operator!=(const Local<S>& that) const {
-    return !operator==(that);
-  }
-
-  template <class S> V8_INLINE bool operator!=(
-      const Persistent<S>& that) const {
-    return !operator==(that);
-  }
-
-  template <class S> V8_INLINE static Local<T> Cast(Local<S> that) {
-#ifdef V8_ENABLE_CHECKS
-    // If we're going to perform the type check then we have to check
-    // that the handle isn't empty before doing the checked cast.
-    if (that.IsEmpty()) return Local<T>();
-#endif
-    return Local<T>(T::Cast(*that));
-  }
-
-  template <class S>
-  V8_INLINE Local<S> As() const {
-    return Local<S>::Cast(*this);
-  }
-
-  /**
-   * Create a local handle for the content of another handle.
-   * The referee is kept alive by the local handle even when
-   * the original handle is destroyed/disposed.
-   */
-  V8_INLINE static Local<T> New(Isolate* isolate, Local<T> that);
-  V8_INLINE static Local<T> New(Isolate* isolate,
-                                const PersistentBase<T>& that);
-
- private:
-  friend class Utils;
-  template<class F> friend class Eternal;
-  template<class F> friend class PersistentBase;
-  template<class F, class M> friend class Persistent;
-  template<class F> friend class Local;
-  template <class F>
-  friend class MaybeLocal;
-  template<class F> friend class FunctionCallbackInfo;
-  template<class F> friend class PropertyCallbackInfo;
-  friend class String;
-  friend class Object;
-  friend class Context;
-  friend class Private;
-  template<class F> friend class internal::CustomArguments;
-  friend Local<Primitive> Undefined(Isolate* isolate);
-  friend Local<Primitive> Null(Isolate* isolate);
-  friend Local<Boolean> True(Isolate* isolate);
-  friend Local<Boolean> False(Isolate* isolate);
-  friend class HandleScope;
-  friend class EscapableHandleScope;
-  template <class F1, class F2, class F3>
-  friend class PersistentValueMapBase;
-  template<class F1, class F2> friend class PersistentValueVector;
-  template <class F>
-  friend class ReturnValue;
-
-  explicit V8_INLINE Local(T* that) : val_(that) {}
-  V8_INLINE static Local<T> New(Isolate* isolate, T* that);
-  T* val_;
-};
-
-
-#if !defined(V8_IMMINENT_DEPRECATION_WARNINGS)
-// Handle is an alias for Local for historical reasons.
-template <class T>
-using Handle = Local<T>;
-#endif
-
-
-/**
- * A MaybeLocal<> is a wrapper around Local<> that enforces a check whether
- * the Local<> is empty before it can be used.
- *
- * If an API method returns a MaybeLocal<>, the API method can potentially fail
- * either because an exception is thrown, or because an exception is pending,
- * e.g. because a previous API call threw an exception that hasn't been caught
- * yet, or because a TerminateExecution exception was thrown. In that case, an
- * empty MaybeLocal is returned.
- */
-template <class T>
-class MaybeLocal {
- public:
-  V8_INLINE MaybeLocal() : val_(nullptr) {}
-  template <class S>
-  V8_INLINE MaybeLocal(Local<S> that)
-      : val_(reinterpret_cast<T*>(*that)) {
-    TYPE_CHECK(T, S);
-  }
-
-  V8_INLINE bool IsEmpty() const { return val_ == nullptr; }
-
-  template <class S>
-  V8_WARN_UNUSED_RESULT V8_INLINE bool ToLocal(Local<S>* out) const {
-    out->val_ = IsEmpty() ? nullptr : this->val_;
-    return !IsEmpty();
-  }
-
-  // Will crash if the MaybeLocal<> is empty.
-  V8_INLINE Local<T> ToLocalChecked();
-
-  template <class S>
-  V8_INLINE Local<S> FromMaybe(Local<S> default_value) const {
-    return IsEmpty() ? default_value : Local<S>(val_);
-  }
-
- private:
-  T* val_;
-};
-
-
-// Eternal handles are set-once handles that live for the life of the isolate.
-template <class T> class Eternal {
- public:
-  V8_INLINE Eternal() : index_(kInitialValue) { }
-  template<class S>
-  V8_INLINE Eternal(Isolate* isolate, Local<S> handle) : index_(kInitialValue) {
-    Set(isolate, handle);
-  }
-  // Can only be safely called if already set.
-  V8_INLINE Local<T> Get(Isolate* isolate);
-  V8_INLINE bool IsEmpty() { return index_ == kInitialValue; }
-  template<class S> V8_INLINE void Set(Isolate* isolate, Local<S> handle);
-
- private:
-  static const int kInitialValue = -1;
-  int index_;
-};
-
-
-static const int kInternalFieldsInWeakCallback = 2;
-
-
-template <typename T>
-class WeakCallbackInfo {
- public:
-  typedef void (*Callback)(const WeakCallbackInfo<T>& data);
-
-  WeakCallbackInfo(Isolate* isolate, T* parameter,
-                   void* internal_fields[kInternalFieldsInWeakCallback],
-                   Callback* callback)
-      : isolate_(isolate), parameter_(parameter), callback_(callback) {
-    for (int i = 0; i < kInternalFieldsInWeakCallback; ++i) {
-      internal_fields_[i] = internal_fields[i];
-    }
-  }
-
-  V8_INLINE Isolate* GetIsolate() const { return isolate_; }
-  V8_INLINE T* GetParameter() const { return parameter_; }
-  V8_INLINE void* GetInternalField(int index) const;
-
-  V8_INLINE V8_DEPRECATED("use indexed version",
-                          void* GetInternalField1() const) {
-    return internal_fields_[0];
-  }
-  V8_INLINE V8_DEPRECATED("use indexed version",
-                          void* GetInternalField2() const) {
-    return internal_fields_[1];
-  }
-
-  V8_DEPRECATED("Not realiable once SetSecondPassCallback() was used.",
-                bool IsFirstPass() const) {
-    return callback_ != nullptr;
-  }
-
-  // When first called, the embedder MUST Reset() the Global which triggered the
-  // callback. The Global itself is unusable for anything else. No v8 other api
-  // calls may be called in the first callback. Should additional work be
-  // required, the embedder must set a second pass callback, which will be
-  // called after all the initial callbacks are processed.
-  // Calling SetSecondPassCallback on the second pass will immediately crash.
-  void SetSecondPassCallback(Callback callback) const { *callback_ = callback; }
-
- private:
-  Isolate* isolate_;
-  T* parameter_;
-  Callback* callback_;
-  void* internal_fields_[kInternalFieldsInWeakCallback];
-};
-
-
-// kParameter will pass a void* parameter back to the callback, kInternalFields
-// will pass the first two internal fields back to the callback, kFinalizer
-// will pass a void* parameter back, but is invoked before the object is
-// actually collected, so it can be resurrected. In the last case, it is not
-// possible to request a second pass callback.
-enum class WeakCallbackType { kParameter, kInternalFields, kFinalizer };
-
-/**
- * An object reference that is independent of any handle scope.  Where
- * a Local handle only lives as long as the HandleScope in which it was
- * allocated, a PersistentBase handle remains valid until it is explicitly
- * disposed.
- *
- * A persistent handle contains a reference to a storage cell within
- * the v8 engine which holds an object value and which is updated by
- * the garbage collector whenever the object is moved.  A new storage
- * cell can be created using the constructor or PersistentBase::Reset and
- * existing handles can be disposed using PersistentBase::Reset.
- *
- */
-template <class T> class PersistentBase {
- public:
-  /**
-   * If non-empty, destroy the underlying storage cell
-   * IsEmpty() will return true after this call.
-   */
-  V8_INLINE void Reset();
-  /**
-   * If non-empty, destroy the underlying storage cell
-   * and create a new one with the contents of other if other is non empty
-   */
-  template <class S>
-  V8_INLINE void Reset(Isolate* isolate, const Local<S>& other);
-
-  /**
-   * If non-empty, destroy the underlying storage cell
-   * and create a new one with the contents of other if other is non empty
-   */
-  template <class S>
-  V8_INLINE void Reset(Isolate* isolate, const PersistentBase<S>& other);
-
-  V8_INLINE bool IsEmpty() const { return val_ == NULL; }
-  V8_INLINE void Empty() { val_ = 0; }
-
-  V8_INLINE Local<T> Get(Isolate* isolate) const {
-    return Local<T>::New(isolate, *this);
-  }
-
-  template <class S>
-  V8_INLINE bool operator==(const PersistentBase<S>& that) const {
-    internal::Object** a = reinterpret_cast<internal::Object**>(this->val_);
-    internal::Object** b = reinterpret_cast<internal::Object**>(that.val_);
-    if (a == NULL) return b == NULL;
-    if (b == NULL) return false;
-    return *a == *b;
-  }
-
-  template <class S>
-  V8_INLINE bool operator==(const Local<S>& that) const {
-    internal::Object** a = reinterpret_cast<internal::Object**>(this->val_);
-    internal::Object** b = reinterpret_cast<internal::Object**>(that.val_);
-    if (a == NULL) return b == NULL;
-    if (b == NULL) return false;
-    return *a == *b;
-  }
-
-  template <class S>
-  V8_INLINE bool operator!=(const PersistentBase<S>& that) const {
-    return !operator==(that);
-  }
-
-  template <class S>
-  V8_INLINE bool operator!=(const Local<S>& that) const {
-    return !operator==(that);
-  }
-
-  /**
-   *  Install a finalization callback on this object.
-   *  NOTE: There is no guarantee as to *when* or even *if* the callback is
-   *  invoked. The invocation is performed solely on a best effort basis.
-   *  As always, GC-based finalization should *not* be relied upon for any
-   *  critical form of resource management!
-   */
-  template <typename P>
-  V8_INLINE void SetWeak(P* parameter,
-                         typename WeakCallbackInfo<P>::Callback callback,
-                         WeakCallbackType type);
-
-  /**
-   * Turns this handle into a weak phantom handle without finalization callback.
-   * The handle will be reset automatically when the garbage collector detects
-   * that the object is no longer reachable.
-   * A related function Isolate::NumberOfPhantomHandleResetsSinceLastCall
-   * returns how many phantom handles were reset by the garbage collector.
-   */
-  V8_INLINE void SetWeak();
-
-  template<typename P>
-  V8_INLINE P* ClearWeak();
-
-  // TODO(dcarney): remove this.
-  V8_INLINE void ClearWeak() { ClearWeak<void>(); }
-
-  /**
-   * Allows the embedder to tell the v8 garbage collector that a certain object
-   * is alive. Only allowed when the embedder is asked to trace its heap by
-   * EmbedderHeapTracer.
-   */
-  V8_INLINE void RegisterExternalReference(Isolate* isolate) const;
-
-  /**
-   * Marks the reference to this object independent. Garbage collector is free
-   * to ignore any object groups containing this object. Weak callback for an
-   * independent handle should not assume that it will be preceded by a global
-   * GC prologue callback or followed by a global GC epilogue callback.
-   */
-  V8_INLINE void MarkIndependent();
-
-  /**
-   * Marks the reference to this object as active. The scavenge garbage
-   * collection should not reclaim the objects marked as active.
-   * This bit is cleared after the each garbage collection pass.
-   */
-  V8_INLINE void MarkActive();
-
-  V8_INLINE bool IsIndependent() const;
-
-  /** Checks if the handle holds the only reference to an object. */
-  V8_INLINE bool IsNearDeath() const;
-
-  /** Returns true if the handle's reference is weak.  */
-  V8_INLINE bool IsWeak() const;
-
-  /**
-   * Assigns a wrapper class ID to the handle. See RetainedObjectInfo interface
-   * description in v8-profiler.h for details.
-   */
-  V8_INLINE void SetWrapperClassId(uint16_t class_id);
-
-  /**
-   * Returns the class ID previously assigned to this handle or 0 if no class ID
-   * was previously assigned.
-   */
-  V8_INLINE uint16_t WrapperClassId() const;
-
-  PersistentBase(const PersistentBase& other) = delete;  // NOLINT
-  void operator=(const PersistentBase&) = delete;
-
- private:
-  friend class Isolate;
-  friend class Utils;
-  template<class F> friend class Local;
-  template<class F1, class F2> friend class Persistent;
-  template <class F>
-  friend class Global;
-  template<class F> friend class PersistentBase;
-  template<class F> friend class ReturnValue;
-  template <class F1, class F2, class F3>
-  friend class PersistentValueMapBase;
-  template<class F1, class F2> friend class PersistentValueVector;
-  friend class Object;
-
-  explicit V8_INLINE PersistentBase(T* val) : val_(val) {}
-  V8_INLINE static T* New(Isolate* isolate, T* that);
-
-  T* val_;
-};
-
-
-/**
- * Default traits for Persistent. This class does not allow
- * use of the copy constructor or assignment operator.
- * At present kResetInDestructor is not set, but that will change in a future
- * version.
- */
-template<class T>
-class NonCopyablePersistentTraits {
- public:
-  typedef Persistent<T, NonCopyablePersistentTraits<T> > NonCopyablePersistent;
-  static const bool kResetInDestructor = false;
-  template<class S, class M>
-  V8_INLINE static void Copy(const Persistent<S, M>& source,
-                             NonCopyablePersistent* dest) {
-    Uncompilable<Object>();
-  }
-  // TODO(dcarney): come up with a good compile error here.
-  template<class O> V8_INLINE static void Uncompilable() {
-    TYPE_CHECK(O, Primitive);
-  }
-};
-
-
-/**
- * Helper class traits to allow copying and assignment of Persistent.
- * This will clone the contents of storage cell, but not any of the flags, etc.
- */
-template<class T>
-struct CopyablePersistentTraits {
-  typedef Persistent<T, CopyablePersistentTraits<T> > CopyablePersistent;
-  static const bool kResetInDestructor = true;
-  template<class S, class M>
-  static V8_INLINE void Copy(const Persistent<S, M>& source,
-                             CopyablePersistent* dest) {
-    // do nothing, just allow copy
-  }
-};
-
-
-/**
- * A PersistentBase which allows copy and assignment.
- *
- * Copy, assignment and destructor behavior is controlled by the traits
- * class M.
- *
- * Note: Persistent class hierarchy is subject to future changes.
- */
-template <class T, class M> class Persistent : public PersistentBase<T> {
- public:
-  /**
-   * A Persistent with no storage cell.
-   */
-  V8_INLINE Persistent() : PersistentBase<T>(0) { }
-  /**
-   * Construct a Persistent from a Local.
-   * When the Local is non-empty, a new storage cell is created
-   * pointing to the same object, and no flags are set.
-   */
-  template <class S>
-  V8_INLINE Persistent(Isolate* isolate, Local<S> that)
-      : PersistentBase<T>(PersistentBase<T>::New(isolate, *that)) {
-    TYPE_CHECK(T, S);
-  }
-  /**
-   * Construct a Persistent from a Persistent.
-   * When the Persistent is non-empty, a new storage cell is created
-   * pointing to the same object, and no flags are set.
-   */
-  template <class S, class M2>
-  V8_INLINE Persistent(Isolate* isolate, const Persistent<S, M2>& that)
-    : PersistentBase<T>(PersistentBase<T>::New(isolate, *that)) {
-    TYPE_CHECK(T, S);
-  }
-  /**
-   * The copy constructors and assignment operator create a Persistent
-   * exactly as the Persistent constructor, but the Copy function from the
-   * traits class is called, allowing the setting of flags based on the
-   * copied Persistent.
-   */
-  V8_INLINE Persistent(const Persistent& that) : PersistentBase<T>(0) {
-    Copy(that);
-  }
-  template <class S, class M2>
-  V8_INLINE Persistent(const Persistent<S, M2>& that) : PersistentBase<T>(0) {
-    Copy(that);
-  }
-  V8_INLINE Persistent& operator=(const Persistent& that) { // NOLINT
-    Copy(that);
-    return *this;
-  }
-  template <class S, class M2>
-  V8_INLINE Persistent& operator=(const Persistent<S, M2>& that) { // NOLINT
-    Copy(that);
-    return *this;
-  }
-  /**
-   * The destructor will dispose the Persistent based on the
-   * kResetInDestructor flags in the traits class.  Since not calling dispose
-   * can result in a memory leak, it is recommended to always set this flag.
-   */
-  V8_INLINE ~Persistent() {
-    if (M::kResetInDestructor) this->Reset();
-  }
-
-  // TODO(dcarney): this is pretty useless, fix or remove
-  template <class S>
-  V8_INLINE static Persistent<T>& Cast(const Persistent<S>& that) {  // NOLINT
-#ifdef V8_ENABLE_CHECKS
-    // If we're going to perform the type check then we have to check
-    // that the handle isn't empty before doing the checked cast.
-    if (!that.IsEmpty()) T::Cast(*that);
-#endif
-    return reinterpret_cast<Persistent<T>&>(const_cast<Persistent<S>&>(that));
-  }
-
-  // TODO(dcarney): this is pretty useless, fix or remove
-  template <class S>
-  V8_INLINE Persistent<S>& As() const {  // NOLINT
-    return Persistent<S>::Cast(*this);
-  }
-
- private:
-  friend class Isolate;
-  friend class Utils;
-  template<class F> friend class Local;
-  template<class F1, class F2> friend class Persistent;
-  template<class F> friend class ReturnValue;
-
-  explicit V8_INLINE Persistent(T* that) : PersistentBase<T>(that) {}
-  V8_INLINE T* operator*() const { return this->val_; }
-  template<class S, class M2>
-  V8_INLINE void Copy(const Persistent<S, M2>& that);
-};
-
-
-/**
- * A PersistentBase which has move semantics.
- *
- * Note: Persistent class hierarchy is subject to future changes.
- */
-template <class T>
-class Global : public PersistentBase<T> {
- public:
-  /**
-   * A Global with no storage cell.
-   */
-  V8_INLINE Global() : PersistentBase<T>(nullptr) {}
-  /**
-   * Construct a Global from a Local.
-   * When the Local is non-empty, a new storage cell is created
-   * pointing to the same object, and no flags are set.
-   */
-  template <class S>
-  V8_INLINE Global(Isolate* isolate, Local<S> that)
-      : PersistentBase<T>(PersistentBase<T>::New(isolate, *that)) {
-    TYPE_CHECK(T, S);
-  }
-  /**
-   * Construct a Global from a PersistentBase.
-   * When the Persistent is non-empty, a new storage cell is created
-   * pointing to the same object, and no flags are set.
-   */
-  template <class S>
-  V8_INLINE Global(Isolate* isolate, const PersistentBase<S>& that)
-      : PersistentBase<T>(PersistentBase<T>::New(isolate, that.val_)) {
-    TYPE_CHECK(T, S);
-  }
-  /**
-   * Move constructor.
-   */
-  V8_INLINE Global(Global&& other) : PersistentBase<T>(other.val_) {  // NOLINT
-    other.val_ = nullptr;
-  }
-  V8_INLINE ~Global() { this->Reset(); }
-  /**
-   * Move via assignment.
-   */
-  template <class S>
-  V8_INLINE Global& operator=(Global<S>&& rhs) {  // NOLINT
-    TYPE_CHECK(T, S);
-    if (this != &rhs) {
-      this->Reset();
-      this->val_ = rhs.val_;
-      rhs.val_ = nullptr;
-    }
-    return *this;
-  }
-  /**
-   * Pass allows returning uniques from functions, etc.
-   */
-  Global Pass() { return static_cast<Global&&>(*this); }  // NOLINT
-
-  /*
-   * For compatibility with Chromium's base::Bind (base::Passed).
-   */
-  typedef void MoveOnlyTypeForCPP03;
-
-  Global(const Global&) = delete;
-  void operator=(const Global&) = delete;
-
- private:
-  template <class F>
-  friend class ReturnValue;
-  V8_INLINE T* operator*() const { return this->val_; }
-};
-
-
-// UniquePersistent is an alias for Global for historical reason.
-template <class T>
-using UniquePersistent = Global<T>;
-
-
- /**
- * A stack-allocated class that governs a number of local handles.
- * After a handle scope has been created, all local handles will be
- * allocated within that handle scope until either the handle scope is
- * deleted or another handle scope is created.  If there is already a
- * handle scope and a new one is created, all allocations will take
- * place in the new handle scope until it is deleted.  After that,
- * new handles will again be allocated in the original handle scope.
- *
- * After the handle scope of a local handle has been deleted the
- * garbage collector will no longer track the object stored in the
- * handle and may deallocate it.  The behavior of accessing a handle
- * for which the handle scope has been deleted is undefined.
- */
-class V8_EXPORT HandleScope {
- public:
-  explicit HandleScope(Isolate* isolate);
-
-  ~HandleScope();
-
-  /**
-   * Counts the number of allocated handles.
-   */
-  static int NumberOfHandles(Isolate* isolate);
-
-  V8_INLINE Isolate* GetIsolate() const {
-    return reinterpret_cast<Isolate*>(isolate_);
-  }
-
-  HandleScope(const HandleScope&) = delete;
-  void operator=(const HandleScope&) = delete;
-  void* operator new(size_t size);
-  void operator delete(void*, size_t);
-
- protected:
-  V8_INLINE HandleScope() {}
-
-  void Initialize(Isolate* isolate);
-
-  static internal::Object** CreateHandle(internal::Isolate* isolate,
-                                         internal::Object* value);
-
- private:
-  // Uses heap_object to obtain the current Isolate.
-  static internal::Object** CreateHandle(internal::HeapObject* heap_object,
-                                         internal::Object* value);
-
-  internal::Isolate* isolate_;
-  internal::Object** prev_next_;
-  internal::Object** prev_limit_;
-
-  // Local::New uses CreateHandle with an Isolate* parameter.
-  template<class F> friend class Local;
-
-  // Object::GetInternalField and Context::GetEmbedderData use CreateHandle with
-  // a HeapObject* in their shortcuts.
-  friend class Object;
-  friend class Context;
-};
-
-
-/**
- * A HandleScope which first allocates a handle in the current scope
- * which will be later filled with the escape value.
- */
-class V8_EXPORT EscapableHandleScope : public HandleScope {
- public:
-  explicit EscapableHandleScope(Isolate* isolate);
-  V8_INLINE ~EscapableHandleScope() {}
-
-  /**
-   * Pushes the value into the previous scope and returns a handle to it.
-   * Cannot be called twice.
-   */
-  template <class T>
-  V8_INLINE Local<T> Escape(Local<T> value) {
-    internal::Object** slot =
-        Escape(reinterpret_cast<internal::Object**>(*value));
-    return Local<T>(reinterpret_cast<T*>(slot));
-  }
-
-  EscapableHandleScope(const EscapableHandleScope&) = delete;
-  void operator=(const EscapableHandleScope&) = delete;
-  void* operator new(size_t size);
-  void operator delete(void*, size_t);
-
- private:
-  internal::Object** Escape(internal::Object** escape_value);
-  internal::Object** escape_slot_;
-};
-
-class V8_EXPORT SealHandleScope {
- public:
-  SealHandleScope(Isolate* isolate);
-  ~SealHandleScope();
-
-  SealHandleScope(const SealHandleScope&) = delete;
-  void operator=(const SealHandleScope&) = delete;
-  void* operator new(size_t size);
-  void operator delete(void*, size_t);
-
- private:
-  internal::Isolate* const isolate_;
-  internal::Object** prev_limit_;
-  int prev_sealed_level_;
-};
-
-
-// --- Special objects ---
-
-
-/**
- * The superclass of values and API object templates.
- */
-class V8_EXPORT Data {
- private:
-  Data();
-};
-
-
-/**
- * The optional attributes of ScriptOrigin.
- */
-class ScriptOriginOptions {
- public:
-  V8_INLINE ScriptOriginOptions(bool is_shared_cross_origin = false,
-                                bool is_opaque = false, bool is_wasm = false,
-                                bool is_module = false)
-      : flags_((is_shared_cross_origin ? kIsSharedCrossOrigin : 0) |
-               (is_wasm ? kIsWasm : 0) | (is_opaque ? kIsOpaque : 0) |
-               (is_module ? kIsModule : 0)) {}
-  V8_INLINE ScriptOriginOptions(int flags)
-      : flags_(flags &
-               (kIsSharedCrossOrigin | kIsOpaque | kIsWasm | kIsModule)) {}
-
-  bool IsSharedCrossOrigin() const {
-    return (flags_ & kIsSharedCrossOrigin) != 0;
-  }
-  bool IsOpaque() const { return (flags_ & kIsOpaque) != 0; }
-  bool IsWasm() const { return (flags_ & kIsWasm) != 0; }
-  bool IsModule() const { return (flags_ & kIsModule) != 0; }
-
-  int Flags() const { return flags_; }
-
- private:
-  enum {
-    kIsSharedCrossOrigin = 1,
-    kIsOpaque = 1 << 1,
-    kIsWasm = 1 << 2,
-    kIsModule = 1 << 3
-  };
-  const int flags_;
-};
-
-/**
- * The origin, within a file, of a script.
- */
-class ScriptOrigin {
- public:
-  V8_INLINE ScriptOrigin(
-      Local<Value> resource_name,
-      Local<Integer> resource_line_offset = Local<Integer>(),
-      Local<Integer> resource_column_offset = Local<Integer>(),
-      Local<Boolean> resource_is_shared_cross_origin = Local<Boolean>(),
-      Local<Integer> script_id = Local<Integer>(),
-      Local<Value> source_map_url = Local<Value>(),
-      Local<Boolean> resource_is_opaque = Local<Boolean>(),
-      Local<Boolean> is_wasm = Local<Boolean>(),
-      Local<Boolean> is_module = Local<Boolean>());
-
-  V8_INLINE Local<Value> ResourceName() const;
-  V8_INLINE Local<Integer> ResourceLineOffset() const;
-  V8_INLINE Local<Integer> ResourceColumnOffset() const;
-  /**
-    * Returns true for embedder's debugger scripts
-    */
-  V8_INLINE Local<Integer> ScriptID() const;
-  V8_INLINE Local<Value> SourceMapUrl() const;
-  V8_INLINE ScriptOriginOptions Options() const { return options_; }
-
- private:
-  Local<Value> resource_name_;
-  Local<Integer> resource_line_offset_;
-  Local<Integer> resource_column_offset_;
-  ScriptOriginOptions options_;
-  Local<Integer> script_id_;
-  Local<Value> source_map_url_;
-};
-
-
-/**
- * A compiled JavaScript script, not yet tied to a Context.
- */
-class V8_EXPORT UnboundScript {
- public:
-  /**
-   * Binds the script to the currently entered context.
-   */
-  Local<Script> BindToCurrentContext();
-
-  int GetId();
-  Local<Value> GetScriptName();
-
-  /**
-   * Data read from magic sourceURL comments.
-   */
-  Local<Value> GetSourceURL();
-  /**
-   * Data read from magic sourceMappingURL comments.
-   */
-  Local<Value> GetSourceMappingURL();
-
-  /**
-   * Returns zero based line number of the code_pos location in the script.
-   * -1 will be returned if no information available.
-   */
-  int GetLineNumber(int code_pos);
-
-  static const int kNoScriptId = 0;
-};
-
-/**
- * This is an unfinished experimental feature, and is only exposed
- * here for internal testing purposes. DO NOT USE.
- *
- * A compiled JavaScript module.
- */
-class V8_EXPORT Module {
- public:
-  /**
-   * Returns the number of modules requested by this module.
-   */
-  int GetModuleRequestsLength() const;
-
-  /**
-   * Returns the ith module specifier in this module.
-   * i must be < GetModuleRequestsLength() and >= 0.
-   */
-  Local<String> GetModuleRequest(int i) const;
-
-  /**
-   * Returns the identity hash for this object.
-   */
-  int GetIdentityHash() const;
-
-  typedef MaybeLocal<Module> (*ResolveCallback)(Local<Context> context,
-                                                Local<String> specifier,
-                                                Local<Module> referrer);
-
-  /**
-   * ModuleDeclarationInstantiation
-   *
-   * Returns false if an exception occurred during instantiation.
-   */
-  V8_WARN_UNUSED_RESULT bool Instantiate(Local<Context> context,
-                                         ResolveCallback callback);
-
-  /**
-   * ModuleEvaluation
-   */
-  V8_WARN_UNUSED_RESULT MaybeLocal<Value> Evaluate(Local<Context> context);
-};
-
-/**
- * A compiled JavaScript script, tied to a Context which was active when the
- * script was compiled.
- */
-class V8_EXPORT Script {
- public:
-  /**
-   * A shorthand for ScriptCompiler::Compile().
-   */
-  static V8_DEPRECATE_SOON(
-      "Use maybe version",
-      Local<Script> Compile(Local<String> source,
-                            ScriptOrigin* origin = nullptr));
-  static V8_WARN_UNUSED_RESULT MaybeLocal<Script> Compile(
-      Local<Context> context, Local<String> source,
-      ScriptOrigin* origin = nullptr);
-
-  static Local<Script> V8_DEPRECATE_SOON("Use maybe version",
-                                         Compile(Local<String> source,
-                                                 Local<String> file_name));
-
-  /**
-   * Runs the script returning the resulting value. It will be run in the
-   * context in which it was created (ScriptCompiler::CompileBound or
-   * UnboundScript::BindToCurrentContext()).
-   */
-  V8_DEPRECATE_SOON("Use maybe version", Local<Value> Run());
-  V8_WARN_UNUSED_RESULT MaybeLocal<Value> Run(Local<Context> context);
-
-  /**
-   * Returns the corresponding context-unbound script.
-   */
-  Local<UnboundScript> GetUnboundScript();
-};
-
-
-/**
- * For compiling scripts.
- */
-class V8_EXPORT ScriptCompiler {
- public:
-  /**
-   * Compilation data that the embedder can cache and pass back to speed up
-   * future compilations. The data is produced if the CompilerOptions passed to
-   * the compilation functions in ScriptCompiler contains produce_data_to_cache
-   * = true. The data to cache can then can be retrieved from
-   * UnboundScript.
-   */
-  struct V8_EXPORT CachedData {
-    enum BufferPolicy {
-      BufferNotOwned,
-      BufferOwned
-    };
-
-    CachedData()
-        : data(NULL),
-          length(0),
-          rejected(false),
-          buffer_policy(BufferNotOwned) {}
-
-    // If buffer_policy is BufferNotOwned, the caller keeps the ownership of
-    // data and guarantees that it stays alive until the CachedData object is
-    // destroyed. If the policy is BufferOwned, the given data will be deleted
-    // (with delete[]) when the CachedData object is destroyed.
-    CachedData(const uint8_t* data, int length,
-               BufferPolicy buffer_policy = BufferNotOwned);
-    ~CachedData();
-    // TODO(marja): Async compilation; add constructors which take a callback
-    // which will be called when V8 no longer needs the data.
-    const uint8_t* data;
-    int length;
-    bool rejected;
-    BufferPolicy buffer_policy;
-
-    // Prevent copying.
-    CachedData(const CachedData&) = delete;
-    CachedData& operator=(const CachedData&) = delete;
-  };
-
-  /**
-   * Source code which can be then compiled to a UnboundScript or Script.
-   */
-  class Source {
-   public:
-    // Source takes ownership of CachedData.
-    V8_INLINE Source(Local<String> source_string, const ScriptOrigin& origin,
-           CachedData* cached_data = NULL);
-    V8_INLINE Source(Local<String> source_string,
-                     CachedData* cached_data = NULL);
-    V8_INLINE ~Source();
-
-    // Ownership of the CachedData or its buffers is *not* transferred to the
-    // caller. The CachedData object is alive as long as the Source object is
-    // alive.
-    V8_INLINE const CachedData* GetCachedData() const;
-
-    V8_INLINE const ScriptOriginOptions& GetResourceOptions() const;
-
-    // Prevent copying.
-    Source(const Source&) = delete;
-    Source& operator=(const Source&) = delete;
-
-   private:
-    friend class ScriptCompiler;
-
-    Local<String> source_string;
-
-    // Origin information
-    Local<Value> resource_name;
-    Local<Integer> resource_line_offset;
-    Local<Integer> resource_column_offset;
-    ScriptOriginOptions resource_options;
-    Local<Value> source_map_url;
-
-    // Cached data from previous compilation (if a kConsume*Cache flag is
-    // set), or hold newly generated cache data (kProduce*Cache flags) are
-    // set when calling a compile method.
-    CachedData* cached_data;
-  };
-
-  /**
-   * For streaming incomplete script data to V8. The embedder should implement a
-   * subclass of this class.
-   */
-  class V8_EXPORT ExternalSourceStream {
-   public:
-    virtual ~ExternalSourceStream() {}
-
-    /**
-     * V8 calls this to request the next chunk of data from the embedder. This
-     * function will be called on a background thread, so it's OK to block and
-     * wait for the data, if the embedder doesn't have data yet. Returns the
-     * length of the data returned. When the data ends, GetMoreData should
-     * return 0. Caller takes ownership of the data.
-     *
-     * When streaming UTF-8 data, V8 handles multi-byte characters split between
-     * two data chunks, but doesn't handle multi-byte characters split between
-     * more than two data chunks. The embedder can avoid this problem by always
-     * returning at least 2 bytes of data.
-     *
-     * If the embedder wants to cancel the streaming, they should make the next
-     * GetMoreData call return 0. V8 will interpret it as end of data (and most
-     * probably, parsing will fail). The streaming task will return as soon as
-     * V8 has parsed the data it received so far.
-     */
-    virtual size_t GetMoreData(const uint8_t** src) = 0;
-
-    /**
-     * V8 calls this method to set a 'bookmark' at the current position in
-     * the source stream, for the purpose of (maybe) later calling
-     * ResetToBookmark. If ResetToBookmark is called later, then subsequent
-     * calls to GetMoreData should return the same data as they did when
-     * SetBookmark was called earlier.
-     *
-     * The embedder may return 'false' to indicate it cannot provide this
-     * functionality.
-     */
-    virtual bool SetBookmark();
-
-    /**
-     * V8 calls this to return to a previously set bookmark.
-     */
-    virtual void ResetToBookmark();
-  };
-
-
-  /**
-   * Source code which can be streamed into V8 in pieces. It will be parsed
-   * while streaming. It can be compiled after the streaming is complete.
-   * StreamedSource must be kept alive while the streaming task is ran (see
-   * ScriptStreamingTask below).
-   */
-  class V8_EXPORT StreamedSource {
-   public:
-    enum Encoding { ONE_BYTE, TWO_BYTE, UTF8 };
-
-    StreamedSource(ExternalSourceStream* source_stream, Encoding encoding);
-    ~StreamedSource();
-
-    // Ownership of the CachedData or its buffers is *not* transferred to the
-    // caller. The CachedData object is alive as long as the StreamedSource
-    // object is alive.
-    const CachedData* GetCachedData() const;
-
-    internal::StreamedSource* impl() const { return impl_; }
-
-    // Prevent copying.
-    StreamedSource(const StreamedSource&) = delete;
-    StreamedSource& operator=(const StreamedSource&) = delete;
-
-   private:
-    internal::StreamedSource* impl_;
-  };
-
-  /**
-   * A streaming task which the embedder must run on a background thread to
-   * stream scripts into V8. Returned by ScriptCompiler::StartStreamingScript.
-   */
-  class ScriptStreamingTask {
-   public:
-    virtual ~ScriptStreamingTask() {}
-    virtual void Run() = 0;
-  };
-
-  enum CompileOptions {
-    kNoCompileOptions = 0,
-    kProduceParserCache,
-    kConsumeParserCache,
-    kProduceCodeCache,
-    kConsumeCodeCache
-  };
-
-  /**
-   * Compiles the specified script (context-independent).
-   * Cached data as part of the source object can be optionally produced to be
-   * consumed later to speed up compilation of identical source scripts.
-   *
-   * Note that when producing cached data, the source must point to NULL for
-   * cached data. When consuming cached data, the cached data must have been
-   * produced by the same version of V8.
-   *
-   * \param source Script source code.
-   * \return Compiled script object (context independent; for running it must be
-   *   bound to a context).
-   */
-  static V8_DEPRECATED("Use maybe version",
-                       Local<UnboundScript> CompileUnbound(
-                           Isolate* isolate, Source* source,
-                           CompileOptions options = kNoCompileOptions));
-  static V8_WARN_UNUSED_RESULT MaybeLocal<UnboundScript> CompileUnboundScript(
-      Isolate* isolate, Source* source,
-      CompileOptions options = kNoCompileOptions);
-
-  /**
-   * Compiles the specified script (bound to current context).
-   *
-   * \param source Script source code.
-   * \param pre_data Pre-parsing data, as obtained by ScriptData::PreCompile()
-   *   using pre_data speeds compilation if it's done multiple times.
-   *   Owned by caller, no references are kept when this function returns.
-   * \return Compiled script object, bound to the context that was active
-   *   when this function was called. When run it will always use this
-   *   context.
-   */
-  static V8_DEPRECATED(
-      "Use maybe version",
-      Local<Script> Compile(Isolate* isolate, Source* source,
-                            CompileOptions options = kNoCompileOptions));
-  static V8_WARN_UNUSED_RESULT MaybeLocal<Script> Compile(
-      Local<Context> context, Source* source,
-      CompileOptions options = kNoCompileOptions);
-
-  /**
-   * Returns a task which streams script data into V8, or NULL if the script
-   * cannot be streamed. The user is responsible for running the task on a
-   * background thread and deleting it. When ran, the task starts parsing the
-   * script, and it will request data from the StreamedSource as needed. When
-   * ScriptStreamingTask::Run exits, all data has been streamed and the script
-   * can be compiled (see Compile below).
-   *
-   * This API allows to start the streaming with as little data as possible, and
-   * the remaining data (for example, the ScriptOrigin) is passed to Compile.
-   */
-  static ScriptStreamingTask* StartStreamingScript(
-      Isolate* isolate, StreamedSource* source,
-      CompileOptions options = kNoCompileOptions);
-
-  /**
-   * Compiles a streamed script (bound to current context).
-   *
-   * This can only be called after the streaming has finished
-   * (ScriptStreamingTask has been run). V8 doesn't construct the source string
-   * during streaming, so the embedder needs to pass the full source here.
-   */
-  static V8_DEPRECATED("Use maybe version",
-                       Local<Script> Compile(Isolate* isolate,
-                                             StreamedSource* source,
-                                             Local<String> full_source_string,
-                                             const ScriptOrigin& origin));
-  static V8_WARN_UNUSED_RESULT MaybeLocal<Script> Compile(
-      Local<Context> context, StreamedSource* source,
-      Local<String> full_source_string, const ScriptOrigin& origin);
-
-  /**
-   * Return a version tag for CachedData for the current V8 version & flags.
-   *
-   * This value is meant only for determining whether a previously generated
-   * CachedData instance is still valid; the tag has no other meaing.
-   *
-   * Background: The data carried by CachedData may depend on the exact
-   *   V8 version number or currently compiler flags. This means when
-   *   persisting CachedData, the embedder must take care to not pass in
-   *   data from another V8 version, or the same version with different
-   *   features enabled.
-   *
-   *   The easiest way to do so is to clear the embedder's cache on any
-   *   such change.
-   *
-   *   Alternatively, this tag can be stored alongside the cached data and
-   *   compared when it is being used.
-   */
-  static uint32_t CachedDataVersionTag();
-
-  /**
-   * This is an unfinished experimental feature, and is only exposed
-   * here for internal testing purposes. DO NOT USE.
-   *
-   * Compile an ES module, returning a Module that encapsulates
-   * the compiled code.
-   *
-   * Corresponds to the ParseModule abstract operation in the
-   * ECMAScript specification.
-   */
-  static V8_WARN_UNUSED_RESULT MaybeLocal<Module> CompileModule(
-      Isolate* isolate, Source* source);
-
-  /**
-   * Compile a function for a given context. This is equivalent to running
-   *
-   * with (obj) {
-   *   return function(args) { ... }
-   * }
-   *
-   * It is possible to specify multiple context extensions (obj in the above
-   * example).
-   */
-  static V8_DEPRECATE_SOON("Use maybe version",
-                           Local<Function> CompileFunctionInContext(
-                               Isolate* isolate, Source* source,
-                               Local<Context> context, size_t arguments_count,
-                               Local<String> arguments[],
-                               size_t context_extension_count,
-                               Local<Object> context_extensions[]));
-  static V8_WARN_UNUSED_RESULT MaybeLocal<Function> CompileFunctionInContext(
-      Local<Context> context, Source* source, size_t arguments_count,
-      Local<String> arguments[], size_t context_extension_count,
-      Local<Object> context_extensions[]);
-
- private:
-  static V8_WARN_UNUSED_RESULT MaybeLocal<UnboundScript> CompileUnboundInternal(
-      Isolate* isolate, Source* source, CompileOptions options);
-};
-
-
-/**
- * An error message.
- */
-class V8_EXPORT Message {
- public:
-  Local<String> Get() const;
-
-  V8_DEPRECATE_SOON("Use maybe version", Local<String> GetSourceLine() const);
-  V8_WARN_UNUSED_RESULT MaybeLocal<String> GetSourceLine(
-      Local<Context> context) const;
-
-  /**
-   * Returns the origin for the script from where the function causing the
-   * error originates.
-   */
-  ScriptOrigin GetScriptOrigin() const;
-
-  /**
-   * Returns the resource name for the script from where the function causing
-   * the error originates.
-   */
-  Local<Value> GetScriptResourceName() const;
-
-  /**
-   * Exception stack trace. By default stack traces are not captured for
-   * uncaught exceptions. SetCaptureStackTraceForUncaughtExceptions allows
-   * to change this option.
-   */
-  Local<StackTrace> GetStackTrace() const;
-
-  /**
-   * Returns the number, 1-based, of the line where the error occurred.
-   */
-  V8_DEPRECATE_SOON("Use maybe version", int GetLineNumber() const);
-  V8_WARN_UNUSED_RESULT Maybe<int> GetLineNumber(Local<Context> context) const;
-
-  /**
-   * Returns the index within the script of the first character where
-   * the error occurred.
-   */
-  int GetStartPosition() const;
-
-  /**
-   * Returns the index within the script of the last character where
-   * the error occurred.
-   */
-  int GetEndPosition() const;
-
-  /**
-   * Returns the error level of the message.
-   */
-  int ErrorLevel() const;
-
-  /**
-   * Returns the index within the line of the first character where
-   * the error occurred.
-   */
-  V8_DEPRECATE_SOON("Use maybe version", int GetStartColumn() const);
-  V8_WARN_UNUSED_RESULT Maybe<int> GetStartColumn(Local<Context> context) const;
-
-  /**
-   * Returns the index within the line of the last character where
-   * the error occurred.
-   */
-  V8_DEPRECATED("Use maybe version", int GetEndColumn() const);
-  V8_WARN_UNUSED_RESULT Maybe<int> GetEndColumn(Local<Context> context) const;
-
-  /**
-   * Passes on the value set by the embedder when it fed the script from which
-   * this Message was generated to V8.
-   */
-  bool IsSharedCrossOrigin() const;
-  bool IsOpaque() const;
-
-  // TODO(1245381): Print to a string instead of on a FILE.
-  static void PrintCurrentStackTrace(Isolate* isolate, FILE* out);
-
-  static const int kNoLineNumberInfo = 0;
-  static const int kNoColumnInfo = 0;
-  static const int kNoScriptIdInfo = 0;
-};
-
-
-/**
- * Representation of a JavaScript stack trace. The information collected is a
- * snapshot of the execution stack and the information remains valid after
- * execution continues.
- */
-class V8_EXPORT StackTrace {
- public:
-  /**
-   * Flags that determine what information is placed captured for each
-   * StackFrame when grabbing the current stack trace.
-   */
-  enum StackTraceOptions {
-    kLineNumber = 1,
-    kColumnOffset = 1 << 1 | kLineNumber,
-    kScriptName = 1 << 2,
-    kFunctionName = 1 << 3,
-    kIsEval = 1 << 4,
-    kIsConstructor = 1 << 5,
-    kScriptNameOrSourceURL = 1 << 6,
-    kScriptId = 1 << 7,
-    kExposeFramesAcrossSecurityOrigins = 1 << 8,
-    kOverview = kLineNumber | kColumnOffset | kScriptName | kFunctionName,
-    kDetailed = kOverview | kIsEval | kIsConstructor | kScriptNameOrSourceURL
-  };
-
-  /**
-   * Returns a StackFrame at a particular index.
-   */
-  Local<StackFrame> GetFrame(uint32_t index) const;
-
-  /**
-   * Returns the number of StackFrames.
-   */
-  int GetFrameCount() const;
-
-  /**
-   * Returns StackTrace as a v8::Array that contains StackFrame objects.
-   */
-  Local<Array> AsArray();
-
-  /**
-   * Grab a snapshot of the current JavaScript execution stack.
-   *
-   * \param frame_limit The maximum number of stack frames we want to capture.
-   * \param options Enumerates the set of things we will capture for each
-   *   StackFrame.
-   */
-  static Local<StackTrace> CurrentStackTrace(
-      Isolate* isolate,
-      int frame_limit,
-      StackTraceOptions options = kOverview);
-};
-
-
-/**
- * A single JavaScript stack frame.
- */
-class V8_EXPORT StackFrame {
- public:
-  /**
-   * Returns the number, 1-based, of the line for the associate function call.
-   * This method will return Message::kNoLineNumberInfo if it is unable to
-   * retrieve the line number, or if kLineNumber was not passed as an option
-   * when capturing the StackTrace.
-   */
-  int GetLineNumber() const;
-
-  /**
-   * Returns the 1-based column offset on the line for the associated function
-   * call.
-   * This method will return Message::kNoColumnInfo if it is unable to retrieve
-   * the column number, or if kColumnOffset was not passed as an option when
-   * capturing the StackTrace.
-   */
-  int GetColumn() const;
-
-  /**
-   * Returns the id of the script for the function for this StackFrame.
-   * This method will return Message::kNoScriptIdInfo if it is unable to
-   * retrieve the script id, or if kScriptId was not passed as an option when
-   * capturing the StackTrace.
-   */
-  int GetScriptId() const;
-
-  /**
-   * Returns the name of the resource that contains the script for the
-   * function for this StackFrame.
-   */
-  Local<String> GetScriptName() const;
-
-  /**
-   * Returns the name of the resource that contains the script for the
-   * function for this StackFrame or sourceURL value if the script name
-   * is undefined and its source ends with //# sourceURL=... string or
-   * deprecated //@ sourceURL=... string.
-   */
-  Local<String> GetScriptNameOrSourceURL() const;
-
-  /**
-   * Returns the name of the function associated with this stack frame.
-   */
-  Local<String> GetFunctionName() const;
-
-  /**
-   * Returns whether or not the associated function is compiled via a call to
-   * eval().
-   */
-  bool IsEval() const;
-
-  /**
-   * Returns whether or not the associated function is called as a
-   * constructor via "new".
-   */
-  bool IsConstructor() const;
-};
-
-
-// A StateTag represents a possible state of the VM.
-enum StateTag { JS, GC, COMPILER, OTHER, EXTERNAL, IDLE };
-
-// A RegisterState represents the current state of registers used
-// by the sampling profiler API.
-struct RegisterState {
-  RegisterState() : pc(nullptr), sp(nullptr), fp(nullptr) {}
-  void* pc;  // Instruction pointer.
-  void* sp;  // Stack pointer.
-  void* fp;  // Frame pointer.
-};
-
-// The output structure filled up by GetStackSample API function.
-struct SampleInfo {
-  size_t frames_count;            // Number of frames collected.
-  StateTag vm_state;              // Current VM state.
-  void* external_callback_entry;  // External callback address if VM is
-                                  // executing an external callback.
-};
-
-/**
- * A JSON Parser and Stringifier.
- */
-class V8_EXPORT JSON {
- public:
-  /**
-   * Tries to parse the string |json_string| and returns it as value if
-   * successful.
-   *
-   * \param json_string The string to parse.
-   * \return The corresponding value if successfully parsed.
-   */
-  static V8_DEPRECATED("Use the maybe version taking context",
-                       Local<Value> Parse(Local<String> json_string));
-  static V8_DEPRECATE_SOON("Use the maybe version taking context",
-                           MaybeLocal<Value> Parse(Isolate* isolate,
-                                                   Local<String> json_string));
-  static V8_WARN_UNUSED_RESULT MaybeLocal<Value> Parse(
-      Local<Context> context, Local<String> json_string);
-
-  /**
-   * Tries to stringify the JSON-serializable object |json_object| and returns
-   * it as string if successful.
-   *
-   * \param json_object The JSON-serializable object to stringify.
-   * \return The corresponding string if successfully stringified.
-   */
-  static V8_WARN_UNUSED_RESULT MaybeLocal<String> Stringify(
-      Local<Context> context, Local<Object> json_object,
-      Local<String> gap = Local<String>());
-};
-
-/**
- * Value serialization compatible with the HTML structured clone algorithm.
- * The format is backward-compatible (i.e. safe to store to disk).
- *
- * WARNING: This API is under development, and changes (including incompatible
- * changes to the API or wire format) may occur without notice until this
- * warning is removed.
- */
-class V8_EXPORT ValueSerializer {
- public:
-  class V8_EXPORT Delegate {
-   public:
-    virtual ~Delegate() {}
-
-    /*
-     * Handles the case where a DataCloneError would be thrown in the structured
-     * clone spec. Other V8 embedders may throw some other appropriate exception
-     * type.
-     */
-    virtual void ThrowDataCloneError(Local<String> message) = 0;
-
-    /*
-     * The embedder overrides this method to write some kind of host object, if
-     * possible. If not, a suitable exception should be thrown and
-     * Nothing<bool>() returned.
-     */
-    virtual Maybe<bool> WriteHostObject(Isolate* isolate, Local<Object> object);
-
-    /*
-     * Called when the ValueSerializer is going to serialize a
-     * SharedArrayBuffer object. The embedder must return an ID for the
-     * object, using the same ID if this SharedArrayBuffer has already been
-     * serialized in this buffer. When deserializing, this ID will be passed to
-     * ValueDeserializer::TransferSharedArrayBuffer as |transfer_id|.
-     *
-     * If the object cannot be serialized, an
-     * exception should be thrown and Nothing<uint32_t>() returned.
-     */
-    virtual Maybe<uint32_t> GetSharedArrayBufferId(
-        Isolate* isolate, Local<SharedArrayBuffer> shared_array_buffer);
-
-    /*
-     * Allocates memory for the buffer of at least the size provided. The actual
-     * size (which may be greater or equal) is written to |actual_size|. If no
-     * buffer has been allocated yet, nullptr will be provided.
-     *
-     * If the memory cannot be allocated, nullptr should be returned.
-     * |actual_size| will be ignored. It is assumed that |old_buffer| is still
-     * valid in this case and has not been modified.
-     */
-    virtual void* ReallocateBufferMemory(void* old_buffer, size_t size,
-                                         size_t* actual_size);
-
-    /*
-     * Frees a buffer allocated with |ReallocateBufferMemory|.
-     */
-    virtual void FreeBufferMemory(void* buffer);
-  };
-
-  explicit ValueSerializer(Isolate* isolate);
-  ValueSerializer(Isolate* isolate, Delegate* delegate);
-  ~ValueSerializer();
-
-  /*
-   * Writes out a header, which includes the format version.
-   */
-  void WriteHeader();
-
-  /*
-   * Serializes a JavaScript value into the buffer.
-   */
-  V8_WARN_UNUSED_RESULT Maybe<bool> WriteValue(Local<Context> context,
-                                               Local<Value> value);
-
-  /*
-   * Returns the stored data. This serializer should not be used once the buffer
-   * is released. The contents are undefined if a previous write has failed.
-   */
-  V8_DEPRECATE_SOON("Use Release()", std::vector<uint8_t> ReleaseBuffer());
-
-  /*
-   * Returns the stored data (allocated using the delegate's
-   * AllocateBufferMemory) and its size. This serializer should not be used once
-   * the buffer is released. The contents are undefined if a previous write has
-   * failed.
-   */
-  V8_WARN_UNUSED_RESULT std::pair<uint8_t*, size_t> Release();
-
-  /*
-   * Marks an ArrayBuffer as havings its contents transferred out of band.
-   * Pass the corresponding ArrayBuffer in the deserializing context to
-   * ValueDeserializer::TransferArrayBuffer.
-   */
-  void TransferArrayBuffer(uint32_t transfer_id,
-                           Local<ArrayBuffer> array_buffer);
-
-  /*
-   * Similar to TransferArrayBuffer, but for SharedArrayBuffer.
-   */
-  V8_DEPRECATE_SOON("Use Delegate::GetSharedArrayBufferId",
-                    void TransferSharedArrayBuffer(
-                        uint32_t transfer_id,
-                        Local<SharedArrayBuffer> shared_array_buffer));
-
-  /*
-   * Indicate whether to treat ArrayBufferView objects as host objects,
-   * i.e. pass them to Delegate::WriteHostObject. This should not be
-   * called when no Delegate was passed.
-   *
-   * The default is not to treat ArrayBufferViews as host objects.
-   */
-  void SetTreatArrayBufferViewsAsHostObjects(bool mode);
-
-  /*
-   * Write raw data in various common formats to the buffer.
-   * Note that integer types are written in base-128 varint format, not with a
-   * binary copy. For use during an override of Delegate::WriteHostObject.
-   */
-  void WriteUint32(uint32_t value);
-  void WriteUint64(uint64_t value);
-  void WriteDouble(double value);
-  void WriteRawBytes(const void* source, size_t length);
-
- private:
-  ValueSerializer(const ValueSerializer&) = delete;
-  void operator=(const ValueSerializer&) = delete;
-
-  struct PrivateData;
-  PrivateData* private_;
-};
-
-/**
- * Deserializes values from data written with ValueSerializer, or a compatible
- * implementation.
- *
- * WARNING: This API is under development, and changes (including incompatible
- * changes to the API or wire format) may occur without notice until this
- * warning is removed.
- */
-class V8_EXPORT ValueDeserializer {
- public:
-  class V8_EXPORT Delegate {
-   public:
-    virtual ~Delegate() {}
-
-    /*
-     * The embedder overrides this method to read some kind of host object, if
-     * possible. If not, a suitable exception should be thrown and
-     * MaybeLocal<Object>() returned.
-     */
-    virtual MaybeLocal<Object> ReadHostObject(Isolate* isolate);
-  };
-
-  ValueDeserializer(Isolate* isolate, const uint8_t* data, size_t size);
-  ValueDeserializer(Isolate* isolate, const uint8_t* data, size_t size,
-                    Delegate* delegate);
-  ~ValueDeserializer();
-
-  /*
-   * Reads and validates a header (including the format version).
-   * May, for example, reject an invalid or unsupported wire format.
-   */
-  V8_WARN_UNUSED_RESULT Maybe<bool> ReadHeader(Local<Context> context);
-
-  /*
-   * Deserializes a JavaScript value from the buffer.
-   */
-  V8_WARN_UNUSED_RESULT MaybeLocal<Value> ReadValue(Local<Context> context);
-
-  /*
-   * Accepts the array buffer corresponding to the one passed previously to
-   * ValueSerializer::TransferArrayBuffer.
-   */
-  void TransferArrayBuffer(uint32_t transfer_id,
-                           Local<ArrayBuffer> array_buffer);
-
-  /*
-   * Similar to TransferArrayBuffer, but for SharedArrayBuffer.
-   * The id is not necessarily in the same namespace as unshared ArrayBuffer
-   * objects.
-   */
-  void TransferSharedArrayBuffer(uint32_t id,
-                                 Local<SharedArrayBuffer> shared_array_buffer);
-
-  /*
-   * Must be called before ReadHeader to enable support for reading the legacy
-   * wire format (i.e., which predates this being shipped).
-   *
-   * Don't use this unless you need to read data written by previous versions of
-   * blink::ScriptValueSerializer.
-   */
-  void SetSupportsLegacyWireFormat(bool supports_legacy_wire_format);
-
-  /*
-   * Reads the underlying wire format version. Likely mostly to be useful to
-   * legacy code reading old wire format versions. Must be called after
-   * ReadHeader.
-   */
-  uint32_t GetWireFormatVersion() const;
-
-  /*
-   * Reads raw data in various common formats to the buffer.
-   * Note that integer types are read in base-128 varint format, not with a
-   * binary copy. For use during an override of Delegate::ReadHostObject.
-   */
-  V8_WARN_UNUSED_RESULT bool ReadUint32(uint32_t* value);
-  V8_WARN_UNUSED_RESULT bool ReadUint64(uint64_t* value);
-  V8_WARN_UNUSED_RESULT bool ReadDouble(double* value);
-  V8_WARN_UNUSED_RESULT bool ReadRawBytes(size_t length, const void** data);
-
- private:
-  ValueDeserializer(const ValueDeserializer&) = delete;
-  void operator=(const ValueDeserializer&) = delete;
-
-  struct PrivateData;
-  PrivateData* private_;
-};
-
-/**
- * A map whose keys are referenced weakly. It is similar to JavaScript WeakMap
- * but can be created without entering a v8::Context and hence shouldn't
- * escape to JavaScript.
- */
-class V8_EXPORT NativeWeakMap : public Data {
- public:
-  static Local<NativeWeakMap> New(Isolate* isolate);
-  void Set(Local<Value> key, Local<Value> value);
-  Local<Value> Get(Local<Value> key);
-  bool Has(Local<Value> key);
-  bool Delete(Local<Value> key);
-};
-
-
-// --- Value ---
-
-
-/**
- * The superclass of all JavaScript values and objects.
- */
-class V8_EXPORT Value : public Data {
- public:
-  /**
-   * Returns true if this value is the undefined value.  See ECMA-262
-   * 4.3.10.
-   */
-  V8_INLINE bool IsUndefined() const;
-
-  /**
-   * Returns true if this value is the null value.  See ECMA-262
-   * 4.3.11.
-   */
-  V8_INLINE bool IsNull() const;
-
-  /**
-   * Returns true if this value is either the null or the undefined value.
-   * See ECMA-262
-   * 4.3.11. and 4.3.12
-   */
-  V8_INLINE bool IsNullOrUndefined() const;
-
-  /**
-  * Returns true if this value is true.
-  */
-  bool IsTrue() const;
-
-  /**
-   * Returns true if this value is false.
-   */
-  bool IsFalse() const;
-
-  /**
-   * Returns true if this value is a symbol or a string.
-   */
-  bool IsName() const;
-
-  /**
-   * Returns true if this value is an instance of the String type.
-   * See ECMA-262 8.4.
-   */
-  V8_INLINE bool IsString() const;
-
-  /**
-   * Returns true if this value is a symbol.
-   */
-  bool IsSymbol() const;
-
-  /**
-   * Returns true if this value is a function.
-   */
-  bool IsFunction() const;
-
-  /**
-   * Returns true if this value is an array. Note that it will return false for
-   * an Proxy for an array.
-   */
-  bool IsArray() const;
-
-  /**
-   * Returns true if this value is an object.
-   */
-  bool IsObject() const;
-
-  /**
-   * Returns true if this value is boolean.
-   */
-  bool IsBoolean() const;
-
-  /**
-   * Returns true if this value is a number.
-   */
-  bool IsNumber() const;
-
-  /**
-   * Returns true if this value is external.
-   */
-  bool IsExternal() const;
-
-  /**
-   * Returns true if this value is a 32-bit signed integer.
-   */
-  bool IsInt32() const;
-
-  /**
-   * Returns true if this value is a 32-bit unsigned integer.
-   */
-  bool IsUint32() const;
-
-  /**
-   * Returns true if this value is a Date.
-   */
-  bool IsDate() const;
-
-  /**
-   * Returns true if this value is an Arguments object.
-   */
-  bool IsArgumentsObject() const;
-
-  /**
-   * Returns true if this value is a Boolean object.
-   */
-  bool IsBooleanObject() const;
-
-  /**
-   * Returns true if this value is a Number object.
-   */
-  bool IsNumberObject() const;
-
-  /**
-   * Returns true if this value is a String object.
-   */
-  bool IsStringObject() const;
-
-  /**
-   * Returns true if this value is a Symbol object.
-   */
-  bool IsSymbolObject() const;
-
-  /**
-   * Returns true if this value is a NativeError.
-   */
-  bool IsNativeError() const;
-
-  /**
-   * Returns true if this value is a RegExp.
-   */
-  bool IsRegExp() const;
-
-  /**
-   * Returns true if this value is an async function.
-   */
-  bool IsAsyncFunction() const;
-
-  /**
-   * Returns true if this value is a Generator function.
-   */
-  bool IsGeneratorFunction() const;
-
-  /**
-   * Returns true if this value is a Generator object (iterator).
-   */
-  bool IsGeneratorObject() const;
-
-  /**
-   * Returns true if this value is a Promise.
-   */
-  bool IsPromise() const;
-
-  /**
-   * Returns true if this value is a Map.
-   */
-  bool IsMap() const;
-
-  /**
-   * Returns true if this value is a Set.
-   */
-  bool IsSet() const;
-
-  /**
-   * Returns true if this value is a Map Iterator.
-   */
-  bool IsMapIterator() const;
-
-  /**
-   * Returns true if this value is a Set Iterator.
-   */
-  bool IsSetIterator() const;
-
-  /**
-   * Returns true if this value is a WeakMap.
-   */
-  bool IsWeakMap() const;
-
-  /**
-   * Returns true if this value is a WeakSet.
-   */
-  bool IsWeakSet() const;
-
-  /**
-   * Returns true if this value is an ArrayBuffer.
-   */
-  bool IsArrayBuffer() const;
-
-  /**
-   * Returns true if this value is an ArrayBufferView.
-   */
-  bool IsArrayBufferView() const;
-
-  /**
-   * Returns true if this value is one of TypedArrays.
-   */
-  bool IsTypedArray() const;
-
-  /**
-   * Returns true if this value is an Uint8Array.
-   */
-  bool IsUint8Array() const;
-
-  /**
-   * Returns true if this value is an Uint8ClampedArray.
-   */
-  bool IsUint8ClampedArray() const;
-
-  /**
-   * Returns true if this value is an Int8Array.
-   */
-  bool IsInt8Array() const;
-
-  /**
-   * Returns true if this value is an Uint16Array.
-   */
-  bool IsUint16Array() const;
-
-  /**
-   * Returns true if this value is an Int16Array.
-   */
-  bool IsInt16Array() const;
-
-  /**
-   * Returns true if this value is an Uint32Array.
-   */
-  bool IsUint32Array() const;
-
-  /**
-   * Returns true if this value is an Int32Array.
-   */
-  bool IsInt32Array() const;
-
-  /**
-   * Returns true if this value is a Float32Array.
-   */
-  bool IsFloat32Array() const;
-
-  /**
-   * Returns true if this value is a Float64Array.
-   */
-  bool IsFloat64Array() const;
-
-  /**
-   * Returns true if this value is a DataView.
-   */
-  bool IsDataView() const;
-
-  /**
-   * Returns true if this value is a SharedArrayBuffer.
-   * This is an experimental feature.
-   */
-  bool IsSharedArrayBuffer() const;
-
-  /**
-   * Returns true if this value is a JavaScript Proxy.
-   */
-  bool IsProxy() const;
-
-  bool IsWebAssemblyCompiledModule() const;
-
-  V8_WARN_UNUSED_RESULT MaybeLocal<Boolean> ToBoolean(
-      Local<Context> context) const;
-  V8_WARN_UNUSED_RESULT MaybeLocal<Number> ToNumber(
-      Local<Context> context) const;
-  V8_WARN_UNUSED_RESULT MaybeLocal<String> ToString(
-      Local<Context> context) const;
-  V8_WARN_UNUSED_RESULT MaybeLocal<String> ToDetailString(
-      Local<Context> context) const;
-  V8_WARN_UNUSED_RESULT MaybeLocal<Object> ToObject(
-      Local<Context> context) const;
-  V8_WARN_UNUSED_RESULT MaybeLocal<Integer> ToInteger(
-      Local<Context> context) const;
-  V8_WARN_UNUSED_RESULT MaybeLocal<Uint32> ToUint32(
-      Local<Context> context) const;
-  V8_WARN_UNUSED_RESULT MaybeLocal<Int32> ToInt32(Local<Context> context) const;
-
-  V8_DEPRECATE_SOON("Use maybe version",
-                    Local<Boolean> ToBoolean(Isolate* isolate) const);
-  V8_DEPRECATE_SOON("Use maybe version",
-                    Local<Number> ToNumber(Isolate* isolate) const);
-  V8_DEPRECATE_SOON("Use maybe version",
-                    Local<String> ToString(Isolate* isolate) const);
-  V8_DEPRECATED("Use maybe version",
-                Local<String> ToDetailString(Isolate* isolate) const);
-  V8_DEPRECATE_SOON("Use maybe version",
-                    Local<Object> ToObject(Isolate* isolate) const);
-  V8_DEPRECATE_SOON("Use maybe version",
-                    Local<Integer> ToInteger(Isolate* isolate) const);
-  V8_DEPRECATED("Use maybe version",
-                Local<Uint32> ToUint32(Isolate* isolate) const);
-  V8_DEPRECATE_SOON("Use maybe version",
-                    Local<Int32> ToInt32(Isolate* isolate) const);
-
-  inline V8_DEPRECATE_SOON("Use maybe version",
-                           Local<Boolean> ToBoolean() const);
-  inline V8_DEPRECATED("Use maybe version", Local<Number> ToNumber() const);
-  inline V8_DEPRECATE_SOON("Use maybe version", Local<String> ToString() const);
-  inline V8_DEPRECATED("Use maybe version",
-                       Local<String> ToDetailString() const);
-  inline V8_DEPRECATE_SOON("Use maybe version", Local<Object> ToObject() const);
-  inline V8_DEPRECATE_SOON("Use maybe version",
-                           Local<Integer> ToInteger() const);
-  inline V8_DEPRECATED("Use maybe version", Local<Uint32> ToUint32() const);
-  inline V8_DEPRECATED("Use maybe version", Local<Int32> ToInt32() const);
-
-  /**
-   * Attempts to convert a string to an array index.
-   * Returns an empty handle if the conversion fails.
-   */
-  V8_DEPRECATED("Use maybe version", Local<Uint32> ToArrayIndex() const);
-  V8_WARN_UNUSED_RESULT MaybeLocal<Uint32> ToArrayIndex(
-      Local<Context> context) const;
-
-  V8_WARN_UNUSED_RESULT Maybe<bool> BooleanValue(Local<Context> context) const;
-  V8_WARN_UNUSED_RESULT Maybe<double> NumberValue(Local<Context> context) const;
-  V8_WARN_UNUSED_RESULT Maybe<int64_t> IntegerValue(
-      Local<Context> context) const;
-  V8_WARN_UNUSED_RESULT Maybe<uint32_t> Uint32Value(
-      Local<Context> context) const;
-  V8_WARN_UNUSED_RESULT Maybe<int32_t> Int32Value(Local<Context> context) const;
-
-  V8_DEPRECATE_SOON("Use maybe version", bool BooleanValue() const);
-  V8_DEPRECATE_SOON("Use maybe version", double NumberValue() const);
-  V8_DEPRECATE_SOON("Use maybe version", int64_t IntegerValue() const);
-  V8_DEPRECATE_SOON("Use maybe version", uint32_t Uint32Value() const);
-  V8_DEPRECATE_SOON("Use maybe version", int32_t Int32Value() const);
-
-  /** JS == */
-  V8_DEPRECATE_SOON("Use maybe version", bool Equals(Local<Value> that) const);
-  V8_WARN_UNUSED_RESULT Maybe<bool> Equals(Local<Context> context,
-                                           Local<Value> that) const;
-  bool StrictEquals(Local<Value> that) const;
-  bool SameValue(Local<Value> that) const;
-
-  template <class T> V8_INLINE static Value* Cast(T* value);
-
-  Local<String> TypeOf(Isolate*);
-
- private:
-  V8_INLINE bool QuickIsUndefined() const;
-  V8_INLINE bool QuickIsNull() const;
-  V8_INLINE bool QuickIsNullOrUndefined() const;
-  V8_INLINE bool QuickIsString() const;
-  bool FullIsUndefined() const;
-  bool FullIsNull() const;
-  bool FullIsString() const;
-};
-
-
-/**
- * The superclass of primitive values.  See ECMA-262 4.3.2.
- */
-class V8_EXPORT Primitive : public Value { };
-
-
-/**
- * A primitive boolean value (ECMA-262, 4.3.14).  Either the true
- * or false value.
- */
-class V8_EXPORT Boolean : public Primitive {
- public:
-  bool Value() const;
-  V8_INLINE static Boolean* Cast(v8::Value* obj);
-  V8_INLINE static Local<Boolean> New(Isolate* isolate, bool value);
-
- private:
-  static void CheckCast(v8::Value* obj);
-};
-
-
-/**
- * A superclass for symbols and strings.
- */
-class V8_EXPORT Name : public Primitive {
- public:
-  /**
-   * Returns the identity hash for this object. The current implementation
-   * uses an inline property on the object to store the identity hash.
-   *
-   * The return value will never be 0. Also, it is not guaranteed to be
-   * unique.
-   */
-  int GetIdentityHash();
-
-  V8_INLINE static Name* Cast(Value* obj);
-
- private:
-  static void CheckCast(Value* obj);
-};
-
-
-enum class NewStringType { kNormal, kInternalized };
-
-
-/**
- * A JavaScript string value (ECMA-262, 4.3.17).
- */
-class V8_EXPORT String : public Name {
- public:
-  static const int kMaxLength = (1 << 28) - 16;
-
-  enum Encoding {
-    UNKNOWN_ENCODING = 0x1,
-    TWO_BYTE_ENCODING = 0x0,
-    ONE_BYTE_ENCODING = 0x8
-  };
-  /**
-   * Returns the number of characters in this string.
-   */
-  int Length() const;
-
-  /**
-   * Returns the number of bytes in the UTF-8 encoded
-   * representation of this string.
-   */
-  int Utf8Length() const;
-
-  /**
-   * Returns whether this string is known to contain only one byte data.
-   * Does not read the string.
-   * False negatives are possible.
-   */
-  bool IsOneByte() const;
-
-  /**
-   * Returns whether this string contain only one byte data.
-   * Will read the entire string in some cases.
-   */
-  bool ContainsOnlyOneByte() const;
-
-  /**
-   * Write the contents of the string to an external buffer.
-   * If no arguments are given, expects the buffer to be large
-   * enough to hold the entire string and NULL terminator. Copies
-   * the contents of the string and the NULL terminator into the
-   * buffer.
-   *
-   * WriteUtf8 will not write partial UTF-8 sequences, preferring to stop
-   * before the end of the buffer.
-   *
-   * Copies up to length characters into the output buffer.
-   * Only null-terminates if there is enough space in the buffer.
-   *
-   * \param buffer The buffer into which the string will be copied.
-   * \param start The starting position within the string at which
-   * copying begins.
-   * \param length The number of characters to copy from the string.  For
-   *    WriteUtf8 the number of bytes in the buffer.
-   * \param nchars_ref The number of characters written, can be NULL.
-   * \param options Various options that might affect performance of this or
-   *    subsequent operations.
-   * \return The number of characters copied to the buffer excluding the null
-   *    terminator.  For WriteUtf8: The number of bytes copied to the buffer
-   *    including the null terminator (if written).
-   */
-  enum WriteOptions {
-    NO_OPTIONS = 0,
-    HINT_MANY_WRITES_EXPECTED = 1,
-    NO_NULL_TERMINATION = 2,
-    PRESERVE_ONE_BYTE_NULL = 4,
-    // Used by WriteUtf8 to replace orphan surrogate code units with the
-    // unicode replacement character. Needs to be set to guarantee valid UTF-8
-    // output.
-    REPLACE_INVALID_UTF8 = 8
-  };
-
-  // 16-bit character codes.
-  int Write(uint16_t* buffer,
-            int start = 0,
-            int length = -1,
-            int options = NO_OPTIONS) const;
-  // One byte characters.
-  int WriteOneByte(uint8_t* buffer,
-                   int start = 0,
-                   int length = -1,
-                   int options = NO_OPTIONS) const;
-  // UTF-8 encoded characters.
-  int WriteUtf8(char* buffer,
-                int length = -1,
-                int* nchars_ref = NULL,
-                int options = NO_OPTIONS) const;
-
-  /**
-   * A zero length string.
-   */
-  V8_INLINE static Local<String> Empty(Isolate* isolate);
-
-  /**
-   * Returns true if the string is external
-   */
-  bool IsExternal() const;
-
-  /**
-   * Returns true if the string is both external and one-byte.
-   */
-  bool IsExternalOneByte() const;
-
-  class V8_EXPORT ExternalStringResourceBase {  // NOLINT
-   public:
-    virtual ~ExternalStringResourceBase() {}
-
-    virtual bool IsCompressible() const { return false; }
-
-   protected:
-    ExternalStringResourceBase() {}
-
-    /**
-     * Internally V8 will call this Dispose method when the external string
-     * resource is no longer needed. The default implementation will use the
-     * delete operator. This method can be overridden in subclasses to
-     * control how allocated external string resources are disposed.
-     */
-    virtual void Dispose() { delete this; }
-
-    // Disallow copying and assigning.
-    ExternalStringResourceBase(const ExternalStringResourceBase&) = delete;
-    void operator=(const ExternalStringResourceBase&) = delete;
-
-   private:
-    friend class internal::Heap;
-    friend class v8::String;
-  };
-
-  /**
-   * An ExternalStringResource is a wrapper around a two-byte string
-   * buffer that resides outside V8's heap. Implement an
-   * ExternalStringResource to manage the life cycle of the underlying
-   * buffer.  Note that the string data must be immutable.
-   */
-  class V8_EXPORT ExternalStringResource
-      : public ExternalStringResourceBase {
-   public:
-    /**
-     * Override the destructor to manage the life cycle of the underlying
-     * buffer.
-     */
-    virtual ~ExternalStringResource() {}
-
-    /**
-     * The string data from the underlying buffer.
-     */
-    virtual const uint16_t* data() const = 0;
-
-    /**
-     * The length of the string. That is, the number of two-byte characters.
-     */
-    virtual size_t length() const = 0;
-
-   protected:
-    ExternalStringResource() {}
-  };
-
-  /**
-   * An ExternalOneByteStringResource is a wrapper around an one-byte
-   * string buffer that resides outside V8's heap. Implement an
-   * ExternalOneByteStringResource to manage the life cycle of the
-   * underlying buffer.  Note that the string data must be immutable
-   * and that the data must be Latin-1 and not UTF-8, which would require
-   * special treatment internally in the engine and do not allow efficient
-   * indexing.  Use String::New or convert to 16 bit data for non-Latin1.
-   */
-
-  class V8_EXPORT ExternalOneByteStringResource
-      : public ExternalStringResourceBase {
-   public:
-    /**
-     * Override the destructor to manage the life cycle of the underlying
-     * buffer.
-     */
-    virtual ~ExternalOneByteStringResource() {}
-    /** The string data from the underlying buffer.*/
-    virtual const char* data() const = 0;
-    /** The number of Latin-1 characters in the string.*/
-    virtual size_t length() const = 0;
-   protected:
-    ExternalOneByteStringResource() {}
-  };
-
-  /**
-   * If the string is an external string, return the ExternalStringResourceBase
-   * regardless of the encoding, otherwise return NULL.  The encoding of the
-   * string is returned in encoding_out.
-   */
-  V8_INLINE ExternalStringResourceBase* GetExternalStringResourceBase(
-      Encoding* encoding_out) const;
-
-  /**
-   * Get the ExternalStringResource for an external string.  Returns
-   * NULL if IsExternal() doesn't return true.
-   */
-  V8_INLINE ExternalStringResource* GetExternalStringResource() const;
-
-  /**
-   * Get the ExternalOneByteStringResource for an external one-byte string.
-   * Returns NULL if IsExternalOneByte() doesn't return true.
-   */
-  const ExternalOneByteStringResource* GetExternalOneByteStringResource() const;
-
-  V8_INLINE static String* Cast(v8::Value* obj);
-
-  // TODO(dcarney): remove with deprecation of New functions.
-  enum NewStringType {
-    kNormalString = static_cast<int>(v8::NewStringType::kNormal),
-    kInternalizedString = static_cast<int>(v8::NewStringType::kInternalized)
-  };
-
-  /** Allocates a new string from UTF-8 data.*/
-  static V8_DEPRECATE_SOON(
-      "Use maybe version",
-      Local<String> NewFromUtf8(Isolate* isolate, const char* data,
-                                NewStringType type = kNormalString,
-                                int length = -1));
-
-  /** Allocates a new string from UTF-8 data. Only returns an empty value when
-   * length > kMaxLength. **/
-  static V8_WARN_UNUSED_RESULT MaybeLocal<String> NewFromUtf8(
-      Isolate* isolate, const char* data, v8::NewStringType type,
-      int length = -1);
-
-  /** Allocates a new string from Latin-1 data.*/
-  static V8_DEPRECATED(
-      "Use maybe version",
-      Local<String> NewFromOneByte(Isolate* isolate, const uint8_t* data,
-                                   NewStringType type = kNormalString,
-                                   int length = -1));
-
-  /** Allocates a new string from Latin-1 data.  Only returns an empty value
-   * when length > kMaxLength. **/
-  static V8_WARN_UNUSED_RESULT MaybeLocal<String> NewFromOneByte(
-      Isolate* isolate, const uint8_t* data, v8::NewStringType type,
-      int length = -1);
-
-  /** Allocates a new string from UTF-16 data.*/
-  static V8_DEPRECATE_SOON(
-      "Use maybe version",
-      Local<String> NewFromTwoByte(Isolate* isolate, const uint16_t* data,
-                                   NewStringType type = kNormalString,
-                                   int length = -1));
-
-  /** Allocates a new string from UTF-16 data. Only returns an empty value when
-   * length > kMaxLength. **/
-  static V8_WARN_UNUSED_RESULT MaybeLocal<String> NewFromTwoByte(
-      Isolate* isolate, const uint16_t* data, v8::NewStringType type,
-      int length = -1);
-
-  /**
-   * Creates a new string by concatenating the left and the right strings
-   * passed in as parameters.
-   */
-  static Local<String> Concat(Local<String> left, Local<String> right);
-
-  /**
-   * Creates a new external string using the data defined in the given
-   * resource. When the external string is no longer live on V8's heap the
-   * resource will be disposed by calling its Dispose method. The caller of
-   * this function should not otherwise delete or modify the resource. Neither
-   * should the underlying buffer be deallocated or modified except through the
-   * destructor of the external string resource.
-   */
-  static V8_DEPRECATED("Use maybe version",
-                       Local<String> NewExternal(
-                           Isolate* isolate, ExternalStringResource* resource));
-  static V8_WARN_UNUSED_RESULT MaybeLocal<String> NewExternalTwoByte(
-      Isolate* isolate, ExternalStringResource* resource);
-
-  /**
-   * Associate an external string resource with this string by transforming it
-   * in place so that existing references to this string in the JavaScript heap
-   * will use the external string resource. The external string resource's
-   * character contents need to be equivalent to this string.
-   * Returns true if the string has been changed to be an external string.
-   * The string is not modified if the operation fails. See NewExternal for
-   * information on the lifetime of the resource.
-   */
-  bool MakeExternal(ExternalStringResource* resource);
-
-  /**
-   * Creates a new external string using the one-byte data defined in the given
-   * resource. When the external string is no longer live on V8's heap the
-   * resource will be disposed by calling its Dispose method. The caller of
-   * this function should not otherwise delete or modify the resource. Neither
-   * should the underlying buffer be deallocated or modified except through the
-   * destructor of the external string resource.
-   */
-  static V8_DEPRECATE_SOON(
-      "Use maybe version",
-      Local<String> NewExternal(Isolate* isolate,
-                                ExternalOneByteStringResource* resource));
-  static V8_WARN_UNUSED_RESULT MaybeLocal<String> NewExternalOneByte(
-      Isolate* isolate, ExternalOneByteStringResource* resource);
-
-  /**
-   * Associate an external string resource with this string by transforming it
-   * in place so that existing references to this string in the JavaScript heap
-   * will use the external string resource. The external string resource's
-   * character contents need to be equivalent to this string.
-   * Returns true if the string has been changed to be an external string.
-   * The string is not modified if the operation fails. See NewExternal for
-   * information on the lifetime of the resource.
-   */
-  bool MakeExternal(ExternalOneByteStringResource* resource);
-
-  /**
-   * Returns true if this string can be made external.
-   */
-  bool CanMakeExternal();
-
-  /**
-   * Converts an object to a UTF-8-encoded character array.  Useful if
-   * you want to print the object.  If conversion to a string fails
-   * (e.g. due to an exception in the toString() method of the object)
-   * then the length() method returns 0 and the * operator returns
-   * NULL.
-   */
-  class V8_EXPORT Utf8Value {
-   public:
-    explicit Utf8Value(Local<v8::Value> obj);
-    ~Utf8Value();
-    char* operator*() { return str_; }
-    const char* operator*() const { return str_; }
-    int length() const { return length_; }
-
-    // Disallow copying and assigning.
-    Utf8Value(const Utf8Value&) = delete;
-    void operator=(const Utf8Value&) = delete;
-
-   private:
-    char* str_;
-    int length_;
-  };
-
-  /**
-   * Converts an object to a two-byte string.
-   * If conversion to a string fails (eg. due to an exception in the toString()
-   * method of the object) then the length() method returns 0 and the * operator
-   * returns NULL.
-   */
-  class V8_EXPORT Value {
-   public:
-    explicit Value(Local<v8::Value> obj);
-    ~Value();
-    uint16_t* operator*() { return str_; }
-    const uint16_t* operator*() const { return str_; }
-    int length() const { return length_; }
-
-    // Disallow copying and assigning.
-    Value(const Value&) = delete;
-    void operator=(const Value&) = delete;
-
-   private:
-    uint16_t* str_;
-    int length_;
-  };
-
- private:
-  void VerifyExternalStringResourceBase(ExternalStringResourceBase* v,
-                                        Encoding encoding) const;
-  void VerifyExternalStringResource(ExternalStringResource* val) const;
-  static void CheckCast(v8::Value* obj);
-};
-
-
-/**
- * A JavaScript symbol (ECMA-262 edition 6)
- */
-class V8_EXPORT Symbol : public Name {
- public:
-  // Returns the print name string of the symbol, or undefined if none.
-  Local<Value> Name() const;
-
-  // Create a symbol. If name is not empty, it will be used as the description.
-  static Local<Symbol> New(Isolate* isolate,
-                           Local<String> name = Local<String>());
-
-  // Access global symbol registry.
-  // Note that symbols created this way are never collected, so
-  // they should only be used for statically fixed properties.
-  // Also, there is only one global name space for the names used as keys.
-  // To minimize the potential for clashes, use qualified names as keys.
-  static Local<Symbol> For(Isolate *isolate, Local<String> name);
-
-  // Retrieve a global symbol. Similar to |For|, but using a separate
-  // registry that is not accessible by (and cannot clash with) JavaScript code.
-  static Local<Symbol> ForApi(Isolate *isolate, Local<String> name);
-
-  // Well-known symbols
-  static Local<Symbol> GetIterator(Isolate* isolate);
-  static Local<Symbol> GetUnscopables(Isolate* isolate);
-  static Local<Symbol> GetToPrimitive(Isolate* isolate);
-  static Local<Symbol> GetToStringTag(Isolate* isolate);
-  static Local<Symbol> GetIsConcatSpreadable(Isolate* isolate);
-
-  V8_INLINE static Symbol* Cast(Value* obj);
-
- private:
-  Symbol();
-  static void CheckCast(Value* obj);
-};
-
-
-/**
- * A private symbol
- *
- * This is an experimental feature. Use at your own risk.
- */
-class V8_EXPORT Private : public Data {
- public:
-  // Returns the print name string of the private symbol, or undefined if none.
-  Local<Value> Name() const;
-
-  // Create a private symbol. If name is not empty, it will be the description.
-  static Local<Private> New(Isolate* isolate,
-                            Local<String> name = Local<String>());
-
-  // Retrieve a global private symbol. If a symbol with this name has not
-  // been retrieved in the same isolate before, it is created.
-  // Note that private symbols created this way are never collected, so
-  // they should only be used for statically fixed properties.
-  // Also, there is only one global name space for the names used as keys.
-  // To minimize the potential for clashes, use qualified names as keys,
-  // e.g., "Class#property".
-  static Local<Private> ForApi(Isolate* isolate, Local<String> name);
-
- private:
-  Private();
-};
-
-
-/**
- * A JavaScript number value (ECMA-262, 4.3.20)
- */
-class V8_EXPORT Number : public Primitive {
- public:
-  double Value() const;
-  static Local<Number> New(Isolate* isolate, double value);
-  V8_INLINE static Number* Cast(v8::Value* obj);
- private:
-  Number();
-  static void CheckCast(v8::Value* obj);
-};
-
-
-/**
- * A JavaScript value representing a signed integer.
- */
-class V8_EXPORT Integer : public Number {
- public:
-  static Local<Integer> New(Isolate* isolate, int32_t value);
-  static Local<Integer> NewFromUnsigned(Isolate* isolate, uint32_t value);
-  int64_t Value() const;
-  V8_INLINE static Integer* Cast(v8::Value* obj);
- private:
-  Integer();
-  static void CheckCast(v8::Value* obj);
-};
-
-
-/**
- * A JavaScript value representing a 32-bit signed integer.
- */
-class V8_EXPORT Int32 : public Integer {
- public:
-  int32_t Value() const;
-  V8_INLINE static Int32* Cast(v8::Value* obj);
-
- private:
-  Int32();
-  static void CheckCast(v8::Value* obj);
-};
-
-
-/**
- * A JavaScript value representing a 32-bit unsigned integer.
- */
-class V8_EXPORT Uint32 : public Integer {
- public:
-  uint32_t Value() const;
-  V8_INLINE static Uint32* Cast(v8::Value* obj);
-
- private:
-  Uint32();
-  static void CheckCast(v8::Value* obj);
-};
-
-/**
- * PropertyAttribute.
- */
-enum PropertyAttribute {
-  /** None. **/
-  None = 0,
-  /** ReadOnly, i.e., not writable. **/
-  ReadOnly = 1 << 0,
-  /** DontEnum, i.e., not enumerable. **/
-  DontEnum = 1 << 1,
-  /** DontDelete, i.e., not configurable. **/
-  DontDelete = 1 << 2
-};
-
-/**
- * Accessor[Getter|Setter] are used as callback functions when
- * setting|getting a particular property. See Object and ObjectTemplate's
- * method SetAccessor.
- */
-typedef void (*AccessorGetterCallback)(
-    Local<String> property,
-    const PropertyCallbackInfo<Value>& info);
-typedef void (*AccessorNameGetterCallback)(
-    Local<Name> property,
-    const PropertyCallbackInfo<Value>& info);
-
-
-typedef void (*AccessorSetterCallback)(
-    Local<String> property,
-    Local<Value> value,
-    const PropertyCallbackInfo<void>& info);
-typedef void (*AccessorNameSetterCallback)(
-    Local<Name> property,
-    Local<Value> value,
-    const PropertyCallbackInfo<void>& info);
-
-
-/**
- * Access control specifications.
- *
- * Some accessors should be accessible across contexts.  These
- * accessors have an explicit access control parameter which specifies
- * the kind of cross-context access that should be allowed.
- *
- * TODO(dcarney): Remove PROHIBITS_OVERWRITING as it is now unused.
- */
-enum AccessControl {
-  DEFAULT               = 0,
-  ALL_CAN_READ          = 1,
-  ALL_CAN_WRITE         = 1 << 1,
-  PROHIBITS_OVERWRITING = 1 << 2
-};
-
-/**
- * Property filter bits. They can be or'ed to build a composite filter.
- */
-enum PropertyFilter {
-  ALL_PROPERTIES = 0,
-  ONLY_WRITABLE = 1,
-  ONLY_ENUMERABLE = 2,
-  ONLY_CONFIGURABLE = 4,
-  SKIP_STRINGS = 8,
-  SKIP_SYMBOLS = 16
-};
-
-/**
- * Keys/Properties filter enums:
- *
- * KeyCollectionMode limits the range of collected properties. kOwnOnly limits
- * the collected properties to the given Object only. kIncludesPrototypes will
- * include all keys of the objects's prototype chain as well.
- */
-enum class KeyCollectionMode { kOwnOnly, kIncludePrototypes };
-
-/**
- * kIncludesIndices allows for integer indices to be collected, while
- * kSkipIndices will exclude integer indicies from being collected.
- */
-enum class IndexFilter { kIncludeIndices, kSkipIndices };
-
-/**
- * Integrity level for objects.
- */
-enum class IntegrityLevel { kFrozen, kSealed };
-
-/**
- * A JavaScript object (ECMA-262, 4.3.3)
- */
-class V8_EXPORT Object : public Value {
- public:
-  V8_DEPRECATE_SOON("Use maybe version",
-                    bool Set(Local<Value> key, Local<Value> value));
-  V8_WARN_UNUSED_RESULT Maybe<bool> Set(Local<Context> context,
-                                        Local<Value> key, Local<Value> value);
-
-  V8_DEPRECATE_SOON("Use maybe version",
-                    bool Set(uint32_t index, Local<Value> value));
-  V8_WARN_UNUSED_RESULT Maybe<bool> Set(Local<Context> context, uint32_t index,
-                                        Local<Value> value);
-
-  // Implements CreateDataProperty (ECMA-262, 7.3.4).
-  //
-  // Defines a configurable, writable, enumerable property with the given value
-  // on the object unless the property already exists and is not configurable
-  // or the object is not extensible.
-  //
-  // Returns true on success.
-  V8_WARN_UNUSED_RESULT Maybe<bool> CreateDataProperty(Local<Context> context,
-                                                       Local<Name> key,
-                                                       Local<Value> value);
-  V8_WARN_UNUSED_RESULT Maybe<bool> CreateDataProperty(Local<Context> context,
-                                                       uint32_t index,
-                                                       Local<Value> value);
-
-  // Implements DefineOwnProperty.
-  //
-  // In general, CreateDataProperty will be faster, however, does not allow
-  // for specifying attributes.
-  //
-  // Returns true on success.
-  V8_WARN_UNUSED_RESULT Maybe<bool> DefineOwnProperty(
-      Local<Context> context, Local<Name> key, Local<Value> value,
-      PropertyAttribute attributes = None);
-
-  // Implements Object.DefineProperty(O, P, Attributes), see Ecma-262 19.1.2.4.
-  //
-  // The defineProperty function is used to add an own property or
-  // update the attributes of an existing own property of an object.
-  //
-  // Both data and accessor descriptors can be used.
-  //
-  // In general, CreateDataProperty is faster, however, does not allow
-  // for specifying attributes or an accessor descriptor.
-  //
-  // The PropertyDescriptor can change when redefining a property.
-  //
-  // Returns true on success.
-  V8_WARN_UNUSED_RESULT Maybe<bool> DefineProperty(
-      Local<Context> context, Local<Name> key, PropertyDescriptor& descriptor);
-
-  // Sets an own property on this object bypassing interceptors and
-  // overriding accessors or read-only properties.
-  //
-  // Note that if the object has an interceptor the property will be set
-  // locally, but since the interceptor takes precedence the local property
-  // will only be returned if the interceptor doesn't return a value.
-  //
-  // Note also that this only works for named properties.
-  V8_DEPRECATED("Use CreateDataProperty / DefineOwnProperty",
-                bool ForceSet(Local<Value> key, Local<Value> value,
-                              PropertyAttribute attribs = None));
-  V8_DEPRECATE_SOON("Use CreateDataProperty / DefineOwnProperty",
-                    Maybe<bool> ForceSet(Local<Context> context,
-                                         Local<Value> key, Local<Value> value,
-                                         PropertyAttribute attribs = None));
-
-  V8_DEPRECATE_SOON("Use maybe version", Local<Value> Get(Local<Value> key));
-  V8_WARN_UNUSED_RESULT MaybeLocal<Value> Get(Local<Context> context,
-                                              Local<Value> key);
-
-  V8_DEPRECATE_SOON("Use maybe version", Local<Value> Get(uint32_t index));
-  V8_WARN_UNUSED_RESULT MaybeLocal<Value> Get(Local<Context> context,
-                                              uint32_t index);
-
-  /**
-   * Gets the property attributes of a property which can be None or
-   * any combination of ReadOnly, DontEnum and DontDelete. Returns
-   * None when the property doesn't exist.
-   */
-  V8_DEPRECATED("Use maybe version",
-                PropertyAttribute GetPropertyAttributes(Local<Value> key));
-  V8_WARN_UNUSED_RESULT Maybe<PropertyAttribute> GetPropertyAttributes(
-      Local<Context> context, Local<Value> key);
-
-  /**
-   * Returns Object.getOwnPropertyDescriptor as per ES5 section 15.2.3.3.
-   */
-  V8_DEPRECATED("Use maybe version",
-                Local<Value> GetOwnPropertyDescriptor(Local<String> key));
-  V8_WARN_UNUSED_RESULT MaybeLocal<Value> GetOwnPropertyDescriptor(
-      Local<Context> context, Local<String> key);
-
-  V8_DEPRECATE_SOON("Use maybe version", bool Has(Local<Value> key));
-  /**
-   * Object::Has() calls the abstract operation HasProperty(O, P) described
-   * in ECMA-262, 7.3.10. Has() returns
-   * true, if the object has the property, either own or on the prototype chain.
-   * Interceptors, i.e., PropertyQueryCallbacks, are called if present.
-   *
-   * Has() has the same side effects as JavaScript's `variable in object`.
-   * For example, calling Has() on a revoked proxy will throw an exception.
-   *
-   * \note Has() converts the key to a name, which possibly calls back into
-   * JavaScript.
-   *
-   * See also v8::Object::HasOwnProperty() and
-   * v8::Object::HasRealNamedProperty().
-   */
-  V8_WARN_UNUSED_RESULT Maybe<bool> Has(Local<Context> context,
-                                        Local<Value> key);
-
-  V8_DEPRECATE_SOON("Use maybe version", bool Delete(Local<Value> key));
-  // TODO(dcarney): mark V8_WARN_UNUSED_RESULT
-  Maybe<bool> Delete(Local<Context> context, Local<Value> key);
-
-  V8_DEPRECATED("Use maybe version", bool Has(uint32_t index));
-  V8_WARN_UNUSED_RESULT Maybe<bool> Has(Local<Context> context, uint32_t index);
-
-  V8_DEPRECATED("Use maybe version", bool Delete(uint32_t index));
-  // TODO(dcarney): mark V8_WARN_UNUSED_RESULT
-  Maybe<bool> Delete(Local<Context> context, uint32_t index);
-
-  V8_DEPRECATED("Use maybe version",
-                bool SetAccessor(Local<String> name,
-                                 AccessorGetterCallback getter,
-                                 AccessorSetterCallback setter = 0,
-                                 Local<Value> data = Local<Value>(),
-                                 AccessControl settings = DEFAULT,
-                                 PropertyAttribute attribute = None));
-  V8_DEPRECATED("Use maybe version",
-                bool SetAccessor(Local<Name> name,
-                                 AccessorNameGetterCallback getter,
-                                 AccessorNameSetterCallback setter = 0,
-                                 Local<Value> data = Local<Value>(),
-                                 AccessControl settings = DEFAULT,
-                                 PropertyAttribute attribute = None));
-  // TODO(dcarney): mark V8_WARN_UNUSED_RESULT
-  Maybe<bool> SetAccessor(Local<Context> context, Local<Name> name,
-                          AccessorNameGetterCallback getter,
-                          AccessorNameSetterCallback setter = 0,
-                          MaybeLocal<Value> data = MaybeLocal<Value>(),
-                          AccessControl settings = DEFAULT,
-                          PropertyAttribute attribute = None);
-
-  void SetAccessorProperty(Local<Name> name, Local<Function> getter,
-                           Local<Function> setter = Local<Function>(),
-                           PropertyAttribute attribute = None,
-                           AccessControl settings = DEFAULT);
-
-  /**
-   * Functionality for private properties.
-   * This is an experimental feature, use at your own risk.
-   * Note: Private properties are not inherited. Do not rely on this, since it
-   * may change.
-   */
-  Maybe<bool> HasPrivate(Local<Context> context, Local<Private> key);
-  Maybe<bool> SetPrivate(Local<Context> context, Local<Private> key,
-                         Local<Value> value);
-  Maybe<bool> DeletePrivate(Local<Context> context, Local<Private> key);
-  MaybeLocal<Value> GetPrivate(Local<Context> context, Local<Private> key);
-
-  /**
-   * Returns an array containing the names of the enumerable properties
-   * of this object, including properties from prototype objects.  The
-   * array returned by this method contains the same values as would
-   * be enumerated by a for-in statement over this object.
-   */
-  V8_DEPRECATE_SOON("Use maybe version", Local<Array> GetPropertyNames());
-  V8_WARN_UNUSED_RESULT MaybeLocal<Array> GetPropertyNames(
-      Local<Context> context);
-  V8_WARN_UNUSED_RESULT MaybeLocal<Array> GetPropertyNames(
-      Local<Context> context, KeyCollectionMode mode,
-      PropertyFilter property_filter, IndexFilter index_filter);
-
-  /**
-   * This function has the same functionality as GetPropertyNames but
-   * the returned array doesn't contain the names of properties from
-   * prototype objects.
-   */
-  V8_DEPRECATE_SOON("Use maybe version", Local<Array> GetOwnPropertyNames());
-  V8_WARN_UNUSED_RESULT MaybeLocal<Array> GetOwnPropertyNames(
-      Local<Context> context);
-
-  /**
-   * Returns an array containing the names of the filtered properties
-   * of this object, including properties from prototype objects.  The
-   * array returned by this method contains the same values as would
-   * be enumerated by a for-in statement over this object.
-   */
-  V8_WARN_UNUSED_RESULT MaybeLocal<Array> GetOwnPropertyNames(
-      Local<Context> context, PropertyFilter filter);
-
-  /**
-   * Get the prototype object.  This does not skip objects marked to
-   * be skipped by __proto__ and it does not consult the security
-   * handler.
-   */
-  Local<Value> GetPrototype();
-
-  /**
-   * Set the prototype object.  This does not skip objects marked to
-   * be skipped by __proto__ and it does not consult the security
-   * handler.
-   */
-  V8_DEPRECATED("Use maybe version", bool SetPrototype(Local<Value> prototype));
-  V8_WARN_UNUSED_RESULT Maybe<bool> SetPrototype(Local<Context> context,
-                                                 Local<Value> prototype);
-
-  /**
-   * Finds an instance of the given function template in the prototype
-   * chain.
-   */
-  Local<Object> FindInstanceInPrototypeChain(Local<FunctionTemplate> tmpl);
-
-  /**
-   * Call builtin Object.prototype.toString on this object.
-   * This is different from Value::ToString() that may call
-   * user-defined toString function. This one does not.
-   */
-  V8_DEPRECATED("Use maybe version", Local<String> ObjectProtoToString());
-  V8_WARN_UNUSED_RESULT MaybeLocal<String> ObjectProtoToString(
-      Local<Context> context);
-
-  /**
-   * Returns the name of the function invoked as a constructor for this object.
-   */
-  Local<String> GetConstructorName();
-
-  /**
-   * Sets the integrity level of the object.
-   */
-  Maybe<bool> SetIntegrityLevel(Local<Context> context, IntegrityLevel level);
-
-  /** Gets the number of internal fields for this Object. */
-  int InternalFieldCount();
-
-  /** Same as above, but works for Persistents */
-  V8_INLINE static int InternalFieldCount(
-      const PersistentBase<Object>& object) {
-    return object.val_->InternalFieldCount();
-  }
-
-  /** Gets the value from an internal field. */
-  V8_INLINE Local<Value> GetInternalField(int index);
-
-  /** Sets the value in an internal field. */
-  void SetInternalField(int index, Local<Value> value);
-
-  /**
-   * Gets a 2-byte-aligned native pointer from an internal field. This field
-   * must have been set by SetAlignedPointerInInternalField, everything else
-   * leads to undefined behavior.
-   */
-  V8_INLINE void* GetAlignedPointerFromInternalField(int index);
-
-  /** Same as above, but works for Persistents */
-  V8_INLINE static void* GetAlignedPointerFromInternalField(
-      const PersistentBase<Object>& object, int index) {
-    return object.val_->GetAlignedPointerFromInternalField(index);
-  }
-
-  /**
-   * Sets a 2-byte-aligned native pointer in an internal field. To retrieve such
-   * a field, GetAlignedPointerFromInternalField must be used, everything else
-   * leads to undefined behavior.
-   */
-  void SetAlignedPointerInInternalField(int index, void* value);
-  void SetAlignedPointerInInternalFields(int argc, int indices[],
-                                         void* values[]);
-
-  // Testers for local properties.
-  V8_DEPRECATED("Use maybe version", bool HasOwnProperty(Local<String> key));
-
-  /**
-   * HasOwnProperty() is like JavaScript's Object.prototype.hasOwnProperty().
-   *
-   * See also v8::Object::Has() and v8::Object::HasRealNamedProperty().
-   */
-  V8_WARN_UNUSED_RESULT Maybe<bool> HasOwnProperty(Local<Context> context,
-                                                   Local<Name> key);
-  V8_WARN_UNUSED_RESULT Maybe<bool> HasOwnProperty(Local<Context> context,
-                                                   uint32_t index);
-  V8_DEPRECATE_SOON("Use maybe version",
-                    bool HasRealNamedProperty(Local<String> key));
-  /**
-   * Use HasRealNamedProperty() if you want to check if an object has an own
-   * property without causing side effects, i.e., without calling interceptors.
-   *
-   * This function is similar to v8::Object::HasOwnProperty(), but it does not
-   * call interceptors.
-   *
-   * \note Consider using non-masking interceptors, i.e., the interceptors are
-   * not called if the receiver has the real named property. See
-   * `v8::PropertyHandlerFlags::kNonMasking`.
-   *
-   * See also v8::Object::Has().
-   */
-  V8_WARN_UNUSED_RESULT Maybe<bool> HasRealNamedProperty(Local<Context> context,
-                                                         Local<Name> key);
-  V8_DEPRECATE_SOON("Use maybe version",
-                    bool HasRealIndexedProperty(uint32_t index));
-  V8_WARN_UNUSED_RESULT Maybe<bool> HasRealIndexedProperty(
-      Local<Context> context, uint32_t index);
-  V8_DEPRECATE_SOON("Use maybe version",
-                    bool HasRealNamedCallbackProperty(Local<String> key));
-  V8_WARN_UNUSED_RESULT Maybe<bool> HasRealNamedCallbackProperty(
-      Local<Context> context, Local<Name> key);
-
-  /**
-   * If result.IsEmpty() no real property was located in the prototype chain.
-   * This means interceptors in the prototype chain are not called.
-   */
-  V8_DEPRECATED(
-      "Use maybe version",
-      Local<Value> GetRealNamedPropertyInPrototypeChain(Local<String> key));
-  V8_WARN_UNUSED_RESULT MaybeLocal<Value> GetRealNamedPropertyInPrototypeChain(
-      Local<Context> context, Local<Name> key);
-
-  /**
-   * Gets the property attributes of a real property in the prototype chain,
-   * which can be None or any combination of ReadOnly, DontEnum and DontDelete.
-   * Interceptors in the prototype chain are not called.
-   */
-  V8_DEPRECATED(
-      "Use maybe version",
-      Maybe<PropertyAttribute> GetRealNamedPropertyAttributesInPrototypeChain(
-          Local<String> key));
-  V8_WARN_UNUSED_RESULT Maybe<PropertyAttribute>
-  GetRealNamedPropertyAttributesInPrototypeChain(Local<Context> context,
-                                                 Local<Name> key);
-
-  /**
-   * If result.IsEmpty() no real property was located on the object or
-   * in the prototype chain.
-   * This means interceptors in the prototype chain are not called.
-   */
-  V8_DEPRECATED("Use maybe version",
-                Local<Value> GetRealNamedProperty(Local<String> key));
-  V8_WARN_UNUSED_RESULT MaybeLocal<Value> GetRealNamedProperty(
-      Local<Context> context, Local<Name> key);
-
-  /**
-   * Gets the property attributes of a real property which can be
-   * None or any combination of ReadOnly, DontEnum and DontDelete.
-   * Interceptors in the prototype chain are not called.
-   */
-  V8_DEPRECATED("Use maybe version",
-                Maybe<PropertyAttribute> GetRealNamedPropertyAttributes(
-                    Local<String> key));
-  V8_WARN_UNUSED_RESULT Maybe<PropertyAttribute> GetRealNamedPropertyAttributes(
-      Local<Context> context, Local<Name> key);
-
-  /** Tests for a named lookup interceptor.*/
-  bool HasNamedLookupInterceptor();
-
-  /** Tests for an index lookup interceptor.*/
-  bool HasIndexedLookupInterceptor();
-
-  /**
-   * Returns the identity hash for this object. The current implementation
-   * uses a hidden property on the object to store the identity hash.
-   *
-   * The return value will never be 0. Also, it is not guaranteed to be
-   * unique.
-   */
-  int GetIdentityHash();
-
-  /**
-   * Clone this object with a fast but shallow copy.  Values will point
-   * to the same values as the original object.
-   */
-  // TODO(dcarney): take an isolate and optionally bail out?
-  Local<Object> Clone();
-
-  /**
-   * Returns the context in which the object was created.
-   */
-  Local<Context> CreationContext();
-
-  /** Same as above, but works for Persistents */
-  V8_INLINE static Local<Context> CreationContext(
-      const PersistentBase<Object>& object) {
-    return object.val_->CreationContext();
-  }
-
-  /**
-   * Checks whether a callback is set by the
-   * ObjectTemplate::SetCallAsFunctionHandler method.
-   * When an Object is callable this method returns true.
-   */
-  bool IsCallable();
-
-  /**
-   * True if this object is a constructor.
-   */
-  bool IsConstructor();
-
-  /**
-   * Call an Object as a function if a callback is set by the
-   * ObjectTemplate::SetCallAsFunctionHandler method.
-   */
-  V8_DEPRECATED("Use maybe version",
-                Local<Value> CallAsFunction(Local<Value> recv, int argc,
-                                            Local<Value> argv[]));
-  V8_WARN_UNUSED_RESULT MaybeLocal<Value> CallAsFunction(Local<Context> context,
-                                                         Local<Value> recv,
-                                                         int argc,
-                                                         Local<Value> argv[]);
-
-  /**
-   * Call an Object as a constructor if a callback is set by the
-   * ObjectTemplate::SetCallAsFunctionHandler method.
-   * Note: This method behaves like the Function::NewInstance method.
-   */
-  V8_DEPRECATED("Use maybe version",
-                Local<Value> CallAsConstructor(int argc, Local<Value> argv[]));
-  V8_WARN_UNUSED_RESULT MaybeLocal<Value> CallAsConstructor(
-      Local<Context> context, int argc, Local<Value> argv[]);
-
-  /**
-   * Return the isolate to which the Object belongs to.
-   */
-  V8_DEPRECATE_SOON("Keep track of isolate correctly", Isolate* GetIsolate());
-
-  static Local<Object> New(Isolate* isolate);
-
-  V8_INLINE static Object* Cast(Value* obj);
-
- private:
-  Object();
-  static void CheckCast(Value* obj);
-  Local<Value> SlowGetInternalField(int index);
-  void* SlowGetAlignedPointerFromInternalField(int index);
-};
-
-
-/**
- * An instance of the built-in array constructor (ECMA-262, 15.4.2).
- */
-class V8_EXPORT Array : public Object {
- public:
-  uint32_t Length() const;
-
-  /**
-   * Clones an element at index |index|.  Returns an empty
-   * handle if cloning fails (for any reason).
-   */
-  V8_DEPRECATED("Cloning is not supported.",
-                Local<Object> CloneElementAt(uint32_t index));
-  V8_DEPRECATED("Cloning is not supported.",
-                MaybeLocal<Object> CloneElementAt(Local<Context> context,
-                                                  uint32_t index));
-
-  /**
-   * Creates a JavaScript array with the given length. If the length
-   * is negative the returned array will have length 0.
-   */
-  static Local<Array> New(Isolate* isolate, int length = 0);
-
-  V8_INLINE static Array* Cast(Value* obj);
- private:
-  Array();
-  static void CheckCast(Value* obj);
-};
-
-
-/**
- * An instance of the built-in Map constructor (ECMA-262, 6th Edition, 23.1.1).
- */
-class V8_EXPORT Map : public Object {
- public:
-  size_t Size() const;
-  void Clear();
-  V8_WARN_UNUSED_RESULT MaybeLocal<Value> Get(Local<Context> context,
-                                              Local<Value> key);
-  V8_WARN_UNUSED_RESULT MaybeLocal<Map> Set(Local<Context> context,
-                                            Local<Value> key,
-                                            Local<Value> value);
-  V8_WARN_UNUSED_RESULT Maybe<bool> Has(Local<Context> context,
-                                        Local<Value> key);
-  V8_WARN_UNUSED_RESULT Maybe<bool> Delete(Local<Context> context,
-                                           Local<Value> key);
-
-  /**
-   * Returns an array of length Size() * 2, where index N is the Nth key and
-   * index N + 1 is the Nth value.
-   */
-  Local<Array> AsArray() const;
-
-  /**
-   * Creates a new empty Map.
-   */
-  static Local<Map> New(Isolate* isolate);
-
-  V8_INLINE static Map* Cast(Value* obj);
-
- private:
-  Map();
-  static void CheckCast(Value* obj);
-};
-
-
-/**
- * An instance of the built-in Set constructor (ECMA-262, 6th Edition, 23.2.1).
- */
-class V8_EXPORT Set : public Object {
- public:
-  size_t Size() const;
-  void Clear();
-  V8_WARN_UNUSED_RESULT MaybeLocal<Set> Add(Local<Context> context,
-                                            Local<Value> key);
-  V8_WARN_UNUSED_RESULT Maybe<bool> Has(Local<Context> context,
-                                        Local<Value> key);
-  V8_WARN_UNUSED_RESULT Maybe<bool> Delete(Local<Context> context,
-                                           Local<Value> key);
-
-  /**
-   * Returns an array of the keys in this Set.
-   */
-  Local<Array> AsArray() const;
-
-  /**
-   * Creates a new empty Set.
-   */
-  static Local<Set> New(Isolate* isolate);
-
-  V8_INLINE static Set* Cast(Value* obj);
-
- private:
-  Set();
-  static void CheckCast(Value* obj);
-};
-
-
-template<typename T>
-class ReturnValue {
- public:
-  template <class S> V8_INLINE ReturnValue(const ReturnValue<S>& that)
-      : value_(that.value_) {
-    TYPE_CHECK(T, S);
-  }
-  // Local setters
-  template <typename S>
-  V8_INLINE V8_DEPRECATE_SOON("Use Global<> instead",
-                              void Set(const Persistent<S>& handle));
-  template <typename S>
-  V8_INLINE void Set(const Global<S>& handle);
-  template <typename S>
-  V8_INLINE void Set(const Local<S> handle);
-  // Fast primitive setters
-  V8_INLINE void Set(bool value);
-  V8_INLINE void Set(double i);
-  V8_INLINE void Set(int32_t i);
-  V8_INLINE void Set(uint32_t i);
-  // Fast JS primitive setters
-  V8_INLINE void SetNull();
-  V8_INLINE void SetUndefined();
-  V8_INLINE void SetEmptyString();
-  // Convenience getter for Isolate
-  V8_INLINE Isolate* GetIsolate() const;
-
-  // Pointer setter: Uncompilable to prevent inadvertent misuse.
-  template <typename S>
-  V8_INLINE void Set(S* whatever);
-
-  // Getter. Creates a new Local<> so it comes with a certain performance
-  // hit. If the ReturnValue was not yet set, this will return the undefined
-  // value.
-  V8_INLINE Local<Value> Get() const;
-
- private:
-  template<class F> friend class ReturnValue;
-  template<class F> friend class FunctionCallbackInfo;
-  template<class F> friend class PropertyCallbackInfo;
-  template <class F, class G, class H>
-  friend class PersistentValueMapBase;
-  V8_INLINE void SetInternal(internal::Object* value) { *value_ = value; }
-  V8_INLINE internal::Object* GetDefaultValue();
-  V8_INLINE explicit ReturnValue(internal::Object** slot);
-  internal::Object** value_;
-};
-
-
-/**
- * The argument information given to function call callbacks.  This
- * class provides access to information about the context of the call,
- * including the receiver, the number and values of arguments, and
- * the holder of the function.
- */
-template<typename T>
-class FunctionCallbackInfo {
- public:
-  V8_INLINE int Length() const;
-  V8_INLINE Local<Value> operator[](int i) const;
-  V8_INLINE V8_DEPRECATED("Use Data() to explicitly pass Callee instead",
-                          Local<Function> Callee() const);
-  V8_INLINE Local<Object> This() const;
-  V8_INLINE Local<Object> Holder() const;
-  V8_INLINE Local<Value> NewTarget() const;
-  V8_INLINE bool IsConstructCall() const;
-  V8_INLINE Local<Value> Data() const;
-  V8_INLINE Isolate* GetIsolate() const;
-  V8_INLINE ReturnValue<T> GetReturnValue() const;
-  // This shouldn't be public, but the arm compiler needs it.
-  static const int kArgsLength = 8;
-
- protected:
-  friend class internal::FunctionCallbackArguments;
-  friend class internal::CustomArguments<FunctionCallbackInfo>;
-  static const int kHolderIndex = 0;
-  static const int kIsolateIndex = 1;
-  static const int kReturnValueDefaultValueIndex = 2;
-  static const int kReturnValueIndex = 3;
-  static const int kDataIndex = 4;
-  static const int kCalleeIndex = 5;
-  static const int kContextSaveIndex = 6;
-  static const int kNewTargetIndex = 7;
-
-  V8_INLINE FunctionCallbackInfo(internal::Object** implicit_args,
-                                 internal::Object** values, int length);
-  internal::Object** implicit_args_;
-  internal::Object** values_;
-  int length_;
-};
-
-
-/**
- * The information passed to a property callback about the context
- * of the property access.
- */
-template<typename T>
-class PropertyCallbackInfo {
- public:
-  /**
-   * \return The isolate of the property access.
-   */
-  V8_INLINE Isolate* GetIsolate() const;
-
-  /**
-   * \return The data set in the configuration, i.e., in
-   * `NamedPropertyHandlerConfiguration` or
-   * `IndexedPropertyHandlerConfiguration.`
-   */
-  V8_INLINE Local<Value> Data() const;
-
-  /**
-   * \return The receiver. In many cases, this is the object on which the
-   * property access was intercepted. When using
-   * `Reflect.get`, `Function.prototype.call`, or similar functions, it is the
-   * object passed in as receiver or thisArg.
-   *
-   * \code
-   *  void GetterCallback(Local<Name> name,
-   *                      const v8::PropertyCallbackInfo<v8::Value>& info) {
-   *     auto context = info.GetIsolate()->GetCurrentContext();
-   *
-   *     v8::Local<v8::Value> a_this =
-   *         info.This()
-   *             ->GetRealNamedProperty(context, v8_str("a"))
-   *             .ToLocalChecked();
-   *     v8::Local<v8::Value> a_holder =
-   *         info.Holder()
-   *             ->GetRealNamedProperty(context, v8_str("a"))
-   *             .ToLocalChecked();
-   *
-   *    CHECK(v8_str("r")->Equals(context, a_this).FromJust());
-   *    CHECK(v8_str("obj")->Equals(context, a_holder).FromJust());
-   *
-   *    info.GetReturnValue().Set(name);
-   *  }
-   *
-   *  v8::Local<v8::FunctionTemplate> templ =
-   *  v8::FunctionTemplate::New(isolate);
-   *  templ->InstanceTemplate()->SetHandler(
-   *      v8::NamedPropertyHandlerConfiguration(GetterCallback));
-   *  LocalContext env;
-   *  env->Global()
-   *      ->Set(env.local(), v8_str("obj"), templ->GetFunction(env.local())
-   *                                           .ToLocalChecked()
-   *                                           ->NewInstance(env.local())
-   *                                           .ToLocalChecked())
-   *      .FromJust();
-   *
-   *  CompileRun("obj.a = 'obj'; var r = {a: 'r'}; Reflect.get(obj, 'x', r)");
-   * \endcode
-   */
-  V8_INLINE Local<Object> This() const;
-
-  /**
-   * \return The object in the prototype chain of the receiver that has the
-   * interceptor. Suppose you have `x` and its prototype is `y`, and `y`
-   * has an interceptor. Then `info.This()` is `x` and `info.Holder()` is `y`.
-   * The Holder() could be a hidden object (the global object, rather
-   * than the global proxy).
-   *
-   * \note For security reasons, do not pass the object back into the runtime.
-   */
-  V8_INLINE Local<Object> Holder() const;
-
-  /**
-   * \return The return value of the callback.
-   * Can be changed by calling Set().
-   * \code
-   * info.GetReturnValue().Set(...)
-   * \endcode
-   *
-   */
-  V8_INLINE ReturnValue<T> GetReturnValue() const;
-
-  /**
-   * \return True if the intercepted function should throw if an error occurs.
-   * Usually, `true` corresponds to `'use strict'`.
-   *
-   * \note Always `false` when intercepting `Reflect.set()`
-   * independent of the language mode.
-   */
-  V8_INLINE bool ShouldThrowOnError() const;
-
-  // This shouldn't be public, but the arm compiler needs it.
-  static const int kArgsLength = 7;
-
- protected:
-  friend class MacroAssembler;
-  friend class internal::PropertyCallbackArguments;
-  friend class internal::CustomArguments<PropertyCallbackInfo>;
-  static const int kShouldThrowOnErrorIndex = 0;
-  static const int kHolderIndex = 1;
-  static const int kIsolateIndex = 2;
-  static const int kReturnValueDefaultValueIndex = 3;
-  static const int kReturnValueIndex = 4;
-  static const int kDataIndex = 5;
-  static const int kThisIndex = 6;
-
-  V8_INLINE PropertyCallbackInfo(internal::Object** args) : args_(args) {}
-  internal::Object** args_;
-};
-
-
-typedef void (*FunctionCallback)(const FunctionCallbackInfo<Value>& info);
-
-enum class ConstructorBehavior { kThrow, kAllow };
-
-/**
- * A JavaScript function object (ECMA-262, 15.3).
- */
-class V8_EXPORT Function : public Object {
- public:
-  /**
-   * Create a function in the current execution context
-   * for a given FunctionCallback.
-   */
-  static MaybeLocal<Function> New(
-      Local<Context> context, FunctionCallback callback,
-      Local<Value> data = Local<Value>(), int length = 0,
-      ConstructorBehavior behavior = ConstructorBehavior::kAllow);
-  static V8_DEPRECATE_SOON(
-      "Use maybe version",
-      Local<Function> New(Isolate* isolate, FunctionCallback callback,
-                          Local<Value> data = Local<Value>(), int length = 0));
-
-  V8_DEPRECATED("Use maybe version",
-                Local<Object> NewInstance(int argc, Local<Value> argv[]) const);
-  V8_WARN_UNUSED_RESULT MaybeLocal<Object> NewInstance(
-      Local<Context> context, int argc, Local<Value> argv[]) const;
-
-  V8_DEPRECATED("Use maybe version", Local<Object> NewInstance() const);
-  V8_WARN_UNUSED_RESULT MaybeLocal<Object> NewInstance(
-      Local<Context> context) const {
-    return NewInstance(context, 0, nullptr);
-  }
-
-  V8_DEPRECATE_SOON("Use maybe version",
-                    Local<Value> Call(Local<Value> recv, int argc,
-                                      Local<Value> argv[]));
-  V8_WARN_UNUSED_RESULT MaybeLocal<Value> Call(Local<Context> context,
-                                               Local<Value> recv, int argc,
-                                               Local<Value> argv[]);
-
-  void SetName(Local<String> name);
-  Local<Value> GetName() const;
-
-  /**
-   * Name inferred from variable or property assignment of this function.
-   * Used to facilitate debugging and profiling of JavaScript code written
-   * in an OO style, where many functions are anonymous but are assigned
-   * to object properties.
-   */
-  Local<Value> GetInferredName() const;
-
-  /**
-   * displayName if it is set, otherwise name if it is configured, otherwise
-   * function name, otherwise inferred name.
-   */
-  Local<Value> GetDebugName() const;
-
-  /**
-   * User-defined name assigned to the "displayName" property of this function.
-   * Used to facilitate debugging and profiling of JavaScript code.
-   */
-  Local<Value> GetDisplayName() const;
-
-  /**
-   * Returns zero based line number of function body and
-   * kLineOffsetNotFound if no information available.
-   */
-  int GetScriptLineNumber() const;
-  /**
-   * Returns zero based column number of function body and
-   * kLineOffsetNotFound if no information available.
-   */
-  int GetScriptColumnNumber() const;
-
-  /**
-   * Tells whether this function is builtin.
-   */
-  V8_DEPRECATED("this should no longer be used.", bool IsBuiltin() const);
-
-  /**
-   * Returns scriptId.
-   */
-  int ScriptId() const;
-
-  /**
-   * Returns the original function if this function is bound, else returns
-   * v8::Undefined.
-   */
-  Local<Value> GetBoundFunction() const;
-
-  ScriptOrigin GetScriptOrigin() const;
-  V8_INLINE static Function* Cast(Value* obj);
-  static const int kLineOffsetNotFound;
-
- private:
-  Function();
-  static void CheckCast(Value* obj);
-};
-
-
-/**
- * An instance of the built-in Promise constructor (ES6 draft).
- */
-class V8_EXPORT Promise : public Object {
- public:
-  /**
-   * State of the promise. Each value corresponds to one of the possible values
-   * of the [[PromiseState]] field.
-   */
-  enum PromiseState { kPending, kFulfilled, kRejected };
-
-  class V8_EXPORT Resolver : public Object {
-   public:
-    /**
-     * Create a new resolver, along with an associated promise in pending state.
-     */
-    static V8_DEPRECATE_SOON("Use maybe version",
-                             Local<Resolver> New(Isolate* isolate));
-    static V8_WARN_UNUSED_RESULT MaybeLocal<Resolver> New(
-        Local<Context> context);
-
-    /**
-     * Extract the associated promise.
-     */
-    Local<Promise> GetPromise();
-
-    /**
-     * Resolve/reject the associated promise with a given value.
-     * Ignored if the promise is no longer pending.
-     */
-    V8_DEPRECATE_SOON("Use maybe version", void Resolve(Local<Value> value));
-    // TODO(dcarney): mark V8_WARN_UNUSED_RESULT
-    Maybe<bool> Resolve(Local<Context> context, Local<Value> value);
-
-    V8_DEPRECATE_SOON("Use maybe version", void Reject(Local<Value> value));
-    // TODO(dcarney): mark V8_WARN_UNUSED_RESULT
-    Maybe<bool> Reject(Local<Context> context, Local<Value> value);
-
-    V8_INLINE static Resolver* Cast(Value* obj);
-
-   private:
-    Resolver();
-    static void CheckCast(Value* obj);
-  };
-
-  /**
-   * Register a resolution/rejection handler with a promise.
-   * The handler is given the respective resolution/rejection value as
-   * an argument. If the promise is already resolved/rejected, the handler is
-   * invoked at the end of turn.
-   */
-  V8_DEPRECATED("Use maybe version",
-                Local<Promise> Catch(Local<Function> handler));
-  V8_WARN_UNUSED_RESULT MaybeLocal<Promise> Catch(Local<Context> context,
-                                                  Local<Function> handler);
-
-  V8_DEPRECATED("Use maybe version",
-                Local<Promise> Then(Local<Function> handler));
-  V8_WARN_UNUSED_RESULT MaybeLocal<Promise> Then(Local<Context> context,
-                                                 Local<Function> handler);
-
-  /**
-   * Returns true if the promise has at least one derived promise, and
-   * therefore resolve/reject handlers (including default handler).
-   */
-  bool HasHandler();
-
-  /**
-   * Returns the content of the [[PromiseResult]] field. The Promise must not
-   * be pending.
-   */
-  Local<Value> Result();
-
-  /**
-   * Returns the value of the [[PromiseState]] field.
-   */
-  PromiseState State();
-
-  V8_INLINE static Promise* Cast(Value* obj);
-
- private:
-  Promise();
-  static void CheckCast(Value* obj);
-};
-
-/**
- * An instance of a Property Descriptor, see Ecma-262 6.2.4.
- *
- * Properties in a descriptor are present or absent. If you do not set
- * `enumerable`, `configurable`, and `writable`, they are absent. If `value`,
- * `get`, or `set` are absent, but you must specify them in the constructor, use
- * empty handles.
- *
- * Accessors `get` and `set` must be callable or undefined if they are present.
- *
- * \note Only query properties if they are present, i.e., call `x()` only if
- * `has_x()` returns true.
- *
- * \code
- * // var desc = {writable: false}
- * v8::PropertyDescriptor d(Local<Value>()), false);
- * d.value(); // error, value not set
- * if (d.has_writable()) {
- *   d.writable(); // false
- * }
- *
- * // var desc = {value: undefined}
- * v8::PropertyDescriptor d(v8::Undefined(isolate));
- *
- * // var desc = {get: undefined}
- * v8::PropertyDescriptor d(v8::Undefined(isolate), Local<Value>()));
- * \endcode
- */
-class V8_EXPORT PropertyDescriptor {
- public:
-  // GenericDescriptor
-  PropertyDescriptor();
-
-  // DataDescriptor
-  PropertyDescriptor(Local<Value> value);
-
-  // DataDescriptor with writable property
-  PropertyDescriptor(Local<Value> value, bool writable);
-
-  // AccessorDescriptor
-  PropertyDescriptor(Local<Value> get, Local<Value> set);
-
-  ~PropertyDescriptor();
-
-  Local<Value> value() const;
-  bool has_value() const;
-
-  Local<Value> get() const;
-  bool has_get() const;
-  Local<Value> set() const;
-  bool has_set() const;
-
-  void set_enumerable(bool enumerable);
-  bool enumerable() const;
-  bool has_enumerable() const;
-
-  void set_configurable(bool configurable);
-  bool configurable() const;
-  bool has_configurable() const;
-
-  bool writable() const;
-  bool has_writable() const;
-
-  struct PrivateData;
-  PrivateData* get_private() const { return private_; }
-
-  PropertyDescriptor(const PropertyDescriptor&) = delete;
-  void operator=(const PropertyDescriptor&) = delete;
-
- private:
-  PrivateData* private_;
-};
-
-/**
- * An instance of the built-in Proxy constructor (ECMA-262, 6th Edition,
- * 26.2.1).
- */
-class V8_EXPORT Proxy : public Object {
- public:
-  Local<Object> GetTarget();
-  Local<Value> GetHandler();
-  bool IsRevoked();
-  void Revoke();
-
-  /**
-   * Creates a new Proxy for the target object.
-   */
-  static MaybeLocal<Proxy> New(Local<Context> context,
-                               Local<Object> local_target,
-                               Local<Object> local_handler);
-
-  V8_INLINE static Proxy* Cast(Value* obj);
-
- private:
-  Proxy();
-  static void CheckCast(Value* obj);
-};
-
-class V8_EXPORT WasmCompiledModule : public Object {
- public:
-  typedef std::pair<std::unique_ptr<const uint8_t[]>, size_t> SerializedModule;
-  // A buffer that is owned by the caller.
-  typedef std::pair<const uint8_t*, size_t> CallerOwnedBuffer;
-  // Get the wasm-encoded bytes that were used to compile this module.
-  Local<String> GetWasmWireBytes();
-
-  // Serialize the compiled module. The serialized data does not include the
-  // uncompiled bytes.
-  SerializedModule Serialize();
-
-  // If possible, deserialize the module, otherwise compile it from the provided
-  // uncompiled bytes.
-  static MaybeLocal<WasmCompiledModule> DeserializeOrCompile(
-      Isolate* isolate, const CallerOwnedBuffer& serialized_module,
-      const CallerOwnedBuffer& wire_bytes);
-  V8_INLINE static WasmCompiledModule* Cast(Value* obj);
-
- private:
-  static MaybeLocal<WasmCompiledModule> Deserialize(
-      Isolate* isolate, const CallerOwnedBuffer& serialized_module,
-      const CallerOwnedBuffer& wire_bytes);
-  static MaybeLocal<WasmCompiledModule> Compile(Isolate* isolate,
-                                                const uint8_t* start,
-                                                size_t length);
-  WasmCompiledModule();
-  static void CheckCast(Value* obj);
-};
-
-#ifndef V8_ARRAY_BUFFER_INTERNAL_FIELD_COUNT
-// The number of required internal fields can be defined by embedder.
-#define V8_ARRAY_BUFFER_INTERNAL_FIELD_COUNT 2
-#endif
-
-
-enum class ArrayBufferCreationMode { kInternalized, kExternalized };
-
-
-/**
- * An instance of the built-in ArrayBuffer constructor (ES6 draft 15.13.5).
- */
-class V8_EXPORT ArrayBuffer : public Object {
- public:
-  /**
-   * A thread-safe allocator that V8 uses to allocate |ArrayBuffer|'s memory.
-   * The allocator is a global V8 setting. It has to be set via
-   * Isolate::CreateParams.
-   *
-   * Memory allocated through this allocator by V8 is accounted for as external
-   * memory by V8. Note that V8 keeps track of the memory for all internalized
-   * |ArrayBuffer|s. Responsibility for tracking external memory (using
-   * Isolate::AdjustAmountOfExternalAllocatedMemory) is handed over to the
-   * embedder upon externalization and taken over upon internalization (creating
-   * an internalized buffer from an existing buffer).
-   *
-   * Note that it is unsafe to call back into V8 from any of the allocator
-   * functions.
-   */
-  class V8_EXPORT Allocator { // NOLINT
-   public:
-    virtual ~Allocator() {}
-
-    /**
-     * Allocate |length| bytes. Return NULL if allocation is not successful.
-     * Memory should be initialized to zeroes.
-     */
-    virtual void* Allocate(size_t length) = 0;
-
-    /**
-     * Allocate |length| bytes. Return NULL if allocation is not successful.
-     * Memory does not have to be initialized.
-     */
-    virtual void* AllocateUninitialized(size_t length) = 0;
-
-    /**
-     * Free the memory block of size |length|, pointed to by |data|.
-     * That memory is guaranteed to be previously allocated by |Allocate|.
-     */
-    virtual void Free(void* data, size_t length) = 0;
-
-    /**
-     * malloc/free based convenience allocator.
-     *
-     * Caller takes ownership.
-     */
-    static Allocator* NewDefaultAllocator();
-  };
-
-  /**
-   * The contents of an |ArrayBuffer|. Externalization of |ArrayBuffer|
-   * returns an instance of this class, populated, with a pointer to data
-   * and byte length.
-   *
-   * The Data pointer of ArrayBuffer::Contents is always allocated with
-   * Allocator::Allocate that is set via Isolate::CreateParams.
-   */
-  class V8_EXPORT Contents { // NOLINT
-   public:
-    Contents() : data_(NULL), byte_length_(0) {}
-
-    void* Data() const { return data_; }
-    size_t ByteLength() const { return byte_length_; }
-
-   private:
-    void* data_;
-    size_t byte_length_;
-
-    friend class ArrayBuffer;
-  };
-
-
-  /**
-   * Data length in bytes.
-   */
-  size_t ByteLength() const;
-
-  /**
-   * Create a new ArrayBuffer. Allocate |byte_length| bytes.
-   * Allocated memory will be owned by a created ArrayBuffer and
-   * will be deallocated when it is garbage-collected,
-   * unless the object is externalized.
-   */
-  static Local<ArrayBuffer> New(Isolate* isolate, size_t byte_length);
-
-  /**
-   * Create a new ArrayBuffer over an existing memory block.
-   * The created array buffer is by default immediately in externalized state.
-   * The memory block will not be reclaimed when a created ArrayBuffer
-   * is garbage-collected.
-   */
-  static Local<ArrayBuffer> New(
-      Isolate* isolate, void* data, size_t byte_length,
-      ArrayBufferCreationMode mode = ArrayBufferCreationMode::kExternalized);
-
-  /**
-   * Returns true if ArrayBuffer is externalized, that is, does not
-   * own its memory block.
-   */
-  bool IsExternal() const;
-
-  /**
-   * Returns true if this ArrayBuffer may be neutered.
-   */
-  bool IsNeuterable() const;
-
-  /**
-   * Neuters this ArrayBuffer and all its views (typed arrays).
-   * Neutering sets the byte length of the buffer and all typed arrays to zero,
-   * preventing JavaScript from ever accessing underlying backing store.
-   * ArrayBuffer should have been externalized and must be neuterable.
-   */
-  void Neuter();
-
-  /**
-   * Make this ArrayBuffer external. The pointer to underlying memory block
-   * and byte length are returned as |Contents| structure. After ArrayBuffer
-   * had been externalized, it does no longer own the memory block. The caller
-   * should take steps to free memory when it is no longer needed.
-   *
-   * The memory block is guaranteed to be allocated with |Allocator::Allocate|
-   * that has been set via Isolate::CreateParams.
-   */
-  Contents Externalize();
-
-  /**
-   * Get a pointer to the ArrayBuffer's underlying memory block without
-   * externalizing it. If the ArrayBuffer is not externalized, this pointer
-   * will become invalid as soon as the ArrayBuffer gets garbage collected.
-   *
-   * The embedder should make sure to hold a strong reference to the
-   * ArrayBuffer while accessing this pointer.
-   *
-   * The memory block is guaranteed to be allocated with |Allocator::Allocate|.
-   */
-  Contents GetContents();
-
-  V8_INLINE static ArrayBuffer* Cast(Value* obj);
-
-  static const int kInternalFieldCount = V8_ARRAY_BUFFER_INTERNAL_FIELD_COUNT;
-
- private:
-  ArrayBuffer();
-  static void CheckCast(Value* obj);
-};
-
-
-#ifndef V8_ARRAY_BUFFER_VIEW_INTERNAL_FIELD_COUNT
-// The number of required internal fields can be defined by embedder.
-#define V8_ARRAY_BUFFER_VIEW_INTERNAL_FIELD_COUNT 2
-#endif
-
-
-/**
- * A base class for an instance of one of "views" over ArrayBuffer,
- * including TypedArrays and DataView (ES6 draft 15.13).
- */
-class V8_EXPORT ArrayBufferView : public Object {
- public:
-  /**
-   * Returns underlying ArrayBuffer.
-   */
-  Local<ArrayBuffer> Buffer();
-  /**
-   * Byte offset in |Buffer|.
-   */
-  size_t ByteOffset();
-  /**
-   * Size of a view in bytes.
-   */
-  size_t ByteLength();
-
-  /**
-   * Copy the contents of the ArrayBufferView's buffer to an embedder defined
-   * memory without additional overhead that calling ArrayBufferView::Buffer
-   * might incur.
-   *
-   * Will write at most min(|byte_length|, ByteLength) bytes starting at
-   * ByteOffset of the underlying buffer to the memory starting at |dest|.
-   * Returns the number of bytes actually written.
-   */
-  size_t CopyContents(void* dest, size_t byte_length);
-
-  /**
-   * Returns true if ArrayBufferView's backing ArrayBuffer has already been
-   * allocated.
-   */
-  bool HasBuffer() const;
-
-  V8_INLINE static ArrayBufferView* Cast(Value* obj);
-
-  static const int kInternalFieldCount =
-      V8_ARRAY_BUFFER_VIEW_INTERNAL_FIELD_COUNT;
-
- private:
-  ArrayBufferView();
-  static void CheckCast(Value* obj);
-};
-
-
-/**
- * A base class for an instance of TypedArray series of constructors
- * (ES6 draft 15.13.6).
- */
-class V8_EXPORT TypedArray : public ArrayBufferView {
- public:
-  /**
-   * Number of elements in this typed array
-   * (e.g. for Int16Array, |ByteLength|/2).
-   */
-  size_t Length();
-
-  V8_INLINE static TypedArray* Cast(Value* obj);
-
- private:
-  TypedArray();
-  static void CheckCast(Value* obj);
-};
-
-
-/**
- * An instance of Uint8Array constructor (ES6 draft 15.13.6).
- */
-class V8_EXPORT Uint8Array : public TypedArray {
- public:
-  static Local<Uint8Array> New(Local<ArrayBuffer> array_buffer,
-                               size_t byte_offset, size_t length);
-  static Local<Uint8Array> New(Local<SharedArrayBuffer> shared_array_buffer,
-                               size_t byte_offset, size_t length);
-  V8_INLINE static Uint8Array* Cast(Value* obj);
-
- private:
-  Uint8Array();
-  static void CheckCast(Value* obj);
-};
-
-
-/**
- * An instance of Uint8ClampedArray constructor (ES6 draft 15.13.6).
- */
-class V8_EXPORT Uint8ClampedArray : public TypedArray {
- public:
-  static Local<Uint8ClampedArray> New(Local<ArrayBuffer> array_buffer,
-                                      size_t byte_offset, size_t length);
-  static Local<Uint8ClampedArray> New(
-      Local<SharedArrayBuffer> shared_array_buffer, size_t byte_offset,
-      size_t length);
-  V8_INLINE static Uint8ClampedArray* Cast(Value* obj);
-
- private:
-  Uint8ClampedArray();
-  static void CheckCast(Value* obj);
-};
-
-/**
- * An instance of Int8Array constructor (ES6 draft 15.13.6).
- */
-class V8_EXPORT Int8Array : public TypedArray {
- public:
-  static Local<Int8Array> New(Local<ArrayBuffer> array_buffer,
-                              size_t byte_offset, size_t length);
-  static Local<Int8Array> New(Local<SharedArrayBuffer> shared_array_buffer,
-                              size_t byte_offset, size_t length);
-  V8_INLINE static Int8Array* Cast(Value* obj);
-
- private:
-  Int8Array();
-  static void CheckCast(Value* obj);
-};
-
-
-/**
- * An instance of Uint16Array constructor (ES6 draft 15.13.6).
- */
-class V8_EXPORT Uint16Array : public TypedArray {
- public:
-  static Local<Uint16Array> New(Local<ArrayBuffer> array_buffer,
-                                size_t byte_offset, size_t length);
-  static Local<Uint16Array> New(Local<SharedArrayBuffer> shared_array_buffer,
-                                size_t byte_offset, size_t length);
-  V8_INLINE static Uint16Array* Cast(Value* obj);
-
- private:
-  Uint16Array();
-  static void CheckCast(Value* obj);
-};
-
-
-/**
- * An instance of Int16Array constructor (ES6 draft 15.13.6).
- */
-class V8_EXPORT Int16Array : public TypedArray {
- public:
-  static Local<Int16Array> New(Local<ArrayBuffer> array_buffer,
-                               size_t byte_offset, size_t length);
-  static Local<Int16Array> New(Local<SharedArrayBuffer> shared_array_buffer,
-                               size_t byte_offset, size_t length);
-  V8_INLINE static Int16Array* Cast(Value* obj);
-
- private:
-  Int16Array();
-  static void CheckCast(Value* obj);
-};
-
-
-/**
- * An instance of Uint32Array constructor (ES6 draft 15.13.6).
- */
-class V8_EXPORT Uint32Array : public TypedArray {
- public:
-  static Local<Uint32Array> New(Local<ArrayBuffer> array_buffer,
-                                size_t byte_offset, size_t length);
-  static Local<Uint32Array> New(Local<SharedArrayBuffer> shared_array_buffer,
-                                size_t byte_offset, size_t length);
-  V8_INLINE static Uint32Array* Cast(Value* obj);
-
- private:
-  Uint32Array();
-  static void CheckCast(Value* obj);
-};
-
-
-/**
- * An instance of Int32Array constructor (ES6 draft 15.13.6).
- */
-class V8_EXPORT Int32Array : public TypedArray {
- public:
-  static Local<Int32Array> New(Local<ArrayBuffer> array_buffer,
-                               size_t byte_offset, size_t length);
-  static Local<Int32Array> New(Local<SharedArrayBuffer> shared_array_buffer,
-                               size_t byte_offset, size_t length);
-  V8_INLINE static Int32Array* Cast(Value* obj);
-
- private:
-  Int32Array();
-  static void CheckCast(Value* obj);
-};
-
-
-/**
- * An instance of Float32Array constructor (ES6 draft 15.13.6).
- */
-class V8_EXPORT Float32Array : public TypedArray {
- public:
-  static Local<Float32Array> New(Local<ArrayBuffer> array_buffer,
-                                 size_t byte_offset, size_t length);
-  static Local<Float32Array> New(Local<SharedArrayBuffer> shared_array_buffer,
-                                 size_t byte_offset, size_t length);
-  V8_INLINE static Float32Array* Cast(Value* obj);
-
- private:
-  Float32Array();
-  static void CheckCast(Value* obj);
-};
-
-
-/**
- * An instance of Float64Array constructor (ES6 draft 15.13.6).
- */
-class V8_EXPORT Float64Array : public TypedArray {
- public:
-  static Local<Float64Array> New(Local<ArrayBuffer> array_buffer,
-                                 size_t byte_offset, size_t length);
-  static Local<Float64Array> New(Local<SharedArrayBuffer> shared_array_buffer,
-                                 size_t byte_offset, size_t length);
-  V8_INLINE static Float64Array* Cast(Value* obj);
-
- private:
-  Float64Array();
-  static void CheckCast(Value* obj);
-};
-
-
-/**
- * An instance of DataView constructor (ES6 draft 15.13.7).
- */
-class V8_EXPORT DataView : public ArrayBufferView {
- public:
-  static Local<DataView> New(Local<ArrayBuffer> array_buffer,
-                             size_t byte_offset, size_t length);
-  static Local<DataView> New(Local<SharedArrayBuffer> shared_array_buffer,
-                             size_t byte_offset, size_t length);
-  V8_INLINE static DataView* Cast(Value* obj);
-
- private:
-  DataView();
-  static void CheckCast(Value* obj);
-};
-
-
-/**
- * An instance of the built-in SharedArrayBuffer constructor.
- * This API is experimental and may change significantly.
- */
-class V8_EXPORT SharedArrayBuffer : public Object {
- public:
-  /**
-   * The contents of an |SharedArrayBuffer|. Externalization of
-   * |SharedArrayBuffer| returns an instance of this class, populated, with a
-   * pointer to data and byte length.
-   *
-   * The Data pointer of SharedArrayBuffer::Contents is always allocated with
-   * |ArrayBuffer::Allocator::Allocate| by the allocator specified in
-   * v8::Isolate::CreateParams::array_buffer_allocator.
-   *
-   * This API is experimental and may change significantly.
-   */
-  class V8_EXPORT Contents {  // NOLINT
-   public:
-    Contents() : data_(NULL), byte_length_(0) {}
-
-    void* Data() const { return data_; }
-    size_t ByteLength() const { return byte_length_; }
-
-   private:
-    void* data_;
-    size_t byte_length_;
-
-    friend class SharedArrayBuffer;
-  };
-
-
-  /**
-   * Data length in bytes.
-   */
-  size_t ByteLength() const;
-
-  /**
-   * Create a new SharedArrayBuffer. Allocate |byte_length| bytes.
-   * Allocated memory will be owned by a created SharedArrayBuffer and
-   * will be deallocated when it is garbage-collected,
-   * unless the object is externalized.
-   */
-  static Local<SharedArrayBuffer> New(Isolate* isolate, size_t byte_length);
-
-  /**
-   * Create a new SharedArrayBuffer over an existing memory block.  The created
-   * array buffer is immediately in externalized state unless otherwise
-   * specified. The memory block will not be reclaimed when a created
-   * SharedArrayBuffer is garbage-collected.
-   */
-  static Local<SharedArrayBuffer> New(
-      Isolate* isolate, void* data, size_t byte_length,
-      ArrayBufferCreationMode mode = ArrayBufferCreationMode::kExternalized);
-
-  /**
-   * Returns true if SharedArrayBuffer is externalized, that is, does not
-   * own its memory block.
-   */
-  bool IsExternal() const;
-
-  /**
-   * Make this SharedArrayBuffer external. The pointer to underlying memory
-   * block and byte length are returned as |Contents| structure. After
-   * SharedArrayBuffer had been externalized, it does no longer own the memory
-   * block. The caller should take steps to free memory when it is no longer
-   * needed.
-   *
-   * The memory block is guaranteed to be allocated with |Allocator::Allocate|
-   * by the allocator specified in
-   * v8::Isolate::CreateParams::array_buffer_allocator.
-   *
-   */
-  Contents Externalize();
-
-  /**
-   * Get a pointer to the ArrayBuffer's underlying memory block without
-   * externalizing it. If the ArrayBuffer is not externalized, this pointer
-   * will become invalid as soon as the ArrayBuffer became garbage collected.
-   *
-   * The embedder should make sure to hold a strong reference to the
-   * ArrayBuffer while accessing this pointer.
-   *
-   * The memory block is guaranteed to be allocated with |Allocator::Allocate|
-   * by the allocator specified in
-   * v8::Isolate::CreateParams::array_buffer_allocator.
-   */
-  Contents GetContents();
-
-  V8_INLINE static SharedArrayBuffer* Cast(Value* obj);
-
-  static const int kInternalFieldCount = V8_ARRAY_BUFFER_INTERNAL_FIELD_COUNT;
-
- private:
-  SharedArrayBuffer();
-  static void CheckCast(Value* obj);
-};
-
-
-/**
- * An instance of the built-in Date constructor (ECMA-262, 15.9).
- */
-class V8_EXPORT Date : public Object {
- public:
-  static V8_DEPRECATE_SOON("Use maybe version.",
-                           Local<Value> New(Isolate* isolate, double time));
-  static V8_WARN_UNUSED_RESULT MaybeLocal<Value> New(Local<Context> context,
-                                                     double time);
-
-  /**
-   * A specialization of Value::NumberValue that is more efficient
-   * because we know the structure of this object.
-   */
-  double ValueOf() const;
-
-  V8_INLINE static Date* Cast(Value* obj);
-
-  /**
-   * Notification that the embedder has changed the time zone,
-   * daylight savings time, or other date / time configuration
-   * parameters.  V8 keeps a cache of various values used for
-   * date / time computation.  This notification will reset
-   * those cached values for the current context so that date /
-   * time configuration changes would be reflected in the Date
-   * object.
-   *
-   * This API should not be called more than needed as it will
-   * negatively impact the performance of date operations.
-   */
-  static void DateTimeConfigurationChangeNotification(Isolate* isolate);
-
- private:
-  static void CheckCast(Value* obj);
-};
-
-
-/**
- * A Number object (ECMA-262, 4.3.21).
- */
-class V8_EXPORT NumberObject : public Object {
- public:
-  static Local<Value> New(Isolate* isolate, double value);
-
-  double ValueOf() const;
-
-  V8_INLINE static NumberObject* Cast(Value* obj);
-
- private:
-  static void CheckCast(Value* obj);
-};
-
-
-/**
- * A Boolean object (ECMA-262, 4.3.15).
- */
-class V8_EXPORT BooleanObject : public Object {
- public:
-  static Local<Value> New(Isolate* isolate, bool value);
-  V8_DEPRECATED("Pass an isolate", static Local<Value> New(bool value));
-
-  bool ValueOf() const;
-
-  V8_INLINE static BooleanObject* Cast(Value* obj);
-
- private:
-  static void CheckCast(Value* obj);
-};
-
-
-/**
- * A String object (ECMA-262, 4.3.18).
- */
-class V8_EXPORT StringObject : public Object {
- public:
-  static Local<Value> New(Local<String> value);
-
-  Local<String> ValueOf() const;
-
-  V8_INLINE static StringObject* Cast(Value* obj);
-
- private:
-  static void CheckCast(Value* obj);
-};
-
-
-/**
- * A Symbol object (ECMA-262 edition 6).
- */
-class V8_EXPORT SymbolObject : public Object {
- public:
-  static Local<Value> New(Isolate* isolate, Local<Symbol> value);
-
-  Local<Symbol> ValueOf() const;
-
-  V8_INLINE static SymbolObject* Cast(Value* obj);
-
- private:
-  static void CheckCast(Value* obj);
-};
-
-
-/**
- * An instance of the built-in RegExp constructor (ECMA-262, 15.10).
- */
-class V8_EXPORT RegExp : public Object {
- public:
-  /**
-   * Regular expression flag bits. They can be or'ed to enable a set
-   * of flags.
-   */
-  enum Flags {
-    kNone = 0,
-    kGlobal = 1,
-    kIgnoreCase = 2,
-    kMultiline = 4,
-    kSticky = 8,
-    kUnicode = 16
-  };
-
-  /**
-   * Creates a regular expression from the given pattern string and
-   * the flags bit field. May throw a JavaScript exception as
-   * described in ECMA-262, 15.10.4.1.
-   *
-   * For example,
-   *   RegExp::New(v8::String::New("foo"),
-   *               static_cast<RegExp::Flags>(kGlobal | kMultiline))
-   * is equivalent to evaluating "/foo/gm".
-   */
-  static V8_DEPRECATE_SOON("Use maybe version",
-                           Local<RegExp> New(Local<String> pattern,
-                                             Flags flags));
-  static V8_WARN_UNUSED_RESULT MaybeLocal<RegExp> New(Local<Context> context,
-                                                      Local<String> pattern,
-                                                      Flags flags);
-
-  /**
-   * Returns the value of the source property: a string representing
-   * the regular expression.
-   */
-  Local<String> GetSource() const;
-
-  /**
-   * Returns the flags bit field.
-   */
-  Flags GetFlags() const;
-
-  V8_INLINE static RegExp* Cast(Value* obj);
-
- private:
-  static void CheckCast(Value* obj);
-};
-
-
-/**
- * A JavaScript value that wraps a C++ void*. This type of value is mainly used
- * to associate C++ data structures with JavaScript objects.
- */
-class V8_EXPORT External : public Value {
- public:
-  static Local<External> New(Isolate* isolate, void* value);
-  V8_INLINE static External* Cast(Value* obj);
-  void* Value() const;
- private:
-  static void CheckCast(v8::Value* obj);
-};
-
-#define V8_INTRINSICS_LIST(F)                    \
-  F(ArrayProto_entries, array_entries_iterator)  \
-  F(ArrayProto_forEach, array_for_each_iterator) \
-  F(ArrayProto_keys, array_keys_iterator)        \
-  F(ArrayProto_values, array_values_iterator)
-
-enum Intrinsic {
-#define V8_DECL_INTRINSIC(name, iname) k##name,
-  V8_INTRINSICS_LIST(V8_DECL_INTRINSIC)
-#undef V8_DECL_INTRINSIC
-};
-
-
-// --- Templates ---
-
-
-/**
- * The superclass of object and function templates.
- */
-class V8_EXPORT Template : public Data {
- public:
-  /**
-   * Adds a property to each instance created by this template.
-   *
-   * The property must be defined either as a primitive value, or a template.
-   */
-  void Set(Local<Name> name, Local<Data> value,
-           PropertyAttribute attributes = None);
-  void SetPrivate(Local<Private> name, Local<Data> value,
-                  PropertyAttribute attributes = None);
-  V8_INLINE void Set(Isolate* isolate, const char* name, Local<Data> value);
-
-  void SetAccessorProperty(
-     Local<Name> name,
-     Local<FunctionTemplate> getter = Local<FunctionTemplate>(),
-     Local<FunctionTemplate> setter = Local<FunctionTemplate>(),
-     PropertyAttribute attribute = None,
-     AccessControl settings = DEFAULT);
-
-  /**
-   * Whenever the property with the given name is accessed on objects
-   * created from this Template the getter and setter callbacks
-   * are called instead of getting and setting the property directly
-   * on the JavaScript object.
-   *
-   * \param name The name of the property for which an accessor is added.
-   * \param getter The callback to invoke when getting the property.
-   * \param setter The callback to invoke when setting the property.
-   * \param data A piece of data that will be passed to the getter and setter
-   *   callbacks whenever they are invoked.
-   * \param settings Access control settings for the accessor. This is a bit
-   *   field consisting of one of more of
-   *   DEFAULT = 0, ALL_CAN_READ = 1, or ALL_CAN_WRITE = 2.
-   *   The default is to not allow cross-context access.
-   *   ALL_CAN_READ means that all cross-context reads are allowed.
-   *   ALL_CAN_WRITE means that all cross-context writes are allowed.
-   *   The combination ALL_CAN_READ | ALL_CAN_WRITE can be used to allow all
-   *   cross-context access.
-   * \param attribute The attributes of the property for which an accessor
-   *   is added.
-   * \param signature The signature describes valid receivers for the accessor
-   *   and is used to perform implicit instance checks against them. If the
-   *   receiver is incompatible (i.e. is not an instance of the constructor as
-   *   defined by FunctionTemplate::HasInstance()), an implicit TypeError is
-   *   thrown and no callback is invoked.
-   */
-  void SetNativeDataProperty(
-      Local<String> name, AccessorGetterCallback getter,
-      AccessorSetterCallback setter = 0,
-      // TODO(dcarney): gcc can't handle Local below
-      Local<Value> data = Local<Value>(), PropertyAttribute attribute = None,
-      Local<AccessorSignature> signature = Local<AccessorSignature>(),
-      AccessControl settings = DEFAULT);
-  void SetNativeDataProperty(
-      Local<Name> name, AccessorNameGetterCallback getter,
-      AccessorNameSetterCallback setter = 0,
-      // TODO(dcarney): gcc can't handle Local below
-      Local<Value> data = Local<Value>(), PropertyAttribute attribute = None,
-      Local<AccessorSignature> signature = Local<AccessorSignature>(),
-      AccessControl settings = DEFAULT);
-
-  /**
-   * Like SetNativeDataProperty, but V8 will replace the native data property
-   * with a real data property on first access.
-   */
-  void SetLazyDataProperty(Local<Name> name, AccessorNameGetterCallback getter,
-                           Local<Value> data = Local<Value>(),
-                           PropertyAttribute attribute = None);
-
-  /**
-   * During template instantiation, sets the value with the intrinsic property
-   * from the correct context.
-   */
-  void SetIntrinsicDataProperty(Local<Name> name, Intrinsic intrinsic,
-                                PropertyAttribute attribute = None);
-
- private:
-  Template();
-
-  friend class ObjectTemplate;
-  friend class FunctionTemplate;
-};
-
-
-/**
- * NamedProperty[Getter|Setter] are used as interceptors on object.
- * See ObjectTemplate::SetNamedPropertyHandler.
- */
-typedef void (*NamedPropertyGetterCallback)(
-    Local<String> property,
-    const PropertyCallbackInfo<Value>& info);
-
-
-/**
- * Returns the value if the setter intercepts the request.
- * Otherwise, returns an empty handle.
- */
-typedef void (*NamedPropertySetterCallback)(
-    Local<String> property,
-    Local<Value> value,
-    const PropertyCallbackInfo<Value>& info);
-
-
-/**
- * Returns a non-empty handle if the interceptor intercepts the request.
- * The result is an integer encoding property attributes (like v8::None,
- * v8::DontEnum, etc.)
- */
-typedef void (*NamedPropertyQueryCallback)(
-    Local<String> property,
-    const PropertyCallbackInfo<Integer>& info);
-
-
-/**
- * Returns a non-empty handle if the deleter intercepts the request.
- * The return value is true if the property could be deleted and false
- * otherwise.
- */
-typedef void (*NamedPropertyDeleterCallback)(
-    Local<String> property,
-    const PropertyCallbackInfo<Boolean>& info);
-
-
-/**
- * Returns an array containing the names of the properties the named
- * property getter intercepts.
- */
-typedef void (*NamedPropertyEnumeratorCallback)(
-    const PropertyCallbackInfo<Array>& info);
-
-
-// TODO(dcarney): Deprecate and remove previous typedefs, and replace
-// GenericNamedPropertyFooCallback with just NamedPropertyFooCallback.
-
-/**
- * Interceptor for get requests on an object.
- *
- * Use `info.GetReturnValue().Set()` to set the return value of the
- * intercepted get request.
- *
- * \param property The name of the property for which the request was
- * intercepted.
- * \param info Information about the intercepted request, such as
- * isolate, receiver, return value, or whether running in `'use strict`' mode.
- * See `PropertyCallbackInfo`.
- *
- * \code
- *  void GetterCallback(
- *    Local<Name> name,
- *    const v8::PropertyCallbackInfo<v8::Value>& info) {
- *      info.GetReturnValue().Set(v8_num(42));
- *  }
- *
- *  v8::Local<v8::FunctionTemplate> templ =
- *      v8::FunctionTemplate::New(isolate);
- *  templ->InstanceTemplate()->SetHandler(
- *      v8::NamedPropertyHandlerConfiguration(GetterCallback));
- *  LocalContext env;
- *  env->Global()
- *      ->Set(env.local(), v8_str("obj"), templ->GetFunction(env.local())
- *                                             .ToLocalChecked()
- *                                             ->NewInstance(env.local())
- *                                             .ToLocalChecked())
- *      .FromJust();
- *  v8::Local<v8::Value> result = CompileRun("obj.a = 17; obj.a");
- *  CHECK(v8_num(42)->Equals(env.local(), result).FromJust());
- * \endcode
- *
- * See also `ObjectTemplate::SetHandler`.
- */
-typedef void (*GenericNamedPropertyGetterCallback)(
-    Local<Name> property, const PropertyCallbackInfo<Value>& info);
-
-/**
- * Interceptor for set requests on an object.
- *
- * Use `info.GetReturnValue()` to indicate whether the request was intercepted
- * or not. If the setter successfully intercepts the request, i.e., if the
- * request should not be further executed, call
- * `info.GetReturnValue().Set(value)`. If the setter
- * did not intercept the request, i.e., if the request should be handled as
- * if no interceptor is present, do not not call `Set()`.
- *
- * \param property The name of the property for which the request was
- * intercepted.
- * \param value The value which the property will have if the request
- * is not intercepted.
- * \param info Information about the intercepted request, such as
- * isolate, receiver, return value, or whether running in `'use strict'` mode.
- * See `PropertyCallbackInfo`.
- *
- * See also
- * `ObjectTemplate::SetHandler.`
- */
-typedef void (*GenericNamedPropertySetterCallback)(
-    Local<Name> property, Local<Value> value,
-    const PropertyCallbackInfo<Value>& info);
-
-/**
- * Intercepts all requests that query the attributes of the
- * property, e.g., getOwnPropertyDescriptor(), propertyIsEnumerable(), and
- * defineProperty().
- *
- * Use `info.GetReturnValue().Set(value)` to set the property attributes. The
- * value is an interger encoding a `v8::PropertyAttribute`.
- *
- * \param property The name of the property for which the request was
- * intercepted.
- * \param info Information about the intercepted request, such as
- * isolate, receiver, return value, or whether running in `'use strict'` mode.
- * See `PropertyCallbackInfo`.
- *
- * \note Some functions query the property attributes internally, even though
- * they do not return the attributes. For example, `hasOwnProperty()` can
- * trigger this interceptor depending on the state of the object.
- *
- * See also
- * `ObjectTemplate::SetHandler.`
- */
-typedef void (*GenericNamedPropertyQueryCallback)(
-    Local<Name> property, const PropertyCallbackInfo<Integer>& info);
-
-/**
- * Interceptor for delete requests on an object.
- *
- * Use `info.GetReturnValue()` to indicate whether the request was intercepted
- * or not. If the deleter successfully intercepts the request, i.e., if the
- * request should not be further executed, call
- * `info.GetReturnValue().Set(value)` with a boolean `value`. The `value` is
- * used as the return value of `delete`.
- *
- * \param property The name of the property for which the request was
- * intercepted.
- * \param info Information about the intercepted request, such as
- * isolate, receiver, return value, or whether running in `'use strict'` mode.
- * See `PropertyCallbackInfo`.
- *
- * \note If you need to mimic the behavior of `delete`, i.e., throw in strict
- * mode instead of returning false, use `info.ShouldThrowOnError()` to determine
- * if you are in strict mode.
- *
- * See also `ObjectTemplate::SetHandler.`
- */
-typedef void (*GenericNamedPropertyDeleterCallback)(
-    Local<Name> property, const PropertyCallbackInfo<Boolean>& info);
-
-
-/**
- * Returns an array containing the names of the properties the named
- * property getter intercepts.
- */
-typedef void (*GenericNamedPropertyEnumeratorCallback)(
-    const PropertyCallbackInfo<Array>& info);
-
-/**
- * Interceptor for defineProperty requests on an object.
- *
- * Use `info.GetReturnValue()` to indicate whether the request was intercepted
- * or not. If the definer successfully intercepts the request, i.e., if the
- * request should not be further executed, call
- * `info.GetReturnValue().Set(value)`. If the definer
- * did not intercept the request, i.e., if the request should be handled as
- * if no interceptor is present, do not not call `Set()`.
- *
- * \param property The name of the property for which the request was
- * intercepted.
- * \param desc The property descriptor which is used to define the
- * property if the request is not intercepted.
- * \param info Information about the intercepted request, such as
- * isolate, receiver, return value, or whether running in `'use strict'` mode.
- * See `PropertyCallbackInfo`.
- *
- * See also `ObjectTemplate::SetHandler`.
- */
-typedef void (*GenericNamedPropertyDefinerCallback)(
-    Local<Name> property, const PropertyDescriptor& desc,
-    const PropertyCallbackInfo<Value>& info);
-
-/**
- * Interceptor for getOwnPropertyDescriptor requests on an object.
- *
- * Use `info.GetReturnValue().Set()` to set the return value of the
- * intercepted request. The return value must be an object that
- * can be converted to a PropertyDescriptor, e.g., a `v8::value` returned from
- * `v8::Object::getOwnPropertyDescriptor`.
- *
- * \param property The name of the property for which the request was
- * intercepted.
- * \info Information about the intercepted request, such as
- * isolate, receiver, return value, or whether running in `'use strict'` mode.
- * See `PropertyCallbackInfo`.
- *
- * \note If GetOwnPropertyDescriptor is intercepted, it will
- * always return true, i.e., indicate that the property was found.
- *
- * See also `ObjectTemplate::SetHandler`.
- */
-typedef void (*GenericNamedPropertyDescriptorCallback)(
-    Local<Name> property, const PropertyCallbackInfo<Value>& info);
-
-/**
- * See `v8::GenericNamedPropertyGetterCallback`.
- */
-typedef void (*IndexedPropertyGetterCallback)(
-    uint32_t index,
-    const PropertyCallbackInfo<Value>& info);
-
-/**
- * See `v8::GenericNamedPropertySetterCallback`.
- */
-typedef void (*IndexedPropertySetterCallback)(
-    uint32_t index,
-    Local<Value> value,
-    const PropertyCallbackInfo<Value>& info);
-
-/**
- * See `v8::GenericNamedPropertyQueryCallback`.
- */
-typedef void (*IndexedPropertyQueryCallback)(
-    uint32_t index,
-    const PropertyCallbackInfo<Integer>& info);
-
-/**
- * See `v8::GenericNamedPropertyDeleterCallback`.
- */
-typedef void (*IndexedPropertyDeleterCallback)(
-    uint32_t index,
-    const PropertyCallbackInfo<Boolean>& info);
-
-/**
- * See `v8::GenericNamedPropertyEnumeratorCallback`.
- */
-typedef void (*IndexedPropertyEnumeratorCallback)(
-    const PropertyCallbackInfo<Array>& info);
-
-/**
- * See `v8::GenericNamedPropertyDefinerCallback`.
- */
-typedef void (*IndexedPropertyDefinerCallback)(
-    uint32_t index, const PropertyDescriptor& desc,
-    const PropertyCallbackInfo<Value>& info);
-
-/**
- * See `v8::GenericNamedPropertyDescriptorCallback`.
- */
-typedef void (*IndexedPropertyDescriptorCallback)(
-    uint32_t index, const PropertyCallbackInfo<Value>& info);
-
-/**
- * Access type specification.
- */
-enum AccessType {
-  ACCESS_GET,
-  ACCESS_SET,
-  ACCESS_HAS,
-  ACCESS_DELETE,
-  ACCESS_KEYS
-};
-
-
-/**
- * Returns true if the given context should be allowed to access the given
- * object.
- */
-typedef bool (*AccessCheckCallback)(Local<Context> accessing_context,
-                                    Local<Object> accessed_object,
-                                    Local<Value> data);
-
-/**
- * A FunctionTemplate is used to create functions at runtime. There
- * can only be one function created from a FunctionTemplate in a
- * context.  The lifetime of the created function is equal to the
- * lifetime of the context.  So in case the embedder needs to create
- * temporary functions that can be collected using Scripts is
- * preferred.
- *
- * Any modification of a FunctionTemplate after first instantiation will trigger
- * a crash.
- *
- * A FunctionTemplate can have properties, these properties are added to the
- * function object when it is created.
- *
- * A FunctionTemplate has a corresponding instance template which is
- * used to create object instances when the function is used as a
- * constructor. Properties added to the instance template are added to
- * each object instance.
- *
- * A FunctionTemplate can have a prototype template. The prototype template
- * is used to create the prototype object of the function.
- *
- * The following example shows how to use a FunctionTemplate:
- *
- * \code
- *    v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate);
- *    t->Set(isolate, "func_property", v8::Number::New(isolate, 1));
- *
- *    v8::Local<v8::Template> proto_t = t->PrototypeTemplate();
- *    proto_t->Set(isolate,
- *                 "proto_method",
- *                 v8::FunctionTemplate::New(isolate, InvokeCallback));
- *    proto_t->Set(isolate, "proto_const", v8::Number::New(isolate, 2));
- *
- *    v8::Local<v8::ObjectTemplate> instance_t = t->InstanceTemplate();
- *    instance_t->SetAccessor(String::NewFromUtf8(isolate, "instance_accessor"),
- *                            InstanceAccessorCallback);
- *    instance_t->SetNamedPropertyHandler(PropertyHandlerCallback);
- *    instance_t->Set(String::NewFromUtf8(isolate, "instance_property"),
- *                    Number::New(isolate, 3));
- *
- *    v8::Local<v8::Function> function = t->GetFunction();
- *    v8::Local<v8::Object> instance = function->NewInstance();
- * \endcode
- *
- * Let's use "function" as the JS variable name of the function object
- * and "instance" for the instance object created above.  The function
- * and the instance will have the following properties:
- *
- * \code
- *   func_property in function == true;
- *   function.func_property == 1;
- *
- *   function.prototype.proto_method() invokes 'InvokeCallback'
- *   function.prototype.proto_const == 2;
- *
- *   instance instanceof function == true;
- *   instance.instance_accessor calls 'InstanceAccessorCallback'
- *   instance.instance_property == 3;
- * \endcode
- *
- * A FunctionTemplate can inherit from another one by calling the
- * FunctionTemplate::Inherit method.  The following graph illustrates
- * the semantics of inheritance:
- *
- * \code
- *   FunctionTemplate Parent  -> Parent() . prototype -> { }
- *     ^                                                  ^
- *     | Inherit(Parent)                                  | .__proto__
- *     |                                                  |
- *   FunctionTemplate Child   -> Child()  . prototype -> { }
- * \endcode
- *
- * A FunctionTemplate 'Child' inherits from 'Parent', the prototype
- * object of the Child() function has __proto__ pointing to the
- * Parent() function's prototype object. An instance of the Child
- * function has all properties on Parent's instance templates.
- *
- * Let Parent be the FunctionTemplate initialized in the previous
- * section and create a Child FunctionTemplate by:
- *
- * \code
- *   Local<FunctionTemplate> parent = t;
- *   Local<FunctionTemplate> child = FunctionTemplate::New();
- *   child->Inherit(parent);
- *
- *   Local<Function> child_function = child->GetFunction();
- *   Local<Object> child_instance = child_function->NewInstance();
- * \endcode
- *
- * The Child function and Child instance will have the following
- * properties:
- *
- * \code
- *   child_func.prototype.__proto__ == function.prototype;
- *   child_instance.instance_accessor calls 'InstanceAccessorCallback'
- *   child_instance.instance_property == 3;
- * \endcode
- */
-class V8_EXPORT FunctionTemplate : public Template {
- public:
-  /** Creates a function template.*/
-  static Local<FunctionTemplate> New(
-      Isolate* isolate, FunctionCallback callback = 0,
-      Local<Value> data = Local<Value>(),
-      Local<Signature> signature = Local<Signature>(), int length = 0,
-      ConstructorBehavior behavior = ConstructorBehavior::kAllow);
-
-  /** Get a template included in the snapshot by index. */
-  static MaybeLocal<FunctionTemplate> FromSnapshot(Isolate* isolate,
-                                                   size_t index);
-
-  /**
-   * Creates a function template with a fast handler. If a fast handler is set,
-   * the callback cannot be null.
-   */
-  static Local<FunctionTemplate> NewWithFastHandler(
-      Isolate* isolate, FunctionCallback callback,
-      experimental::FastAccessorBuilder* fast_handler = nullptr,
-      Local<Value> data = Local<Value>(),
-      Local<Signature> signature = Local<Signature>(), int length = 0);
-
-  /**
-   * Creates a function template backed/cached by a private property.
-   */
-  static Local<FunctionTemplate> NewWithCache(
-      Isolate* isolate, FunctionCallback callback,
-      Local<Private> cache_property, Local<Value> data = Local<Value>(),
-      Local<Signature> signature = Local<Signature>(), int length = 0);
-
-  /** Returns the unique function instance in the current execution context.*/
-  V8_DEPRECATE_SOON("Use maybe version", Local<Function> GetFunction());
-  V8_WARN_UNUSED_RESULT MaybeLocal<Function> GetFunction(
-      Local<Context> context);
-
-  /**
-   * Similar to Context::NewRemoteContext, this creates an instance that
-   * isn't backed by an actual object.
-   *
-   * The InstanceTemplate of this FunctionTemplate must have access checks with
-   * handlers installed.
-   */
-  V8_WARN_UNUSED_RESULT MaybeLocal<Object> NewRemoteInstance();
-
-  /**
-   * Set the call-handler callback for a FunctionTemplate.  This
-   * callback is called whenever the function created from this
-   * FunctionTemplate is called.
-   */
-  void SetCallHandler(
-      FunctionCallback callback, Local<Value> data = Local<Value>(),
-      experimental::FastAccessorBuilder* fast_handler = nullptr);
-
-  /** Set the predefined length property for the FunctionTemplate. */
-  void SetLength(int length);
-
-  /** Get the InstanceTemplate. */
-  Local<ObjectTemplate> InstanceTemplate();
-
-  /**
-   * Causes the function template to inherit from a parent function template.
-   * This means the the function's prototype.__proto__ is set to the parent
-   * function's prototype.
-   **/
-  void Inherit(Local<FunctionTemplate> parent);
-
-  /**
-   * A PrototypeTemplate is the template used to create the prototype object
-   * of the function created by this template.
-   */
-  Local<ObjectTemplate> PrototypeTemplate();
-
-  /**
-   * A PrototypeProviderTemplate is another function template whose prototype
-   * property is used for this template. This is mutually exclusive with setting
-   * a prototype template indirectly by calling PrototypeTemplate() or using
-   * Inherit().
-   **/
-  void SetPrototypeProviderTemplate(Local<FunctionTemplate> prototype_provider);
-
-  /**
-   * Set the class name of the FunctionTemplate.  This is used for
-   * printing objects created with the function created from the
-   * FunctionTemplate as its constructor.
-   */
-  void SetClassName(Local<String> name);
-
-
-  /**
-   * When set to true, no access check will be performed on the receiver of a
-   * function call.  Currently defaults to true, but this is subject to change.
-   */
-  void SetAcceptAnyReceiver(bool value);
-
-  /**
-   * Determines whether the __proto__ accessor ignores instances of
-   * the function template.  If instances of the function template are
-   * ignored, __proto__ skips all instances and instead returns the
-   * next object in the prototype chain.
-   *
-   * Call with a value of true to make the __proto__ accessor ignore
-   * instances of the function template.  Call with a value of false
-   * to make the __proto__ accessor not ignore instances of the
-   * function template.  By default, instances of a function template
-   * are not ignored.
-   */
-  void SetHiddenPrototype(bool value);
-
-  /**
-   * Sets the ReadOnly flag in the attributes of the 'prototype' property
-   * of functions created from this FunctionTemplate to true.
-   */
-  void ReadOnlyPrototype();
-
-  /**
-   * Removes the prototype property from functions created from this
-   * FunctionTemplate.
-   */
-  void RemovePrototype();
-
-  /**
-   * Returns true if the given object is an instance of this function
-   * template.
-   */
-  bool HasInstance(Local<Value> object);
-
- private:
-  FunctionTemplate();
-  friend class Context;
-  friend class ObjectTemplate;
-};
-
-/**
- * Configuration flags for v8::NamedPropertyHandlerConfiguration or
- * v8::IndexedPropertyHandlerConfiguration.
- */
-enum class PropertyHandlerFlags {
-  /**
-   * None.
-   */
-  kNone = 0,
-
-  /**
-   * See ALL_CAN_READ above.
-   */
-  kAllCanRead = 1,
-
-  /** Will not call into interceptor for properties on the receiver or prototype
-   * chain, i.e., only call into interceptor for properties that do not exist.
-   * Currently only valid for named interceptors.
-   */
-  kNonMasking = 1 << 1,
-
-  /**
-   * Will not call into interceptor for symbol lookup.  Only meaningful for
-   * named interceptors.
-   */
-  kOnlyInterceptStrings = 1 << 2,
-};
-
-struct NamedPropertyHandlerConfiguration {
-  NamedPropertyHandlerConfiguration(
-      /** Note: getter is required */
-      GenericNamedPropertyGetterCallback getter = 0,
-      GenericNamedPropertySetterCallback setter = 0,
-      GenericNamedPropertyQueryCallback query = 0,
-      GenericNamedPropertyDeleterCallback deleter = 0,
-      GenericNamedPropertyEnumeratorCallback enumerator = 0,
-      Local<Value> data = Local<Value>(),
-      PropertyHandlerFlags flags = PropertyHandlerFlags::kNone)
-      : getter(getter),
-        setter(setter),
-        query(query),
-        deleter(deleter),
-        enumerator(enumerator),
-        definer(0),
-        descriptor(0),
-        data(data),
-        flags(flags) {}
-
-  NamedPropertyHandlerConfiguration(
-      GenericNamedPropertyGetterCallback getter,
-      GenericNamedPropertySetterCallback setter,
-      GenericNamedPropertyDescriptorCallback descriptor,
-      GenericNamedPropertyDeleterCallback deleter,
-      GenericNamedPropertyEnumeratorCallback enumerator,
-      GenericNamedPropertyDefinerCallback definer,
-      Local<Value> data = Local<Value>(),
-      PropertyHandlerFlags flags = PropertyHandlerFlags::kNone)
-      : getter(getter),
-        setter(setter),
-        query(0),
-        deleter(deleter),
-        enumerator(enumerator),
-        definer(definer),
-        descriptor(descriptor),
-        data(data),
-        flags(flags) {}
-
-  GenericNamedPropertyGetterCallback getter;
-  GenericNamedPropertySetterCallback setter;
-  GenericNamedPropertyQueryCallback query;
-  GenericNamedPropertyDeleterCallback deleter;
-  GenericNamedPropertyEnumeratorCallback enumerator;
-  GenericNamedPropertyDefinerCallback definer;
-  GenericNamedPropertyDescriptorCallback descriptor;
-  Local<Value> data;
-  PropertyHandlerFlags flags;
-};
-
-
-struct IndexedPropertyHandlerConfiguration {
-  IndexedPropertyHandlerConfiguration(
-      /** Note: getter is required */
-      IndexedPropertyGetterCallback getter = 0,
-      IndexedPropertySetterCallback setter = 0,
-      IndexedPropertyQueryCallback query = 0,
-      IndexedPropertyDeleterCallback deleter = 0,
-      IndexedPropertyEnumeratorCallback enumerator = 0,
-      Local<Value> data = Local<Value>(),
-      PropertyHandlerFlags flags = PropertyHandlerFlags::kNone)
-      : getter(getter),
-        setter(setter),
-        query(query),
-        deleter(deleter),
-        enumerator(enumerator),
-        definer(0),
-        descriptor(0),
-        data(data),
-        flags(flags) {}
-
-  IndexedPropertyHandlerConfiguration(
-      IndexedPropertyGetterCallback getter,
-      IndexedPropertySetterCallback setter,
-      IndexedPropertyDescriptorCallback descriptor,
-      IndexedPropertyDeleterCallback deleter,
-      IndexedPropertyEnumeratorCallback enumerator,
-      IndexedPropertyDefinerCallback definer,
-      Local<Value> data = Local<Value>(),
-      PropertyHandlerFlags flags = PropertyHandlerFlags::kNone)
-      : getter(getter),
-        setter(setter),
-        query(0),
-        deleter(deleter),
-        enumerator(enumerator),
-        definer(definer),
-        descriptor(descriptor),
-        data(data),
-        flags(flags) {}
-
-  IndexedPropertyGetterCallback getter;
-  IndexedPropertySetterCallback setter;
-  IndexedPropertyQueryCallback query;
-  IndexedPropertyDeleterCallback deleter;
-  IndexedPropertyEnumeratorCallback enumerator;
-  IndexedPropertyDefinerCallback definer;
-  IndexedPropertyDescriptorCallback descriptor;
-  Local<Value> data;
-  PropertyHandlerFlags flags;
-};
-
-
-/**
- * An ObjectTemplate is used to create objects at runtime.
- *
- * Properties added to an ObjectTemplate are added to each object
- * created from the ObjectTemplate.
- */
-class V8_EXPORT ObjectTemplate : public Template {
- public:
-  /** Creates an ObjectTemplate. */
-  static Local<ObjectTemplate> New(
-      Isolate* isolate,
-      Local<FunctionTemplate> constructor = Local<FunctionTemplate>());
-  static V8_DEPRECATED("Use isolate version", Local<ObjectTemplate> New());
-
-  /** Get a template included in the snapshot by index. */
-  static MaybeLocal<ObjectTemplate> FromSnapshot(Isolate* isolate,
-                                                 size_t index);
-
-  /** Creates a new instance of this template.*/
-  V8_DEPRECATE_SOON("Use maybe version", Local<Object> NewInstance());
-  V8_WARN_UNUSED_RESULT MaybeLocal<Object> NewInstance(Local<Context> context);
-
-  /**
-   * Sets an accessor on the object template.
-   *
-   * Whenever the property with the given name is accessed on objects
-   * created from this ObjectTemplate the getter and setter callbacks
-   * are called instead of getting and setting the property directly
-   * on the JavaScript object.
-   *
-   * \param name The name of the property for which an accessor is added.
-   * \param getter The callback to invoke when getting the property.
-   * \param setter The callback to invoke when setting the property.
-   * \param data A piece of data that will be passed to the getter and setter
-   *   callbacks whenever they are invoked.
-   * \param settings Access control settings for the accessor. This is a bit
-   *   field consisting of one of more of
-   *   DEFAULT = 0, ALL_CAN_READ = 1, or ALL_CAN_WRITE = 2.
-   *   The default is to not allow cross-context access.
-   *   ALL_CAN_READ means that all cross-context reads are allowed.
-   *   ALL_CAN_WRITE means that all cross-context writes are allowed.
-   *   The combination ALL_CAN_READ | ALL_CAN_WRITE can be used to allow all
-   *   cross-context access.
-   * \param attribute The attributes of the property for which an accessor
-   *   is added.
-   * \param signature The signature describes valid receivers for the accessor
-   *   and is used to perform implicit instance checks against them. If the
-   *   receiver is incompatible (i.e. is not an instance of the constructor as
-   *   defined by FunctionTemplate::HasInstance()), an implicit TypeError is
-   *   thrown and no callback is invoked.
-   */
-  void SetAccessor(
-      Local<String> name, AccessorGetterCallback getter,
-      AccessorSetterCallback setter = 0, Local<Value> data = Local<Value>(),
-      AccessControl settings = DEFAULT, PropertyAttribute attribute = None,
-      Local<AccessorSignature> signature = Local<AccessorSignature>());
-  void SetAccessor(
-      Local<Name> name, AccessorNameGetterCallback getter,
-      AccessorNameSetterCallback setter = 0, Local<Value> data = Local<Value>(),
-      AccessControl settings = DEFAULT, PropertyAttribute attribute = None,
-      Local<AccessorSignature> signature = Local<AccessorSignature>());
-
-  /**
-   * Sets a named property handler on the object template.
-   *
-   * Whenever a property whose name is a string is accessed on objects created
-   * from this object template, the provided callback is invoked instead of
-   * accessing the property directly on the JavaScript object.
-   *
-   * SetNamedPropertyHandler() is different from SetHandler(), in
-   * that the latter can intercept symbol-named properties as well as
-   * string-named properties when called with a
-   * NamedPropertyHandlerConfiguration. New code should use SetHandler().
-   *
-   * \param getter The callback to invoke when getting a property.
-   * \param setter The callback to invoke when setting a property.
-   * \param query The callback to invoke to check if a property is present,
-   *   and if present, get its attributes.
-   * \param deleter The callback to invoke when deleting a property.
-   * \param enumerator The callback to invoke to enumerate all the named
-   *   properties of an object.
-   * \param data A piece of data that will be passed to the callbacks
-   *   whenever they are invoked.
-   */
-  // TODO(dcarney): deprecate
-  void SetNamedPropertyHandler(NamedPropertyGetterCallback getter,
-                               NamedPropertySetterCallback setter = 0,
-                               NamedPropertyQueryCallback query = 0,
-                               NamedPropertyDeleterCallback deleter = 0,
-                               NamedPropertyEnumeratorCallback enumerator = 0,
-                               Local<Value> data = Local<Value>());
-
-  /**
-   * Sets a named property handler on the object template.
-   *
-   * Whenever a property whose name is a string or a symbol is accessed on
-   * objects created from this object template, the provided callback is
-   * invoked instead of accessing the property directly on the JavaScript
-   * object.
-   *
-   * @param configuration The NamedPropertyHandlerConfiguration that defines the
-   * callbacks to invoke when accessing a property.
-   */
-  void SetHandler(const NamedPropertyHandlerConfiguration& configuration);
-
-  /**
-   * Sets an indexed property handler on the object template.
-   *
-   * Whenever an indexed property is accessed on objects created from
-   * this object template, the provided callback is invoked instead of
-   * accessing the property directly on the JavaScript object.
-   *
-   * \param getter The callback to invoke when getting a property.
-   * \param setter The callback to invoke when setting a property.
-   * \param query The callback to invoke to check if an object has a property.
-   * \param deleter The callback to invoke when deleting a property.
-   * \param enumerator The callback to invoke to enumerate all the indexed
-   *   properties of an object.
-   * \param data A piece of data that will be passed to the callbacks
-   *   whenever they are invoked.
-   */
-  // TODO(dcarney): deprecate
-  void SetIndexedPropertyHandler(
-      IndexedPropertyGetterCallback getter,
-      IndexedPropertySetterCallback setter = 0,
-      IndexedPropertyQueryCallback query = 0,
-      IndexedPropertyDeleterCallback deleter = 0,
-      IndexedPropertyEnumeratorCallback enumerator = 0,
-      Local<Value> data = Local<Value>()) {
-    SetHandler(IndexedPropertyHandlerConfiguration(getter, setter, query,
-                                                   deleter, enumerator, data));
-  }
-
-  /**
-   * Sets an indexed property handler on the object template.
-   *
-   * Whenever an indexed property is accessed on objects created from
-   * this object template, the provided callback is invoked instead of
-   * accessing the property directly on the JavaScript object.
-   *
-   * @param configuration The IndexedPropertyHandlerConfiguration that defines
-   * the callbacks to invoke when accessing a property.
-   */
-  void SetHandler(const IndexedPropertyHandlerConfiguration& configuration);
-
-  /**
-   * Sets the callback to be used when calling instances created from
-   * this template as a function.  If no callback is set, instances
-   * behave like normal JavaScript objects that cannot be called as a
-   * function.
-   */
-  void SetCallAsFunctionHandler(FunctionCallback callback,
-                                Local<Value> data = Local<Value>());
-
-  /**
-   * Mark object instances of the template as undetectable.
-   *
-   * In many ways, undetectable objects behave as though they are not
-   * there.  They behave like 'undefined' in conditionals and when
-   * printed.  However, properties can be accessed and called as on
-   * normal objects.
-   */
-  void MarkAsUndetectable();
-
-  /**
-   * Sets access check callback on the object template and enables access
-   * checks.
-   *
-   * When accessing properties on instances of this object template,
-   * the access check callback will be called to determine whether or
-   * not to allow cross-context access to the properties.
-   */
-  void SetAccessCheckCallback(AccessCheckCallback callback,
-                              Local<Value> data = Local<Value>());
-
-  /**
-   * Like SetAccessCheckCallback but invokes an interceptor on failed access
-   * checks instead of looking up all-can-read properties. You can only use
-   * either this method or SetAccessCheckCallback, but not both at the same
-   * time.
-   */
-  void SetAccessCheckCallbackAndHandler(
-      AccessCheckCallback callback,
-      const NamedPropertyHandlerConfiguration& named_handler,
-      const IndexedPropertyHandlerConfiguration& indexed_handler,
-      Local<Value> data = Local<Value>());
-
-  /**
-   * Gets the number of internal fields for objects generated from
-   * this template.
-   */
-  int InternalFieldCount();
-
-  /**
-   * Sets the number of internal fields for objects generated from
-   * this template.
-   */
-  void SetInternalFieldCount(int value);
-
-  /**
-   * Returns true if the object will be an immutable prototype exotic object.
-   */
-  bool IsImmutableProto();
-
-  /**
-   * Makes the ObjectTempate for an immutable prototype exotic object, with an
-   * immutable __proto__.
-   */
-  void SetImmutableProto();
-
- private:
-  ObjectTemplate();
-  static Local<ObjectTemplate> New(internal::Isolate* isolate,
-                                   Local<FunctionTemplate> constructor);
-  friend class FunctionTemplate;
-};
-
-
-/**
- * A Signature specifies which receiver is valid for a function.
- */
-class V8_EXPORT Signature : public Data {
- public:
-  static Local<Signature> New(
-      Isolate* isolate,
-      Local<FunctionTemplate> receiver = Local<FunctionTemplate>());
-
- private:
-  Signature();
-};
-
-
-/**
- * An AccessorSignature specifies which receivers are valid parameters
- * to an accessor callback.
- */
-class V8_EXPORT AccessorSignature : public Data {
- public:
-  static Local<AccessorSignature> New(
-      Isolate* isolate,
-      Local<FunctionTemplate> receiver = Local<FunctionTemplate>());
-
- private:
-  AccessorSignature();
-};
-
-
-// --- Extensions ---
-
-class V8_EXPORT ExternalOneByteStringResourceImpl
-    : public String::ExternalOneByteStringResource {
- public:
-  ExternalOneByteStringResourceImpl() : data_(0), length_(0) {}
-  ExternalOneByteStringResourceImpl(const char* data, size_t length)
-      : data_(data), length_(length) {}
-  const char* data() const { return data_; }
-  size_t length() const { return length_; }
-
- private:
-  const char* data_;
-  size_t length_;
-};
-
-/**
- * Ignore
- */
-class V8_EXPORT Extension {  // NOLINT
- public:
-  // Note that the strings passed into this constructor must live as long
-  // as the Extension itself.
-  Extension(const char* name,
-            const char* source = 0,
-            int dep_count = 0,
-            const char** deps = 0,
-            int source_length = -1);
-  virtual ~Extension() { }
-  virtual Local<FunctionTemplate> GetNativeFunctionTemplate(
-      Isolate* isolate, Local<String> name) {
-    return Local<FunctionTemplate>();
-  }
-
-  const char* name() const { return name_; }
-  size_t source_length() const { return source_length_; }
-  const String::ExternalOneByteStringResource* source() const {
-    return &source_; }
-  int dependency_count() { return dep_count_; }
-  const char** dependencies() { return deps_; }
-  void set_auto_enable(bool value) { auto_enable_ = value; }
-  bool auto_enable() { return auto_enable_; }
-
-  // Disallow copying and assigning.
-  Extension(const Extension&) = delete;
-  void operator=(const Extension&) = delete;
-
- private:
-  const char* name_;
-  size_t source_length_;  // expected to initialize before source_
-  ExternalOneByteStringResourceImpl source_;
-  int dep_count_;
-  const char** deps_;
-  bool auto_enable_;
-};
-
-
-void V8_EXPORT RegisterExtension(Extension* extension);
-
-
-// --- Statics ---
-
-V8_INLINE Local<Primitive> Undefined(Isolate* isolate);
-V8_INLINE Local<Primitive> Null(Isolate* isolate);
-V8_INLINE Local<Boolean> True(Isolate* isolate);
-V8_INLINE Local<Boolean> False(Isolate* isolate);
-
-/**
- * A set of constraints that specifies the limits of the runtime's memory use.
- * You must set the heap size before initializing the VM - the size cannot be
- * adjusted after the VM is initialized.
- *
- * If you are using threads then you should hold the V8::Locker lock while
- * setting the stack limit and you must set a non-default stack limit separately
- * for each thread.
- *
- * The arguments for set_max_semi_space_size, set_max_old_space_size,
- * set_max_executable_size, set_code_range_size specify limits in MB.
- */
-class V8_EXPORT ResourceConstraints {
- public:
-  ResourceConstraints();
-
-  /**
-   * Configures the constraints with reasonable default values based on the
-   * capabilities of the current device the VM is running on.
-   *
-   * \param physical_memory The total amount of physical memory on the current
-   *   device, in bytes.
-   * \param virtual_memory_limit The amount of virtual memory on the current
-   *   device, in bytes, or zero, if there is no limit.
-   */
-  void ConfigureDefaults(uint64_t physical_memory,
-                         uint64_t virtual_memory_limit);
-
-  int max_semi_space_size() const { return max_semi_space_size_; }
-  void set_max_semi_space_size(int limit_in_mb) {
-    max_semi_space_size_ = limit_in_mb;
-  }
-  int max_old_space_size() const { return max_old_space_size_; }
-  void set_max_old_space_size(int limit_in_mb) {
-    max_old_space_size_ = limit_in_mb;
-  }
-  int max_executable_size() const { return max_executable_size_; }
-  void set_max_executable_size(int limit_in_mb) {
-    max_executable_size_ = limit_in_mb;
-  }
-  uint32_t* stack_limit() const { return stack_limit_; }
-  // Sets an address beyond which the VM's stack may not grow.
-  void set_stack_limit(uint32_t* value) { stack_limit_ = value; }
-  size_t code_range_size() const { return code_range_size_; }
-  void set_code_range_size(size_t limit_in_mb) {
-    code_range_size_ = limit_in_mb;
-  }
-  size_t max_zone_pool_size() const { return max_zone_pool_size_; }
-  void set_max_zone_pool_size(const size_t bytes) {
-    max_zone_pool_size_ = bytes;
-  }
-
- private:
-  int max_semi_space_size_;
-  int max_old_space_size_;
-  int max_executable_size_;
-  uint32_t* stack_limit_;
-  size_t code_range_size_;
-  size_t max_zone_pool_size_;
-};
-
-
-// --- Exceptions ---
-
-
-typedef void (*FatalErrorCallback)(const char* location, const char* message);
-
-typedef void (*OOMErrorCallback)(const char* location, bool is_heap_oom);
-
-typedef void (*MessageCallback)(Local<Message> message, Local<Value> data);
-
-// --- Tracing ---
-
-typedef void (*LogEventCallback)(const char* name, int event);
-
-/**
- * Create new error objects by calling the corresponding error object
- * constructor with the message.
- */
-class V8_EXPORT Exception {
- public:
-  static Local<Value> RangeError(Local<String> message);
-  static Local<Value> ReferenceError(Local<String> message);
-  static Local<Value> SyntaxError(Local<String> message);
-  static Local<Value> TypeError(Local<String> message);
-  static Local<Value> Error(Local<String> message);
-
-  /**
-   * Creates an error message for the given exception.
-   * Will try to reconstruct the original stack trace from the exception value,
-   * or capture the current stack trace if not available.
-   */
-  static Local<Message> CreateMessage(Isolate* isolate, Local<Value> exception);
-  V8_DEPRECATED("Use version with an Isolate*",
-                static Local<Message> CreateMessage(Local<Value> exception));
-
-  /**
-   * Returns the original stack trace that was captured at the creation time
-   * of a given exception, or an empty handle if not available.
-   */
-  static Local<StackTrace> GetStackTrace(Local<Value> exception);
-};
-
-
-// --- Counters Callbacks ---
-
-typedef int* (*CounterLookupCallback)(const char* name);
-
-typedef void* (*CreateHistogramCallback)(const char* name,
-                                         int min,
-                                         int max,
-                                         size_t buckets);
-
-typedef void (*AddHistogramSampleCallback)(void* histogram, int sample);
-
-// --- Memory Allocation Callback ---
-enum ObjectSpace {
-  kObjectSpaceNewSpace = 1 << 0,
-  kObjectSpaceOldSpace = 1 << 1,
-  kObjectSpaceCodeSpace = 1 << 2,
-  kObjectSpaceMapSpace = 1 << 3,
-  kObjectSpaceLoSpace = 1 << 4,
-  kObjectSpaceAll = kObjectSpaceNewSpace | kObjectSpaceOldSpace |
-                    kObjectSpaceCodeSpace | kObjectSpaceMapSpace |
-                    kObjectSpaceLoSpace
-};
-
-  enum AllocationAction {
-    kAllocationActionAllocate = 1 << 0,
-    kAllocationActionFree = 1 << 1,
-    kAllocationActionAll = kAllocationActionAllocate | kAllocationActionFree
-  };
-
-// --- Enter/Leave Script Callback ---
-typedef void (*BeforeCallEnteredCallback)(Isolate*);
-typedef void (*CallCompletedCallback)(Isolate*);
-typedef void (*DeprecatedCallCompletedCallback)();
-
-/**
- * PromiseHook with type kInit is called when a new promise is
- * created. When a new promise is created as part of the chain in the
- * case of Promise.then or in the intermediate promises created by
- * Promise.{race, all}/AsyncFunctionAwait, we pass the parent promise
- * otherwise we pass undefined.
- *
- * PromiseHook with type kResolve is called at the beginning of
- * resolve or reject function defined by CreateResolvingFunctions.
- *
- * PromiseHook with type kBefore is called at the beginning of the
- * PromiseReactionJob.
- *
- * PromiseHook with type kAfter is called right at the end of the
- * PromiseReactionJob.
- */
-enum class PromiseHookType { kInit, kResolve, kBefore, kAfter };
-
-typedef void (*PromiseHook)(PromiseHookType type, Local<Promise> promise,
-                            Local<Value> parent);
-
-// --- Promise Reject Callback ---
-enum PromiseRejectEvent {
-  kPromiseRejectWithNoHandler = 0,
-  kPromiseHandlerAddedAfterReject = 1
-};
-
-class PromiseRejectMessage {
- public:
-  PromiseRejectMessage(Local<Promise> promise, PromiseRejectEvent event,
-                       Local<Value> value, Local<StackTrace> stack_trace)
-      : promise_(promise),
-        event_(event),
-        value_(value),
-        stack_trace_(stack_trace) {}
-
-  V8_INLINE Local<Promise> GetPromise() const { return promise_; }
-  V8_INLINE PromiseRejectEvent GetEvent() const { return event_; }
-  V8_INLINE Local<Value> GetValue() const { return value_; }
-
-  V8_DEPRECATED("Use v8::Exception::CreateMessage(GetValue())->GetStackTrace()",
-                V8_INLINE Local<StackTrace> GetStackTrace() const) {
-    return stack_trace_;
-  }
-
- private:
-  Local<Promise> promise_;
-  PromiseRejectEvent event_;
-  Local<Value> value_;
-  Local<StackTrace> stack_trace_;
-};
-
-typedef void (*PromiseRejectCallback)(PromiseRejectMessage message);
-
-// --- Microtasks Callbacks ---
-typedef void (*MicrotasksCompletedCallback)(Isolate*);
-typedef void (*MicrotaskCallback)(void* data);
-
-
-/**
- * Policy for running microtasks:
- *   - explicit: microtasks are invoked with Isolate::RunMicrotasks() method;
- *   - scoped: microtasks invocation is controlled by MicrotasksScope objects;
- *   - auto: microtasks are invoked when the script call depth decrements
- *           to zero.
- */
-enum class MicrotasksPolicy { kExplicit, kScoped, kAuto };
-
-
-/**
- * This scope is used to control microtasks when kScopeMicrotasksInvocation
- * is used on Isolate. In this mode every non-primitive call to V8 should be
- * done inside some MicrotasksScope.
- * Microtasks are executed when topmost MicrotasksScope marked as kRunMicrotasks
- * exits.
- * kDoNotRunMicrotasks should be used to annotate calls not intended to trigger
- * microtasks.
- */
-class V8_EXPORT MicrotasksScope {
- public:
-  enum Type { kRunMicrotasks, kDoNotRunMicrotasks };
-
-  MicrotasksScope(Isolate* isolate, Type type);
-  ~MicrotasksScope();
-
-  /**
-   * Runs microtasks if no kRunMicrotasks scope is currently active.
-   */
-  static void PerformCheckpoint(Isolate* isolate);
-
-  /**
-   * Returns current depth of nested kRunMicrotasks scopes.
-   */
-  static int GetCurrentDepth(Isolate* isolate);
-
-  /**
-   * Returns true while microtasks are being executed.
-   */
-  static bool IsRunningMicrotasks(Isolate* isolate);
-
-  // Prevent copying.
-  MicrotasksScope(const MicrotasksScope&) = delete;
-  MicrotasksScope& operator=(const MicrotasksScope&) = delete;
-
- private:
-  internal::Isolate* const isolate_;
-  bool run_;
-};
-
-
-// --- Failed Access Check Callback ---
-typedef void (*FailedAccessCheckCallback)(Local<Object> target,
-                                          AccessType type,
-                                          Local<Value> data);
-
-// --- AllowCodeGenerationFromStrings callbacks ---
-
-/**
- * Callback to check if code generation from strings is allowed. See
- * Context::AllowCodeGenerationFromStrings.
- */
-typedef bool (*AllowCodeGenerationFromStringsCallback)(Local<Context> context);
-
-// --- WASM compilation callbacks ---
-
-/**
- * Callback to check if a buffer source may be compiled to WASM, given
- * the compilation is attempted as a promise or not.
- */
-
-typedef bool (*AllowWasmCompileCallback)(Isolate* isolate, Local<Value> source,
-                                         bool as_promise);
-
-typedef bool (*AllowWasmInstantiateCallback)(Isolate* isolate,
-                                             Local<Value> module_or_bytes,
-                                             MaybeLocal<Value> ffi,
-                                             bool as_promise);
-
-// --- Garbage Collection Callbacks ---
-
-/**
- * Applications can register callback functions which will be called before and
- * after certain garbage collection operations.  Allocations are not allowed in
- * the callback functions, you therefore cannot manipulate objects (set or
- * delete properties for example) since it is possible such operations will
- * result in the allocation of objects.
- */
-enum GCType {
-  kGCTypeScavenge = 1 << 0,
-  kGCTypeMarkSweepCompact = 1 << 1,
-  kGCTypeIncrementalMarking = 1 << 2,
-  kGCTypeProcessWeakCallbacks = 1 << 3,
-  kGCTypeAll = kGCTypeScavenge | kGCTypeMarkSweepCompact |
-               kGCTypeIncrementalMarking | kGCTypeProcessWeakCallbacks
-};
-
-/**
- * GCCallbackFlags is used to notify additional information about the GC
- * callback.
- *   - kGCCallbackFlagConstructRetainedObjectInfos: The GC callback is for
- *     constructing retained object infos.
- *   - kGCCallbackFlagForced: The GC callback is for a forced GC for testing.
- *   - kGCCallbackFlagSynchronousPhantomCallbackProcessing: The GC callback
- *     is called synchronously without getting posted to an idle task.
- *   - kGCCallbackFlagCollectAllAvailableGarbage: The GC callback is called
- *     in a phase where V8 is trying to collect all available garbage
- *     (e.g., handling a low memory notification).
- */
-enum GCCallbackFlags {
-  kNoGCCallbackFlags = 0,
-  kGCCallbackFlagConstructRetainedObjectInfos = 1 << 1,
-  kGCCallbackFlagForced = 1 << 2,
-  kGCCallbackFlagSynchronousPhantomCallbackProcessing = 1 << 3,
-  kGCCallbackFlagCollectAllAvailableGarbage = 1 << 4,
-  kGCCallbackFlagCollectAllExternalMemory = 1 << 5,
-};
-
-typedef void (*GCCallback)(GCType type, GCCallbackFlags flags);
-
-typedef void (*InterruptCallback)(Isolate* isolate, void* data);
-
-
-/**
- * Collection of V8 heap information.
- *
- * Instances of this class can be passed to v8::V8::HeapStatistics to
- * get heap statistics from V8.
- */
-class V8_EXPORT HeapStatistics {
- public:
-  HeapStatistics();
-  size_t total_heap_size() { return total_heap_size_; }
-  size_t total_heap_size_executable() { return total_heap_size_executable_; }
-  size_t total_physical_size() { return total_physical_size_; }
-  size_t total_available_size() { return total_available_size_; }
-  size_t used_heap_size() { return used_heap_size_; }
-  size_t heap_size_limit() { return heap_size_limit_; }
-  size_t malloced_memory() { return malloced_memory_; }
-  size_t peak_malloced_memory() { return peak_malloced_memory_; }
-  size_t does_zap_garbage() { return does_zap_garbage_; }
-
- private:
-  size_t total_heap_size_;
-  size_t total_heap_size_executable_;
-  size_t total_physical_size_;
-  size_t total_available_size_;
-  size_t used_heap_size_;
-  size_t heap_size_limit_;
-  size_t malloced_memory_;
-  size_t peak_malloced_memory_;
-  bool does_zap_garbage_;
-
-  friend class V8;
-  friend class Isolate;
-};
-
-
-class V8_EXPORT HeapSpaceStatistics {
- public:
-  HeapSpaceStatistics();
-  const char* space_name() { return space_name_; }
-  size_t space_size() { return space_size_; }
-  size_t space_used_size() { return space_used_size_; }
-  size_t space_available_size() { return space_available_size_; }
-  size_t physical_space_size() { return physical_space_size_; }
-
- private:
-  const char* space_name_;
-  size_t space_size_;
-  size_t space_used_size_;
-  size_t space_available_size_;
-  size_t physical_space_size_;
-
-  friend class Isolate;
-};
-
-
-class V8_EXPORT HeapObjectStatistics {
- public:
-  HeapObjectStatistics();
-  const char* object_type() { return object_type_; }
-  const char* object_sub_type() { return object_sub_type_; }
-  size_t object_count() { return object_count_; }
-  size_t object_size() { return object_size_; }
-
- private:
-  const char* object_type_;
-  const char* object_sub_type_;
-  size_t object_count_;
-  size_t object_size_;
-
-  friend class Isolate;
-};
-
-class V8_EXPORT HeapCodeStatistics {
- public:
-  HeapCodeStatistics();
-  size_t code_and_metadata_size() { return code_and_metadata_size_; }
-  size_t bytecode_and_metadata_size() { return bytecode_and_metadata_size_; }
-
- private:
-  size_t code_and_metadata_size_;
-  size_t bytecode_and_metadata_size_;
-
-  friend class Isolate;
-};
-
-class RetainedObjectInfo;
-
-
-/**
- * FunctionEntryHook is the type of the profile entry hook called at entry to
- * any generated function when function-level profiling is enabled.
- *
- * \param function the address of the function that's being entered.
- * \param return_addr_location points to a location on stack where the machine
- *    return address resides. This can be used to identify the caller of
- *    \p function, and/or modified to divert execution when \p function exits.
- *
- * \note the entry hook must not cause garbage collection.
- */
-typedef void (*FunctionEntryHook)(uintptr_t function,
-                                  uintptr_t return_addr_location);
-
-/**
- * A JIT code event is issued each time code is added, moved or removed.
- *
- * \note removal events are not currently issued.
- */
-struct JitCodeEvent {
-  enum EventType {
-    CODE_ADDED,
-    CODE_MOVED,
-    CODE_REMOVED,
-    CODE_ADD_LINE_POS_INFO,
-    CODE_START_LINE_INFO_RECORDING,
-    CODE_END_LINE_INFO_RECORDING
-  };
-  // Definition of the code position type. The "POSITION" type means the place
-  // in the source code which are of interest when making stack traces to
-  // pin-point the source location of a stack frame as close as possible.
-  // The "STATEMENT_POSITION" means the place at the beginning of each
-  // statement, and is used to indicate possible break locations.
-  enum PositionType { POSITION, STATEMENT_POSITION };
-
-  // Type of event.
-  EventType type;
-  // Start of the instructions.
-  void* code_start;
-  // Size of the instructions.
-  size_t code_len;
-  // Script info for CODE_ADDED event.
-  Local<UnboundScript> script;
-  // User-defined data for *_LINE_INFO_* event. It's used to hold the source
-  // code line information which is returned from the
-  // CODE_START_LINE_INFO_RECORDING event. And it's passed to subsequent
-  // CODE_ADD_LINE_POS_INFO and CODE_END_LINE_INFO_RECORDING events.
-  void* user_data;
-
-  struct name_t {
-    // Name of the object associated with the code, note that the string is not
-    // zero-terminated.
-    const char* str;
-    // Number of chars in str.
-    size_t len;
-  };
-
-  struct line_info_t {
-    // PC offset
-    size_t offset;
-    // Code postion
-    size_t pos;
-    // The position type.
-    PositionType position_type;
-  };
-
-  union {
-    // Only valid for CODE_ADDED.
-    struct name_t name;
-
-    // Only valid for CODE_ADD_LINE_POS_INFO
-    struct line_info_t line_info;
-
-    // New location of instructions. Only valid for CODE_MOVED.
-    void* new_code_start;
-  };
-};
-
-/**
- * Option flags passed to the SetRAILMode function.
- * See documentation https://developers.google.com/web/tools/chrome-devtools/
- * profile/evaluate-performance/rail
- */
-enum RAILMode {
-  // Response performance mode: In this mode very low virtual machine latency
-  // is provided. V8 will try to avoid JavaScript execution interruptions.
-  // Throughput may be throttled.
-  PERFORMANCE_RESPONSE,
-  // Animation performance mode: In this mode low virtual machine latency is
-  // provided. V8 will try to avoid as many JavaScript execution interruptions
-  // as possible. Throughput may be throttled. This is the default mode.
-  PERFORMANCE_ANIMATION,
-  // Idle performance mode: The embedder is idle. V8 can complete deferred work
-  // in this mode.
-  PERFORMANCE_IDLE,
-  // Load performance mode: In this mode high throughput is provided. V8 may
-  // turn off latency optimizations.
-  PERFORMANCE_LOAD
-};
-
-/**
- * Option flags passed to the SetJitCodeEventHandler function.
- */
-enum JitCodeEventOptions {
-  kJitCodeEventDefault = 0,
-  // Generate callbacks for already existent code.
-  kJitCodeEventEnumExisting = 1
-};
-
-
-/**
- * Callback function passed to SetJitCodeEventHandler.
- *
- * \param event code add, move or removal event.
- */
-typedef void (*JitCodeEventHandler)(const JitCodeEvent* event);
-
-
-/**
- * Interface for iterating through all external resources in the heap.
- */
-class V8_EXPORT ExternalResourceVisitor {  // NOLINT
- public:
-  virtual ~ExternalResourceVisitor() {}
-  virtual void VisitExternalString(Local<String> string) {}
-};
-
-
-/**
- * Interface for iterating through all the persistent handles in the heap.
- */
-class V8_EXPORT PersistentHandleVisitor {  // NOLINT
- public:
-  virtual ~PersistentHandleVisitor() {}
-  virtual void VisitPersistentHandle(Persistent<Value>* value,
-                                     uint16_t class_id) {}
-};
-
-/**
- * Memory pressure level for the MemoryPressureNotification.
- * kNone hints V8 that there is no memory pressure.
- * kModerate hints V8 to speed up incremental garbage collection at the cost of
- * of higher latency due to garbage collection pauses.
- * kCritical hints V8 to free memory as soon as possible. Garbage collection
- * pauses at this level will be large.
- */
-enum class MemoryPressureLevel { kNone, kModerate, kCritical };
-
-/**
- * Interface for tracing through the embedder heap. During a v8 garbage
- * collection, v8 collects hidden fields of all potential wrappers, and at the
- * end of its marking phase iterates the collection and asks the embedder to
- * trace through its heap and use reporter to report each JavaScript object
- * reachable from any of the given wrappers.
- *
- * Before the first call to the TraceWrappersFrom function TracePrologue will be
- * called. When the garbage collection cycle is finished, TraceEpilogue will be
- * called.
- */
-class V8_EXPORT EmbedderHeapTracer {
- public:
-  enum ForceCompletionAction { FORCE_COMPLETION, DO_NOT_FORCE_COMPLETION };
-
-  struct AdvanceTracingActions {
-    explicit AdvanceTracingActions(ForceCompletionAction force_completion_)
-        : force_completion(force_completion_) {}
-
-    ForceCompletionAction force_completion;
-  };
-
-  /**
-   * Called by v8 to register internal fields of found wrappers.
-   *
-   * The embedder is expected to store them somewhere and trace reachable
-   * wrappers from them when called through |AdvanceTracing|.
-   */
-  virtual void RegisterV8References(
-      const std::vector<std::pair<void*, void*> >& internal_fields) = 0;
-
-  /**
-   * Called at the beginning of a GC cycle.
-   */
-  virtual void TracePrologue() = 0;
-
-  /**
-   * Called to to make a tracing step in the embedder.
-   *
-   * The embedder is expected to trace its heap starting from wrappers reported
-   * by RegisterV8References method, and report back all reachable wrappers.
-   * Furthermore, the embedder is expected to stop tracing by the given
-   * deadline.
-   *
-   * Returns true if there is still work to do.
-   */
-  virtual bool AdvanceTracing(double deadline_in_ms,
-                              AdvanceTracingActions actions) = 0;
-
-  /**
-   * Called at the end of a GC cycle.
-   *
-   * Note that allocation is *not* allowed within |TraceEpilogue|.
-   */
-  virtual void TraceEpilogue() = 0;
-
-  /**
-   * Called upon entering the final marking pause. No more incremental marking
-   * steps will follow this call.
-   */
-  virtual void EnterFinalPause() = 0;
-
-  /**
-   * Called when tracing is aborted.
-   *
-   * The embedder is expected to throw away all intermediate data and reset to
-   * the initial state.
-   */
-  virtual void AbortTracing() = 0;
-
-  /**
-   * Returns the number of wrappers that are still to be traced by the embedder.
-   */
-  virtual size_t NumberOfWrappersToTrace() { return 0; }
-
- protected:
-  virtual ~EmbedderHeapTracer() = default;
-};
-
-/**
- * Callback and supporting data used in SnapshotCreator to implement embedder
- * logic to serialize internal fields.
- */
-struct SerializeInternalFieldsCallback {
-  typedef StartupData (*CallbackFunction)(Local<Object> holder, int index,
-                                          void* data);
-  SerializeInternalFieldsCallback(CallbackFunction function = nullptr,
-                                  void* data_arg = nullptr)
-      : callback(function), data(data_arg) {}
-  CallbackFunction callback;
-  void* data;
-};
-
-/**
- * Callback and supporting data used to implement embedder logic to deserialize
- * internal fields.
- */
-struct DeserializeInternalFieldsCallback {
-  typedef void (*CallbackFunction)(Local<Object> holder, int index,
-                                   StartupData payload, void* data);
-  DeserializeInternalFieldsCallback(CallbackFunction function = nullptr,
-                                    void* data_arg = nullptr)
-      : callback(function), data(data_arg) {}
-  void (*callback)(Local<Object> holder, int index, StartupData payload,
-                   void* data);
-  void* data;
-};
-
-/**
- * Isolate represents an isolated instance of the V8 engine.  V8 isolates have
- * completely separate states.  Objects from one isolate must not be used in
- * other isolates.  The embedder can create multiple isolates and use them in
- * parallel in multiple threads.  An isolate can be entered by at most one
- * thread at any given time.  The Locker/Unlocker API must be used to
- * synchronize.
- */
-class V8_EXPORT Isolate {
- public:
-  /**
-   * Initial configuration parameters for a new Isolate.
-   */
-  struct CreateParams {
-    CreateParams()
-        : entry_hook(nullptr),
-          code_event_handler(nullptr),
-          snapshot_blob(nullptr),
-          counter_lookup_callback(nullptr),
-          create_histogram_callback(nullptr),
-          add_histogram_sample_callback(nullptr),
-          array_buffer_allocator(nullptr),
-          external_references(nullptr),
-          allow_atomics_wait(true) {}
-
-    /**
-     * The optional entry_hook allows the host application to provide the
-     * address of a function that's invoked on entry to every V8-generated
-     * function.  Note that entry_hook is invoked at the very start of each
-     * generated function. Furthermore, if an entry_hook is given, V8 will
-     * not use a snapshot, including custom snapshots.
-     */
-    FunctionEntryHook entry_hook;
-
-    /**
-     * Allows the host application to provide the address of a function that is
-     * notified each time code is added, moved or removed.
-     */
-    JitCodeEventHandler code_event_handler;
-
-    /**
-     * ResourceConstraints to use for the new Isolate.
-     */
-    ResourceConstraints constraints;
-
-    /**
-     * Explicitly specify a startup snapshot blob. The embedder owns the blob.
-     */
-    StartupData* snapshot_blob;
-
-
-    /**
-     * Enables the host application to provide a mechanism for recording
-     * statistics counters.
-     */
-    CounterLookupCallback counter_lookup_callback;
-
-    /**
-     * Enables the host application to provide a mechanism for recording
-     * histograms. The CreateHistogram function returns a
-     * histogram which will later be passed to the AddHistogramSample
-     * function.
-     */
-    CreateHistogramCallback create_histogram_callback;
-    AddHistogramSampleCallback add_histogram_sample_callback;
-
-    /**
-     * The ArrayBuffer::Allocator to use for allocating and freeing the backing
-     * store of ArrayBuffers.
-     */
-    ArrayBuffer::Allocator* array_buffer_allocator;
-
-    /**
-     * Specifies an optional nullptr-terminated array of raw addresses in the
-     * embedder that V8 can match against during serialization and use for
-     * deserialization. This array and its content must stay valid for the
-     * entire lifetime of the isolate.
-     */
-    intptr_t* external_references;
-
-    /**
-     * Whether calling Atomics.wait (a function that may block) is allowed in
-     * this isolate.
-     */
-    bool allow_atomics_wait;
-  };
-
-
-  /**
-   * Stack-allocated class which sets the isolate for all operations
-   * executed within a local scope.
-   */
-  class V8_EXPORT Scope {
-   public:
-    explicit Scope(Isolate* isolate) : isolate_(isolate) {
-      isolate->Enter();
-    }
-
-    ~Scope() { isolate_->Exit(); }
-
-    // Prevent copying of Scope objects.
-    Scope(const Scope&) = delete;
-    Scope& operator=(const Scope&) = delete;
-
-   private:
-    Isolate* const isolate_;
-  };
-
-
-  /**
-   * Assert that no Javascript code is invoked.
-   */
-  class V8_EXPORT DisallowJavascriptExecutionScope {
-   public:
-    enum OnFailure { CRASH_ON_FAILURE, THROW_ON_FAILURE };
-
-    DisallowJavascriptExecutionScope(Isolate* isolate, OnFailure on_failure);
-    ~DisallowJavascriptExecutionScope();
-
-    // Prevent copying of Scope objects.
-    DisallowJavascriptExecutionScope(const DisallowJavascriptExecutionScope&) =
-        delete;
-    DisallowJavascriptExecutionScope& operator=(
-        const DisallowJavascriptExecutionScope&) = delete;
-
-   private:
-    bool on_failure_;
-    void* internal_;
-  };
-
-
-  /**
-   * Introduce exception to DisallowJavascriptExecutionScope.
-   */
-  class V8_EXPORT AllowJavascriptExecutionScope {
-   public:
-    explicit AllowJavascriptExecutionScope(Isolate* isolate);
-    ~AllowJavascriptExecutionScope();
-
-    // Prevent copying of Scope objects.
-    AllowJavascriptExecutionScope(const AllowJavascriptExecutionScope&) =
-        delete;
-    AllowJavascriptExecutionScope& operator=(
-        const AllowJavascriptExecutionScope&) = delete;
-
-   private:
-    void* internal_throws_;
-    void* internal_assert_;
-  };
-
-  /**
-   * Do not run microtasks while this scope is active, even if microtasks are
-   * automatically executed otherwise.
-   */
-  class V8_EXPORT SuppressMicrotaskExecutionScope {
-   public:
-    explicit SuppressMicrotaskExecutionScope(Isolate* isolate);
-    ~SuppressMicrotaskExecutionScope();
-
-    // Prevent copying of Scope objects.
-    SuppressMicrotaskExecutionScope(const SuppressMicrotaskExecutionScope&) =
-        delete;
-    SuppressMicrotaskExecutionScope& operator=(
-        const SuppressMicrotaskExecutionScope&) = delete;
-
-   private:
-    internal::Isolate* const isolate_;
-  };
-
-  /**
-   * Types of garbage collections that can be requested via
-   * RequestGarbageCollectionForTesting.
-   */
-  enum GarbageCollectionType {
-    kFullGarbageCollection,
-    kMinorGarbageCollection
-  };
-
-  /**
-   * Features reported via the SetUseCounterCallback callback. Do not change
-   * assigned numbers of existing items; add new features to the end of this
-   * list.
-   */
-  enum UseCounterFeature {
-    kUseAsm = 0,
-    kBreakIterator = 1,
-    kLegacyConst = 2,
-    kMarkDequeOverflow = 3,
-    kStoreBufferOverflow = 4,
-    kSlotsBufferOverflow = 5,
-    kObjectObserve = 6,
-    kForcedGC = 7,
-    kSloppyMode = 8,
-    kStrictMode = 9,
-    kStrongMode = 10,
-    kRegExpPrototypeStickyGetter = 11,
-    kRegExpPrototypeToString = 12,
-    kRegExpPrototypeUnicodeGetter = 13,
-    kIntlV8Parse = 14,
-    kIntlPattern = 15,
-    kIntlResolved = 16,
-    kPromiseChain = 17,
-    kPromiseAccept = 18,
-    kPromiseDefer = 19,
-    kHtmlCommentInExternalScript = 20,
-    kHtmlComment = 21,
-    kSloppyModeBlockScopedFunctionRedefinition = 22,
-    kForInInitializer = 23,
-    kArrayProtectorDirtied = 24,
-    kArraySpeciesModified = 25,
-    kArrayPrototypeConstructorModified = 26,
-    kArrayInstanceProtoModified = 27,
-    kArrayInstanceConstructorModified = 28,
-    kLegacyFunctionDeclaration = 29,
-    kRegExpPrototypeSourceGetter = 30,
-    kRegExpPrototypeOldFlagGetter = 31,
-    kDecimalWithLeadingZeroInStrictMode = 32,
-    kLegacyDateParser = 33,
-    kDefineGetterOrSetterWouldThrow = 34,
-    kFunctionConstructorReturnedUndefined = 35,
-    kAssigmentExpressionLHSIsCallInSloppy = 36,
-    kAssigmentExpressionLHSIsCallInStrict = 37,
-    kPromiseConstructorReturnedUndefined = 38,
-
-    // If you add new values here, you'll also need to update Chromium's:
-    // UseCounter.h, V8PerIsolateData.cpp, histograms.xml
-    kUseCounterFeatureCount  // This enum value must be last.
-  };
-
-  enum MessageErrorLevel {
-    kMessageLog = (1 << 0),
-    kMessageDebug = (1 << 1),
-    kMessageInfo = (1 << 2),
-    kMessageError = (1 << 3),
-    kMessageWarning = (1 << 4),
-    kMessageAll = kMessageLog | kMessageDebug | kMessageInfo | kMessageError |
-                  kMessageWarning,
-  };
-
-  typedef void (*UseCounterCallback)(Isolate* isolate,
-                                     UseCounterFeature feature);
-
-
-  /**
-   * Creates a new isolate.  Does not change the currently entered
-   * isolate.
-   *
-   * When an isolate is no longer used its resources should be freed
-   * by calling Dispose().  Using the delete operator is not allowed.
-   *
-   * V8::Initialize() must have run prior to this.
-   */
-  static Isolate* New(const CreateParams& params);
-
-  /**
-   * Returns the entered isolate for the current thread or NULL in
-   * case there is no current isolate.
-   *
-   * This method must not be invoked before V8::Initialize() was invoked.
-   */
-  static Isolate* GetCurrent();
-
-  /**
-   * Custom callback used by embedders to help V8 determine if it should abort
-   * when it throws and no internal handler is predicted to catch the
-   * exception. If --abort-on-uncaught-exception is used on the command line,
-   * then V8 will abort if either:
-   * - no custom callback is set.
-   * - the custom callback set returns true.
-   * Otherwise, the custom callback will not be called and V8 will not abort.
-   */
-  typedef bool (*AbortOnUncaughtExceptionCallback)(Isolate*);
-  void SetAbortOnUncaughtExceptionCallback(
-      AbortOnUncaughtExceptionCallback callback);
-
-  /**
-   * Optional notification that the system is running low on memory.
-   * V8 uses these notifications to guide heuristics.
-   * It is allowed to call this function from another thread while
-   * the isolate is executing long running JavaScript code.
-   */
-  void MemoryPressureNotification(MemoryPressureLevel level);
-
-  /**
-   * Methods below this point require holding a lock (using Locker) in
-   * a multi-threaded environment.
-   */
-
-  /**
-   * Sets this isolate as the entered one for the current thread.
-   * Saves the previously entered one (if any), so that it can be
-   * restored when exiting.  Re-entering an isolate is allowed.
-   */
-  void Enter();
-
-  /**
-   * Exits this isolate by restoring the previously entered one in the
-   * current thread.  The isolate may still stay the same, if it was
-   * entered more than once.
-   *
-   * Requires: this == Isolate::GetCurrent().
-   */
-  void Exit();
-
-  /**
-   * Disposes the isolate.  The isolate must not be entered by any
-   * thread to be disposable.
-   */
-  void Dispose();
-
-  /**
-   * Discards all V8 thread-specific data for the Isolate. Should be used
-   * if a thread is terminating and it has used an Isolate that will outlive
-   * the thread -- all thread-specific data for an Isolate is discarded when
-   * an Isolate is disposed so this call is pointless if an Isolate is about
-   * to be Disposed.
-   */
-  void DiscardThreadSpecificMetadata();
-
-  /**
-   * Associate embedder-specific data with the isolate. |slot| has to be
-   * between 0 and GetNumberOfDataSlots() - 1.
-   */
-  V8_INLINE void SetData(uint32_t slot, void* data);
-
-  /**
-   * Retrieve embedder-specific data from the isolate.
-   * Returns NULL if SetData has never been called for the given |slot|.
-   */
-  V8_INLINE void* GetData(uint32_t slot);
-
-  /**
-   * Returns the maximum number of available embedder data slots. Valid slots
-   * are in the range of 0 - GetNumberOfDataSlots() - 1.
-   */
-  V8_INLINE static uint32_t GetNumberOfDataSlots();
-
-  /**
-   * Get statistics about the heap memory usage.
-   */
-  void GetHeapStatistics(HeapStatistics* heap_statistics);
-
-  /**
-   * Returns the number of spaces in the heap.
-   */
-  size_t NumberOfHeapSpaces();
-
-  /**
-   * Get the memory usage of a space in the heap.
-   *
-   * \param space_statistics The HeapSpaceStatistics object to fill in
-   *   statistics.
-   * \param index The index of the space to get statistics from, which ranges
-   *   from 0 to NumberOfHeapSpaces() - 1.
-   * \returns true on success.
-   */
-  bool GetHeapSpaceStatistics(HeapSpaceStatistics* space_statistics,
-                              size_t index);
-
-  /**
-   * Returns the number of types of objects tracked in the heap at GC.
-   */
-  size_t NumberOfTrackedHeapObjectTypes();
-
-  /**
-   * Get statistics about objects in the heap.
-   *
-   * \param object_statistics The HeapObjectStatistics object to fill in
-   *   statistics of objects of given type, which were live in the previous GC.
-   * \param type_index The index of the type of object to fill details about,
-   *   which ranges from 0 to NumberOfTrackedHeapObjectTypes() - 1.
-   * \returns true on success.
-   */
-  bool GetHeapObjectStatisticsAtLastGC(HeapObjectStatistics* object_statistics,
-                                       size_t type_index);
-
-  /**
-   * Get statistics about code and its metadata in the heap.
-   *
-   * \param object_statistics The HeapCodeStatistics object to fill in
-   *   statistics of code, bytecode and their metadata.
-   * \returns true on success.
-   */
-  bool GetHeapCodeAndMetadataStatistics(HeapCodeStatistics* object_statistics);
-
-  /**
-   * Get a call stack sample from the isolate.
-   * \param state Execution state.
-   * \param frames Caller allocated buffer to store stack frames.
-   * \param frames_limit Maximum number of frames to capture. The buffer must
-   *                     be large enough to hold the number of frames.
-   * \param sample_info The sample info is filled up by the function
-   *                    provides number of actual captured stack frames and
-   *                    the current VM state.
-   * \note GetStackSample should only be called when the JS thread is paused or
-   *       interrupted. Otherwise the behavior is undefined.
-   */
-  void GetStackSample(const RegisterState& state, void** frames,
-                      size_t frames_limit, SampleInfo* sample_info);
-
-  /**
-   * Adjusts the amount of registered external memory. Used to give V8 an
-   * indication of the amount of externally allocated memory that is kept alive
-   * by JavaScript objects. V8 uses this to decide when to perform global
-   * garbage collections. Registering externally allocated memory will trigger
-   * global garbage collections more often than it would otherwise in an attempt
-   * to garbage collect the JavaScript objects that keep the externally
-   * allocated memory alive.
-   *
-   * \param change_in_bytes the change in externally allocated memory that is
-   *   kept alive by JavaScript objects.
-   * \returns the adjusted value.
-   */
-  V8_INLINE int64_t
-      AdjustAmountOfExternalAllocatedMemory(int64_t change_in_bytes);
-
-  /**
-   * Returns the number of phantom handles without callbacks that were reset
-   * by the garbage collector since the last call to this function.
-   */
-  size_t NumberOfPhantomHandleResetsSinceLastCall();
-
-  /**
-   * Returns heap profiler for this isolate. Will return NULL until the isolate
-   * is initialized.
-   */
-  HeapProfiler* GetHeapProfiler();
-
-  /**
-   * Returns CPU profiler for this isolate. Will return NULL unless the isolate
-   * is initialized. It is the embedder's responsibility to stop all CPU
-   * profiling activities if it has started any.
-   */
-  V8_DEPRECATE_SOON("CpuProfiler should be created with CpuProfiler::New call.",
-                    CpuProfiler* GetCpuProfiler());
-
-  /** Returns the ArrayBuffer::Allocator used in this isolate. */
-  ArrayBuffer::Allocator* GetArrayBufferAllocator();
-
-  /** Returns true if this isolate has a current context. */
-  bool InContext();
-
-  /**
-   * Returns the context of the currently running JavaScript, or the context
-   * on the top of the stack if no JavaScript is running.
-   */
-  Local<Context> GetCurrentContext();
-
-  /**
-   * Returns the context of the calling JavaScript code.  That is the
-   * context of the top-most JavaScript frame.  If there are no
-   * JavaScript frames an empty handle is returned.
-   */
-  V8_DEPRECATE_SOON(
-      "Calling context concept is not compatible with tail calls, and will be "
-      "removed.",
-      Local<Context> GetCallingContext());
-
-  /** Returns the last context entered through V8's C++ API. */
-  Local<Context> GetEnteredContext();
-
-  /**
-   * Returns either the last context entered through V8's C++ API, or the
-   * context of the currently running microtask while processing microtasks.
-   * If a context is entered while executing a microtask, that context is
-   * returned.
-   */
-  Local<Context> GetEnteredOrMicrotaskContext();
-
-  /**
-   * Schedules an exception to be thrown when returning to JavaScript.  When an
-   * exception has been scheduled it is illegal to invoke any JavaScript
-   * operation; the caller must return immediately and only after the exception
-   * has been handled does it become legal to invoke JavaScript operations.
-   */
-  Local<Value> ThrowException(Local<Value> exception);
-
-  /**
-   * Allows the host application to group objects together. If one
-   * object in the group is alive, all objects in the group are alive.
-   * After each garbage collection, object groups are removed. It is
-   * intended to be used in the before-garbage-collection callback
-   * function, for instance to simulate DOM tree connections among JS
-   * wrapper objects. Object groups for all dependent handles need to
-   * be provided for kGCTypeMarkSweepCompact collections, for all other
-   * garbage collection types it is sufficient to provide object groups
-   * for partially dependent handles only.
-   */
-  template <typename T>
-  V8_DEPRECATED("Use EmbedderHeapTracer",
-                void SetObjectGroupId(const Persistent<T>& object,
-                                      UniqueId id));
-
-  /**
-   * Allows the host application to declare implicit references from an object
-   * group to an object. If the objects of the object group are alive, the child
-   * object is alive too. After each garbage collection, all implicit references
-   * are removed. It is intended to be used in the before-garbage-collection
-   * callback function.
-   */
-  template <typename T>
-  V8_DEPRECATED("Use EmbedderHeapTracer",
-                void SetReferenceFromGroup(UniqueId id,
-                                           const Persistent<T>& child));
-
-  /**
-   * Allows the host application to declare implicit references from an object
-   * to another object. If the parent object is alive, the child object is alive
-   * too. After each garbage collection, all implicit references are removed. It
-   * is intended to be used in the before-garbage-collection callback function.
-   */
-  template <typename T, typename S>
-  V8_DEPRECATED("Use EmbedderHeapTracer",
-                void SetReference(const Persistent<T>& parent,
-                                  const Persistent<S>& child));
-
-  typedef void (*GCCallback)(Isolate* isolate, GCType type,
-                             GCCallbackFlags flags);
-
-  /**
-   * Enables the host application to receive a notification before a
-   * garbage collection. Allocations are allowed in the callback function,
-   * but the callback is not re-entrant: if the allocation inside it will
-   * trigger the garbage collection, the callback won't be called again.
-   * It is possible to specify the GCType filter for your callback. But it is
-   * not possible to register the same callback function two times with
-   * different GCType filters.
-   */
-  void AddGCPrologueCallback(GCCallback callback,
-                             GCType gc_type_filter = kGCTypeAll);
-
-  /**
-   * This function removes callback which was installed by
-   * AddGCPrologueCallback function.
-   */
-  void RemoveGCPrologueCallback(GCCallback callback);
-
-  /**
-   * Sets the embedder heap tracer for the isolate.
-   */
-  void SetEmbedderHeapTracer(EmbedderHeapTracer* tracer);
-
-  /**
-   * Enables the host application to receive a notification after a
-   * garbage collection. Allocations are allowed in the callback function,
-   * but the callback is not re-entrant: if the allocation inside it will
-   * trigger the garbage collection, the callback won't be called again.
-   * It is possible to specify the GCType filter for your callback. But it is
-   * not possible to register the same callback function two times with
-   * different GCType filters.
-   */
-  void AddGCEpilogueCallback(GCCallback callback,
-                             GCType gc_type_filter = kGCTypeAll);
-
-  /**
-   * This function removes callback which was installed by
-   * AddGCEpilogueCallback function.
-   */
-  void RemoveGCEpilogueCallback(GCCallback callback);
-
-  /**
-   * Forcefully terminate the current thread of JavaScript execution
-   * in the given isolate.
-   *
-   * This method can be used by any thread even if that thread has not
-   * acquired the V8 lock with a Locker object.
-   */
-  void TerminateExecution();
-
-  /**
-   * Is V8 terminating JavaScript execution.
-   *
-   * Returns true if JavaScript execution is currently terminating
-   * because of a call to TerminateExecution.  In that case there are
-   * still JavaScript frames on the stack and the termination
-   * exception is still active.
-   */
-  bool IsExecutionTerminating();
-
-  /**
-   * Resume execution capability in the given isolate, whose execution
-   * was previously forcefully terminated using TerminateExecution().
-   *
-   * When execution is forcefully terminated using TerminateExecution(),
-   * the isolate can not resume execution until all JavaScript frames
-   * have propagated the uncatchable exception which is generated.  This
-   * method allows the program embedding the engine to handle the
-   * termination event and resume execution capability, even if
-   * JavaScript frames remain on the stack.
-   *
-   * This method can be used by any thread even if that thread has not
-   * acquired the V8 lock with a Locker object.
-   */
-  void CancelTerminateExecution();
-
-  /**
-   * Request V8 to interrupt long running JavaScript code and invoke
-   * the given |callback| passing the given |data| to it. After |callback|
-   * returns control will be returned to the JavaScript code.
-   * There may be a number of interrupt requests in flight.
-   * Can be called from another thread without acquiring a |Locker|.
-   * Registered |callback| must not reenter interrupted Isolate.
-   */
-  void RequestInterrupt(InterruptCallback callback, void* data);
-
-  /**
-   * Request garbage collection in this Isolate. It is only valid to call this
-   * function if --expose_gc was specified.
-   *
-   * This should only be used for testing purposes and not to enforce a garbage
-   * collection schedule. It has strong negative impact on the garbage
-   * collection performance. Use IdleNotificationDeadline() or
-   * LowMemoryNotification() instead to influence the garbage collection
-   * schedule.
-   */
-  void RequestGarbageCollectionForTesting(GarbageCollectionType type);
-
-  /**
-   * Set the callback to invoke for logging event.
-   */
-  void SetEventLogger(LogEventCallback that);
-
-  /**
-   * Adds a callback to notify the host application right before a script
-   * is about to run. If a script re-enters the runtime during executing, the
-   * BeforeCallEnteredCallback is invoked for each re-entrance.
-   * Executing scripts inside the callback will re-trigger the callback.
-   */
-  void AddBeforeCallEnteredCallback(BeforeCallEnteredCallback callback);
-
-  /**
-   * Removes callback that was installed by AddBeforeCallEnteredCallback.
-   */
-  void RemoveBeforeCallEnteredCallback(BeforeCallEnteredCallback callback);
-
-  /**
-   * Adds a callback to notify the host application when a script finished
-   * running.  If a script re-enters the runtime during executing, the
-   * CallCompletedCallback is only invoked when the outer-most script
-   * execution ends.  Executing scripts inside the callback do not trigger
-   * further callbacks.
-   */
-  void AddCallCompletedCallback(CallCompletedCallback callback);
-  V8_DEPRECATE_SOON(
-      "Use callback with parameter",
-      void AddCallCompletedCallback(DeprecatedCallCompletedCallback callback));
-
-  /**
-   * Removes callback that was installed by AddCallCompletedCallback.
-   */
-  void RemoveCallCompletedCallback(CallCompletedCallback callback);
-  V8_DEPRECATE_SOON(
-      "Use callback with parameter",
-      void RemoveCallCompletedCallback(
-          DeprecatedCallCompletedCallback callback));
-
-  /**
-   * Experimental: Set the PromiseHook callback for various promise
-   * lifecycle events.
-   */
-  void SetPromiseHook(PromiseHook hook);
-
-  /**
-   * Set callback to notify about promise reject with no handler, or
-   * revocation of such a previous notification once the handler is added.
-   */
-  void SetPromiseRejectCallback(PromiseRejectCallback callback);
-
-  /**
-   * Experimental: Runs the Microtask Work Queue until empty
-   * Any exceptions thrown by microtask callbacks are swallowed.
-   */
-  void RunMicrotasks();
-
-  /**
-   * Experimental: Enqueues the callback to the Microtask Work Queue
-   */
-  void EnqueueMicrotask(Local<Function> microtask);
-
-  /**
-   * Experimental: Enqueues the callback to the Microtask Work Queue
-   */
-  void EnqueueMicrotask(MicrotaskCallback microtask, void* data = NULL);
-
-  /**
-   * Experimental: Controls how Microtasks are invoked. See MicrotasksPolicy
-   * for details.
-   */
-  void SetMicrotasksPolicy(MicrotasksPolicy policy);
-  V8_DEPRECATE_SOON("Use SetMicrotasksPolicy",
-                    void SetAutorunMicrotasks(bool autorun));
-
-  /**
-   * Experimental: Returns the policy controlling how Microtasks are invoked.
-   */
-  MicrotasksPolicy GetMicrotasksPolicy() const;
-  V8_DEPRECATE_SOON("Use GetMicrotasksPolicy",
-                    bool WillAutorunMicrotasks() const);
-
-  /**
-   * Experimental: adds a callback to notify the host application after
-   * microtasks were run. The callback is triggered by explicit RunMicrotasks
-   * call or automatic microtasks execution (see SetAutorunMicrotasks).
-   *
-   * Callback will trigger even if microtasks were attempted to run,
-   * but the microtasks queue was empty and no single microtask was actually
-   * executed.
-   *
-   * Executing scriptsinside the callback will not re-trigger microtasks and
-   * the callback.
-   */
-  void AddMicrotasksCompletedCallback(MicrotasksCompletedCallback callback);
-
-  /**
-   * Removes callback that was installed by AddMicrotasksCompletedCallback.
-   */
-  void RemoveMicrotasksCompletedCallback(MicrotasksCompletedCallback callback);
-
-  /**
-   * Sets a callback for counting the number of times a feature of V8 is used.
-   */
-  void SetUseCounterCallback(UseCounterCallback callback);
-
-  /**
-   * Enables the host application to provide a mechanism for recording
-   * statistics counters.
-   */
-  void SetCounterFunction(CounterLookupCallback);
-
-  /**
-   * Enables the host application to provide a mechanism for recording
-   * histograms. The CreateHistogram function returns a
-   * histogram which will later be passed to the AddHistogramSample
-   * function.
-   */
-  void SetCreateHistogramFunction(CreateHistogramCallback);
-  void SetAddHistogramSampleFunction(AddHistogramSampleCallback);
-
-  /**
-   * Optional notification that the embedder is idle.
-   * V8 uses the notification to perform garbage collection.
-   * This call can be used repeatedly if the embedder remains idle.
-   * Returns true if the embedder should stop calling IdleNotificationDeadline
-   * until real work has been done.  This indicates that V8 has done
-   * as much cleanup as it will be able to do.
-   *
-   * The deadline_in_seconds argument specifies the deadline V8 has to finish
-   * garbage collection work. deadline_in_seconds is compared with
-   * MonotonicallyIncreasingTime() and should be based on the same timebase as
-   * that function. There is no guarantee that the actual work will be done
-   * within the time limit.
-   */
-  bool IdleNotificationDeadline(double deadline_in_seconds);
-
-  V8_DEPRECATED("use IdleNotificationDeadline()",
-                bool IdleNotification(int idle_time_in_ms));
-
-  /**
-   * Optional notification that the system is running low on memory.
-   * V8 uses these notifications to attempt to free memory.
-   */
-  void LowMemoryNotification();
-
-  /**
-   * Optional notification that a context has been disposed. V8 uses
-   * these notifications to guide the GC heuristic. Returns the number
-   * of context disposals - including this one - since the last time
-   * V8 had a chance to clean up.
-   *
-   * The optional parameter |dependant_context| specifies whether the disposed
-   * context was depending on state from other contexts or not.
-   */
-  int ContextDisposedNotification(bool dependant_context = true);
-
-  /**
-   * Optional notification that the isolate switched to the foreground.
-   * V8 uses these notifications to guide heuristics.
-   */
-  void IsolateInForegroundNotification();
-
-  /**
-   * Optional notification that the isolate switched to the background.
-   * V8 uses these notifications to guide heuristics.
-   */
-  void IsolateInBackgroundNotification();
-
-  /**
-   * Optional notification to tell V8 the current performance requirements
-   * of the embedder based on RAIL.
-   * V8 uses these notifications to guide heuristics.
-   * This is an unfinished experimental feature. Semantics and implementation
-   * may change frequently.
-   */
-  void SetRAILMode(RAILMode rail_mode);
-
-  /**
-   * Optional notification to tell V8 the current isolate is used for debugging
-   * and requires higher heap limit.
-   */
-  void IncreaseHeapLimitForDebugging();
-
-  /**
-   * Restores the original heap limit after IncreaseHeapLimitForDebugging().
-   */
-  void RestoreOriginalHeapLimit();
-
-  /**
-   * Returns true if the heap limit was increased for debugging and the
-   * original heap limit was not restored yet.
-   */
-  bool IsHeapLimitIncreasedForDebugging();
-
-  /**
-   * Allows the host application to provide the address of a function that is
-   * notified each time code is added, moved or removed.
-   *
-   * \param options options for the JIT code event handler.
-   * \param event_handler the JIT code event handler, which will be invoked
-   *     each time code is added, moved or removed.
-   * \note \p event_handler won't get notified of existent code.
-   * \note since code removal notifications are not currently issued, the
-   *     \p event_handler may get notifications of code that overlaps earlier
-   *     code notifications. This happens when code areas are reused, and the
-   *     earlier overlapping code areas should therefore be discarded.
-   * \note the events passed to \p event_handler and the strings they point to
-   *     are not guaranteed to live past each call. The \p event_handler must
-   *     copy strings and other parameters it needs to keep around.
-   * \note the set of events declared in JitCodeEvent::EventType is expected to
-   *     grow over time, and the JitCodeEvent structure is expected to accrue
-   *     new members. The \p event_handler function must ignore event codes
-   *     it does not recognize to maintain future compatibility.
-   * \note Use Isolate::CreateParams to get events for code executed during
-   *     Isolate setup.
-   */
-  void SetJitCodeEventHandler(JitCodeEventOptions options,
-                              JitCodeEventHandler event_handler);
-
-  /**
-   * Modifies the stack limit for this Isolate.
-   *
-   * \param stack_limit An address beyond which the Vm's stack may not grow.
-   *
-   * \note  If you are using threads then you should hold the V8::Locker lock
-   *     while setting the stack limit and you must set a non-default stack
-   *     limit separately for each thread.
-   */
-  void SetStackLimit(uintptr_t stack_limit);
-
-  /**
-   * Returns a memory range that can potentially contain jitted code.
-   *
-   * On Win64, embedders are advised to install function table callbacks for
-   * these ranges, as default SEH won't be able to unwind through jitted code.
-   *
-   * The first page of the code range is reserved for the embedder and is
-   * committed, writable, and executable.
-   *
-   * Might be empty on other platforms.
-   *
-   * https://code.google.com/p/v8/issues/detail?id=3598
-   */
-  void GetCodeRange(void** start, size_t* length_in_bytes);
-
-  /** Set the callback to invoke in case of fatal errors. */
-  void SetFatalErrorHandler(FatalErrorCallback that);
-
-  /** Set the callback to invoke in case of OOM errors. */
-  void SetOOMErrorHandler(OOMErrorCallback that);
-
-  /**
-   * Set the callback to invoke to check if code generation from
-   * strings should be allowed.
-   */
-  void SetAllowCodeGenerationFromStringsCallback(
-      AllowCodeGenerationFromStringsCallback callback);
-
-  /**
-   * Set the callback to invoke to check if wasm compilation from
-   * the specified object is allowed. By default, wasm compilation
-   * is allowed.
-   *
-   * Similar for instantiate.
-   */
-  void SetAllowWasmCompileCallback(AllowWasmCompileCallback callback);
-  void SetAllowWasmInstantiateCallback(AllowWasmInstantiateCallback callback);
-
-  /**
-  * Check if V8 is dead and therefore unusable.  This is the case after
-  * fatal errors such as out-of-memory situations.
-  */
-  bool IsDead();
-
-  /**
-   * Adds a message listener (errors only).
-   *
-   * The same message listener can be added more than once and in that
-   * case it will be called more than once for each message.
-   *
-   * If data is specified, it will be passed to the callback when it is called.
-   * Otherwise, the exception object will be passed to the callback instead.
-   */
-  bool AddMessageListener(MessageCallback that,
-                          Local<Value> data = Local<Value>());
-
-  /**
-   * Adds a message listener.
-   *
-   * The same message listener can be added more than once and in that
-   * case it will be called more than once for each message.
-   *
-   * If data is specified, it will be passed to the callback when it is called.
-   * Otherwise, the exception object will be passed to the callback instead.
-   *
-   * A listener can listen for particular error levels by providing a mask.
-   */
-  bool AddMessageListenerWithErrorLevel(MessageCallback that,
-                                        int message_levels,
-                                        Local<Value> data = Local<Value>());
-
-  /**
-   * Remove all message listeners from the specified callback function.
-   */
-  void RemoveMessageListeners(MessageCallback that);
-
-  /** Callback function for reporting failed access checks.*/
-  void SetFailedAccessCheckCallbackFunction(FailedAccessCheckCallback);
-
-  /**
-   * Tells V8 to capture current stack trace when uncaught exception occurs
-   * and report it to the message listeners. The option is off by default.
-   */
-  void SetCaptureStackTraceForUncaughtExceptions(
-      bool capture, int frame_limit = 10,
-      StackTrace::StackTraceOptions options = StackTrace::kOverview);
-
-  /**
-   * Iterates through all external resources referenced from current isolate
-   * heap.  GC is not invoked prior to iterating, therefore there is no
-   * guarantee that visited objects are still alive.
-   */
-  void VisitExternalResources(ExternalResourceVisitor* visitor);
-
-  /**
-   * Iterates through all the persistent handles in the current isolate's heap
-   * that have class_ids.
-   */
-  void VisitHandlesWithClassIds(PersistentHandleVisitor* visitor);
-
-  /**
-   * Iterates through all the persistent handles in the current isolate's heap
-   * that have class_ids and are candidates to be marked as partially dependent
-   * handles. This will visit handles to young objects created since the last
-   * garbage collection but is free to visit an arbitrary superset of these
-   * objects.
-   */
-  void VisitHandlesForPartialDependence(PersistentHandleVisitor* visitor);
-
-  /**
-   * Iterates through all the persistent handles in the current isolate's heap
-   * that have class_ids and are weak to be marked as inactive if there is no
-   * pending activity for the handle.
-   */
-  void VisitWeakHandles(PersistentHandleVisitor* visitor);
-
-  /**
-   * Check if this isolate is in use.
-   * True if at least one thread Enter'ed this isolate.
-   */
-  bool IsInUse();
-
-  Isolate() = delete;
-  ~Isolate() = delete;
-  Isolate(const Isolate&) = delete;
-  Isolate& operator=(const Isolate&) = delete;
-  void* operator new(size_t size) = delete;
-  void operator delete(void*, size_t) = delete;
-
- private:
-  template <class K, class V, class Traits>
-  friend class PersistentValueMapBase;
-
-  void SetObjectGroupId(internal::Object** object, UniqueId id);
-  void SetReferenceFromGroup(UniqueId id, internal::Object** object);
-  void SetReference(internal::Object** parent, internal::Object** child);
-  void ReportExternalAllocationLimitReached();
-};
-
-class V8_EXPORT StartupData {
- public:
-  const char* data;
-  int raw_size;
-};
-
-
-/**
- * EntropySource is used as a callback function when v8 needs a source
- * of entropy.
- */
-typedef bool (*EntropySource)(unsigned char* buffer, size_t length);
-
-/**
- * ReturnAddressLocationResolver is used as a callback function when v8 is
- * resolving the location of a return address on the stack. Profilers that
- * change the return address on the stack can use this to resolve the stack
- * location to whereever the profiler stashed the original return address.
- *
- * \param return_addr_location A location on stack where a machine
- *    return address resides.
- * \returns Either return_addr_location, or else a pointer to the profiler's
- *    copy of the original return address.
- *
- * \note The resolver function must not cause garbage collection.
- */
-typedef uintptr_t (*ReturnAddressLocationResolver)(
-    uintptr_t return_addr_location);
-
-
-/**
- * Container class for static utility functions.
- */
-class V8_EXPORT V8 {
- public:
-  /** Set the callback to invoke in case of fatal errors. */
-  V8_INLINE static V8_DEPRECATED(
-      "Use isolate version",
-      void SetFatalErrorHandler(FatalErrorCallback that));
-
-  /**
-   * Set the callback to invoke to check if code generation from
-   * strings should be allowed.
-   */
-  V8_INLINE static V8_DEPRECATED(
-      "Use isolate version", void SetAllowCodeGenerationFromStringsCallback(
-                                 AllowCodeGenerationFromStringsCallback that));
-
-  /**
-  * Check if V8 is dead and therefore unusable.  This is the case after
-  * fatal errors such as out-of-memory situations.
-  */
-  V8_INLINE static V8_DEPRECATED("Use isolate version", bool IsDead());
-
-  /**
-   * Hand startup data to V8, in case the embedder has chosen to build
-   * V8 with external startup data.
-   *
-   * Note:
-   * - By default the startup data is linked into the V8 library, in which
-   *   case this function is not meaningful.
-   * - If this needs to be called, it needs to be called before V8
-   *   tries to make use of its built-ins.
-   * - To avoid unnecessary copies of data, V8 will point directly into the
-   *   given data blob, so pretty please keep it around until V8 exit.
-   * - Compression of the startup blob might be useful, but needs to
-   *   handled entirely on the embedders' side.
-   * - The call will abort if the data is invalid.
-   */
-  static void SetNativesDataBlob(StartupData* startup_blob);
-  static void SetSnapshotDataBlob(StartupData* startup_blob);
-
-  /**
-   * Bootstrap an isolate and a context from scratch to create a startup
-   * snapshot. Include the side-effects of running the optional script.
-   * Returns { NULL, 0 } on failure.
-   * The caller acquires ownership of the data array in the return value.
-   */
-  static StartupData CreateSnapshotDataBlob(const char* embedded_source = NULL);
-
-  /**
-   * Bootstrap an isolate and a context from the cold startup blob, run the
-   * warm-up script to trigger code compilation. The side effects are then
-   * discarded. The resulting startup snapshot will include compiled code.
-   * Returns { NULL, 0 } on failure.
-   * The caller acquires ownership of the data array in the return value.
-   * The argument startup blob is untouched.
-   */
-  static StartupData WarmUpSnapshotDataBlob(StartupData cold_startup_blob,
-                                            const char* warmup_source);
-
-  /**
-   * Adds a message listener.
-   *
-   * The same message listener can be added more than once and in that
-   * case it will be called more than once for each message.
-   *
-   * If data is specified, it will be passed to the callback when it is called.
-   * Otherwise, the exception object will be passed to the callback instead.
-   */
-  V8_INLINE static V8_DEPRECATED(
-      "Use isolate version",
-      bool AddMessageListener(MessageCallback that,
-                              Local<Value> data = Local<Value>()));
-
-  /**
-   * Remove all message listeners from the specified callback function.
-   */
-  V8_INLINE static V8_DEPRECATED(
-      "Use isolate version", void RemoveMessageListeners(MessageCallback that));
-
-  /**
-   * Tells V8 to capture current stack trace when uncaught exception occurs
-   * and report it to the message listeners. The option is off by default.
-   */
-  V8_INLINE static V8_DEPRECATED(
-      "Use isolate version",
-      void SetCaptureStackTraceForUncaughtExceptions(
-          bool capture, int frame_limit = 10,
-          StackTrace::StackTraceOptions options = StackTrace::kOverview));
-
-  /**
-   * Sets V8 flags from a string.
-   */
-  static void SetFlagsFromString(const char* str, int length);
-
-  /**
-   * Sets V8 flags from the command line.
-   */
-  static void SetFlagsFromCommandLine(int* argc,
-                                      char** argv,
-                                      bool remove_flags);
-
-  /** Get the version string. */
-  static const char* GetVersion();
-
-  /** Callback function for reporting failed access checks.*/
-  V8_INLINE static V8_DEPRECATED(
-      "Use isolate version",
-      void SetFailedAccessCheckCallbackFunction(FailedAccessCheckCallback));
-
-  /**
-   * Enables the host application to receive a notification before a
-   * garbage collection.  Allocations are not allowed in the
-   * callback function, you therefore cannot manipulate objects (set
-   * or delete properties for example) since it is possible such
-   * operations will result in the allocation of objects. It is possible
-   * to specify the GCType filter for your callback. But it is not possible to
-   * register the same callback function two times with different
-   * GCType filters.
-   */
-  static V8_DEPRECATED(
-      "Use isolate version",
-      void AddGCPrologueCallback(GCCallback callback,
-                                 GCType gc_type_filter = kGCTypeAll));
-
-  /**
-   * This function removes callback which was installed by
-   * AddGCPrologueCallback function.
-   */
-  V8_INLINE static V8_DEPRECATED(
-      "Use isolate version",
-      void RemoveGCPrologueCallback(GCCallback callback));
-
-  /**
-   * Enables the host application to receive a notification after a
-   * garbage collection.  Allocations are not allowed in the
-   * callback function, you therefore cannot manipulate objects (set
-   * or delete properties for example) since it is possible such
-   * operations will result in the allocation of objects. It is possible
-   * to specify the GCType filter for your callback. But it is not possible to
-   * register the same callback function two times with different
-   * GCType filters.
-   */
-  static V8_DEPRECATED(
-      "Use isolate version",
-      void AddGCEpilogueCallback(GCCallback callback,
-                                 GCType gc_type_filter = kGCTypeAll));
-
-  /**
-   * This function removes callback which was installed by
-   * AddGCEpilogueCallback function.
-   */
-  V8_INLINE static V8_DEPRECATED(
-      "Use isolate version",
-      void RemoveGCEpilogueCallback(GCCallback callback));
-
-  /**
-   * Initializes V8. This function needs to be called before the first Isolate
-   * is created. It always returns true.
-   */
-  static bool Initialize();
-
-  /**
-   * Allows the host application to provide a callback which can be used
-   * as a source of entropy for random number generators.
-   */
-  static void SetEntropySource(EntropySource source);
-
-  /**
-   * Allows the host application to provide a callback that allows v8 to
-   * cooperate with a profiler that rewrites return addresses on stack.
-   */
-  static void SetReturnAddressLocationResolver(
-      ReturnAddressLocationResolver return_address_resolver);
-
-  /**
-   * Forcefully terminate the current thread of JavaScript execution
-   * in the given isolate.
-   *
-   * This method can be used by any thread even if that thread has not
-   * acquired the V8 lock with a Locker object.
-   *
-   * \param isolate The isolate in which to terminate the current JS execution.
-   */
-  V8_INLINE static V8_DEPRECATED("Use isolate version",
-                                 void TerminateExecution(Isolate* isolate));
-
-  /**
-   * Is V8 terminating JavaScript execution.
-   *
-   * Returns true if JavaScript execution is currently terminating
-   * because of a call to TerminateExecution.  In that case there are
-   * still JavaScript frames on the stack and the termination
-   * exception is still active.
-   *
-   * \param isolate The isolate in which to check.
-   */
-  V8_INLINE static V8_DEPRECATED(
-      "Use isolate version",
-      bool IsExecutionTerminating(Isolate* isolate = NULL));
-
-  /**
-   * Resume execution capability in the given isolate, whose execution
-   * was previously forcefully terminated using TerminateExecution().
-   *
-   * When execution is forcefully terminated using TerminateExecution(),
-   * the isolate can not resume execution until all JavaScript frames
-   * have propagated the uncatchable exception which is generated.  This
-   * method allows the program embedding the engine to handle the
-   * termination event and resume execution capability, even if
-   * JavaScript frames remain on the stack.
-   *
-   * This method can be used by any thread even if that thread has not
-   * acquired the V8 lock with a Locker object.
-   *
-   * \param isolate The isolate in which to resume execution capability.
-   */
-  V8_INLINE static V8_DEPRECATED(
-      "Use isolate version", void CancelTerminateExecution(Isolate* isolate));
-
-  /**
-   * Releases any resources used by v8 and stops any utility threads
-   * that may be running.  Note that disposing v8 is permanent, it
-   * cannot be reinitialized.
-   *
-   * It should generally not be necessary to dispose v8 before exiting
-   * a process, this should happen automatically.  It is only necessary
-   * to use if the process needs the resources taken up by v8.
-   */
-  static bool Dispose();
-
-  /**
-   * Iterates through all external resources referenced from current isolate
-   * heap.  GC is not invoked prior to iterating, therefore there is no
-   * guarantee that visited objects are still alive.
-   */
-  V8_INLINE static V8_DEPRECATED(
-      "Use isolate version",
-      void VisitExternalResources(ExternalResourceVisitor* visitor));
-
-  /**
-   * Iterates through all the persistent handles in the current isolate's heap
-   * that have class_ids.
-   */
-  V8_INLINE static V8_DEPRECATED(
-      "Use isolate version",
-      void VisitHandlesWithClassIds(PersistentHandleVisitor* visitor));
-
-  /**
-   * Iterates through all the persistent handles in isolate's heap that have
-   * class_ids.
-   */
-  V8_INLINE static V8_DEPRECATED(
-      "Use isolate version",
-      void VisitHandlesWithClassIds(Isolate* isolate,
-                                    PersistentHandleVisitor* visitor));
-
-  /**
-   * Iterates through all the persistent handles in the current isolate's heap
-   * that have class_ids and are candidates to be marked as partially dependent
-   * handles. This will visit handles to young objects created since the last
-   * garbage collection but is free to visit an arbitrary superset of these
-   * objects.
-   */
-  V8_INLINE static V8_DEPRECATED(
-      "Use isolate version",
-      void VisitHandlesForPartialDependence(Isolate* isolate,
-                                            PersistentHandleVisitor* visitor));
-
-  /**
-   * Initialize the ICU library bundled with V8. The embedder should only
-   * invoke this method when using the bundled ICU. Returns true on success.
-   *
-   * If V8 was compiled with the ICU data in an external file, the location
-   * of the data file has to be provided.
-   */
-  V8_DEPRECATE_SOON(
-      "Use version with default location.",
-      static bool InitializeICU(const char* icu_data_file = nullptr));
-
-  /**
-   * Initialize the ICU library bundled with V8. The embedder should only
-   * invoke this method when using the bundled ICU. If V8 was compiled with
-   * the ICU data in an external file and when the default location of that
-   * file should be used, a path to the executable must be provided.
-   * Returns true on success.
-   *
-   * The default is a file called icudtl.dat side-by-side with the executable.
-   *
-   * Optionally, the location of the data file can be provided to override the
-   * default.
-   */
-  static bool InitializeICUDefaultLocation(const char* exec_path,
-                                           const char* icu_data_file = nullptr);
-
-  /**
-   * Initialize the external startup data. The embedder only needs to
-   * invoke this method when external startup data was enabled in a build.
-   *
-   * If V8 was compiled with the startup data in an external file, then
-   * V8 needs to be given those external files during startup. There are
-   * three ways to do this:
-   * - InitializeExternalStartupData(const char*)
-   *   This will look in the given directory for files "natives_blob.bin"
-   *   and "snapshot_blob.bin" - which is what the default build calls them.
-   * - InitializeExternalStartupData(const char*, const char*)
-   *   As above, but will directly use the two given file names.
-   * - Call SetNativesDataBlob, SetNativesDataBlob.
-   *   This will read the blobs from the given data structures and will
-   *   not perform any file IO.
-   */
-  static void InitializeExternalStartupData(const char* directory_path);
-  static void InitializeExternalStartupData(const char* natives_blob,
-                                            const char* snapshot_blob);
-  /**
-   * Sets the v8::Platform to use. This should be invoked before V8 is
-   * initialized.
-   */
-  static void InitializePlatform(Platform* platform);
-
-  /**
-   * Clears all references to the v8::Platform. This should be invoked after
-   * V8 was disposed.
-   */
-  static void ShutdownPlatform();
-
- private:
-  V8();
-
-  static internal::Object** GlobalizeReference(internal::Isolate* isolate,
-                                               internal::Object** handle);
-  static internal::Object** CopyPersistent(internal::Object** handle);
-  static void DisposeGlobal(internal::Object** global_handle);
-  static void MakeWeak(internal::Object** location, void* data,
-                       WeakCallbackInfo<void>::Callback weak_callback,
-                       WeakCallbackType type);
-  static void MakeWeak(internal::Object** location, void* data,
-                       // Must be 0 or -1.
-                       int internal_field_index1,
-                       // Must be 1 or -1.
-                       int internal_field_index2,
-                       WeakCallbackInfo<void>::Callback weak_callback);
-  static void MakeWeak(internal::Object*** location_addr);
-  static void* ClearWeak(internal::Object** location);
-  static void Eternalize(Isolate* isolate,
-                         Value* handle,
-                         int* index);
-  static Local<Value> GetEternal(Isolate* isolate, int index);
-
-  static void RegisterExternallyReferencedObject(internal::Object** object,
-                                                 internal::Isolate* isolate);
-
-  template <class K, class V, class T>
-  friend class PersistentValueMapBase;
-
-  static void FromJustIsNothing();
-  static void ToLocalEmpty();
-  static void InternalFieldOutOfBounds(int index);
-  template <class T> friend class Local;
-  template <class T>
-  friend class MaybeLocal;
-  template <class T>
-  friend class Maybe;
-  template <class T>
-  friend class WeakCallbackInfo;
-  template <class T> friend class Eternal;
-  template <class T> friend class PersistentBase;
-  template <class T, class M> friend class Persistent;
-  friend class Context;
-};
-
-/**
- * Helper class to create a snapshot data blob.
- */
-class V8_EXPORT SnapshotCreator {
- public:
-  enum class FunctionCodeHandling { kClear, kKeep };
-
-  /**
-   * Create and enter an isolate, and set it up for serialization.
-   * The isolate is either created from scratch or from an existing snapshot.
-   * The caller keeps ownership of the argument snapshot.
-   * \param existing_blob existing snapshot from which to create this one.
-   * \param external_references a null-terminated array of external references
-   *        that must be equivalent to CreateParams::external_references.
-   */
-  SnapshotCreator(intptr_t* external_references = nullptr,
-                  StartupData* existing_blob = nullptr);
-
-  ~SnapshotCreator();
-
-  /**
-   * \returns the isolate prepared by the snapshot creator.
-   */
-  Isolate* GetIsolate();
-
-  /**
-   * Set the default context to be included in the snapshot blob.
-   * The snapshot will not contain the global proxy, and we expect one or a
-   * global object template to create one, to be provided upon deserialization.
-   */
-  void SetDefaultContext(Local<Context> context);
-
-  /**
-   * Add additional context to be included in the snapshot blob.
-   * The snapshot will include the global proxy.
-   *
-   * \param callback optional callback to serialize internal fields.
-   *
-   * \returns the index of the context in the snapshot blob.
-   */
-  size_t AddContext(Local<Context> context,
-                    SerializeInternalFieldsCallback callback =
-                        SerializeInternalFieldsCallback());
-
-  /**
-   * Add a template to be included in the snapshot blob.
-   * \returns the index of the template in the snapshot blob.
-   */
-  size_t AddTemplate(Local<Template> template_obj);
-
-  /**
-   * Created a snapshot data blob.
-   * This must not be called from within a handle scope.
-   * \param function_code_handling whether to include compiled function code
-   *        in the snapshot.
-   * \returns { nullptr, 0 } on failure, and a startup snapshot on success. The
-   *        caller acquires ownership of the data array in the return value.
-   */
-  StartupData CreateBlob(FunctionCodeHandling function_code_handling);
-
-  // Disallow copying and assigning.
-  SnapshotCreator(const SnapshotCreator&) = delete;
-  void operator=(const SnapshotCreator&) = delete;
-
- private:
-  void* data_;
-};
-
-/**
- * A simple Maybe type, representing an object which may or may not have a
- * value, see https://hackage.haskell.org/package/base/docs/Data-Maybe.html.
- *
- * If an API method returns a Maybe<>, the API method can potentially fail
- * either because an exception is thrown, or because an exception is pending,
- * e.g. because a previous API call threw an exception that hasn't been caught
- * yet, or because a TerminateExecution exception was thrown. In that case, a
- * "Nothing" value is returned.
- */
-template <class T>
-class Maybe {
- public:
-  V8_INLINE bool IsNothing() const { return !has_value_; }
-  V8_INLINE bool IsJust() const { return has_value_; }
-
-  // Will crash if the Maybe<> is nothing.
-  V8_INLINE T ToChecked() const { return FromJust(); }
-
-  V8_WARN_UNUSED_RESULT V8_INLINE bool To(T* out) const {
-    if (V8_LIKELY(IsJust())) *out = value_;
-    return IsJust();
-  }
-
-  // Will crash if the Maybe<> is nothing.
-  V8_INLINE T FromJust() const {
-    if (V8_UNLIKELY(!IsJust())) V8::FromJustIsNothing();
-    return value_;
-  }
-
-  V8_INLINE T FromMaybe(const T& default_value) const {
-    return has_value_ ? value_ : default_value;
-  }
-
-  V8_INLINE bool operator==(const Maybe& other) const {
-    return (IsJust() == other.IsJust()) &&
-           (!IsJust() || FromJust() == other.FromJust());
-  }
-
-  V8_INLINE bool operator!=(const Maybe& other) const {
-    return !operator==(other);
-  }
-
- private:
-  Maybe() : has_value_(false) {}
-  explicit Maybe(const T& t) : has_value_(true), value_(t) {}
-
-  bool has_value_;
-  T value_;
-
-  template <class U>
-  friend Maybe<U> Nothing();
-  template <class U>
-  friend Maybe<U> Just(const U& u);
-};
-
-
-template <class T>
-inline Maybe<T> Nothing() {
-  return Maybe<T>();
-}
-
-
-template <class T>
-inline Maybe<T> Just(const T& t) {
-  return Maybe<T>(t);
-}
-
-
-/**
- * An external exception handler.
- */
-class V8_EXPORT TryCatch {
- public:
-  /**
-   * Creates a new try/catch block and registers it with v8.  Note that
-   * all TryCatch blocks should be stack allocated because the memory
-   * location itself is compared against JavaScript try/catch blocks.
-   */
-  V8_DEPRECATED("Use isolate version", TryCatch());
-
-  /**
-   * Creates a new try/catch block and registers it with v8.  Note that
-   * all TryCatch blocks should be stack allocated because the memory
-   * location itself is compared against JavaScript try/catch blocks.
-   */
-  TryCatch(Isolate* isolate);
-
-  /**
-   * Unregisters and deletes this try/catch block.
-   */
-  ~TryCatch();
-
-  /**
-   * Returns true if an exception has been caught by this try/catch block.
-   */
-  bool HasCaught() const;
-
-  /**
-   * For certain types of exceptions, it makes no sense to continue execution.
-   *
-   * If CanContinue returns false, the correct action is to perform any C++
-   * cleanup needed and then return.  If CanContinue returns false and
-   * HasTerminated returns true, it is possible to call
-   * CancelTerminateExecution in order to continue calling into the engine.
-   */
-  bool CanContinue() const;
-
-  /**
-   * Returns true if an exception has been caught due to script execution
-   * being terminated.
-   *
-   * There is no JavaScript representation of an execution termination
-   * exception.  Such exceptions are thrown when the TerminateExecution
-   * methods are called to terminate a long-running script.
-   *
-   * If such an exception has been thrown, HasTerminated will return true,
-   * indicating that it is possible to call CancelTerminateExecution in order
-   * to continue calling into the engine.
-   */
-  bool HasTerminated() const;
-
-  /**
-   * Throws the exception caught by this TryCatch in a way that avoids
-   * it being caught again by this same TryCatch.  As with ThrowException
-   * it is illegal to execute any JavaScript operations after calling
-   * ReThrow; the caller must return immediately to where the exception
-   * is caught.
-   */
-  Local<Value> ReThrow();
-
-  /**
-   * Returns the exception caught by this try/catch block.  If no exception has
-   * been caught an empty handle is returned.
-   *
-   * The returned handle is valid until this TryCatch block has been destroyed.
-   */
-  Local<Value> Exception() const;
-
-  /**
-   * Returns the .stack property of the thrown object.  If no .stack
-   * property is present an empty handle is returned.
-   */
-  V8_DEPRECATE_SOON("Use maybe version.", Local<Value> StackTrace() const);
-  V8_WARN_UNUSED_RESULT MaybeLocal<Value> StackTrace(
-      Local<Context> context) const;
-
-  /**
-   * Returns the message associated with this exception.  If there is
-   * no message associated an empty handle is returned.
-   *
-   * The returned handle is valid until this TryCatch block has been
-   * destroyed.
-   */
-  Local<v8::Message> Message() const;
-
-  /**
-   * Clears any exceptions that may have been caught by this try/catch block.
-   * After this method has been called, HasCaught() will return false. Cancels
-   * the scheduled exception if it is caught and ReThrow() is not called before.
-   *
-   * It is not necessary to clear a try/catch block before using it again; if
-   * another exception is thrown the previously caught exception will just be
-   * overwritten.  However, it is often a good idea since it makes it easier
-   * to determine which operation threw a given exception.
-   */
-  void Reset();
-
-  /**
-   * Set verbosity of the external exception handler.
-   *
-   * By default, exceptions that are caught by an external exception
-   * handler are not reported.  Call SetVerbose with true on an
-   * external exception handler to have exceptions caught by the
-   * handler reported as if they were not caught.
-   */
-  void SetVerbose(bool value);
-
-  /**
-   * Set whether or not this TryCatch should capture a Message object
-   * which holds source information about where the exception
-   * occurred.  True by default.
-   */
-  void SetCaptureMessage(bool value);
-
-  /**
-   * There are cases when the raw address of C++ TryCatch object cannot be
-   * used for comparisons with addresses into the JS stack. The cases are:
-   * 1) ARM, ARM64 and MIPS simulators which have separate JS stack.
-   * 2) Address sanitizer allocates local C++ object in the heap when
-   *    UseAfterReturn mode is enabled.
-   * This method returns address that can be used for comparisons with
-   * addresses into the JS stack. When neither simulator nor ASAN's
-   * UseAfterReturn is enabled, then the address returned will be the address
-   * of the C++ try catch handler itself.
-   */
-  static void* JSStackComparableAddress(TryCatch* handler) {
-    if (handler == NULL) return NULL;
-    return handler->js_stack_comparable_address_;
-  }
-
-  TryCatch(const TryCatch&) = delete;
-  void operator=(const TryCatch&) = delete;
-  void* operator new(size_t size);
-  void operator delete(void*, size_t);
-
- private:
-  void ResetInternal();
-
-  internal::Isolate* isolate_;
-  TryCatch* next_;
-  void* exception_;
-  void* message_obj_;
-  void* js_stack_comparable_address_;
-  bool is_verbose_ : 1;
-  bool can_continue_ : 1;
-  bool capture_message_ : 1;
-  bool rethrow_ : 1;
-  bool has_terminated_ : 1;
-
-  friend class internal::Isolate;
-};
-
-
-// --- Context ---
-
-
-/**
- * A container for extension names.
- */
-class V8_EXPORT ExtensionConfiguration {
- public:
-  ExtensionConfiguration() : name_count_(0), names_(NULL) { }
-  ExtensionConfiguration(int name_count, const char* names[])
-      : name_count_(name_count), names_(names) { }
-
-  const char** begin() const { return &names_[0]; }
-  const char** end()  const { return &names_[name_count_]; }
-
- private:
-  const int name_count_;
-  const char** names_;
-};
-
-/**
- * A sandboxed execution context with its own set of built-in objects
- * and functions.
- */
-class V8_EXPORT Context {
- public:
-  /**
-   * Returns the global proxy object.
-   *
-   * Global proxy object is a thin wrapper whose prototype points to actual
-   * context's global object with the properties like Object, etc. This is done
-   * that way for security reasons (for more details see
-   * https://wiki.mozilla.org/Gecko:SplitWindow).
-   *
-   * Please note that changes to global proxy object prototype most probably
-   * would break VM---v8 expects only global object as a prototype of global
-   * proxy object.
-   */
-  Local<Object> Global();
-
-  /**
-   * Detaches the global object from its context before
-   * the global object can be reused to create a new context.
-   */
-  void DetachGlobal();
-
-  /**
-   * Creates a new context and returns a handle to the newly allocated
-   * context.
-   *
-   * \param isolate The isolate in which to create the context.
-   *
-   * \param extensions An optional extension configuration containing
-   * the extensions to be installed in the newly created context.
-   *
-   * \param global_template An optional object template from which the
-   * global object for the newly created context will be created.
-   *
-   * \param global_object An optional global object to be reused for
-   * the newly created context. This global object must have been
-   * created by a previous call to Context::New with the same global
-   * template. The state of the global object will be completely reset
-   * and only object identify will remain.
-   */
-  static Local<Context> New(
-      Isolate* isolate, ExtensionConfiguration* extensions = NULL,
-      MaybeLocal<ObjectTemplate> global_template = MaybeLocal<ObjectTemplate>(),
-      MaybeLocal<Value> global_object = MaybeLocal<Value>());
-
-  /**
-   * Create a new context from a (non-default) context snapshot. There
-   * is no way to provide a global object template since we do not create
-   * a new global object from template, but we can reuse a global object.
-   *
-   * \param isolate See v8::Context::New.
-   *
-   * \param context_snapshot_index The index of the context snapshot to
-   * deserialize from. Use v8::Context::New for the default snapshot.
-   *
-   * \param internal_fields_deserializer Optional callback to deserialize
-   * internal fields. It should match the SerializeInternalFieldCallback used
-   * to serialize.
-   *
-   * \param extensions See v8::Context::New.
-   *
-   * \param global_object See v8::Context::New.
-   */
-
-  static MaybeLocal<Context> FromSnapshot(
-      Isolate* isolate, size_t context_snapshot_index,
-      DeserializeInternalFieldsCallback internal_fields_deserializer =
-          DeserializeInternalFieldsCallback(),
-      ExtensionConfiguration* extensions = nullptr,
-      MaybeLocal<Value> global_object = MaybeLocal<Value>());
-
-  /**
-   * Returns an global object that isn't backed by an actual context.
-   *
-   * The global template needs to have access checks with handlers installed.
-   * If an existing global object is passed in, the global object is detached
-   * from its context.
-   *
-   * Note that this is different from a detached context where all accesses to
-   * the global proxy will fail. Instead, the access check handlers are invoked.
-   *
-   * It is also not possible to detach an object returned by this method.
-   * Instead, the access check handlers need to return nothing to achieve the
-   * same effect.
-   *
-   * It is possible, however, to create a new context from the global object
-   * returned by this method.
-   */
-  static MaybeLocal<Object> NewRemoteContext(
-      Isolate* isolate, Local<ObjectTemplate> global_template,
-      MaybeLocal<Value> global_object = MaybeLocal<Value>());
-
-  /**
-   * Sets the security token for the context.  To access an object in
-   * another context, the security tokens must match.
-   */
-  void SetSecurityToken(Local<Value> token);
-
-  /** Restores the security token to the default value. */
-  void UseDefaultSecurityToken();
-
-  /** Returns the security token of this context.*/
-  Local<Value> GetSecurityToken();
-
-  /**
-   * Enter this context.  After entering a context, all code compiled
-   * and run is compiled and run in this context.  If another context
-   * is already entered, this old context is saved so it can be
-   * restored when the new context is exited.
-   */
-  void Enter();
-
-  /**
-   * Exit this context.  Exiting the current context restores the
-   * context that was in place when entering the current context.
-   */
-  void Exit();
-
-  /** Returns an isolate associated with a current context. */
-  Isolate* GetIsolate();
-
-  /**
-   * The field at kDebugIdIndex is reserved for V8 debugger implementation.
-   * The value is propagated to the scripts compiled in given Context and
-   * can be used for filtering scripts.
-   */
-  enum EmbedderDataFields { kDebugIdIndex = 0 };
-
-  /**
-   * Gets the embedder data with the given index, which must have been set by a
-   * previous call to SetEmbedderData with the same index. Note that index 0
-   * currently has a special meaning for Chrome's debugger.
-   */
-  V8_INLINE Local<Value> GetEmbedderData(int index);
-
-  /**
-   * Gets the binding object used by V8 extras. Extra natives get a reference
-   * to this object and can use it to "export" functionality by adding
-   * properties. Extra natives can also "import" functionality by accessing
-   * properties added by the embedder using the V8 API.
-   */
-  Local<Object> GetExtrasBindingObject();
-
-  /**
-   * Sets the embedder data with the given index, growing the data as
-   * needed. Note that index 0 currently has a special meaning for Chrome's
-   * debugger.
-   */
-  void SetEmbedderData(int index, Local<Value> value);
-
-  /**
-   * Gets a 2-byte-aligned native pointer from the embedder data with the given
-   * index, which must have been set by a previous call to
-   * SetAlignedPointerInEmbedderData with the same index. Note that index 0
-   * currently has a special meaning for Chrome's debugger.
-   */
-  V8_INLINE void* GetAlignedPointerFromEmbedderData(int index);
-
-  /**
-   * Sets a 2-byte-aligned native pointer in the embedder data with the given
-   * index, growing the data as needed. Note that index 0 currently has a
-   * special meaning for Chrome's debugger.
-   */
-  void SetAlignedPointerInEmbedderData(int index, void* value);
-
-  /**
-   * Control whether code generation from strings is allowed. Calling
-   * this method with false will disable 'eval' and the 'Function'
-   * constructor for code running in this context. If 'eval' or the
-   * 'Function' constructor are used an exception will be thrown.
-   *
-   * If code generation from strings is not allowed the
-   * V8::AllowCodeGenerationFromStrings callback will be invoked if
-   * set before blocking the call to 'eval' or the 'Function'
-   * constructor. If that callback returns true, the call will be
-   * allowed, otherwise an exception will be thrown. If no callback is
-   * set an exception will be thrown.
-   */
-  void AllowCodeGenerationFromStrings(bool allow);
-
-  /**
-   * Returns true if code generation from strings is allowed for the context.
-   * For more details see AllowCodeGenerationFromStrings(bool) documentation.
-   */
-  bool IsCodeGenerationFromStringsAllowed();
-
-  /**
-   * Sets the error description for the exception that is thrown when
-   * code generation from strings is not allowed and 'eval' or the 'Function'
-   * constructor are called.
-   */
-  void SetErrorMessageForCodeGenerationFromStrings(Local<String> message);
-
-  /**
-   * Estimate the memory in bytes retained by this context.
-   */
-  size_t EstimatedSize();
-
-  /**
-   * Stack-allocated class which sets the execution context for all
-   * operations executed within a local scope.
-   */
-  class Scope {
-   public:
-    explicit V8_INLINE Scope(Local<Context> context) : context_(context) {
-      context_->Enter();
-    }
-    V8_INLINE ~Scope() { context_->Exit(); }
-
-   private:
-    Local<Context> context_;
-  };
-
- private:
-  friend class Value;
-  friend class Script;
-  friend class Object;
-  friend class Function;
-
-  Local<Value> SlowGetEmbedderData(int index);
-  void* SlowGetAlignedPointerFromEmbedderData(int index);
-};
-
-
-/**
- * Multiple threads in V8 are allowed, but only one thread at a time is allowed
- * to use any given V8 isolate, see the comments in the Isolate class. The
- * definition of 'using a V8 isolate' includes accessing handles or holding onto
- * object pointers obtained from V8 handles while in the particular V8 isolate.
- * It is up to the user of V8 to ensure, perhaps with locking, that this
- * constraint is not violated. In addition to any other synchronization
- * mechanism that may be used, the v8::Locker and v8::Unlocker classes must be
- * used to signal thread switches to V8.
- *
- * v8::Locker is a scoped lock object. While it's active, i.e. between its
- * construction and destruction, the current thread is allowed to use the locked
- * isolate. V8 guarantees that an isolate can be locked by at most one thread at
- * any time. In other words, the scope of a v8::Locker is a critical section.
- *
- * Sample usage:
-* \code
- * ...
- * {
- *   v8::Locker locker(isolate);
- *   v8::Isolate::Scope isolate_scope(isolate);
- *   ...
- *   // Code using V8 and isolate goes here.
- *   ...
- * } // Destructor called here
- * \endcode
- *
- * If you wish to stop using V8 in a thread A you can do this either by
- * destroying the v8::Locker object as above or by constructing a v8::Unlocker
- * object:
- *
- * \code
- * {
- *   isolate->Exit();
- *   v8::Unlocker unlocker(isolate);
- *   ...
- *   // Code not using V8 goes here while V8 can run in another thread.
- *   ...
- * } // Destructor called here.
- * isolate->Enter();
- * \endcode
- *
- * The Unlocker object is intended for use in a long-running callback from V8,
- * where you want to release the V8 lock for other threads to use.
- *
- * The v8::Locker is a recursive lock, i.e. you can lock more than once in a
- * given thread. This can be useful if you have code that can be called either
- * from code that holds the lock or from code that does not. The Unlocker is
- * not recursive so you can not have several Unlockers on the stack at once, and
- * you can not use an Unlocker in a thread that is not inside a Locker's scope.
- *
- * An unlocker will unlock several lockers if it has to and reinstate the
- * correct depth of locking on its destruction, e.g.:
- *
- * \code
- * // V8 not locked.
- * {
- *   v8::Locker locker(isolate);
- *   Isolate::Scope isolate_scope(isolate);
- *   // V8 locked.
- *   {
- *     v8::Locker another_locker(isolate);
- *     // V8 still locked (2 levels).
- *     {
- *       isolate->Exit();
- *       v8::Unlocker unlocker(isolate);
- *       // V8 not locked.
- *     }
- *     isolate->Enter();
- *     // V8 locked again (2 levels).
- *   }
- *   // V8 still locked (1 level).
- * }
- * // V8 Now no longer locked.
- * \endcode
- */
-class V8_EXPORT Unlocker {
- public:
-  /**
-   * Initialize Unlocker for a given Isolate.
-   */
-  V8_INLINE explicit Unlocker(Isolate* isolate) { Initialize(isolate); }
-
-  ~Unlocker();
- private:
-  void Initialize(Isolate* isolate);
-
-  internal::Isolate* isolate_;
-};
-
-
-class V8_EXPORT Locker {
- public:
-  /**
-   * Initialize Locker for a given Isolate.
-   */
-  V8_INLINE explicit Locker(Isolate* isolate) { Initialize(isolate); }
-
-  ~Locker();
-
-  /**
-   * Returns whether or not the locker for a given isolate, is locked by the
-   * current thread.
-   */
-  static bool IsLocked(Isolate* isolate);
-
-  /**
-   * Returns whether v8::Locker is being used by this V8 instance.
-   */
-  static bool IsActive();
-
-  // Disallow copying and assigning.
-  Locker(const Locker&) = delete;
-  void operator=(const Locker&) = delete;
-
- private:
-  void Initialize(Isolate* isolate);
-
-  bool has_lock_;
-  bool top_level_;
-  internal::Isolate* isolate_;
-};
-
-
-// --- Implementation ---
-
-
-namespace internal {
-
-const int kApiPointerSize = sizeof(void*);  // NOLINT
-const int kApiIntSize = sizeof(int);  // NOLINT
-const int kApiInt64Size = sizeof(int64_t);  // NOLINT
-
-// Tag information for HeapObject.
-const int kHeapObjectTag = 1;
-const int kHeapObjectTagSize = 2;
-const intptr_t kHeapObjectTagMask = (1 << kHeapObjectTagSize) - 1;
-
-// Tag information for Smi.
-const int kSmiTag = 0;
-const int kSmiTagSize = 1;
-const intptr_t kSmiTagMask = (1 << kSmiTagSize) - 1;
-
-template <size_t ptr_size> struct SmiTagging;
-
-template<int kSmiShiftSize>
-V8_INLINE internal::Object* IntToSmi(int value) {
-  int smi_shift_bits = kSmiTagSize + kSmiShiftSize;
-  uintptr_t tagged_value =
-      (static_cast<uintptr_t>(value) << smi_shift_bits) | kSmiTag;
-  return reinterpret_cast<internal::Object*>(tagged_value);
-}
-
-// Smi constants for 32-bit systems.
-template <> struct SmiTagging<4> {
-  enum { kSmiShiftSize = 0, kSmiValueSize = 31 };
-  static int SmiShiftSize() { return kSmiShiftSize; }
-  static int SmiValueSize() { return kSmiValueSize; }
-  V8_INLINE static int SmiToInt(const internal::Object* value) {
-    int shift_bits = kSmiTagSize + kSmiShiftSize;
-    // Throw away top 32 bits and shift down (requires >> to be sign extending).
-    return static_cast<int>(reinterpret_cast<intptr_t>(value)) >> shift_bits;
-  }
-  V8_INLINE static internal::Object* IntToSmi(int value) {
-    return internal::IntToSmi<kSmiShiftSize>(value);
-  }
-  V8_INLINE static bool IsValidSmi(intptr_t value) {
-    // To be representable as an tagged small integer, the two
-    // most-significant bits of 'value' must be either 00 or 11 due to
-    // sign-extension. To check this we add 01 to the two
-    // most-significant bits, and check if the most-significant bit is 0
-    //
-    // CAUTION: The original code below:
-    // bool result = ((value + 0x40000000) & 0x80000000) == 0;
-    // may lead to incorrect results according to the C language spec, and
-    // in fact doesn't work correctly with gcc4.1.1 in some cases: The
-    // compiler may produce undefined results in case of signed integer
-    // overflow. The computation must be done w/ unsigned ints.
-    return static_cast<uintptr_t>(value + 0x40000000U) < 0x80000000U;
-  }
-};
-
-// Smi constants for 64-bit systems.
-template <> struct SmiTagging<8> {
-  enum { kSmiShiftSize = 31, kSmiValueSize = 32 };
-  static int SmiShiftSize() { return kSmiShiftSize; }
-  static int SmiValueSize() { return kSmiValueSize; }
-  V8_INLINE static int SmiToInt(const internal::Object* value) {
-    int shift_bits = kSmiTagSize + kSmiShiftSize;
-    // Shift down and throw away top 32 bits.
-    return static_cast<int>(reinterpret_cast<intptr_t>(value) >> shift_bits);
-  }
-  V8_INLINE static internal::Object* IntToSmi(int value) {
-    return internal::IntToSmi<kSmiShiftSize>(value);
-  }
-  V8_INLINE static bool IsValidSmi(intptr_t value) {
-    // To be representable as a long smi, the value must be a 32-bit integer.
-    return (value == static_cast<int32_t>(value));
-  }
-};
-
-typedef SmiTagging<kApiPointerSize> PlatformSmiTagging;
-const int kSmiShiftSize = PlatformSmiTagging::kSmiShiftSize;
-const int kSmiValueSize = PlatformSmiTagging::kSmiValueSize;
-V8_INLINE static bool SmiValuesAre31Bits() { return kSmiValueSize == 31; }
-V8_INLINE static bool SmiValuesAre32Bits() { return kSmiValueSize == 32; }
-
-/**
- * This class exports constants and functionality from within v8 that
- * is necessary to implement inline functions in the v8 api.  Don't
- * depend on functions and constants defined here.
- */
-class Internals {
- public:
-  // These values match non-compiler-dependent values defined within
-  // the implementation of v8.
-  static const int kHeapObjectMapOffset = 0;
-  static const int kMapInstanceTypeAndBitFieldOffset =
-      1 * kApiPointerSize + kApiIntSize;
-  static const int kStringResourceOffset = 3 * kApiPointerSize;
-
-  static const int kOddballKindOffset = 4 * kApiPointerSize + sizeof(double);
-  static const int kForeignAddressOffset = kApiPointerSize;
-  static const int kJSObjectHeaderSize = 3 * kApiPointerSize;
-  static const int kFixedArrayHeaderSize = 2 * kApiPointerSize;
-  static const int kContextHeaderSize = 2 * kApiPointerSize;
-  static const int kContextEmbedderDataIndex = 5;
-  static const int kFullStringRepresentationMask = 0x0f;
-  static const int kStringEncodingMask = 0x8;
-  static const int kExternalTwoByteRepresentationTag = 0x02;
-  static const int kExternalOneByteRepresentationTag = 0x0a;
-
-  static const int kIsolateEmbedderDataOffset = 0 * kApiPointerSize;
-  static const int kExternalMemoryOffset = 4 * kApiPointerSize;
-  static const int kExternalMemoryLimitOffset =
-      kExternalMemoryOffset + kApiInt64Size;
-  static const int kIsolateRootsOffset = kExternalMemoryLimitOffset +
-                                         kApiInt64Size + kApiInt64Size +
-                                         kApiPointerSize + kApiPointerSize;
-  static const int kUndefinedValueRootIndex = 4;
-  static const int kTheHoleValueRootIndex = 5;
-  static const int kNullValueRootIndex = 6;
-  static const int kTrueValueRootIndex = 7;
-  static const int kFalseValueRootIndex = 8;
-  static const int kEmptyStringRootIndex = 9;
-
-  static const int kNodeClassIdOffset = 1 * kApiPointerSize;
-  static const int kNodeFlagsOffset = 1 * kApiPointerSize + 3;
-  static const int kNodeStateMask = 0x7;
-  static const int kNodeStateIsWeakValue = 2;
-  static const int kNodeStateIsPendingValue = 3;
-  static const int kNodeStateIsNearDeathValue = 4;
-  static const int kNodeIsIndependentShift = 3;
-  static const int kNodeIsActiveShift = 4;
-
-  static const int kJSApiObjectType = 0xb9;
-  static const int kJSObjectType = 0xba;
-  static const int kFirstNonstringType = 0x80;
-  static const int kOddballType = 0x82;
-  static const int kForeignType = 0x86;
-
-  static const int kUndefinedOddballKind = 5;
-  static const int kNullOddballKind = 3;
-
-  static const uint32_t kNumIsolateDataSlots = 4;
-
-  V8_EXPORT static void CheckInitializedImpl(v8::Isolate* isolate);
-  V8_INLINE static void CheckInitialized(v8::Isolate* isolate) {
-#ifdef V8_ENABLE_CHECKS
-    CheckInitializedImpl(isolate);
-#endif
-  }
-
-  V8_INLINE static bool HasHeapObjectTag(const internal::Object* value) {
-    return ((reinterpret_cast<intptr_t>(value) & kHeapObjectTagMask) ==
-            kHeapObjectTag);
-  }
-
-  V8_INLINE static int SmiValue(const internal::Object* value) {
-    return PlatformSmiTagging::SmiToInt(value);
-  }
-
-  V8_INLINE static internal::Object* IntToSmi(int value) {
-    return PlatformSmiTagging::IntToSmi(value);
-  }
-
-  V8_INLINE static bool IsValidSmi(intptr_t value) {
-    return PlatformSmiTagging::IsValidSmi(value);
-  }
-
-  V8_INLINE static int GetInstanceType(const internal::Object* obj) {
-    typedef internal::Object O;
-    O* map = ReadField<O*>(obj, kHeapObjectMapOffset);
-    // Map::InstanceType is defined so that it will always be loaded into
-    // the LS 8 bits of one 16-bit word, regardless of endianess.
-    return ReadField<uint16_t>(map, kMapInstanceTypeAndBitFieldOffset) & 0xff;
-  }
-
-  V8_INLINE static int GetOddballKind(const internal::Object* obj) {
-    typedef internal::Object O;
-    return SmiValue(ReadField<O*>(obj, kOddballKindOffset));
-  }
-
-  V8_INLINE static bool IsExternalTwoByteString(int instance_type) {
-    int representation = (instance_type & kFullStringRepresentationMask);
-    return representation == kExternalTwoByteRepresentationTag;
-  }
-
-  V8_INLINE static uint8_t GetNodeFlag(internal::Object** obj, int shift) {
-      uint8_t* addr = reinterpret_cast<uint8_t*>(obj) + kNodeFlagsOffset;
-      return *addr & static_cast<uint8_t>(1U << shift);
-  }
-
-  V8_INLINE static void UpdateNodeFlag(internal::Object** obj,
-                                       bool value, int shift) {
-      uint8_t* addr = reinterpret_cast<uint8_t*>(obj) + kNodeFlagsOffset;
-      uint8_t mask = static_cast<uint8_t>(1U << shift);
-      *addr = static_cast<uint8_t>((*addr & ~mask) | (value << shift));
-  }
-
-  V8_INLINE static uint8_t GetNodeState(internal::Object** obj) {
-    uint8_t* addr = reinterpret_cast<uint8_t*>(obj) + kNodeFlagsOffset;
-    return *addr & kNodeStateMask;
-  }
-
-  V8_INLINE static void UpdateNodeState(internal::Object** obj,
-                                        uint8_t value) {
-    uint8_t* addr = reinterpret_cast<uint8_t*>(obj) + kNodeFlagsOffset;
-    *addr = static_cast<uint8_t>((*addr & ~kNodeStateMask) | value);
-  }
-
-  V8_INLINE static void SetEmbedderData(v8::Isolate* isolate,
-                                        uint32_t slot,
-                                        void* data) {
-    uint8_t* addr = reinterpret_cast<uint8_t*>(isolate) +
-                    kIsolateEmbedderDataOffset + slot * kApiPointerSize;
-    *reinterpret_cast<void**>(addr) = data;
-  }
-
-  V8_INLINE static void* GetEmbedderData(const v8::Isolate* isolate,
-                                         uint32_t slot) {
-    const uint8_t* addr = reinterpret_cast<const uint8_t*>(isolate) +
-        kIsolateEmbedderDataOffset + slot * kApiPointerSize;
-    return *reinterpret_cast<void* const*>(addr);
-  }
-
-  V8_INLINE static internal::Object** GetRoot(v8::Isolate* isolate,
-                                              int index) {
-    uint8_t* addr = reinterpret_cast<uint8_t*>(isolate) + kIsolateRootsOffset;
-    return reinterpret_cast<internal::Object**>(addr + index * kApiPointerSize);
-  }
-
-  template <typename T>
-  V8_INLINE static T ReadField(const internal::Object* ptr, int offset) {
-    const uint8_t* addr =
-        reinterpret_cast<const uint8_t*>(ptr) + offset - kHeapObjectTag;
-    return *reinterpret_cast<const T*>(addr);
-  }
-
-  template <typename T>
-  V8_INLINE static T ReadEmbedderData(const v8::Context* context, int index) {
-    typedef internal::Object O;
-    typedef internal::Internals I;
-    O* ctx = *reinterpret_cast<O* const*>(context);
-    int embedder_data_offset = I::kContextHeaderSize +
-        (internal::kApiPointerSize * I::kContextEmbedderDataIndex);
-    O* embedder_data = I::ReadField<O*>(ctx, embedder_data_offset);
-    int value_offset =
-        I::kFixedArrayHeaderSize + (internal::kApiPointerSize * index);
-    return I::ReadField<T>(embedder_data, value_offset);
-  }
-};
-
-}  // namespace internal
-
-
-template <class T>
-Local<T> Local<T>::New(Isolate* isolate, Local<T> that) {
-  return New(isolate, that.val_);
-}
-
-template <class T>
-Local<T> Local<T>::New(Isolate* isolate, const PersistentBase<T>& that) {
-  return New(isolate, that.val_);
-}
-
-
-template <class T>
-Local<T> Local<T>::New(Isolate* isolate, T* that) {
-  if (that == NULL) return Local<T>();
-  T* that_ptr = that;
-  internal::Object** p = reinterpret_cast<internal::Object**>(that_ptr);
-  return Local<T>(reinterpret_cast<T*>(HandleScope::CreateHandle(
-      reinterpret_cast<internal::Isolate*>(isolate), *p)));
-}
-
-
-template<class T>
-template<class S>
-void Eternal<T>::Set(Isolate* isolate, Local<S> handle) {
-  TYPE_CHECK(T, S);
-  V8::Eternalize(isolate, reinterpret_cast<Value*>(*handle), &this->index_);
-}
-
-
-template<class T>
-Local<T> Eternal<T>::Get(Isolate* isolate) {
-  return Local<T>(reinterpret_cast<T*>(*V8::GetEternal(isolate, index_)));
-}
-
-
-template <class T>
-Local<T> MaybeLocal<T>::ToLocalChecked() {
-  if (V8_UNLIKELY(val_ == nullptr)) V8::ToLocalEmpty();
-  return Local<T>(val_);
-}
-
-
-template <class T>
-void* WeakCallbackInfo<T>::GetInternalField(int index) const {
-#ifdef V8_ENABLE_CHECKS
-  if (index < 0 || index >= kInternalFieldsInWeakCallback) {
-    V8::InternalFieldOutOfBounds(index);
-  }
-#endif
-  return internal_fields_[index];
-}
-
-
-template <class T>
-T* PersistentBase<T>::New(Isolate* isolate, T* that) {
-  if (that == NULL) return NULL;
-  internal::Object** p = reinterpret_cast<internal::Object**>(that);
-  return reinterpret_cast<T*>(
-      V8::GlobalizeReference(reinterpret_cast<internal::Isolate*>(isolate),
-                             p));
-}
-
-
-template <class T, class M>
-template <class S, class M2>
-void Persistent<T, M>::Copy(const Persistent<S, M2>& that) {
-  TYPE_CHECK(T, S);
-  this->Reset();
-  if (that.IsEmpty()) return;
-  internal::Object** p = reinterpret_cast<internal::Object**>(that.val_);
-  this->val_ = reinterpret_cast<T*>(V8::CopyPersistent(p));
-  M::Copy(that, this);
-}
-
-
-template <class T>
-bool PersistentBase<T>::IsIndependent() const {
-  typedef internal::Internals I;
-  if (this->IsEmpty()) return false;
-  return I::GetNodeFlag(reinterpret_cast<internal::Object**>(this->val_),
-                        I::kNodeIsIndependentShift);
-}
-
-
-template <class T>
-bool PersistentBase<T>::IsNearDeath() const {
-  typedef internal::Internals I;
-  if (this->IsEmpty()) return false;
-  uint8_t node_state =
-      I::GetNodeState(reinterpret_cast<internal::Object**>(this->val_));
-  return node_state == I::kNodeStateIsNearDeathValue ||
-      node_state == I::kNodeStateIsPendingValue;
-}
-
-
-template <class T>
-bool PersistentBase<T>::IsWeak() const {
-  typedef internal::Internals I;
-  if (this->IsEmpty()) return false;
-  return I::GetNodeState(reinterpret_cast<internal::Object**>(this->val_)) ==
-      I::kNodeStateIsWeakValue;
-}
-
-
-template <class T>
-void PersistentBase<T>::Reset() {
-  if (this->IsEmpty()) return;
-  V8::DisposeGlobal(reinterpret_cast<internal::Object**>(this->val_));
-  val_ = 0;
-}
-
-
-template <class T>
-template <class S>
-void PersistentBase<T>::Reset(Isolate* isolate, const Local<S>& other) {
-  TYPE_CHECK(T, S);
-  Reset();
-  if (other.IsEmpty()) return;
-  this->val_ = New(isolate, other.val_);
-}
-
-
-template <class T>
-template <class S>
-void PersistentBase<T>::Reset(Isolate* isolate,
-                              const PersistentBase<S>& other) {
-  TYPE_CHECK(T, S);
-  Reset();
-  if (other.IsEmpty()) return;
-  this->val_ = New(isolate, other.val_);
-}
-
-
-template <class T>
-template <typename P>
-V8_INLINE void PersistentBase<T>::SetWeak(
-    P* parameter, typename WeakCallbackInfo<P>::Callback callback,
-    WeakCallbackType type) {
-  typedef typename WeakCallbackInfo<void>::Callback Callback;
-  V8::MakeWeak(reinterpret_cast<internal::Object**>(this->val_), parameter,
-               reinterpret_cast<Callback>(callback), type);
-}
-
-template <class T>
-void PersistentBase<T>::SetWeak() {
-  V8::MakeWeak(reinterpret_cast<internal::Object***>(&this->val_));
-}
-
-template <class T>
-template <typename P>
-P* PersistentBase<T>::ClearWeak() {
-  return reinterpret_cast<P*>(
-    V8::ClearWeak(reinterpret_cast<internal::Object**>(this->val_)));
-}
-
-template <class T>
-void PersistentBase<T>::RegisterExternalReference(Isolate* isolate) const {
-  if (IsEmpty()) return;
-  V8::RegisterExternallyReferencedObject(
-      reinterpret_cast<internal::Object**>(this->val_),
-      reinterpret_cast<internal::Isolate*>(isolate));
-}
-
-template <class T>
-void PersistentBase<T>::MarkIndependent() {
-  typedef internal::Internals I;
-  if (this->IsEmpty()) return;
-  I::UpdateNodeFlag(reinterpret_cast<internal::Object**>(this->val_),
-                    true,
-                    I::kNodeIsIndependentShift);
-}
-
-template <class T>
-void PersistentBase<T>::MarkActive() {
-  typedef internal::Internals I;
-  if (this->IsEmpty()) return;
-  I::UpdateNodeFlag(reinterpret_cast<internal::Object**>(this->val_), true,
-                    I::kNodeIsActiveShift);
-}
-
-
-template <class T>
-void PersistentBase<T>::SetWrapperClassId(uint16_t class_id) {
-  typedef internal::Internals I;
-  if (this->IsEmpty()) return;
-  internal::Object** obj = reinterpret_cast<internal::Object**>(this->val_);
-  uint8_t* addr = reinterpret_cast<uint8_t*>(obj) + I::kNodeClassIdOffset;
-  *reinterpret_cast<uint16_t*>(addr) = class_id;
-}
-
-
-template <class T>
-uint16_t PersistentBase<T>::WrapperClassId() const {
-  typedef internal::Internals I;
-  if (this->IsEmpty()) return 0;
-  internal::Object** obj = reinterpret_cast<internal::Object**>(this->val_);
-  uint8_t* addr = reinterpret_cast<uint8_t*>(obj) + I::kNodeClassIdOffset;
-  return *reinterpret_cast<uint16_t*>(addr);
-}
-
-
-template<typename T>
-ReturnValue<T>::ReturnValue(internal::Object** slot) : value_(slot) {}
-
-template<typename T>
-template<typename S>
-void ReturnValue<T>::Set(const Persistent<S>& handle) {
-  TYPE_CHECK(T, S);
-  if (V8_UNLIKELY(handle.IsEmpty())) {
-    *value_ = GetDefaultValue();
-  } else {
-    *value_ = *reinterpret_cast<internal::Object**>(*handle);
-  }
-}
-
-template <typename T>
-template <typename S>
-void ReturnValue<T>::Set(const Global<S>& handle) {
-  TYPE_CHECK(T, S);
-  if (V8_UNLIKELY(handle.IsEmpty())) {
-    *value_ = GetDefaultValue();
-  } else {
-    *value_ = *reinterpret_cast<internal::Object**>(*handle);
-  }
-}
-
-template <typename T>
-template <typename S>
-void ReturnValue<T>::Set(const Local<S> handle) {
-  TYPE_CHECK(T, S);
-  if (V8_UNLIKELY(handle.IsEmpty())) {
-    *value_ = GetDefaultValue();
-  } else {
-    *value_ = *reinterpret_cast<internal::Object**>(*handle);
-  }
-}
-
-template<typename T>
-void ReturnValue<T>::Set(double i) {
-  TYPE_CHECK(T, Number);
-  Set(Number::New(GetIsolate(), i));
-}
-
-template<typename T>
-void ReturnValue<T>::Set(int32_t i) {
-  TYPE_CHECK(T, Integer);
-  typedef internal::Internals I;
-  if (V8_LIKELY(I::IsValidSmi(i))) {
-    *value_ = I::IntToSmi(i);
-    return;
-  }
-  Set(Integer::New(GetIsolate(), i));
-}
-
-template<typename T>
-void ReturnValue<T>::Set(uint32_t i) {
-  TYPE_CHECK(T, Integer);
-  // Can't simply use INT32_MAX here for whatever reason.
-  bool fits_into_int32_t = (i & (1U << 31)) == 0;
-  if (V8_LIKELY(fits_into_int32_t)) {
-    Set(static_cast<int32_t>(i));
-    return;
-  }
-  Set(Integer::NewFromUnsigned(GetIsolate(), i));
-}
-
-template<typename T>
-void ReturnValue<T>::Set(bool value) {
-  TYPE_CHECK(T, Boolean);
-  typedef internal::Internals I;
-  int root_index;
-  if (value) {
-    root_index = I::kTrueValueRootIndex;
-  } else {
-    root_index = I::kFalseValueRootIndex;
-  }
-  *value_ = *I::GetRoot(GetIsolate(), root_index);
-}
-
-template<typename T>
-void ReturnValue<T>::SetNull() {
-  TYPE_CHECK(T, Primitive);
-  typedef internal::Internals I;
-  *value_ = *I::GetRoot(GetIsolate(), I::kNullValueRootIndex);
-}
-
-template<typename T>
-void ReturnValue<T>::SetUndefined() {
-  TYPE_CHECK(T, Primitive);
-  typedef internal::Internals I;
-  *value_ = *I::GetRoot(GetIsolate(), I::kUndefinedValueRootIndex);
-}
-
-template<typename T>
-void ReturnValue<T>::SetEmptyString() {
-  TYPE_CHECK(T, String);
-  typedef internal::Internals I;
-  *value_ = *I::GetRoot(GetIsolate(), I::kEmptyStringRootIndex);
-}
-
-template <typename T>
-Isolate* ReturnValue<T>::GetIsolate() const {
-  // Isolate is always the pointer below the default value on the stack.
-  return *reinterpret_cast<Isolate**>(&value_[-2]);
-}
-
-template <typename T>
-Local<Value> ReturnValue<T>::Get() const {
-  typedef internal::Internals I;
-  if (*value_ == *I::GetRoot(GetIsolate(), I::kTheHoleValueRootIndex))
-    return Local<Value>(*Undefined(GetIsolate()));
-  return Local<Value>::New(GetIsolate(), reinterpret_cast<Value*>(value_));
-}
-
-template <typename T>
-template <typename S>
-void ReturnValue<T>::Set(S* whatever) {
-  // Uncompilable to prevent inadvertent misuse.
-  TYPE_CHECK(S*, Primitive);
-}
-
-template<typename T>
-internal::Object* ReturnValue<T>::GetDefaultValue() {
-  // Default value is always the pointer below value_ on the stack.
-  return value_[-1];
-}
-
-template <typename T>
-FunctionCallbackInfo<T>::FunctionCallbackInfo(internal::Object** implicit_args,
-                                              internal::Object** values,
-                                              int length)
-    : implicit_args_(implicit_args), values_(values), length_(length) {}
-
-template<typename T>
-Local<Value> FunctionCallbackInfo<T>::operator[](int i) const {
-  if (i < 0 || length_ <= i) return Local<Value>(*Undefined(GetIsolate()));
-  return Local<Value>(reinterpret_cast<Value*>(values_ - i));
-}
-
-
-template<typename T>
-Local<Function> FunctionCallbackInfo<T>::Callee() const {
-  return Local<Function>(reinterpret_cast<Function*>(
-      &implicit_args_[kCalleeIndex]));
-}
-
-
-template<typename T>
-Local<Object> FunctionCallbackInfo<T>::This() const {
-  return Local<Object>(reinterpret_cast<Object*>(values_ + 1));
-}
-
-
-template<typename T>
-Local<Object> FunctionCallbackInfo<T>::Holder() const {
-  return Local<Object>(reinterpret_cast<Object*>(
-      &implicit_args_[kHolderIndex]));
-}
-
-template <typename T>
-Local<Value> FunctionCallbackInfo<T>::NewTarget() const {
-  return Local<Value>(
-      reinterpret_cast<Value*>(&implicit_args_[kNewTargetIndex]));
-}
-
-template <typename T>
-Local<Value> FunctionCallbackInfo<T>::Data() const {
-  return Local<Value>(reinterpret_cast<Value*>(&implicit_args_[kDataIndex]));
-}
-
-
-template<typename T>
-Isolate* FunctionCallbackInfo<T>::GetIsolate() const {
-  return *reinterpret_cast<Isolate**>(&implicit_args_[kIsolateIndex]);
-}
-
-
-template<typename T>
-ReturnValue<T> FunctionCallbackInfo<T>::GetReturnValue() const {
-  return ReturnValue<T>(&implicit_args_[kReturnValueIndex]);
-}
-
-
-template<typename T>
-bool FunctionCallbackInfo<T>::IsConstructCall() const {
-  return !NewTarget()->IsUndefined();
-}
-
-
-template<typename T>
-int FunctionCallbackInfo<T>::Length() const {
-  return length_;
-}
-
-ScriptOrigin::ScriptOrigin(Local<Value> resource_name,
-                           Local<Integer> resource_line_offset,
-                           Local<Integer> resource_column_offset,
-                           Local<Boolean> resource_is_shared_cross_origin,
-                           Local<Integer> script_id,
-                           Local<Value> source_map_url,
-                           Local<Boolean> resource_is_opaque,
-                           Local<Boolean> is_wasm, Local<Boolean> is_module)
-    : resource_name_(resource_name),
-      resource_line_offset_(resource_line_offset),
-      resource_column_offset_(resource_column_offset),
-      options_(!resource_is_shared_cross_origin.IsEmpty() &&
-                   resource_is_shared_cross_origin->IsTrue(),
-               !resource_is_opaque.IsEmpty() && resource_is_opaque->IsTrue(),
-               !is_wasm.IsEmpty() && is_wasm->IsTrue(),
-               !is_module.IsEmpty() && is_module->IsTrue()),
-      script_id_(script_id),
-      source_map_url_(source_map_url) {}
-
-Local<Value> ScriptOrigin::ResourceName() const { return resource_name_; }
-
-
-Local<Integer> ScriptOrigin::ResourceLineOffset() const {
-  return resource_line_offset_;
-}
-
-
-Local<Integer> ScriptOrigin::ResourceColumnOffset() const {
-  return resource_column_offset_;
-}
-
-
-Local<Integer> ScriptOrigin::ScriptID() const { return script_id_; }
-
-
-Local<Value> ScriptOrigin::SourceMapUrl() const { return source_map_url_; }
-
-
-ScriptCompiler::Source::Source(Local<String> string, const ScriptOrigin& origin,
-                               CachedData* data)
-    : source_string(string),
-      resource_name(origin.ResourceName()),
-      resource_line_offset(origin.ResourceLineOffset()),
-      resource_column_offset(origin.ResourceColumnOffset()),
-      resource_options(origin.Options()),
-      source_map_url(origin.SourceMapUrl()),
-      cached_data(data) {}
-
-
-ScriptCompiler::Source::Source(Local<String> string,
-                               CachedData* data)
-    : source_string(string), cached_data(data) {}
-
-
-ScriptCompiler::Source::~Source() {
-  delete cached_data;
-}
-
-
-const ScriptCompiler::CachedData* ScriptCompiler::Source::GetCachedData()
-    const {
-  return cached_data;
-}
-
-const ScriptOriginOptions& ScriptCompiler::Source::GetResourceOptions() const {
-  return resource_options;
-}
-
-Local<Boolean> Boolean::New(Isolate* isolate, bool value) {
-  return value ? True(isolate) : False(isolate);
-}
-
-void Template::Set(Isolate* isolate, const char* name, Local<Data> value) {
-  Set(String::NewFromUtf8(isolate, name, NewStringType::kInternalized)
-          .ToLocalChecked(),
-      value);
-}
-
-
-Local<Value> Object::GetInternalField(int index) {
-#ifndef V8_ENABLE_CHECKS
-  typedef internal::Object O;
-  typedef internal::HeapObject HO;
-  typedef internal::Internals I;
-  O* obj = *reinterpret_cast<O**>(this);
-  // Fast path: If the object is a plain JSObject, which is the common case, we
-  // know where to find the internal fields and can return the value directly.
-  auto instance_type = I::GetInstanceType(obj);
-  if (instance_type == I::kJSObjectType ||
-      instance_type == I::kJSApiObjectType) {
-    int offset = I::kJSObjectHeaderSize + (internal::kApiPointerSize * index);
-    O* value = I::ReadField<O*>(obj, offset);
-    O** result = HandleScope::CreateHandle(reinterpret_cast<HO*>(obj), value);
-    return Local<Value>(reinterpret_cast<Value*>(result));
-  }
-#endif
-  return SlowGetInternalField(index);
-}
-
-
-void* Object::GetAlignedPointerFromInternalField(int index) {
-#ifndef V8_ENABLE_CHECKS
-  typedef internal::Object O;
-  typedef internal::Internals I;
-  O* obj = *reinterpret_cast<O**>(this);
-  // Fast path: If the object is a plain JSObject, which is the common case, we
-  // know where to find the internal fields and can return the value directly.
-  auto instance_type = I::GetInstanceType(obj);
-  if (V8_LIKELY(instance_type == I::kJSObjectType ||
-                instance_type == I::kJSApiObjectType)) {
-    int offset = I::kJSObjectHeaderSize + (internal::kApiPointerSize * index);
-    return I::ReadField<void*>(obj, offset);
-  }
-#endif
-  return SlowGetAlignedPointerFromInternalField(index);
-}
-
-String* String::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<String*>(value);
-}
-
-
-Local<String> String::Empty(Isolate* isolate) {
-  typedef internal::Object* S;
-  typedef internal::Internals I;
-  I::CheckInitialized(isolate);
-  S* slot = I::GetRoot(isolate, I::kEmptyStringRootIndex);
-  return Local<String>(reinterpret_cast<String*>(slot));
-}
-
-
-String::ExternalStringResource* String::GetExternalStringResource() const {
-  typedef internal::Object O;
-  typedef internal::Internals I;
-  O* obj = *reinterpret_cast<O* const*>(this);
-  String::ExternalStringResource* result;
-  if (I::IsExternalTwoByteString(I::GetInstanceType(obj))) {
-    void* value = I::ReadField<void*>(obj, I::kStringResourceOffset);
-    result = reinterpret_cast<String::ExternalStringResource*>(value);
-  } else {
-    result = NULL;
-  }
-#ifdef V8_ENABLE_CHECKS
-  VerifyExternalStringResource(result);
-#endif
-  return result;
-}
-
-
-String::ExternalStringResourceBase* String::GetExternalStringResourceBase(
-    String::Encoding* encoding_out) const {
-  typedef internal::Object O;
-  typedef internal::Internals I;
-  O* obj = *reinterpret_cast<O* const*>(this);
-  int type = I::GetInstanceType(obj) & I::kFullStringRepresentationMask;
-  *encoding_out = static_cast<Encoding>(type & I::kStringEncodingMask);
-  ExternalStringResourceBase* resource = NULL;
-  if (type == I::kExternalOneByteRepresentationTag ||
-      type == I::kExternalTwoByteRepresentationTag) {
-    void* value = I::ReadField<void*>(obj, I::kStringResourceOffset);
-    resource = static_cast<ExternalStringResourceBase*>(value);
-  }
-#ifdef V8_ENABLE_CHECKS
-    VerifyExternalStringResourceBase(resource, *encoding_out);
-#endif
-  return resource;
-}
-
-
-bool Value::IsUndefined() const {
-#ifdef V8_ENABLE_CHECKS
-  return FullIsUndefined();
-#else
-  return QuickIsUndefined();
-#endif
-}
-
-bool Value::QuickIsUndefined() const {
-  typedef internal::Object O;
-  typedef internal::Internals I;
-  O* obj = *reinterpret_cast<O* const*>(this);
-  if (!I::HasHeapObjectTag(obj)) return false;
-  if (I::GetInstanceType(obj) != I::kOddballType) return false;
-  return (I::GetOddballKind(obj) == I::kUndefinedOddballKind);
-}
-
-
-bool Value::IsNull() const {
-#ifdef V8_ENABLE_CHECKS
-  return FullIsNull();
-#else
-  return QuickIsNull();
-#endif
-}
-
-bool Value::QuickIsNull() const {
-  typedef internal::Object O;
-  typedef internal::Internals I;
-  O* obj = *reinterpret_cast<O* const*>(this);
-  if (!I::HasHeapObjectTag(obj)) return false;
-  if (I::GetInstanceType(obj) != I::kOddballType) return false;
-  return (I::GetOddballKind(obj) == I::kNullOddballKind);
-}
-
-bool Value::IsNullOrUndefined() const {
-#ifdef V8_ENABLE_CHECKS
-  return FullIsNull() || FullIsUndefined();
-#else
-  return QuickIsNullOrUndefined();
-#endif
-}
-
-bool Value::QuickIsNullOrUndefined() const {
-  typedef internal::Object O;
-  typedef internal::Internals I;
-  O* obj = *reinterpret_cast<O* const*>(this);
-  if (!I::HasHeapObjectTag(obj)) return false;
-  if (I::GetInstanceType(obj) != I::kOddballType) return false;
-  int kind = I::GetOddballKind(obj);
-  return kind == I::kNullOddballKind || kind == I::kUndefinedOddballKind;
-}
-
-bool Value::IsString() const {
-#ifdef V8_ENABLE_CHECKS
-  return FullIsString();
-#else
-  return QuickIsString();
-#endif
-}
-
-bool Value::QuickIsString() const {
-  typedef internal::Object O;
-  typedef internal::Internals I;
-  O* obj = *reinterpret_cast<O* const*>(this);
-  if (!I::HasHeapObjectTag(obj)) return false;
-  return (I::GetInstanceType(obj) < I::kFirstNonstringType);
-}
-
-
-template <class T> Value* Value::Cast(T* value) {
-  return static_cast<Value*>(value);
-}
-
-
-Local<Boolean> Value::ToBoolean() const {
-  return ToBoolean(Isolate::GetCurrent()->GetCurrentContext())
-      .FromMaybe(Local<Boolean>());
-}
-
-
-Local<Number> Value::ToNumber() const {
-  return ToNumber(Isolate::GetCurrent()->GetCurrentContext())
-      .FromMaybe(Local<Number>());
-}
-
-
-Local<String> Value::ToString() const {
-  return ToString(Isolate::GetCurrent()->GetCurrentContext())
-      .FromMaybe(Local<String>());
-}
-
-
-Local<String> Value::ToDetailString() const {
-  return ToDetailString(Isolate::GetCurrent()->GetCurrentContext())
-      .FromMaybe(Local<String>());
-}
-
-
-Local<Object> Value::ToObject() const {
-  return ToObject(Isolate::GetCurrent()->GetCurrentContext())
-      .FromMaybe(Local<Object>());
-}
-
-
-Local<Integer> Value::ToInteger() const {
-  return ToInteger(Isolate::GetCurrent()->GetCurrentContext())
-      .FromMaybe(Local<Integer>());
-}
-
-
-Local<Uint32> Value::ToUint32() const {
-  return ToUint32(Isolate::GetCurrent()->GetCurrentContext())
-      .FromMaybe(Local<Uint32>());
-}
-
-
-Local<Int32> Value::ToInt32() const {
-  return ToInt32(Isolate::GetCurrent()->GetCurrentContext())
-      .FromMaybe(Local<Int32>());
-}
-
-
-Boolean* Boolean::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<Boolean*>(value);
-}
-
-
-Name* Name::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<Name*>(value);
-}
-
-
-Symbol* Symbol::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<Symbol*>(value);
-}
-
-
-Number* Number::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<Number*>(value);
-}
-
-
-Integer* Integer::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<Integer*>(value);
-}
-
-
-Int32* Int32::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<Int32*>(value);
-}
-
-
-Uint32* Uint32::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<Uint32*>(value);
-}
-
-
-Date* Date::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<Date*>(value);
-}
-
-
-StringObject* StringObject::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<StringObject*>(value);
-}
-
-
-SymbolObject* SymbolObject::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<SymbolObject*>(value);
-}
-
-
-NumberObject* NumberObject::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<NumberObject*>(value);
-}
-
-
-BooleanObject* BooleanObject::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<BooleanObject*>(value);
-}
-
-
-RegExp* RegExp::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<RegExp*>(value);
-}
-
-
-Object* Object::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<Object*>(value);
-}
-
-
-Array* Array::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<Array*>(value);
-}
-
-
-Map* Map::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<Map*>(value);
-}
-
-
-Set* Set::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<Set*>(value);
-}
-
-
-Promise* Promise::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<Promise*>(value);
-}
-
-
-Proxy* Proxy::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<Proxy*>(value);
-}
-
-WasmCompiledModule* WasmCompiledModule::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<WasmCompiledModule*>(value);
-}
-
-Promise::Resolver* Promise::Resolver::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<Promise::Resolver*>(value);
-}
-
-
-ArrayBuffer* ArrayBuffer::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<ArrayBuffer*>(value);
-}
-
-
-ArrayBufferView* ArrayBufferView::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<ArrayBufferView*>(value);
-}
-
-
-TypedArray* TypedArray::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<TypedArray*>(value);
-}
-
-
-Uint8Array* Uint8Array::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<Uint8Array*>(value);
-}
-
-
-Int8Array* Int8Array::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<Int8Array*>(value);
-}
-
-
-Uint16Array* Uint16Array::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<Uint16Array*>(value);
-}
-
-
-Int16Array* Int16Array::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<Int16Array*>(value);
-}
-
-
-Uint32Array* Uint32Array::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<Uint32Array*>(value);
-}
-
-
-Int32Array* Int32Array::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<Int32Array*>(value);
-}
-
-
-Float32Array* Float32Array::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<Float32Array*>(value);
-}
-
-
-Float64Array* Float64Array::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<Float64Array*>(value);
-}
-
-
-Uint8ClampedArray* Uint8ClampedArray::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<Uint8ClampedArray*>(value);
-}
-
-
-DataView* DataView::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<DataView*>(value);
-}
-
-
-SharedArrayBuffer* SharedArrayBuffer::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<SharedArrayBuffer*>(value);
-}
-
-
-Function* Function::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<Function*>(value);
-}
-
-
-External* External::Cast(v8::Value* value) {
-#ifdef V8_ENABLE_CHECKS
-  CheckCast(value);
-#endif
-  return static_cast<External*>(value);
-}
-
-
-template<typename T>
-Isolate* PropertyCallbackInfo<T>::GetIsolate() const {
-  return *reinterpret_cast<Isolate**>(&args_[kIsolateIndex]);
-}
-
-
-template<typename T>
-Local<Value> PropertyCallbackInfo<T>::Data() const {
-  return Local<Value>(reinterpret_cast<Value*>(&args_[kDataIndex]));
-}
-
-
-template<typename T>
-Local<Object> PropertyCallbackInfo<T>::This() const {
-  return Local<Object>(reinterpret_cast<Object*>(&args_[kThisIndex]));
-}
-
-
-template<typename T>
-Local<Object> PropertyCallbackInfo<T>::Holder() const {
-  return Local<Object>(reinterpret_cast<Object*>(&args_[kHolderIndex]));
-}
-
-
-template<typename T>
-ReturnValue<T> PropertyCallbackInfo<T>::GetReturnValue() const {
-  return ReturnValue<T>(&args_[kReturnValueIndex]);
-}
-
-template <typename T>
-bool PropertyCallbackInfo<T>::ShouldThrowOnError() const {
-  typedef internal::Internals I;
-  return args_[kShouldThrowOnErrorIndex] != I::IntToSmi(0);
-}
-
-
-Local<Primitive> Undefined(Isolate* isolate) {
-  typedef internal::Object* S;
-  typedef internal::Internals I;
-  I::CheckInitialized(isolate);
-  S* slot = I::GetRoot(isolate, I::kUndefinedValueRootIndex);
-  return Local<Primitive>(reinterpret_cast<Primitive*>(slot));
-}
-
-
-Local<Primitive> Null(Isolate* isolate) {
-  typedef internal::Object* S;
-  typedef internal::Internals I;
-  I::CheckInitialized(isolate);
-  S* slot = I::GetRoot(isolate, I::kNullValueRootIndex);
-  return Local<Primitive>(reinterpret_cast<Primitive*>(slot));
-}
-
-
-Local<Boolean> True(Isolate* isolate) {
-  typedef internal::Object* S;
-  typedef internal::Internals I;
-  I::CheckInitialized(isolate);
-  S* slot = I::GetRoot(isolate, I::kTrueValueRootIndex);
-  return Local<Boolean>(reinterpret_cast<Boolean*>(slot));
-}
-
-
-Local<Boolean> False(Isolate* isolate) {
-  typedef internal::Object* S;
-  typedef internal::Internals I;
-  I::CheckInitialized(isolate);
-  S* slot = I::GetRoot(isolate, I::kFalseValueRootIndex);
-  return Local<Boolean>(reinterpret_cast<Boolean*>(slot));
-}
-
-
-void Isolate::SetData(uint32_t slot, void* data) {
-  typedef internal::Internals I;
-  I::SetEmbedderData(this, slot, data);
-}
-
-
-void* Isolate::GetData(uint32_t slot) {
-  typedef internal::Internals I;
-  return I::GetEmbedderData(this, slot);
-}
-
-
-uint32_t Isolate::GetNumberOfDataSlots() {
-  typedef internal::Internals I;
-  return I::kNumIsolateDataSlots;
-}
-
-
-int64_t Isolate::AdjustAmountOfExternalAllocatedMemory(
-    int64_t change_in_bytes) {
-  typedef internal::Internals I;
-  int64_t* external_memory = reinterpret_cast<int64_t*>(
-      reinterpret_cast<uint8_t*>(this) + I::kExternalMemoryOffset);
-  const int64_t external_memory_limit = *reinterpret_cast<int64_t*>(
-      reinterpret_cast<uint8_t*>(this) + I::kExternalMemoryLimitOffset);
-  const int64_t amount = *external_memory + change_in_bytes;
-  *external_memory = amount;
-  if (change_in_bytes > 0 && amount > external_memory_limit) {
-    ReportExternalAllocationLimitReached();
-  }
-  return *external_memory;
-}
-
-
-template<typename T>
-void Isolate::SetObjectGroupId(const Persistent<T>& object,
-                               UniqueId id) {
-  TYPE_CHECK(Value, T);
-  SetObjectGroupId(reinterpret_cast<internal::Object**>(object.val_), id);
-}
-
-
-template<typename T>
-void Isolate::SetReferenceFromGroup(UniqueId id,
-                                    const Persistent<T>& object) {
-  TYPE_CHECK(Value, T);
-  SetReferenceFromGroup(id, reinterpret_cast<internal::Object**>(object.val_));
-}
-
-
-template<typename T, typename S>
-void Isolate::SetReference(const Persistent<T>& parent,
-                           const Persistent<S>& child) {
-  TYPE_CHECK(Object, T);
-  TYPE_CHECK(Value, S);
-  SetReference(reinterpret_cast<internal::Object**>(parent.val_),
-               reinterpret_cast<internal::Object**>(child.val_));
-}
-
-
-Local<Value> Context::GetEmbedderData(int index) {
-#ifndef V8_ENABLE_CHECKS
-  typedef internal::Object O;
-  typedef internal::HeapObject HO;
-  typedef internal::Internals I;
-  HO* context = *reinterpret_cast<HO**>(this);
-  O** result =
-      HandleScope::CreateHandle(context, I::ReadEmbedderData<O*>(this, index));
-  return Local<Value>(reinterpret_cast<Value*>(result));
-#else
-  return SlowGetEmbedderData(index);
-#endif
-}
-
-
-void* Context::GetAlignedPointerFromEmbedderData(int index) {
-#ifndef V8_ENABLE_CHECKS
-  typedef internal::Internals I;
-  return I::ReadEmbedderData<void*>(this, index);
-#else
-  return SlowGetAlignedPointerFromEmbedderData(index);
-#endif
-}
-
-
-void V8::SetAllowCodeGenerationFromStringsCallback(
-    AllowCodeGenerationFromStringsCallback callback) {
-  Isolate* isolate = Isolate::GetCurrent();
-  isolate->SetAllowCodeGenerationFromStringsCallback(callback);
-}
-
-
-bool V8::IsDead() {
-  Isolate* isolate = Isolate::GetCurrent();
-  return isolate->IsDead();
-}
-
-
-bool V8::AddMessageListener(MessageCallback that, Local<Value> data) {
-  Isolate* isolate = Isolate::GetCurrent();
-  return isolate->AddMessageListener(that, data);
-}
-
-
-void V8::RemoveMessageListeners(MessageCallback that) {
-  Isolate* isolate = Isolate::GetCurrent();
-  isolate->RemoveMessageListeners(that);
-}
-
-
-void V8::SetFailedAccessCheckCallbackFunction(
-    FailedAccessCheckCallback callback) {
-  Isolate* isolate = Isolate::GetCurrent();
-  isolate->SetFailedAccessCheckCallbackFunction(callback);
-}
-
-
-void V8::SetCaptureStackTraceForUncaughtExceptions(
-    bool capture, int frame_limit, StackTrace::StackTraceOptions options) {
-  Isolate* isolate = Isolate::GetCurrent();
-  isolate->SetCaptureStackTraceForUncaughtExceptions(capture, frame_limit,
-                                                     options);
-}
-
-
-void V8::SetFatalErrorHandler(FatalErrorCallback callback) {
-  Isolate* isolate = Isolate::GetCurrent();
-  isolate->SetFatalErrorHandler(callback);
-}
-
-void V8::RemoveGCPrologueCallback(GCCallback callback) {
-  Isolate* isolate = Isolate::GetCurrent();
-  isolate->RemoveGCPrologueCallback(
-      reinterpret_cast<Isolate::GCCallback>(callback));
-}
-
-
-void V8::RemoveGCEpilogueCallback(GCCallback callback) {
-  Isolate* isolate = Isolate::GetCurrent();
-  isolate->RemoveGCEpilogueCallback(
-      reinterpret_cast<Isolate::GCCallback>(callback));
-}
-
-void V8::TerminateExecution(Isolate* isolate) { isolate->TerminateExecution(); }
-
-
-bool V8::IsExecutionTerminating(Isolate* isolate) {
-  if (isolate == NULL) {
-    isolate = Isolate::GetCurrent();
-  }
-  return isolate->IsExecutionTerminating();
-}
-
-
-void V8::CancelTerminateExecution(Isolate* isolate) {
-  isolate->CancelTerminateExecution();
-}
-
-
-void V8::VisitExternalResources(ExternalResourceVisitor* visitor) {
-  Isolate* isolate = Isolate::GetCurrent();
-  isolate->VisitExternalResources(visitor);
-}
-
-
-void V8::VisitHandlesWithClassIds(PersistentHandleVisitor* visitor) {
-  Isolate* isolate = Isolate::GetCurrent();
-  isolate->VisitHandlesWithClassIds(visitor);
-}
-
-
-void V8::VisitHandlesWithClassIds(Isolate* isolate,
-                                  PersistentHandleVisitor* visitor) {
-  isolate->VisitHandlesWithClassIds(visitor);
-}
-
-
-void V8::VisitHandlesForPartialDependence(Isolate* isolate,
-                                          PersistentHandleVisitor* visitor) {
-  isolate->VisitHandlesForPartialDependence(visitor);
-}
-
-/**
- * \example shell.cc
- * A simple shell that takes a list of expressions on the
- * command-line and executes them.
- */
-
-
-/**
- * \example process.cc
- */
-
-
-}  // namespace v8
-
-
-#undef TYPE_CHECK
-
-
-#endif  // INCLUDE_V8_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/v8/include/v8config.h
+++ /dev/null
@@ -1,428 +0,0 @@
-// Copyright 2013 the V8 project authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef V8CONFIG_H_
-#define V8CONFIG_H_
-
-// clang-format off
-
-// Platform headers for feature detection below.
-#if defined(__ANDROID__)
-# include <sys/cdefs.h>
-#elif defined(__APPLE__)
-# include <TargetConditionals.h>
-#elif defined(__linux__)
-# include <features.h>
-#endif
-
-
-// This macro allows to test for the version of the GNU C library (or
-// a compatible C library that masquerades as glibc). It evaluates to
-// 0 if libc is not GNU libc or compatible.
-// Use like:
-//  #if V8_GLIBC_PREREQ(2, 3)
-//   ...
-//  #endif
-#if defined(__GLIBC__) && defined(__GLIBC_MINOR__)
-# define V8_GLIBC_PREREQ(major, minor)                                    \
-    ((__GLIBC__ * 100 + __GLIBC_MINOR__) >= ((major) * 100 + (minor)))
-#else
-# define V8_GLIBC_PREREQ(major, minor) 0
-#endif
-
-
-// This macro allows to test for the version of the GNU C++ compiler.
-// Note that this also applies to compilers that masquerade as GCC,
-// for example clang and the Intel C++ compiler for Linux.
-// Use like:
-//  #if V8_GNUC_PREREQ(4, 3, 1)
-//   ...
-//  #endif
-#if defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__GNUC_PATCHLEVEL__)
-# define V8_GNUC_PREREQ(major, minor, patchlevel)                         \
-    ((__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__) >=   \
-     ((major) * 10000 + (minor) * 100 + (patchlevel)))
-#elif defined(__GNUC__) && defined(__GNUC_MINOR__)
-# define V8_GNUC_PREREQ(major, minor, patchlevel)      \
-    ((__GNUC__ * 10000 + __GNUC_MINOR__ * 100) >=      \
-     ((major) * 10000 + (minor) * 100 + (patchlevel)))
-#else
-# define V8_GNUC_PREREQ(major, minor, patchlevel) 0
-#endif
-
-
-
-// -----------------------------------------------------------------------------
-// Operating system detection
-//
-//  V8_OS_ANDROID       - Android
-//  V8_OS_BSD           - BSDish (Mac OS X, Net/Free/Open/DragonFlyBSD)
-//  V8_OS_CYGWIN        - Cygwin
-//  V8_OS_DRAGONFLYBSD  - DragonFlyBSD
-//  V8_OS_FREEBSD       - FreeBSD
-//  V8_OS_LINUX         - Linux
-//  V8_OS_MACOSX        - Mac OS X
-//  V8_OS_NETBSD        - NetBSD
-//  V8_OS_OPENBSD       - OpenBSD
-//  V8_OS_POSIX         - POSIX compatible (mostly everything except Windows)
-//  V8_OS_QNX           - QNX Neutrino
-//  V8_OS_SOLARIS       - Sun Solaris and OpenSolaris
-//  V8_OS_AIX           - AIX
-//  V8_OS_WIN           - Microsoft Windows
-
-#if defined(__ANDROID__)
-# define V8_OS_ANDROID 1
-# define V8_OS_LINUX 1
-# define V8_OS_POSIX 1
-#elif defined(__APPLE__)
-# define V8_OS_BSD 1
-# define V8_OS_MACOSX 1
-# define V8_OS_POSIX 1
-#elif defined(__CYGWIN__)
-# define V8_OS_CYGWIN 1
-# define V8_OS_POSIX 1
-#elif defined(__linux__)
-# define V8_OS_LINUX 1
-# define V8_OS_POSIX 1
-#elif defined(__sun)
-# define V8_OS_POSIX 1
-# define V8_OS_SOLARIS 1
-#elif defined(_AIX)
-#define V8_OS_POSIX 1
-#define V8_OS_AIX 1
-#elif defined(__FreeBSD__)
-# define V8_OS_BSD 1
-# define V8_OS_FREEBSD 1
-# define V8_OS_POSIX 1
-#elif defined(__DragonFly__)
-# define V8_OS_BSD 1
-# define V8_OS_DRAGONFLYBSD 1
-# define V8_OS_POSIX 1
-#elif defined(__NetBSD__)
-# define V8_OS_BSD 1
-# define V8_OS_NETBSD 1
-# define V8_OS_POSIX 1
-#elif defined(__OpenBSD__)
-# define V8_OS_BSD 1
-# define V8_OS_OPENBSD 1
-# define V8_OS_POSIX 1
-#elif defined(__QNXNTO__)
-# define V8_OS_POSIX 1
-# define V8_OS_QNX 1
-#elif defined(_WIN32)
-# define V8_OS_WIN 1
-#endif
-
-
-// -----------------------------------------------------------------------------
-// C library detection
-//
-//  V8_LIBC_MSVCRT  - MSVC libc
-//  V8_LIBC_BIONIC  - Bionic libc
-//  V8_LIBC_BSD     - BSD libc derivate
-//  V8_LIBC_GLIBC   - GNU C library
-//  V8_LIBC_UCLIBC  - uClibc
-//
-// Note that testing for libc must be done using #if not #ifdef. For example,
-// to test for the GNU C library, use:
-//  #if V8_LIBC_GLIBC
-//   ...
-//  #endif
-
-#if defined (_MSC_VER)
-# define V8_LIBC_MSVCRT 1
-#elif defined(__BIONIC__)
-# define V8_LIBC_BIONIC 1
-# define V8_LIBC_BSD 1
-#elif defined(__UCLIBC__)
-// Must test for UCLIBC before GLIBC, as UCLIBC pretends to be GLIBC.
-# define V8_LIBC_UCLIBC 1
-#elif defined(__GLIBC__) || defined(__GNU_LIBRARY__)
-# define V8_LIBC_GLIBC 1
-#else
-# define V8_LIBC_BSD V8_OS_BSD
-#endif
-
-
-// -----------------------------------------------------------------------------
-// Compiler detection
-//
-//  V8_CC_GNU     - GCC, or clang in gcc mode
-//  V8_CC_INTEL   - Intel C++
-//  V8_CC_MINGW   - Minimalist GNU for Windows
-//  V8_CC_MINGW32 - Minimalist GNU for Windows (mingw32)
-//  V8_CC_MINGW64 - Minimalist GNU for Windows (mingw-w64)
-//  V8_CC_MSVC    - Microsoft Visual C/C++, or clang in cl.exe mode
-//
-// C++11 feature detection
-//
-//  V8_HAS_CXX11_ALIGNAS        - alignas specifier supported
-//  V8_HAS_CXX11_ALIGNOF        - alignof(type) operator supported
-//
-// Compiler-specific feature detection
-//
-//  V8_HAS___ALIGNOF                    - __alignof(type) operator supported
-//  V8_HAS___ALIGNOF__                  - __alignof__(type) operator supported
-//  V8_HAS_ATTRIBUTE_ALIGNED            - __attribute__((aligned(n))) supported
-//  V8_HAS_ATTRIBUTE_ALWAYS_INLINE      - __attribute__((always_inline))
-//                                        supported
-//  V8_HAS_ATTRIBUTE_DEPRECATED         - __attribute__((deprecated)) supported
-//  V8_HAS_ATTRIBUTE_NOINLINE           - __attribute__((noinline)) supported
-//  V8_HAS_ATTRIBUTE_NORETURN           - __attribute__((noreturn)) supported
-//  V8_HAS_ATTRIBUTE_UNUSED             - __attribute__((unused)) supported
-//  V8_HAS_ATTRIBUTE_VISIBILITY         - __attribute__((visibility)) supported
-//  V8_HAS_ATTRIBUTE_WARN_UNUSED_RESULT - __attribute__((warn_unused_result))
-//                                        supported
-//  V8_HAS_BUILTIN_CLZ                  - __builtin_clz() supported
-//  V8_HAS_BUILTIN_CTZ                  - __builtin_ctz() supported
-//  V8_HAS_BUILTIN_EXPECT               - __builtin_expect() supported
-//  V8_HAS_BUILTIN_FRAME_ADDRESS        - __builtin_frame_address() supported
-//  V8_HAS_BUILTIN_POPCOUNT             - __builtin_popcount() supported
-//  V8_HAS_BUILTIN_SADD_OVERFLOW        - __builtin_sadd_overflow() supported
-//  V8_HAS_BUILTIN_SSUB_OVERFLOW        - __builtin_ssub_overflow() supported
-//  V8_HAS_BUILTIN_UADD_OVERFLOW        - __builtin_uadd_overflow() supported
-//  V8_HAS_DECLSPEC_ALIGN               - __declspec(align(n)) supported
-//  V8_HAS_DECLSPEC_DEPRECATED          - __declspec(deprecated) supported
-//  V8_HAS_DECLSPEC_NOINLINE            - __declspec(noinline) supported
-//  V8_HAS_DECLSPEC_SELECTANY           - __declspec(selectany) supported
-//  V8_HAS_DECLSPEC_NORETURN            - __declspec(noreturn) supported
-//  V8_HAS___FORCEINLINE                - __forceinline supported
-//
-// Note that testing for compilers and/or features must be done using #if
-// not #ifdef. For example, to test for Intel C++ Compiler, use:
-//  #if V8_CC_INTEL
-//   ...
-//  #endif
-
-#if defined(__clang__)
-
-#if defined(__GNUC__)  // Clang in gcc mode.
-# define V8_CC_GNU 1
-#endif
-
-// Clang defines __alignof__ as alias for __alignof
-# define V8_HAS___ALIGNOF 1
-# define V8_HAS___ALIGNOF__ V8_HAS___ALIGNOF
-
-# define V8_HAS_ATTRIBUTE_ALIGNED (__has_attribute(aligned))
-# define V8_HAS_ATTRIBUTE_ALWAYS_INLINE (__has_attribute(always_inline))
-# define V8_HAS_ATTRIBUTE_DEPRECATED (__has_attribute(deprecated))
-# define V8_HAS_ATTRIBUTE_NOINLINE (__has_attribute(noinline))
-# define V8_HAS_ATTRIBUTE_NORETURN (__has_attribute(noreturn))
-# define V8_HAS_ATTRIBUTE_UNUSED (__has_attribute(unused))
-# define V8_HAS_ATTRIBUTE_VISIBILITY (__has_attribute(visibility))
-# define V8_HAS_ATTRIBUTE_WARN_UNUSED_RESULT \
-    (__has_attribute(warn_unused_result))
-
-# define V8_HAS_BUILTIN_CLZ (__has_builtin(__builtin_clz))
-# define V8_HAS_BUILTIN_CTZ (__has_builtin(__builtin_ctz))
-# define V8_HAS_BUILTIN_EXPECT (__has_builtin(__builtin_expect))
-# define V8_HAS_BUILTIN_FRAME_ADDRESS (__has_builtin(__builtin_frame_address))
-# define V8_HAS_BUILTIN_POPCOUNT (__has_builtin(__builtin_popcount))
-# define V8_HAS_BUILTIN_SADD_OVERFLOW (__has_builtin(__builtin_sadd_overflow))
-# define V8_HAS_BUILTIN_SSUB_OVERFLOW (__has_builtin(__builtin_ssub_overflow))
-# define V8_HAS_BUILTIN_UADD_OVERFLOW (__has_builtin(__builtin_uadd_overflow))
-
-# define V8_HAS_CXX11_ALIGNAS (__has_feature(cxx_alignas))
-
-#elif defined(__GNUC__)
-
-# define V8_CC_GNU 1
-# if defined(__INTEL_COMPILER)  // Intel C++ also masquerades as GCC 3.2.0
-#  define V8_CC_INTEL 1
-# endif
-# if defined(__MINGW32__)
-#  define V8_CC_MINGW32 1
-# endif
-# if defined(__MINGW64__)
-#  define V8_CC_MINGW64 1
-# endif
-# define V8_CC_MINGW (V8_CC_MINGW32 || V8_CC_MINGW64)
-
-# define V8_HAS___ALIGNOF__ (V8_GNUC_PREREQ(4, 3, 0))
-
-# define V8_HAS_ATTRIBUTE_ALIGNED (V8_GNUC_PREREQ(2, 95, 0))
-// always_inline is available in gcc 4.0 but not very reliable until 4.4.
-// Works around "sorry, unimplemented: inlining failed" build errors with
-// older compilers.
-# define V8_HAS_ATTRIBUTE_ALWAYS_INLINE (V8_GNUC_PREREQ(4, 4, 0))
-# define V8_HAS_ATTRIBUTE_DEPRECATED (V8_GNUC_PREREQ(3, 4, 0))
-# define V8_HAS_ATTRIBUTE_DEPRECATED_MESSAGE (V8_GNUC_PREREQ(4, 5, 0))
-# define V8_HAS_ATTRIBUTE_NOINLINE (V8_GNUC_PREREQ(3, 4, 0))
-# define V8_HAS_ATTRIBUTE_NORETURN (V8_GNUC_PREREQ(2, 5, 0))
-# define V8_HAS_ATTRIBUTE_UNUSED (V8_GNUC_PREREQ(2, 95, 0))
-# define V8_HAS_ATTRIBUTE_VISIBILITY (V8_GNUC_PREREQ(4, 3, 0))
-# define V8_HAS_ATTRIBUTE_WARN_UNUSED_RESULT \
-    (!V8_CC_INTEL && V8_GNUC_PREREQ(4, 1, 0))
-
-# define V8_HAS_BUILTIN_CLZ (V8_GNUC_PREREQ(3, 4, 0))
-# define V8_HAS_BUILTIN_CTZ (V8_GNUC_PREREQ(3, 4, 0))
-# define V8_HAS_BUILTIN_EXPECT (V8_GNUC_PREREQ(2, 96, 0))
-# define V8_HAS_BUILTIN_FRAME_ADDRESS (V8_GNUC_PREREQ(2, 96, 0))
-# define V8_HAS_BUILTIN_POPCOUNT (V8_GNUC_PREREQ(3, 4, 0))
-
-# if __cplusplus >= 201103L
-#  define V8_HAS_CXX11_ALIGNAS (V8_GNUC_PREREQ(4, 8, 0))
-#  define V8_HAS_CXX11_ALIGNOF (V8_GNUC_PREREQ(4, 8, 0))
-# endif
-#endif
-
-#if defined(_MSC_VER)
-# define V8_CC_MSVC 1
-# define V8_HAS___ALIGNOF 1
-
-# define V8_HAS_DECLSPEC_ALIGN 1
-# define V8_HAS_DECLSPEC_DEPRECATED 1
-# define V8_HAS_DECLSPEC_NOINLINE 1
-# define V8_HAS_DECLSPEC_SELECTANY 1
-# define V8_HAS_DECLSPEC_NORETURN 1
-
-# define V8_HAS___FORCEINLINE 1
-
-#endif
-
-
-// -----------------------------------------------------------------------------
-// Helper macros
-
-// A macro used to make better inlining. Don't bother for debug builds.
-// Use like:
-//   V8_INLINE int GetZero() { return 0; }
-#if !defined(DEBUG) && V8_HAS_ATTRIBUTE_ALWAYS_INLINE
-# define V8_INLINE inline __attribute__((always_inline))
-#elif !defined(DEBUG) && V8_HAS___FORCEINLINE
-# define V8_INLINE __forceinline
-#else
-# define V8_INLINE inline
-#endif
-
-
-// A macro used to tell the compiler to never inline a particular function.
-// Don't bother for debug builds.
-// Use like:
-//   V8_NOINLINE int GetMinusOne() { return -1; }
-#if !defined(DEBUG) && V8_HAS_ATTRIBUTE_NOINLINE
-# define V8_NOINLINE __attribute__((noinline))
-#elif !defined(DEBUG) && V8_HAS_DECLSPEC_NOINLINE
-# define V8_NOINLINE __declspec(noinline)
-#else
-# define V8_NOINLINE /* NOT SUPPORTED */
-#endif
-
-
-// A macro used to tell the compiler that a particular function never returns.
-// Use like:
-//   V8_NORETURN void MyAbort() { abort(); }
-#if V8_HAS_ATTRIBUTE_NORETURN
-# define V8_NORETURN __attribute__((noreturn))
-#elif HAS_DECLSPEC_NORETURN
-# define V8_NORETURN __declspec(noreturn)
-#else
-# define V8_NORETURN /* NOT SUPPORTED */
-#endif
-
-
-// A macro (V8_DEPRECATED) to mark classes or functions as deprecated.
-#if defined(V8_DEPRECATION_WARNINGS) && V8_HAS_ATTRIBUTE_DEPRECATED_MESSAGE
-#define V8_DEPRECATED(message, declarator) \
-  declarator __attribute__((deprecated(message)))
-#elif defined(V8_DEPRECATION_WARNINGS) && V8_HAS_ATTRIBUTE_DEPRECATED
-#define V8_DEPRECATED(message, declarator) \
-  declarator __attribute__((deprecated))
-#elif defined(V8_DEPRECATION_WARNINGS) && V8_HAS_DECLSPEC_DEPRECATED
-#define V8_DEPRECATED(message, declarator) __declspec(deprecated) declarator
-#else
-#define V8_DEPRECATED(message, declarator) declarator
-#endif
-
-
-// A macro (V8_DEPRECATE_SOON) to make it easier to see what will be deprecated.
-#if defined(V8_IMMINENT_DEPRECATION_WARNINGS) && \
-    V8_HAS_ATTRIBUTE_DEPRECATED_MESSAGE
-#define V8_DEPRECATE_SOON(message, declarator) \
-  declarator __attribute__((deprecated(message)))
-#elif defined(V8_IMMINENT_DEPRECATION_WARNINGS) && V8_HAS_ATTRIBUTE_DEPRECATED
-#define V8_DEPRECATE_SOON(message, declarator) \
-  declarator __attribute__((deprecated))
-#elif defined(V8_IMMINENT_DEPRECATION_WARNINGS) && V8_HAS_DECLSPEC_DEPRECATED
-#define V8_DEPRECATE_SOON(message, declarator) __declspec(deprecated) declarator
-#else
-#define V8_DEPRECATE_SOON(message, declarator) declarator
-#endif
-
-
-// A macro to provide the compiler with branch prediction information.
-#if V8_HAS_BUILTIN_EXPECT
-# define V8_UNLIKELY(condition) (__builtin_expect(!!(condition), 0))
-# define V8_LIKELY(condition) (__builtin_expect(!!(condition), 1))
-#else
-# define V8_UNLIKELY(condition) (condition)
-# define V8_LIKELY(condition) (condition)
-#endif
-
-
-// This macro allows to specify memory alignment for structs, classes, etc.
-// Use like:
-//   class V8_ALIGNED(16) MyClass { ... };
-//   V8_ALIGNED(32) int array[42];
-#if V8_HAS_CXX11_ALIGNAS
-# define V8_ALIGNED(n) alignas(n)
-#elif V8_HAS_ATTRIBUTE_ALIGNED
-# define V8_ALIGNED(n) __attribute__((aligned(n)))
-#elif V8_HAS_DECLSPEC_ALIGN
-# define V8_ALIGNED(n) __declspec(align(n))
-#else
-# define V8_ALIGNED(n) /* NOT SUPPORTED */
-#endif
-
-
-// This macro is similar to V8_ALIGNED(), but takes a type instead of size
-// in bytes. If the compiler does not supports using the alignment of the
-// |type|, it will align according to the |alignment| instead. For example,
-// Visual Studio C++ cannot combine __declspec(align) and __alignof. The
-// |alignment| must be a literal that is used as a kind of worst-case fallback
-// alignment.
-// Use like:
-//   struct V8_ALIGNAS(AnotherClass, 16) NewClass { ... };
-//   V8_ALIGNAS(double, 8) int array[100];
-#if V8_HAS_CXX11_ALIGNAS
-# define V8_ALIGNAS(type, alignment) alignas(type)
-#elif V8_HAS___ALIGNOF__ && V8_HAS_ATTRIBUTE_ALIGNED
-# define V8_ALIGNAS(type, alignment) __attribute__((aligned(__alignof__(type))))
-#else
-# define V8_ALIGNAS(type, alignment) V8_ALIGNED(alignment)
-#endif
-
-
-// This macro returns alignment in bytes (an integer power of two) required for
-// any instance of the given type, which is either complete type, an array type,
-// or a reference type.
-// Use like:
-//   size_t alignment = V8_ALIGNOF(double);
-#if V8_HAS_CXX11_ALIGNOF
-# define V8_ALIGNOF(type) alignof(type)
-#elif V8_HAS___ALIGNOF
-# define V8_ALIGNOF(type) __alignof(type)
-#elif V8_HAS___ALIGNOF__
-# define V8_ALIGNOF(type) __alignof__(type)
-#else
-// Note that alignment of a type within a struct can be less than the
-// alignment of the type stand-alone (because of ancient ABIs), so this
-// should only be used as a last resort.
-namespace v8 { template <typename T> class AlignOfHelper { char c; T t; }; }
-# define V8_ALIGNOF(type) (sizeof(::v8::AlignOfHelper<type>) - sizeof(type))
-#endif
-
-// Annotate a function indicating the caller must examine the return value.
-// Use like:
-//   int foo() WARN_UNUSED_RESULT;
-#if V8_HAS_ATTRIBUTE_WARN_UNUSED_RESULT
-#define V8_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
-#else
-#define V8_WARN_UNUSED_RESULT /* NOT SUPPORTED */
-#endif
-
-// clang-format on
-
-#endif  // V8CONFIG_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/zlib/contrib/blast/blast.h
+++ /dev/null
@@ -1,83 +0,0 @@
-/* blast.h -- interface for blast.c
-  Copyright (C) 2003, 2012, 2013 Mark Adler
-  version 1.3, 24 Aug 2013
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the author be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  Mark Adler    madler@alumni.caltech.edu
- */
-
-
-/*
- * blast() decompresses the PKWare Data Compression Library (DCL) compressed
- * format.  It provides the same functionality as the explode() function in
- * that library.  (Note: PKWare overused the "implode" verb, and the format
- * used by their library implode() function is completely different and
- * incompatible with the implode compression method supported by PKZIP.)
- *
- * The binary mode for stdio functions should be used to assure that the
- * compressed data is not corrupted when read or written.  For example:
- * fopen(..., "rb") and fopen(..., "wb").
- */
-
-
-typedef unsigned (*blast_in)(void *how, unsigned char **buf);
-typedef int (*blast_out)(void *how, unsigned char *buf, unsigned len);
-/* Definitions for input/output functions passed to blast().  See below for
- * what the provided functions need to do.
- */
-
-
-int blast(blast_in infun, void *inhow, blast_out outfun, void *outhow,
-          unsigned *left, unsigned char **in);
-/* Decompress input to output using the provided infun() and outfun() calls.
- * On success, the return value of blast() is zero.  If there is an error in
- * the source data, i.e. it is not in the proper format, then a negative value
- * is returned.  If there is not enough input available or there is not enough
- * output space, then a positive error is returned.
- *
- * The input function is invoked: len = infun(how, &buf), where buf is set by
- * infun() to point to the input buffer, and infun() returns the number of
- * available bytes there.  If infun() returns zero, then blast() returns with
- * an input error.  (blast() only asks for input if it needs it.)  inhow is for
- * use by the application to pass an input descriptor to infun(), if desired.
- *
- * If left and in are not NULL and *left is not zero when blast() is called,
- * then the *left bytes are *in are consumed for input before infun() is used.
- *
- * The output function is invoked: err = outfun(how, buf, len), where the bytes
- * to be written are buf[0..len-1].  If err is not zero, then blast() returns
- * with an output error.  outfun() is always called with len <= 4096.  outhow
- * is for use by the application to pass an output descriptor to outfun(), if
- * desired.
- *
- * If there is any unused input, *left is set to the number of bytes that were
- * read and *in points to them.  Otherwise *left is set to zero and *in is set
- * to NULL.  If left or in are NULL, then they are not set.
- *
- * The return codes are:
- *
- *   2:  ran out of input before completing decompression
- *   1:  output error before completing decompression
- *   0:  successful decompression
- *  -1:  literal flag not zero or one
- *  -2:  dictionary size not in 4..6
- *  -3:  distance is too far back
- *
- * At the bottom of blast.c is an example program that uses blast() that can be
- * compiled to produce a command-line decompression filter by defining TEST.
- */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/zlib/contrib/infback9/infback9.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/* infback9.h -- header for using inflateBack9 functions
- * Copyright (C) 2003 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/*
- * This header file and associated patches provide a decoder for PKWare's
- * undocumented deflate64 compression method (method 9).  Use with infback9.c,
- * inftree9.h, inftree9.c, and inffix9.h.  These patches are not supported.
- * This should be compiled with zlib, since it uses zutil.h and zutil.o.
- * This code has not yet been tested on 16-bit architectures.  See the
- * comments in zlib.h for inflateBack() usage.  These functions are used
- * identically, except that there is no windowBits parameter, and a 64K
- * window must be provided.  Also if int's are 16 bits, then a zero for
- * the third parameter of the "out" function actually means 65536UL.
- * zlib.h must be included before this header file.
- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-ZEXTERN int ZEXPORT inflateBack9 OF((z_stream FAR *strm,
-                                    in_func in, void FAR *in_desc,
-                                    out_func out, void FAR *out_desc));
-ZEXTERN int ZEXPORT inflateBack9End OF((z_stream FAR *strm));
-ZEXTERN int ZEXPORT inflateBack9Init_ OF((z_stream FAR *strm,
-                                         unsigned char FAR *window,
-                                         const char *version,
-                                         int stream_size));
-#define inflateBack9Init(strm, window) \
-        inflateBack9Init_((strm), (window), \
-        ZLIB_VERSION, sizeof(z_stream))
-
-#ifdef __cplusplus
-}
-#endif
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/zlib/contrib/infback9/inffix9.h
+++ /dev/null
@@ -1,107 +0,0 @@
-    /* inffix9.h -- table for decoding deflate64 fixed codes
-     * Generated automatically by makefixed9().
-     */
-
-    /* WARNING: this file should *not* be used by applications.
-       It is part of the implementation of this library and is
-       subject to change. Applications should only use zlib.h.
-     */
-
-    static const code lenfix[512] = {
-        {96,7,0},{0,8,80},{0,8,16},{132,8,115},{130,7,31},{0,8,112},
-        {0,8,48},{0,9,192},{128,7,10},{0,8,96},{0,8,32},{0,9,160},
-        {0,8,0},{0,8,128},{0,8,64},{0,9,224},{128,7,6},{0,8,88},
-        {0,8,24},{0,9,144},{131,7,59},{0,8,120},{0,8,56},{0,9,208},
-        {129,7,17},{0,8,104},{0,8,40},{0,9,176},{0,8,8},{0,8,136},
-        {0,8,72},{0,9,240},{128,7,4},{0,8,84},{0,8,20},{133,8,227},
-        {131,7,43},{0,8,116},{0,8,52},{0,9,200},{129,7,13},{0,8,100},
-        {0,8,36},{0,9,168},{0,8,4},{0,8,132},{0,8,68},{0,9,232},
-        {128,7,8},{0,8,92},{0,8,28},{0,9,152},{132,7,83},{0,8,124},
-        {0,8,60},{0,9,216},{130,7,23},{0,8,108},{0,8,44},{0,9,184},
-        {0,8,12},{0,8,140},{0,8,76},{0,9,248},{128,7,3},{0,8,82},
-        {0,8,18},{133,8,163},{131,7,35},{0,8,114},{0,8,50},{0,9,196},
-        {129,7,11},{0,8,98},{0,8,34},{0,9,164},{0,8,2},{0,8,130},
-        {0,8,66},{0,9,228},{128,7,7},{0,8,90},{0,8,26},{0,9,148},
-        {132,7,67},{0,8,122},{0,8,58},{0,9,212},{130,7,19},{0,8,106},
-        {0,8,42},{0,9,180},{0,8,10},{0,8,138},{0,8,74},{0,9,244},
-        {128,7,5},{0,8,86},{0,8,22},{65,8,0},{131,7,51},{0,8,118},
-        {0,8,54},{0,9,204},{129,7,15},{0,8,102},{0,8,38},{0,9,172},
-        {0,8,6},{0,8,134},{0,8,70},{0,9,236},{128,7,9},{0,8,94},
-        {0,8,30},{0,9,156},{132,7,99},{0,8,126},{0,8,62},{0,9,220},
-        {130,7,27},{0,8,110},{0,8,46},{0,9,188},{0,8,14},{0,8,142},
-        {0,8,78},{0,9,252},{96,7,0},{0,8,81},{0,8,17},{133,8,131},
-        {130,7,31},{0,8,113},{0,8,49},{0,9,194},{128,7,10},{0,8,97},
-        {0,8,33},{0,9,162},{0,8,1},{0,8,129},{0,8,65},{0,9,226},
-        {128,7,6},{0,8,89},{0,8,25},{0,9,146},{131,7,59},{0,8,121},
-        {0,8,57},{0,9,210},{129,7,17},{0,8,105},{0,8,41},{0,9,178},
-        {0,8,9},{0,8,137},{0,8,73},{0,9,242},{128,7,4},{0,8,85},
-        {0,8,21},{144,8,3},{131,7,43},{0,8,117},{0,8,53},{0,9,202},
-        {129,7,13},{0,8,101},{0,8,37},{0,9,170},{0,8,5},{0,8,133},
-        {0,8,69},{0,9,234},{128,7,8},{0,8,93},{0,8,29},{0,9,154},
-        {132,7,83},{0,8,125},{0,8,61},{0,9,218},{130,7,23},{0,8,109},
-        {0,8,45},{0,9,186},{0,8,13},{0,8,141},{0,8,77},{0,9,250},
-        {128,7,3},{0,8,83},{0,8,19},{133,8,195},{131,7,35},{0,8,115},
-        {0,8,51},{0,9,198},{129,7,11},{0,8,99},{0,8,35},{0,9,166},
-        {0,8,3},{0,8,131},{0,8,67},{0,9,230},{128,7,7},{0,8,91},
-        {0,8,27},{0,9,150},{132,7,67},{0,8,123},{0,8,59},{0,9,214},
-        {130,7,19},{0,8,107},{0,8,43},{0,9,182},{0,8,11},{0,8,139},
-        {0,8,75},{0,9,246},{128,7,5},{0,8,87},{0,8,23},{77,8,0},
-        {131,7,51},{0,8,119},{0,8,55},{0,9,206},{129,7,15},{0,8,103},
-        {0,8,39},{0,9,174},{0,8,7},{0,8,135},{0,8,71},{0,9,238},
-        {128,7,9},{0,8,95},{0,8,31},{0,9,158},{132,7,99},{0,8,127},
-        {0,8,63},{0,9,222},{130,7,27},{0,8,111},{0,8,47},{0,9,190},
-        {0,8,15},{0,8,143},{0,8,79},{0,9,254},{96,7,0},{0,8,80},
-        {0,8,16},{132,8,115},{130,7,31},{0,8,112},{0,8,48},{0,9,193},
-        {128,7,10},{0,8,96},{0,8,32},{0,9,161},{0,8,0},{0,8,128},
-        {0,8,64},{0,9,225},{128,7,6},{0,8,88},{0,8,24},{0,9,145},
-        {131,7,59},{0,8,120},{0,8,56},{0,9,209},{129,7,17},{0,8,104},
-        {0,8,40},{0,9,177},{0,8,8},{0,8,136},{0,8,72},{0,9,241},
-        {128,7,4},{0,8,84},{0,8,20},{133,8,227},{131,7,43},{0,8,116},
-        {0,8,52},{0,9,201},{129,7,13},{0,8,100},{0,8,36},{0,9,169},
-        {0,8,4},{0,8,132},{0,8,68},{0,9,233},{128,7,8},{0,8,92},
-        {0,8,28},{0,9,153},{132,7,83},{0,8,124},{0,8,60},{0,9,217},
-        {130,7,23},{0,8,108},{0,8,44},{0,9,185},{0,8,12},{0,8,140},
-        {0,8,76},{0,9,249},{128,7,3},{0,8,82},{0,8,18},{133,8,163},
-        {131,7,35},{0,8,114},{0,8,50},{0,9,197},{129,7,11},{0,8,98},
-        {0,8,34},{0,9,165},{0,8,2},{0,8,130},{0,8,66},{0,9,229},
-        {128,7,7},{0,8,90},{0,8,26},{0,9,149},{132,7,67},{0,8,122},
-        {0,8,58},{0,9,213},{130,7,19},{0,8,106},{0,8,42},{0,9,181},
-        {0,8,10},{0,8,138},{0,8,74},{0,9,245},{128,7,5},{0,8,86},
-        {0,8,22},{65,8,0},{131,7,51},{0,8,118},{0,8,54},{0,9,205},
-        {129,7,15},{0,8,102},{0,8,38},{0,9,173},{0,8,6},{0,8,134},
-        {0,8,70},{0,9,237},{128,7,9},{0,8,94},{0,8,30},{0,9,157},
-        {132,7,99},{0,8,126},{0,8,62},{0,9,221},{130,7,27},{0,8,110},
-        {0,8,46},{0,9,189},{0,8,14},{0,8,142},{0,8,78},{0,9,253},
-        {96,7,0},{0,8,81},{0,8,17},{133,8,131},{130,7,31},{0,8,113},
-        {0,8,49},{0,9,195},{128,7,10},{0,8,97},{0,8,33},{0,9,163},
-        {0,8,1},{0,8,129},{0,8,65},{0,9,227},{128,7,6},{0,8,89},
-        {0,8,25},{0,9,147},{131,7,59},{0,8,121},{0,8,57},{0,9,211},
-        {129,7,17},{0,8,105},{0,8,41},{0,9,179},{0,8,9},{0,8,137},
-        {0,8,73},{0,9,243},{128,7,4},{0,8,85},{0,8,21},{144,8,3},
-        {131,7,43},{0,8,117},{0,8,53},{0,9,203},{129,7,13},{0,8,101},
-        {0,8,37},{0,9,171},{0,8,5},{0,8,133},{0,8,69},{0,9,235},
-        {128,7,8},{0,8,93},{0,8,29},{0,9,155},{132,7,83},{0,8,125},
-        {0,8,61},{0,9,219},{130,7,23},{0,8,109},{0,8,45},{0,9,187},
-        {0,8,13},{0,8,141},{0,8,77},{0,9,251},{128,7,3},{0,8,83},
-        {0,8,19},{133,8,195},{131,7,35},{0,8,115},{0,8,51},{0,9,199},
-        {129,7,11},{0,8,99},{0,8,35},{0,9,167},{0,8,3},{0,8,131},
-        {0,8,67},{0,9,231},{128,7,7},{0,8,91},{0,8,27},{0,9,151},
-        {132,7,67},{0,8,123},{0,8,59},{0,9,215},{130,7,19},{0,8,107},
-        {0,8,43},{0,9,183},{0,8,11},{0,8,139},{0,8,75},{0,9,247},
-        {128,7,5},{0,8,87},{0,8,23},{77,8,0},{131,7,51},{0,8,119},
-        {0,8,55},{0,9,207},{129,7,15},{0,8,103},{0,8,39},{0,9,175},
-        {0,8,7},{0,8,135},{0,8,71},{0,9,239},{128,7,9},{0,8,95},
-        {0,8,31},{0,9,159},{132,7,99},{0,8,127},{0,8,63},{0,9,223},
-        {130,7,27},{0,8,111},{0,8,47},{0,9,191},{0,8,15},{0,8,143},
-        {0,8,79},{0,9,255}
-    };
-
-    static const code distfix[32] = {
-        {128,5,1},{135,5,257},{131,5,17},{139,5,4097},{129,5,5},
-        {137,5,1025},{133,5,65},{141,5,16385},{128,5,3},{136,5,513},
-        {132,5,33},{140,5,8193},{130,5,9},{138,5,2049},{134,5,129},
-        {142,5,32769},{128,5,2},{135,5,385},{131,5,25},{139,5,6145},
-        {129,5,7},{137,5,1537},{133,5,97},{141,5,24577},{128,5,4},
-        {136,5,769},{132,5,49},{140,5,12289},{130,5,13},{138,5,3073},
-        {134,5,193},{142,5,49153}
-    };
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/zlib/contrib/infback9/inflate9.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/* inflate9.h -- internal inflate state definition
- * Copyright (C) 1995-2003 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-/* Possible inflate modes between inflate() calls */
-typedef enum {
-        TYPE,       /* i: waiting for type bits, including last-flag bit */
-        STORED,     /* i: waiting for stored size (length and complement) */
-        TABLE,      /* i: waiting for dynamic block table lengths */
-            LEN,        /* i: waiting for length/lit code */
-    DONE,       /* finished check, done -- remain here until reset */
-    BAD         /* got a data error -- remain here until reset */
-} inflate_mode;
-
-/*
-    State transitions between above modes -
-
-    (most modes can go to the BAD mode -- not shown for clarity)
-
-    Read deflate blocks:
-            TYPE -> STORED or TABLE or LEN or DONE
-            STORED -> TYPE
-            TABLE -> LENLENS -> CODELENS -> LEN
-    Read deflate codes:
-                LEN -> LEN or TYPE
- */
-
-/* state maintained between inflate() calls.  Approximately 7K bytes. */
-struct inflate_state {
-        /* sliding window */
-    unsigned char FAR *window;  /* allocated sliding window, if needed */
-        /* dynamic table building */
-    unsigned ncode;             /* number of code length code lengths */
-    unsigned nlen;              /* number of length code lengths */
-    unsigned ndist;             /* number of distance code lengths */
-    unsigned have;              /* number of code lengths in lens[] */
-    code FAR *next;             /* next available space in codes[] */
-    unsigned short lens[320];   /* temporary storage for code lengths */
-    unsigned short work[288];   /* work area for code table building */
-    code codes[ENOUGH];         /* space for code tables */
-};
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/zlib/contrib/infback9/inftree9.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/* inftree9.h -- header to use inftree9.c
- * Copyright (C) 1995-2008 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-/* Structure for decoding tables.  Each entry provides either the
-   information needed to do the operation requested by the code that
-   indexed that table entry, or it provides a pointer to another
-   table that indexes more bits of the code.  op indicates whether
-   the entry is a pointer to another table, a literal, a length or
-   distance, an end-of-block, or an invalid code.  For a table
-   pointer, the low four bits of op is the number of index bits of
-   that table.  For a length or distance, the low four bits of op
-   is the number of extra bits to get after the code.  bits is
-   the number of bits in this code or part of the code to drop off
-   of the bit buffer.  val is the actual byte to output in the case
-   of a literal, the base length or distance, or the offset from
-   the current table to the next table.  Each entry is four bytes. */
-typedef struct {
-    unsigned char op;           /* operation, extra bits, table bits */
-    unsigned char bits;         /* bits in this part of the code */
-    unsigned short val;         /* offset in table or code value */
-} code;
-
-/* op values as set by inflate_table():
-    00000000 - literal
-    0000tttt - table link, tttt != 0 is the number of table index bits
-    100eeeee - length or distance, eeee is the number of extra bits
-    01100000 - end of block
-    01000000 - invalid code
- */
-
-/* Maximum size of the dynamic table.  The maximum number of code structures is
-   1446, which is the sum of 852 for literal/length codes and 594 for distance
-   codes.  These values were found by exhaustive searches using the program
-   examples/enough.c found in the zlib distribtution.  The arguments to that
-   program are the number of symbols, the initial root table size, and the
-   maximum bit length of a code.  "enough 286 9 15" for literal/length codes
-   returns returns 852, and "enough 32 6 15" for distance codes returns 594.
-   The initial root table size (9 or 6) is found in the fifth argument of the
-   inflate_table() calls in infback9.c.  If the root table size is changed,
-   then these maximum sizes would be need to be recalculated and updated. */
-#define ENOUGH_LENS 852
-#define ENOUGH_DISTS 594
-#define ENOUGH (ENOUGH_LENS+ENOUGH_DISTS)
-
-/* Type of code to build for inflate_table9() */
-typedef enum {
-    CODES,
-    LENS,
-    DISTS
-} codetype;
-
-extern int inflate_table9 OF((codetype type, unsigned short FAR *lens,
-                             unsigned codes, code FAR * FAR *table,
-                             unsigned FAR *bits, unsigned short FAR *work));
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/zlib/contrib/iostream/zfstream.h
+++ /dev/null
@@ -1,128 +0,0 @@
-
-#ifndef zfstream_h
-#define zfstream_h
-
-#include <fstream.h>
-#include "zlib.h"
-
-class gzfilebuf : public streambuf {
-
-public:
-
-  gzfilebuf( );
-  virtual ~gzfilebuf();
-
-  gzfilebuf *open( const char *name, int io_mode );
-  gzfilebuf *attach( int file_descriptor, int io_mode );
-  gzfilebuf *close();
-
-  int setcompressionlevel( int comp_level );
-  int setcompressionstrategy( int comp_strategy );
-
-  inline int is_open() const { return (file !=NULL); }
-
-  virtual streampos seekoff( streamoff, ios::seek_dir, int );
-
-  virtual int sync();
-
-protected:
-
-  virtual int underflow();
-  virtual int overflow( int = EOF );
-
-private:
-
-  gzFile file;
-  short mode;
-  short own_file_descriptor;
-
-  int flushbuf();
-  int fillbuf();
-
-};
-
-class gzfilestream_common : virtual public ios {
-
-  friend class gzifstream;
-  friend class gzofstream;
-  friend gzofstream &setcompressionlevel( gzofstream &, int );
-  friend gzofstream &setcompressionstrategy( gzofstream &, int );
-
-public:
-  virtual ~gzfilestream_common();
-
-  void attach( int fd, int io_mode );
-  void open( const char *name, int io_mode );
-  void close();
-
-protected:
-  gzfilestream_common();
-
-private:
-  gzfilebuf *rdbuf();
-
-  gzfilebuf buffer;
-
-};
-
-class gzifstream : public gzfilestream_common, public istream {
-
-public:
-
-  gzifstream();
-  gzifstream( const char *name, int io_mode = ios::in );
-  gzifstream( int fd, int io_mode = ios::in );
-
-  virtual ~gzifstream();
-
-};
-
-class gzofstream : public gzfilestream_common, public ostream {
-
-public:
-
-  gzofstream();
-  gzofstream( const char *name, int io_mode = ios::out );
-  gzofstream( int fd, int io_mode = ios::out );
-
-  virtual ~gzofstream();
-
-};
-
-template<class T> class gzomanip {
-  friend gzofstream &operator<<(gzofstream &, const gzomanip<T> &);
-public:
-  gzomanip(gzofstream &(*f)(gzofstream &, T), T v) : func(f), val(v) { }
-private:
-  gzofstream &(*func)(gzofstream &, T);
-  T val;
-};
-
-template<class T> gzofstream &operator<<(gzofstream &s, const gzomanip<T> &m)
-{
-  return (*m.func)(s, m.val);
-}
-
-inline gzofstream &setcompressionlevel( gzofstream &s, int l )
-{
-  (s.rdbuf())->setcompressionlevel(l);
-  return s;
-}
-
-inline gzofstream &setcompressionstrategy( gzofstream &s, int l )
-{
-  (s.rdbuf())->setcompressionstrategy(l);
-  return s;
-}
-
-inline gzomanip<int> setcompressionlevel(int l)
-{
-  return gzomanip<int>(&setcompressionlevel,l);
-}
-
-inline gzomanip<int> setcompressionstrategy(int l)
-{
-  return gzomanip<int>(&setcompressionstrategy,l);
-}
-
-#endif
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/zlib/contrib/iostream2/zstream.h
+++ /dev/null
@@ -1,307 +0,0 @@
-/*
- *
- * Copyright (c) 1997
- * Christian Michelsen Research AS
- * Advanced Computing
- * Fantoftvegen 38, 5036 BERGEN, Norway
- * http://www.cmr.no
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Christian Michelsen Research AS makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- */
-
-#ifndef ZSTREAM__H
-#define ZSTREAM__H
-
-/*
- * zstream.h - C++ interface to the 'zlib' general purpose compression library
- * $Id: zstream.h 1.1 1997-06-25 12:00:56+02 tyge Exp tyge $
- */
-
-#include <strstream.h>
-#include <string.h>
-#include <stdio.h>
-#include "zlib.h"
-
-#if defined(_WIN32)
-#   include <fcntl.h>
-#   include <io.h>
-#   define SET_BINARY_MODE(file) setmode(fileno(file), O_BINARY)
-#else
-#   define SET_BINARY_MODE(file)
-#endif
-
-class zstringlen {
-public:
-    zstringlen(class izstream&);
-    zstringlen(class ozstream&, const char*);
-    size_t value() const { return val.word; }
-private:
-    struct Val { unsigned char byte; size_t word; } val;
-};
-
-//  ----------------------------- izstream -----------------------------
-
-class izstream
-{
-    public:
-        izstream() : m_fp(0) {}
-        izstream(FILE* fp) : m_fp(0) { open(fp); }
-        izstream(const char* name) : m_fp(0) { open(name); }
-        ~izstream() { close(); }
-
-        /* Opens a gzip (.gz) file for reading.
-         * open() can be used to read a file which is not in gzip format;
-         * in this case read() will directly read from the file without
-         * decompression. errno can be checked to distinguish two error
-         * cases (if errno is zero, the zlib error is Z_MEM_ERROR).
-         */
-        void open(const char* name) {
-            if (m_fp) close();
-            m_fp = ::gzopen(name, "rb");
-        }
-
-        void open(FILE* fp) {
-            SET_BINARY_MODE(fp);
-            if (m_fp) close();
-            m_fp = ::gzdopen(fileno(fp), "rb");
-        }
-
-        /* Flushes all pending input if necessary, closes the compressed file
-         * and deallocates all the (de)compression state. The return value is
-         * the zlib error number (see function error() below).
-         */
-        int close() {
-            int r = ::gzclose(m_fp);
-            m_fp = 0; return r;
-        }
-
-        /* Binary read the given number of bytes from the compressed file.
-         */
-        int read(void* buf, size_t len) {
-            return ::gzread(m_fp, buf, len);
-        }
-
-        /* Returns the error message for the last error which occurred on the
-         * given compressed file. errnum is set to zlib error number. If an
-         * error occurred in the file system and not in the compression library,
-         * errnum is set to Z_ERRNO and the application may consult errno
-         * to get the exact error code.
-         */
-        const char* error(int* errnum) {
-            return ::gzerror(m_fp, errnum);
-        }
-
-        gzFile fp() { return m_fp; }
-
-    private:
-        gzFile m_fp;
-};
-
-/*
- * Binary read the given (array of) object(s) from the compressed file.
- * If the input file was not in gzip format, read() copies the objects number
- * of bytes into the buffer.
- * returns the number of uncompressed bytes actually read
- * (0 for end of file, -1 for error).
- */
-template <class T, class Items>
-inline int read(izstream& zs, T* x, Items items) {
-    return ::gzread(zs.fp(), x, items*sizeof(T));
-}
-
-/*
- * Binary input with the '>' operator.
- */
-template <class T>
-inline izstream& operator>(izstream& zs, T& x) {
-    ::gzread(zs.fp(), &x, sizeof(T));
-    return zs;
-}
-
-
-inline zstringlen::zstringlen(izstream& zs) {
-    zs > val.byte;
-    if (val.byte == 255) zs > val.word;
-    else val.word = val.byte;
-}
-
-/*
- * Read length of string + the string with the '>' operator.
- */
-inline izstream& operator>(izstream& zs, char* x) {
-    zstringlen len(zs);
-    ::gzread(zs.fp(), x, len.value());
-    x[len.value()] = '\0';
-    return zs;
-}
-
-inline char* read_string(izstream& zs) {
-    zstringlen len(zs);
-    char* x = new char[len.value()+1];
-    ::gzread(zs.fp(), x, len.value());
-    x[len.value()] = '\0';
-    return x;
-}
-
-// ----------------------------- ozstream -----------------------------
-
-class ozstream
-{
-    public:
-        ozstream() : m_fp(0), m_os(0) {
-        }
-        ozstream(FILE* fp, int level = Z_DEFAULT_COMPRESSION)
-            : m_fp(0), m_os(0) {
-            open(fp, level);
-        }
-        ozstream(const char* name, int level = Z_DEFAULT_COMPRESSION)
-            : m_fp(0), m_os(0) {
-            open(name, level);
-        }
-        ~ozstream() {
-            close();
-        }
-
-        /* Opens a gzip (.gz) file for writing.
-         * The compression level parameter should be in 0..9
-         * errno can be checked to distinguish two error cases
-         * (if errno is zero, the zlib error is Z_MEM_ERROR).
-         */
-        void open(const char* name, int level = Z_DEFAULT_COMPRESSION) {
-            char mode[4] = "wb\0";
-            if (level != Z_DEFAULT_COMPRESSION) mode[2] = '0'+level;
-            if (m_fp) close();
-            m_fp = ::gzopen(name, mode);
-        }
-
-        /* open from a FILE pointer.
-         */
-        void open(FILE* fp, int level = Z_DEFAULT_COMPRESSION) {
-            SET_BINARY_MODE(fp);
-            char mode[4] = "wb\0";
-            if (level != Z_DEFAULT_COMPRESSION) mode[2] = '0'+level;
-            if (m_fp) close();
-            m_fp = ::gzdopen(fileno(fp), mode);
-        }
-
-        /* Flushes all pending output if necessary, closes the compressed file
-         * and deallocates all the (de)compression state. The return value is
-         * the zlib error number (see function error() below).
-         */
-        int close() {
-            if (m_os) {
-                ::gzwrite(m_fp, m_os->str(), m_os->pcount());
-                delete[] m_os->str(); delete m_os; m_os = 0;
-            }
-            int r = ::gzclose(m_fp); m_fp = 0; return r;
-        }
-
-        /* Binary write the given number of bytes into the compressed file.
-         */
-        int write(const void* buf, size_t len) {
-            return ::gzwrite(m_fp, (voidp) buf, len);
-        }
-
-        /* Flushes all pending output into the compressed file. The parameter
-         * _flush is as in the deflate() function. The return value is the zlib
-         * error number (see function gzerror below). flush() returns Z_OK if
-         * the flush_ parameter is Z_FINISH and all output could be flushed.
-         * flush() should be called only when strictly necessary because it can
-         * degrade compression.
-         */
-        int flush(int _flush) {
-            os_flush();
-            return ::gzflush(m_fp, _flush);
-        }
-
-        /* Returns the error message for the last error which occurred on the
-         * given compressed file. errnum is set to zlib error number. If an
-         * error occurred in the file system and not in the compression library,
-         * errnum is set to Z_ERRNO and the application may consult errno
-         * to get the exact error code.
-         */
-        const char* error(int* errnum) {
-            return ::gzerror(m_fp, errnum);
-        }
-
-        gzFile fp() { return m_fp; }
-
-        ostream& os() {
-            if (m_os == 0) m_os = new ostrstream;
-            return *m_os;
-        }
-
-        void os_flush() {
-            if (m_os && m_os->pcount()>0) {
-                ostrstream* oss = new ostrstream;
-                oss->fill(m_os->fill());
-                oss->flags(m_os->flags());
-                oss->precision(m_os->precision());
-                oss->width(m_os->width());
-                ::gzwrite(m_fp, m_os->str(), m_os->pcount());
-                delete[] m_os->str(); delete m_os; m_os = oss;
-            }
-        }
-
-    private:
-        gzFile m_fp;
-        ostrstream* m_os;
-};
-
-/*
- * Binary write the given (array of) object(s) into the compressed file.
- * returns the number of uncompressed bytes actually written
- * (0 in case of error).
- */
-template <class T, class Items>
-inline int write(ozstream& zs, const T* x, Items items) {
-    return ::gzwrite(zs.fp(), (voidp) x, items*sizeof(T));
-}
-
-/*
- * Binary output with the '<' operator.
- */
-template <class T>
-inline ozstream& operator<(ozstream& zs, const T& x) {
-    ::gzwrite(zs.fp(), (voidp) &x, sizeof(T));
-    return zs;
-}
-
-inline zstringlen::zstringlen(ozstream& zs, const char* x) {
-    val.byte = 255;  val.word = ::strlen(x);
-    if (val.word < 255) zs < (val.byte = val.word);
-    else zs < val;
-}
-
-/*
- * Write length of string + the string with the '<' operator.
- */
-inline ozstream& operator<(ozstream& zs, const char* x) {
-    zstringlen len(zs, x);
-    ::gzwrite(zs.fp(), (voidp) x, len.value());
-    return zs;
-}
-
-#ifdef _MSC_VER
-inline ozstream& operator<(ozstream& zs, char* const& x) {
-    return zs < (const char*) x;
-}
-#endif
-
-/*
- * Ascii write with the << operator;
- */
-template <class T>
-inline ostream& operator<<(ozstream& zs, const T& x) {
-    zs.os_flush();
-    return zs.os() << x;
-}
-
-#endif
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/zlib/contrib/iostream3/zfstream.h
+++ /dev/null
@@ -1,466 +0,0 @@
-/*
- * A C++ I/O streams interface to the zlib gz* functions
- *
- * by Ludwig Schwardt <schwardt@sun.ac.za>
- * original version by Kevin Ruland <kevin@rodin.wustl.edu>
- *
- * This version is standard-compliant and compatible with gcc 3.x.
- */
-
-#ifndef ZFSTREAM_H
-#define ZFSTREAM_H
-
-#include <istream>  // not iostream, since we don't need cin/cout
-#include <ostream>
-#include "zlib.h"
-
-/*****************************************************************************/
-
-/**
- *  @brief  Gzipped file stream buffer class.
- *
- *  This class implements basic_filebuf for gzipped files. It doesn't yet support
- *  seeking (allowed by zlib but slow/limited), putback and read/write access
- *  (tricky). Otherwise, it attempts to be a drop-in replacement for the standard
- *  file streambuf.
-*/
-class gzfilebuf : public std::streambuf
-{
-public:
-  //  Default constructor.
-  gzfilebuf();
-
-  //  Destructor.
-  virtual
-  ~gzfilebuf();
-
-  /**
-   *  @brief  Set compression level and strategy on the fly.
-   *  @param  comp_level  Compression level (see zlib.h for allowed values)
-   *  @param  comp_strategy  Compression strategy (see zlib.h for allowed values)
-   *  @return  Z_OK on success, Z_STREAM_ERROR otherwise.
-   *
-   *  Unfortunately, these parameters cannot be modified separately, as the
-   *  previous zfstream version assumed. Since the strategy is seldom changed,
-   *  it can default and setcompression(level) then becomes like the old
-   *  setcompressionlevel(level).
-  */
-  int
-  setcompression(int comp_level,
-                 int comp_strategy = Z_DEFAULT_STRATEGY);
-
-  /**
-   *  @brief  Check if file is open.
-   *  @return  True if file is open.
-  */
-  bool
-  is_open() const { return (file != NULL); }
-
-  /**
-   *  @brief  Open gzipped file.
-   *  @param  name  File name.
-   *  @param  mode  Open mode flags.
-   *  @return  @c this on success, NULL on failure.
-  */
-  gzfilebuf*
-  open(const char* name,
-       std::ios_base::openmode mode);
-
-  /**
-   *  @brief  Attach to already open gzipped file.
-   *  @param  fd  File descriptor.
-   *  @param  mode  Open mode flags.
-   *  @return  @c this on success, NULL on failure.
-  */
-  gzfilebuf*
-  attach(int fd,
-         std::ios_base::openmode mode);
-
-  /**
-   *  @brief  Close gzipped file.
-   *  @return  @c this on success, NULL on failure.
-  */
-  gzfilebuf*
-  close();
-
-protected:
-  /**
-   *  @brief  Convert ios open mode int to mode string used by zlib.
-   *  @return  True if valid mode flag combination.
-  */
-  bool
-  open_mode(std::ios_base::openmode mode,
-            char* c_mode) const;
-
-  /**
-   *  @brief  Number of characters available in stream buffer.
-   *  @return  Number of characters.
-   *
-   *  This indicates number of characters in get area of stream buffer.
-   *  These characters can be read without accessing the gzipped file.
-  */
-  virtual std::streamsize
-  showmanyc();
-
-  /**
-   *  @brief  Fill get area from gzipped file.
-   *  @return  First character in get area on success, EOF on error.
-   *
-   *  This actually reads characters from gzipped file to stream
-   *  buffer. Always buffered.
-  */
-  virtual int_type
-  underflow();
-
-  /**
-   *  @brief  Write put area to gzipped file.
-   *  @param  c  Extra character to add to buffer contents.
-   *  @return  Non-EOF on success, EOF on error.
-   *
-   *  This actually writes characters in stream buffer to
-   *  gzipped file. With unbuffered output this is done one
-   *  character at a time.
-  */
-  virtual int_type
-  overflow(int_type c = traits_type::eof());
-
-  /**
-   *  @brief  Installs external stream buffer.
-   *  @param  p  Pointer to char buffer.
-   *  @param  n  Size of external buffer.
-   *  @return  @c this on success, NULL on failure.
-   *
-   *  Call setbuf(0,0) to enable unbuffered output.
-  */
-  virtual std::streambuf*
-  setbuf(char_type* p,
-         std::streamsize n);
-
-  /**
-   *  @brief  Flush stream buffer to file.
-   *  @return  0 on success, -1 on error.
-   *
-   *  This calls underflow(EOF) to do the job.
-  */
-  virtual int
-  sync();
-
-//
-// Some future enhancements
-//
-//  virtual int_type uflow();
-//  virtual int_type pbackfail(int_type c = traits_type::eof());
-//  virtual pos_type
-//  seekoff(off_type off,
-//          std::ios_base::seekdir way,
-//          std::ios_base::openmode mode = std::ios_base::in|std::ios_base::out);
-//  virtual pos_type
-//  seekpos(pos_type sp,
-//          std::ios_base::openmode mode = std::ios_base::in|std::ios_base::out);
-
-private:
-  /**
-   *  @brief  Allocate internal buffer.
-   *
-   *  This function is safe to call multiple times. It will ensure
-   *  that a proper internal buffer exists if it is required. If the
-   *  buffer already exists or is external, the buffer pointers will be
-   *  reset to their original state.
-  */
-  void
-  enable_buffer();
-
-  /**
-   *  @brief  Destroy internal buffer.
-   *
-   *  This function is safe to call multiple times. It will ensure
-   *  that the internal buffer is deallocated if it exists. In any
-   *  case, it will also reset the buffer pointers.
-  */
-  void
-  disable_buffer();
-
-  /**
-   *  Underlying file pointer.
-  */
-  gzFile file;
-
-  /**
-   *  Mode in which file was opened.
-  */
-  std::ios_base::openmode io_mode;
-
-  /**
-   *  @brief  True if this object owns file descriptor.
-   *
-   *  This makes the class responsible for closing the file
-   *  upon destruction.
-  */
-  bool own_fd;
-
-  /**
-   *  @brief  Stream buffer.
-   *
-   *  For simplicity this remains allocated on the free store for the
-   *  entire life span of the gzfilebuf object, unless replaced by setbuf.
-  */
-  char_type* buffer;
-
-  /**
-   *  @brief  Stream buffer size.
-   *
-   *  Defaults to system default buffer size (typically 8192 bytes).
-   *  Modified by setbuf.
-  */
-  std::streamsize buffer_size;
-
-  /**
-   *  @brief  True if this object owns stream buffer.
-   *
-   *  This makes the class responsible for deleting the buffer
-   *  upon destruction.
-  */
-  bool own_buffer;
-};
-
-/*****************************************************************************/
-
-/**
- *  @brief  Gzipped file input stream class.
- *
- *  This class implements ifstream for gzipped files. Seeking and putback
- *  is not supported yet.
-*/
-class gzifstream : public std::istream
-{
-public:
-  //  Default constructor
-  gzifstream();
-
-  /**
-   *  @brief  Construct stream on gzipped file to be opened.
-   *  @param  name  File name.
-   *  @param  mode  Open mode flags (forced to contain ios::in).
-  */
-  explicit
-  gzifstream(const char* name,
-             std::ios_base::openmode mode = std::ios_base::in);
-
-  /**
-   *  @brief  Construct stream on already open gzipped file.
-   *  @param  fd    File descriptor.
-   *  @param  mode  Open mode flags (forced to contain ios::in).
-  */
-  explicit
-  gzifstream(int fd,
-             std::ios_base::openmode mode = std::ios_base::in);
-
-  /**
-   *  Obtain underlying stream buffer.
-  */
-  gzfilebuf*
-  rdbuf() const
-  { return const_cast<gzfilebuf*>(&sb); }
-
-  /**
-   *  @brief  Check if file is open.
-   *  @return  True if file is open.
-  */
-  bool
-  is_open() { return sb.is_open(); }
-
-  /**
-   *  @brief  Open gzipped file.
-   *  @param  name  File name.
-   *  @param  mode  Open mode flags (forced to contain ios::in).
-   *
-   *  Stream will be in state good() if file opens successfully;
-   *  otherwise in state fail(). This differs from the behavior of
-   *  ifstream, which never sets the state to good() and therefore
-   *  won't allow you to reuse the stream for a second file unless
-   *  you manually clear() the state. The choice is a matter of
-   *  convenience.
-  */
-  void
-  open(const char* name,
-       std::ios_base::openmode mode = std::ios_base::in);
-
-  /**
-   *  @brief  Attach to already open gzipped file.
-   *  @param  fd  File descriptor.
-   *  @param  mode  Open mode flags (forced to contain ios::in).
-   *
-   *  Stream will be in state good() if attach succeeded; otherwise
-   *  in state fail().
-  */
-  void
-  attach(int fd,
-         std::ios_base::openmode mode = std::ios_base::in);
-
-  /**
-   *  @brief  Close gzipped file.
-   *
-   *  Stream will be in state fail() if close failed.
-  */
-  void
-  close();
-
-private:
-  /**
-   *  Underlying stream buffer.
-  */
-  gzfilebuf sb;
-};
-
-/*****************************************************************************/
-
-/**
- *  @brief  Gzipped file output stream class.
- *
- *  This class implements ofstream for gzipped files. Seeking and putback
- *  is not supported yet.
-*/
-class gzofstream : public std::ostream
-{
-public:
-  //  Default constructor
-  gzofstream();
-
-  /**
-   *  @brief  Construct stream on gzipped file to be opened.
-   *  @param  name  File name.
-   *  @param  mode  Open mode flags (forced to contain ios::out).
-  */
-  explicit
-  gzofstream(const char* name,
-             std::ios_base::openmode mode = std::ios_base::out);
-
-  /**
-   *  @brief  Construct stream on already open gzipped file.
-   *  @param  fd    File descriptor.
-   *  @param  mode  Open mode flags (forced to contain ios::out).
-  */
-  explicit
-  gzofstream(int fd,
-             std::ios_base::openmode mode = std::ios_base::out);
-
-  /**
-   *  Obtain underlying stream buffer.
-  */
-  gzfilebuf*
-  rdbuf() const
-  { return const_cast<gzfilebuf*>(&sb); }
-
-  /**
-   *  @brief  Check if file is open.
-   *  @return  True if file is open.
-  */
-  bool
-  is_open() { return sb.is_open(); }
-
-  /**
-   *  @brief  Open gzipped file.
-   *  @param  name  File name.
-   *  @param  mode  Open mode flags (forced to contain ios::out).
-   *
-   *  Stream will be in state good() if file opens successfully;
-   *  otherwise in state fail(). This differs from the behavior of
-   *  ofstream, which never sets the state to good() and therefore
-   *  won't allow you to reuse the stream for a second file unless
-   *  you manually clear() the state. The choice is a matter of
-   *  convenience.
-  */
-  void
-  open(const char* name,
-       std::ios_base::openmode mode = std::ios_base::out);
-
-  /**
-   *  @brief  Attach to already open gzipped file.
-   *  @param  fd  File descriptor.
-   *  @param  mode  Open mode flags (forced to contain ios::out).
-   *
-   *  Stream will be in state good() if attach succeeded; otherwise
-   *  in state fail().
-  */
-  void
-  attach(int fd,
-         std::ios_base::openmode mode = std::ios_base::out);
-
-  /**
-   *  @brief  Close gzipped file.
-   *
-   *  Stream will be in state fail() if close failed.
-  */
-  void
-  close();
-
-private:
-  /**
-   *  Underlying stream buffer.
-  */
-  gzfilebuf sb;
-};
-
-/*****************************************************************************/
-
-/**
- *  @brief  Gzipped file output stream manipulator class.
- *
- *  This class defines a two-argument manipulator for gzofstream. It is used
- *  as base for the setcompression(int,int) manipulator.
-*/
-template<typename T1, typename T2>
-  class gzomanip2
-  {
-  public:
-    // Allows insertor to peek at internals
-    template <typename Ta, typename Tb>
-      friend gzofstream&
-      operator<<(gzofstream&,
-                 const gzomanip2<Ta,Tb>&);
-
-    // Constructor
-    gzomanip2(gzofstream& (*f)(gzofstream&, T1, T2),
-              T1 v1,
-              T2 v2);
-  private:
-    // Underlying manipulator function
-    gzofstream&
-    (*func)(gzofstream&, T1, T2);
-
-    // Arguments for manipulator function
-    T1 val1;
-    T2 val2;
-  };
-
-/*****************************************************************************/
-
-// Manipulator function thunks through to stream buffer
-inline gzofstream&
-setcompression(gzofstream &gzs, int l, int s = Z_DEFAULT_STRATEGY)
-{
-  (gzs.rdbuf())->setcompression(l, s);
-  return gzs;
-}
-
-// Manipulator constructor stores arguments
-template<typename T1, typename T2>
-  inline
-  gzomanip2<T1,T2>::gzomanip2(gzofstream &(*f)(gzofstream &, T1, T2),
-                              T1 v1,
-                              T2 v2)
-  : func(f), val1(v1), val2(v2)
-  { }
-
-// Insertor applies underlying manipulator function to stream
-template<typename T1, typename T2>
-  inline gzofstream&
-  operator<<(gzofstream& s, const gzomanip2<T1,T2>& m)
-  { return (*m.func)(s, m.val1, m.val2); }
-
-// Insert this onto stream to simplify setting of compression level
-inline gzomanip2<int,int>
-setcompression(int l, int s = Z_DEFAULT_STRATEGY)
-{ return gzomanip2<int,int>(&setcompression, l, s); }
-
-#endif // ZFSTREAM_H
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/zlib/contrib/minizip/crypt.h
+++ /dev/null
@@ -1,131 +0,0 @@
-/* crypt.h -- base code for crypt/uncrypt ZIPfile
-
-
-   Version 1.01e, February 12th, 2005
-
-   Copyright (C) 1998-2005 Gilles Vollant
-
-   This code is a modified version of crypting code in Infozip distribution
-
-   The encryption/decryption parts of this source code (as opposed to the
-   non-echoing password parts) were originally written in Europe.  The
-   whole source package can be freely distributed, including from the USA.
-   (Prior to January 2000, re-export from the US was a violation of US law.)
-
-   This encryption code is a direct transcription of the algorithm from
-   Roger Schlafly, described by Phil Katz in the file appnote.txt.  This
-   file (appnote.txt) is distributed with the PKZIP program (even in the
-   version without encryption capabilities).
-
-   If you don't need crypting in your application, just define symbols
-   NOCRYPT and NOUNCRYPT.
-
-   This code support the "Traditional PKWARE Encryption".
-
-   The new AES encryption added on Zip format by Winzip (see the page
-   http://www.winzip.com/aes_info.htm ) and PKWare PKZip 5.x Strong
-   Encryption is not supported.
-*/
-
-#define CRC32(c, b) ((*(pcrc_32_tab+(((int)(c) ^ (b)) & 0xff))) ^ ((c) >> 8))
-
-/***********************************************************************
- * Return the next byte in the pseudo-random sequence
- */
-static int decrypt_byte(unsigned long* pkeys, const z_crc_t* pcrc_32_tab)
-{
-    unsigned temp;  /* POTENTIAL BUG:  temp*(temp^1) may overflow in an
-                     * unpredictable manner on 16-bit systems; not a problem
-                     * with any known compiler so far, though */
-
-    temp = ((unsigned)(*(pkeys+2)) & 0xffff) | 2;
-    return (int)(((temp * (temp ^ 1)) >> 8) & 0xff);
-}
-
-/***********************************************************************
- * Update the encryption keys with the next byte of plain text
- */
-static int update_keys(unsigned long* pkeys,const z_crc_t* pcrc_32_tab,int c)
-{
-    (*(pkeys+0)) = CRC32((*(pkeys+0)), c);
-    (*(pkeys+1)) += (*(pkeys+0)) & 0xff;
-    (*(pkeys+1)) = (*(pkeys+1)) * 134775813L + 1;
-    {
-      register int keyshift = (int)((*(pkeys+1)) >> 24);
-      (*(pkeys+2)) = CRC32((*(pkeys+2)), keyshift);
-    }
-    return c;
-}
-
-
-/***********************************************************************
- * Initialize the encryption keys and the random header according to
- * the given password.
- */
-static void init_keys(const char* passwd,unsigned long* pkeys,const z_crc_t* pcrc_32_tab)
-{
-    *(pkeys+0) = 305419896L;
-    *(pkeys+1) = 591751049L;
-    *(pkeys+2) = 878082192L;
-    while (*passwd != '\0') {
-        update_keys(pkeys,pcrc_32_tab,(int)*passwd);
-        passwd++;
-    }
-}
-
-#define zdecode(pkeys,pcrc_32_tab,c) \
-    (update_keys(pkeys,pcrc_32_tab,c ^= decrypt_byte(pkeys,pcrc_32_tab)))
-
-#define zencode(pkeys,pcrc_32_tab,c,t) \
-    (t=decrypt_byte(pkeys,pcrc_32_tab), update_keys(pkeys,pcrc_32_tab,c), t^(c))
-
-#ifdef INCLUDECRYPTINGCODE_IFCRYPTALLOWED
-
-#define RAND_HEAD_LEN  12
-   /* "last resort" source for second part of crypt seed pattern */
-#  ifndef ZCR_SEED2
-#    define ZCR_SEED2 3141592654UL     /* use PI as default pattern */
-#  endif
-
-static int crypthead(const char* passwd,      /* password string */
-                     unsigned char* buf,      /* where to write header */
-                     int bufSize,
-                     unsigned long* pkeys,
-                     const z_crc_t* pcrc_32_tab,
-                     unsigned long crcForCrypting)
-{
-    int n;                       /* index in random header */
-    int t;                       /* temporary */
-    int c;                       /* random byte */
-    unsigned char header[RAND_HEAD_LEN-2]; /* random header */
-    static unsigned calls = 0;   /* ensure different random header each time */
-
-    if (bufSize<RAND_HEAD_LEN)
-      return 0;
-
-    /* First generate RAND_HEAD_LEN-2 random bytes. We encrypt the
-     * output of rand() to get less predictability, since rand() is
-     * often poorly implemented.
-     */
-    if (++calls == 1)
-    {
-        srand((unsigned)(time(NULL) ^ ZCR_SEED2));
-    }
-    init_keys(passwd, pkeys, pcrc_32_tab);
-    for (n = 0; n < RAND_HEAD_LEN-2; n++)
-    {
-        c = (rand() >> 7) & 0xff;
-        header[n] = (unsigned char)zencode(pkeys, pcrc_32_tab, c, t);
-    }
-    /* Encrypt random header (last two bytes is high word of crc) */
-    init_keys(passwd, pkeys, pcrc_32_tab);
-    for (n = 0; n < RAND_HEAD_LEN-2; n++)
-    {
-        buf[n] = (unsigned char)zencode(pkeys, pcrc_32_tab, header[n], t);
-    }
-    buf[n++] = (unsigned char)zencode(pkeys, pcrc_32_tab, (int)(crcForCrypting >> 16) & 0xff, t);
-    buf[n++] = (unsigned char)zencode(pkeys, pcrc_32_tab, (int)(crcForCrypting >> 24) & 0xff, t);
-    return n;
-}
-
-#endif
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/zlib/contrib/minizip/ioapi.h
+++ /dev/null
@@ -1,208 +0,0 @@
-/* ioapi.h -- IO base function header for compress/uncompress .zip
-   part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Modifications for Zip64 support
-         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
-
-         For more info read MiniZip_info.txt
-
-         Changes
-
-    Oct-2009 - Defined ZPOS64_T to fpos_t on windows and u_int64_t on linux. (might need to find a better why for this)
-    Oct-2009 - Change to fseeko64, ftello64 and fopen64 so large files would work on linux.
-               More if/def section may be needed to support other platforms
-    Oct-2009 - Defined fxxxx64 calls to normal fopen/ftell/fseek so they would compile on windows.
-                          (but you should use iowin32.c for windows instead)
-
-*/
-
-#ifndef _ZLIBIOAPI64_H
-#define _ZLIBIOAPI64_H
-
-#if (!defined(_WIN32)) && (!defined(WIN32)) && (!defined(__APPLE__))
-
-  // Linux needs this to support file operation on files larger then 4+GB
-  // But might need better if/def to select just the platforms that needs them.
-
-        #ifndef __USE_FILE_OFFSET64
-                #define __USE_FILE_OFFSET64
-        #endif
-        #ifndef __USE_LARGEFILE64
-                #define __USE_LARGEFILE64
-        #endif
-        #ifndef _LARGEFILE64_SOURCE
-                #define _LARGEFILE64_SOURCE
-        #endif
-        #ifndef _FILE_OFFSET_BIT
-                #define _FILE_OFFSET_BIT 64
-        #endif
-
-#endif
-
-#include <stdio.h>
-#include <stdlib.h>
-#include "zlib.h"
-
-#if defined(USE_FILE32API)
-#define fopen64 fopen
-#define ftello64 ftell
-#define fseeko64 fseek
-#else
-#ifdef __FreeBSD__
-#define fopen64 fopen
-#define ftello64 ftello
-#define fseeko64 fseeko
-#endif
-#ifdef _MSC_VER
- #define fopen64 fopen
- #if (_MSC_VER >= 1400) && (!(defined(NO_MSCVER_FILE64_FUNC)))
-  #define ftello64 _ftelli64
-  #define fseeko64 _fseeki64
- #else // old MSC
-  #define ftello64 ftell
-  #define fseeko64 fseek
- #endif
-#endif
-#endif
-
-/*
-#ifndef ZPOS64_T
-  #ifdef _WIN32
-                #define ZPOS64_T fpos_t
-  #else
-    #include <stdint.h>
-    #define ZPOS64_T uint64_t
-  #endif
-#endif
-*/
-
-#ifdef HAVE_MINIZIP64_CONF_H
-#include "mz64conf.h"
-#endif
-
-/* a type choosen by DEFINE */
-#ifdef HAVE_64BIT_INT_CUSTOM
-typedef  64BIT_INT_CUSTOM_TYPE ZPOS64_T;
-#else
-#ifdef HAS_STDINT_H
-#include "stdint.h"
-typedef uint64_t ZPOS64_T;
-#else
-
-/* Maximum unsigned 32-bit value used as placeholder for zip64 */
-#define MAXU32 0xffffffff
-
-#if defined(_MSC_VER) || defined(__BORLANDC__)
-typedef unsigned __int64 ZPOS64_T;
-#else
-typedef unsigned long long int ZPOS64_T;
-#endif
-#endif
-#endif
-
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-#define ZLIB_FILEFUNC_SEEK_CUR (1)
-#define ZLIB_FILEFUNC_SEEK_END (2)
-#define ZLIB_FILEFUNC_SEEK_SET (0)
-
-#define ZLIB_FILEFUNC_MODE_READ      (1)
-#define ZLIB_FILEFUNC_MODE_WRITE     (2)
-#define ZLIB_FILEFUNC_MODE_READWRITEFILTER (3)
-
-#define ZLIB_FILEFUNC_MODE_EXISTING (4)
-#define ZLIB_FILEFUNC_MODE_CREATE   (8)
-
-
-#ifndef ZCALLBACK
- #if (defined(WIN32) || defined(_WIN32) || defined (WINDOWS) || defined (_WINDOWS)) && defined(CALLBACK) && defined (USEWINDOWS_CALLBACK)
-   #define ZCALLBACK CALLBACK
- #else
-   #define ZCALLBACK
- #endif
-#endif
-
-
-
-
-typedef voidpf   (ZCALLBACK *open_file_func)      OF((voidpf opaque, const char* filename, int mode));
-typedef uLong    (ZCALLBACK *read_file_func)      OF((voidpf opaque, voidpf stream, void* buf, uLong size));
-typedef uLong    (ZCALLBACK *write_file_func)     OF((voidpf opaque, voidpf stream, const void* buf, uLong size));
-typedef int      (ZCALLBACK *close_file_func)     OF((voidpf opaque, voidpf stream));
-typedef int      (ZCALLBACK *testerror_file_func) OF((voidpf opaque, voidpf stream));
-
-typedef long     (ZCALLBACK *tell_file_func)      OF((voidpf opaque, voidpf stream));
-typedef long     (ZCALLBACK *seek_file_func)      OF((voidpf opaque, voidpf stream, uLong offset, int origin));
-
-
-/* here is the "old" 32 bits structure structure */
-typedef struct zlib_filefunc_def_s
-{
-    open_file_func      zopen_file;
-    read_file_func      zread_file;
-    write_file_func     zwrite_file;
-    tell_file_func      ztell_file;
-    seek_file_func      zseek_file;
-    close_file_func     zclose_file;
-    testerror_file_func zerror_file;
-    voidpf              opaque;
-} zlib_filefunc_def;
-
-typedef ZPOS64_T (ZCALLBACK *tell64_file_func)    OF((voidpf opaque, voidpf stream));
-typedef long     (ZCALLBACK *seek64_file_func)    OF((voidpf opaque, voidpf stream, ZPOS64_T offset, int origin));
-typedef voidpf   (ZCALLBACK *open64_file_func)    OF((voidpf opaque, const void* filename, int mode));
-
-typedef struct zlib_filefunc64_def_s
-{
-    open64_file_func    zopen64_file;
-    read_file_func      zread_file;
-    write_file_func     zwrite_file;
-    tell64_file_func    ztell64_file;
-    seek64_file_func    zseek64_file;
-    close_file_func     zclose_file;
-    testerror_file_func zerror_file;
-    voidpf              opaque;
-} zlib_filefunc64_def;
-
-void fill_fopen64_filefunc OF((zlib_filefunc64_def* pzlib_filefunc_def));
-void fill_fopen_filefunc OF((zlib_filefunc_def* pzlib_filefunc_def));
-
-/* now internal definition, only for zip.c and unzip.h */
-typedef struct zlib_filefunc64_32_def_s
-{
-    zlib_filefunc64_def zfile_func64;
-    open_file_func      zopen32_file;
-    tell_file_func      ztell32_file;
-    seek_file_func      zseek32_file;
-} zlib_filefunc64_32_def;
-
-
-#define ZREAD64(filefunc,filestream,buf,size)     ((*((filefunc).zfile_func64.zread_file))   ((filefunc).zfile_func64.opaque,filestream,buf,size))
-#define ZWRITE64(filefunc,filestream,buf,size)    ((*((filefunc).zfile_func64.zwrite_file))  ((filefunc).zfile_func64.opaque,filestream,buf,size))
-//#define ZTELL64(filefunc,filestream)            ((*((filefunc).ztell64_file)) ((filefunc).opaque,filestream))
-//#define ZSEEK64(filefunc,filestream,pos,mode)   ((*((filefunc).zseek64_file)) ((filefunc).opaque,filestream,pos,mode))
-#define ZCLOSE64(filefunc,filestream)             ((*((filefunc).zfile_func64.zclose_file))  ((filefunc).zfile_func64.opaque,filestream))
-#define ZERROR64(filefunc,filestream)             ((*((filefunc).zfile_func64.zerror_file))  ((filefunc).zfile_func64.opaque,filestream))
-
-voidpf call_zopen64 OF((const zlib_filefunc64_32_def* pfilefunc,const void*filename,int mode));
-long    call_zseek64 OF((const zlib_filefunc64_32_def* pfilefunc,voidpf filestream, ZPOS64_T offset, int origin));
-ZPOS64_T call_ztell64 OF((const zlib_filefunc64_32_def* pfilefunc,voidpf filestream));
-
-void    fill_zlib_filefunc64_32_def_from_filefunc32(zlib_filefunc64_32_def* p_filefunc64_32,const zlib_filefunc_def* p_filefunc32);
-
-#define ZOPEN64(filefunc,filename,mode)         (call_zopen64((&(filefunc)),(filename),(mode)))
-#define ZTELL64(filefunc,filestream)            (call_ztell64((&(filefunc)),(filestream)))
-#define ZSEEK64(filefunc,filestream,pos,mode)   (call_zseek64((&(filefunc)),(filestream),(pos),(mode)))
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/zlib/contrib/minizip/iowin32.h
+++ /dev/null
@@ -1,28 +0,0 @@
-/* iowin32.h -- IO base function header for compress/uncompress .zip
-     Version 1.1, February 14h, 2010
-     part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Modifications for Zip64 support
-         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
-
-         For more info read MiniZip_info.txt
-
-*/
-
-#include <windows.h>
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-void fill_win32_filefunc OF((zlib_filefunc_def* pzlib_filefunc_def));
-void fill_win32_filefunc64 OF((zlib_filefunc64_def* pzlib_filefunc_def));
-void fill_win32_filefunc64A OF((zlib_filefunc64_def* pzlib_filefunc_def));
-void fill_win32_filefunc64W OF((zlib_filefunc64_def* pzlib_filefunc_def));
-
-#ifdef __cplusplus
-}
-#endif
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/zlib/contrib/minizip/mztools.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
-  Additional tools for Minizip
-  Code: Xavier Roche '2004
-  License: Same as ZLIB (www.gzip.org)
-*/
-
-#ifndef _zip_tools_H
-#define _zip_tools_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#ifndef _ZLIB_H
-#include "zlib.h"
-#endif
-
-#include "unzip.h"
-
-/* Repair a ZIP file (missing central directory)
-   file: file to recover
-   fileOut: output file after recovery
-   fileOutTmp: temporary file name used for recovery
-*/
-extern int ZEXPORT unzRepair(const char* file,
-                             const char* fileOut,
-                             const char* fileOutTmp,
-                             uLong* nRecovered,
-                             uLong* bytesRecovered);
-
-
-#ifdef __cplusplus
-}
-#endif
-
-
-#endif
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/zlib/contrib/minizip/unzip.h
+++ /dev/null
@@ -1,437 +0,0 @@
-/* unzip.h -- IO for uncompress .zip files using zlib
-   Version 1.1, February 14h, 2010
-   part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Modifications of Unzip for Zip64
-         Copyright (C) 2007-2008 Even Rouault
-
-         Modifications for Zip64 support on both zip and unzip
-         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
-
-         For more info read MiniZip_info.txt
-
-         ---------------------------------------------------------------------------------
-
-        Condition of use and distribution are the same than zlib :
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  ---------------------------------------------------------------------------------
-
-        Changes
-
-        See header of unzip64.c
-
-*/
-
-#ifndef _unz64_H
-#define _unz64_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#ifndef _ZLIB_H
-#include "zlib.h"
-#endif
-
-#ifndef  _ZLIBIOAPI_H
-#include "ioapi.h"
-#endif
-
-#ifdef HAVE_BZIP2
-#include "bzlib.h"
-#endif
-
-#define Z_BZIP2ED 12
-
-#if defined(STRICTUNZIP) || defined(STRICTZIPUNZIP)
-/* like the STRICT of WIN32, we define a pointer that cannot be converted
-    from (void*) without cast */
-typedef struct TagunzFile__ { int unused; } unzFile__;
-typedef unzFile__ *unzFile;
-#else
-typedef voidp unzFile;
-#endif
-
-
-#define UNZ_OK                          (0)
-#define UNZ_END_OF_LIST_OF_FILE         (-100)
-#define UNZ_ERRNO                       (Z_ERRNO)
-#define UNZ_EOF                         (0)
-#define UNZ_PARAMERROR                  (-102)
-#define UNZ_BADZIPFILE                  (-103)
-#define UNZ_INTERNALERROR               (-104)
-#define UNZ_CRCERROR                    (-105)
-
-/* tm_unz contain date/time info */
-typedef struct tm_unz_s
-{
-    uInt tm_sec;            /* seconds after the minute - [0,59] */
-    uInt tm_min;            /* minutes after the hour - [0,59] */
-    uInt tm_hour;           /* hours since midnight - [0,23] */
-    uInt tm_mday;           /* day of the month - [1,31] */
-    uInt tm_mon;            /* months since January - [0,11] */
-    uInt tm_year;           /* years - [1980..2044] */
-} tm_unz;
-
-/* unz_global_info structure contain global data about the ZIPfile
-   These data comes from the end of central dir */
-typedef struct unz_global_info64_s
-{
-    ZPOS64_T number_entry;         /* total number of entries in
-                                     the central dir on this disk */
-    uLong size_comment;         /* size of the global comment of the zipfile */
-} unz_global_info64;
-
-typedef struct unz_global_info_s
-{
-    uLong number_entry;         /* total number of entries in
-                                     the central dir on this disk */
-    uLong size_comment;         /* size of the global comment of the zipfile */
-} unz_global_info;
-
-/* unz_file_info contain information about a file in the zipfile */
-typedef struct unz_file_info64_s
-{
-    uLong version;              /* version made by                 2 bytes */
-    uLong version_needed;       /* version needed to extract       2 bytes */
-    uLong flag;                 /* general purpose bit flag        2 bytes */
-    uLong compression_method;   /* compression method              2 bytes */
-    uLong dosDate;              /* last mod file date in Dos fmt   4 bytes */
-    uLong crc;                  /* crc-32                          4 bytes */
-    ZPOS64_T compressed_size;   /* compressed size                 8 bytes */
-    ZPOS64_T uncompressed_size; /* uncompressed size               8 bytes */
-    uLong size_filename;        /* filename length                 2 bytes */
-    uLong size_file_extra;      /* extra field length              2 bytes */
-    uLong size_file_comment;    /* file comment length             2 bytes */
-
-    uLong disk_num_start;       /* disk number start               2 bytes */
-    uLong internal_fa;          /* internal file attributes        2 bytes */
-    uLong external_fa;          /* external file attributes        4 bytes */
-
-    tm_unz tmu_date;
-} unz_file_info64;
-
-typedef struct unz_file_info_s
-{
-    uLong version;              /* version made by                 2 bytes */
-    uLong version_needed;       /* version needed to extract       2 bytes */
-    uLong flag;                 /* general purpose bit flag        2 bytes */
-    uLong compression_method;   /* compression method              2 bytes */
-    uLong dosDate;              /* last mod file date in Dos fmt   4 bytes */
-    uLong crc;                  /* crc-32                          4 bytes */
-    uLong compressed_size;      /* compressed size                 4 bytes */
-    uLong uncompressed_size;    /* uncompressed size               4 bytes */
-    uLong size_filename;        /* filename length                 2 bytes */
-    uLong size_file_extra;      /* extra field length              2 bytes */
-    uLong size_file_comment;    /* file comment length             2 bytes */
-
-    uLong disk_num_start;       /* disk number start               2 bytes */
-    uLong internal_fa;          /* internal file attributes        2 bytes */
-    uLong external_fa;          /* external file attributes        4 bytes */
-
-    tm_unz tmu_date;
-} unz_file_info;
-
-extern int ZEXPORT unzStringFileNameCompare OF ((const char* fileName1,
-                                                 const char* fileName2,
-                                                 int iCaseSensitivity));
-/*
-   Compare two filename (fileName1,fileName2).
-   If iCaseSenisivity = 1, comparision is case sensitivity (like strcmp)
-   If iCaseSenisivity = 2, comparision is not case sensitivity (like strcmpi
-                                or strcasecmp)
-   If iCaseSenisivity = 0, case sensitivity is defaut of your operating system
-    (like 1 on Unix, 2 on Windows)
-*/
-
-
-extern unzFile ZEXPORT unzOpen OF((const char *path));
-extern unzFile ZEXPORT unzOpen64 OF((const void *path));
-/*
-  Open a Zip file. path contain the full pathname (by example,
-     on a Windows XP computer "c:\\zlib\\zlib113.zip" or on an Unix computer
-     "zlib/zlib113.zip".
-     If the zipfile cannot be opened (file don't exist or in not valid), the
-       return value is NULL.
-     Else, the return value is a unzFile Handle, usable with other function
-       of this unzip package.
-     the "64" function take a const void* pointer, because the path is just the
-       value passed to the open64_file_func callback.
-     Under Windows, if UNICODE is defined, using fill_fopen64_filefunc, the path
-       is a pointer to a wide unicode string (LPCTSTR is LPCWSTR), so const char*
-       does not describe the reality
-*/
-
-
-extern unzFile ZEXPORT unzOpen2 OF((const char *path,
-                                    zlib_filefunc_def* pzlib_filefunc_def));
-/*
-   Open a Zip file, like unzOpen, but provide a set of file low level API
-      for read/write the zip file (see ioapi.h)
-*/
-
-extern unzFile ZEXPORT unzOpen2_64 OF((const void *path,
-                                    zlib_filefunc64_def* pzlib_filefunc_def));
-/*
-   Open a Zip file, like unz64Open, but provide a set of file low level API
-      for read/write the zip file (see ioapi.h)
-*/
-
-extern int ZEXPORT unzClose OF((unzFile file));
-/*
-  Close a ZipFile opened with unzOpen.
-  If there is files inside the .Zip opened with unzOpenCurrentFile (see later),
-    these files MUST be closed with unzCloseCurrentFile before call unzClose.
-  return UNZ_OK if there is no problem. */
-
-extern int ZEXPORT unzGetGlobalInfo OF((unzFile file,
-                                        unz_global_info *pglobal_info));
-
-extern int ZEXPORT unzGetGlobalInfo64 OF((unzFile file,
-                                        unz_global_info64 *pglobal_info));
-/*
-  Write info about the ZipFile in the *pglobal_info structure.
-  No preparation of the structure is needed
-  return UNZ_OK if there is no problem. */
-
-
-extern int ZEXPORT unzGetGlobalComment OF((unzFile file,
-                                           char *szComment,
-                                           uLong uSizeBuf));
-/*
-  Get the global comment string of the ZipFile, in the szComment buffer.
-  uSizeBuf is the size of the szComment buffer.
-  return the number of byte copied or an error code <0
-*/
-
-
-/***************************************************************************/
-/* Unzip package allow you browse the directory of the zipfile */
-
-extern int ZEXPORT unzGoToFirstFile OF((unzFile file));
-/*
-  Set the current file of the zipfile to the first file.
-  return UNZ_OK if there is no problem
-*/
-
-extern int ZEXPORT unzGoToNextFile OF((unzFile file));
-/*
-  Set the current file of the zipfile to the next file.
-  return UNZ_OK if there is no problem
-  return UNZ_END_OF_LIST_OF_FILE if the actual file was the latest.
-*/
-
-extern int ZEXPORT unzLocateFile OF((unzFile file,
-                     const char *szFileName,
-                     int iCaseSensitivity));
-/*
-  Try locate the file szFileName in the zipfile.
-  For the iCaseSensitivity signification, see unzStringFileNameCompare
-
-  return value :
-  UNZ_OK if the file is found. It becomes the current file.
-  UNZ_END_OF_LIST_OF_FILE if the file is not found
-*/
-
-
-/* ****************************************** */
-/* Ryan supplied functions */
-/* unz_file_info contain information about a file in the zipfile */
-typedef struct unz_file_pos_s
-{
-    uLong pos_in_zip_directory;   /* offset in zip file directory */
-    uLong num_of_file;            /* # of file */
-} unz_file_pos;
-
-extern int ZEXPORT unzGetFilePos(
-    unzFile file,
-    unz_file_pos* file_pos);
-
-extern int ZEXPORT unzGoToFilePos(
-    unzFile file,
-    unz_file_pos* file_pos);
-
-typedef struct unz64_file_pos_s
-{
-    ZPOS64_T pos_in_zip_directory;   /* offset in zip file directory */
-    ZPOS64_T num_of_file;            /* # of file */
-} unz64_file_pos;
-
-extern int ZEXPORT unzGetFilePos64(
-    unzFile file,
-    unz64_file_pos* file_pos);
-
-extern int ZEXPORT unzGoToFilePos64(
-    unzFile file,
-    const unz64_file_pos* file_pos);
-
-/* ****************************************** */
-
-extern int ZEXPORT unzGetCurrentFileInfo64 OF((unzFile file,
-                         unz_file_info64 *pfile_info,
-                         char *szFileName,
-                         uLong fileNameBufferSize,
-                         void *extraField,
-                         uLong extraFieldBufferSize,
-                         char *szComment,
-                         uLong commentBufferSize));
-
-extern int ZEXPORT unzGetCurrentFileInfo OF((unzFile file,
-                         unz_file_info *pfile_info,
-                         char *szFileName,
-                         uLong fileNameBufferSize,
-                         void *extraField,
-                         uLong extraFieldBufferSize,
-                         char *szComment,
-                         uLong commentBufferSize));
-/*
-  Get Info about the current file
-  if pfile_info!=NULL, the *pfile_info structure will contain somes info about
-        the current file
-  if szFileName!=NULL, the filemane string will be copied in szFileName
-            (fileNameBufferSize is the size of the buffer)
-  if extraField!=NULL, the extra field information will be copied in extraField
-            (extraFieldBufferSize is the size of the buffer).
-            This is the Central-header version of the extra field
-  if szComment!=NULL, the comment string of the file will be copied in szComment
-            (commentBufferSize is the size of the buffer)
-*/
-
-
-/** Addition for GDAL : START */
-
-extern ZPOS64_T ZEXPORT unzGetCurrentFileZStreamPos64 OF((unzFile file));
-
-/** Addition for GDAL : END */
-
-
-/***************************************************************************/
-/* for reading the content of the current zipfile, you can open it, read data
-   from it, and close it (you can close it before reading all the file)
-   */
-
-extern int ZEXPORT unzOpenCurrentFile OF((unzFile file));
-/*
-  Open for reading data the current file in the zipfile.
-  If there is no error, the return value is UNZ_OK.
-*/
-
-extern int ZEXPORT unzOpenCurrentFilePassword OF((unzFile file,
-                                                  const char* password));
-/*
-  Open for reading data the current file in the zipfile.
-  password is a crypting password
-  If there is no error, the return value is UNZ_OK.
-*/
-
-extern int ZEXPORT unzOpenCurrentFile2 OF((unzFile file,
-                                           int* method,
-                                           int* level,
-                                           int raw));
-/*
-  Same than unzOpenCurrentFile, but open for read raw the file (not uncompress)
-    if raw==1
-  *method will receive method of compression, *level will receive level of
-     compression
-  note : you can set level parameter as NULL (if you did not want known level,
-         but you CANNOT set method parameter as NULL
-*/
-
-extern int ZEXPORT unzOpenCurrentFile3 OF((unzFile file,
-                                           int* method,
-                                           int* level,
-                                           int raw,
-                                           const char* password));
-/*
-  Same than unzOpenCurrentFile, but open for read raw the file (not uncompress)
-    if raw==1
-  *method will receive method of compression, *level will receive level of
-     compression
-  note : you can set level parameter as NULL (if you did not want known level,
-         but you CANNOT set method parameter as NULL
-*/
-
-
-extern int ZEXPORT unzCloseCurrentFile OF((unzFile file));
-/*
-  Close the file in zip opened with unzOpenCurrentFile
-  Return UNZ_CRCERROR if all the file was read but the CRC is not good
-*/
-
-extern int ZEXPORT unzReadCurrentFile OF((unzFile file,
-                      voidp buf,
-                      unsigned len));
-/*
-  Read bytes from the current file (opened by unzOpenCurrentFile)
-  buf contain buffer where data must be copied
-  len the size of buf.
-
-  return the number of byte copied if somes bytes are copied
-  return 0 if the end of file was reached
-  return <0 with error code if there is an error
-    (UNZ_ERRNO for IO error, or zLib error for uncompress error)
-*/
-
-extern z_off_t ZEXPORT unztell OF((unzFile file));
-
-extern ZPOS64_T ZEXPORT unztell64 OF((unzFile file));
-/*
-  Give the current position in uncompressed data
-*/
-
-extern int ZEXPORT unzeof OF((unzFile file));
-/*
-  return 1 if the end of file was reached, 0 elsewhere
-*/
-
-extern int ZEXPORT unzGetLocalExtrafield OF((unzFile file,
-                                             voidp buf,
-                                             unsigned len));
-/*
-  Read extra field from the current file (opened by unzOpenCurrentFile)
-  This is the local-header version of the extra field (sometimes, there is
-    more info in the local-header version than in the central-header)
-
-  if buf==NULL, it return the size of the local extra field
-
-  if buf!=NULL, len is the size of the buffer, the extra header is copied in
-    buf.
-  the return value is the number of bytes copied in buf, or (if <0)
-    the error code
-*/
-
-/***************************************************************************/
-
-/* Get the current file offset */
-extern ZPOS64_T ZEXPORT unzGetOffset64 (unzFile file);
-extern uLong ZEXPORT unzGetOffset (unzFile file);
-
-/* Set the current file offset */
-extern int ZEXPORT unzSetOffset64 (unzFile file, ZPOS64_T pos);
-extern int ZEXPORT unzSetOffset (unzFile file, uLong pos);
-
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _unz64_H */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/zlib/contrib/minizip/zip.h
+++ /dev/null
@@ -1,362 +0,0 @@
-/* zip.h -- IO on .zip files using zlib
-   Version 1.1, February 14h, 2010
-   part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Modifications for Zip64 support
-         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
-
-         For more info read MiniZip_info.txt
-
-         ---------------------------------------------------------------------------
-
-   Condition of use and distribution are the same than zlib :
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-        ---------------------------------------------------------------------------
-
-        Changes
-
-        See header of zip.h
-
-*/
-
-#ifndef _zip12_H
-#define _zip12_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-//#define HAVE_BZIP2
-
-#ifndef _ZLIB_H
-#include "zlib.h"
-#endif
-
-#ifndef _ZLIBIOAPI_H
-#include "ioapi.h"
-#endif
-
-#ifdef HAVE_BZIP2
-#include "bzlib.h"
-#endif
-
-#define Z_BZIP2ED 12
-
-#if defined(STRICTZIP) || defined(STRICTZIPUNZIP)
-/* like the STRICT of WIN32, we define a pointer that cannot be converted
-    from (void*) without cast */
-typedef struct TagzipFile__ { int unused; } zipFile__;
-typedef zipFile__ *zipFile;
-#else
-typedef voidp zipFile;
-#endif
-
-#define ZIP_OK                          (0)
-#define ZIP_EOF                         (0)
-#define ZIP_ERRNO                       (Z_ERRNO)
-#define ZIP_PARAMERROR                  (-102)
-#define ZIP_BADZIPFILE                  (-103)
-#define ZIP_INTERNALERROR               (-104)
-
-#ifndef DEF_MEM_LEVEL
-#  if MAX_MEM_LEVEL >= 8
-#    define DEF_MEM_LEVEL 8
-#  else
-#    define DEF_MEM_LEVEL  MAX_MEM_LEVEL
-#  endif
-#endif
-/* default memLevel */
-
-/* tm_zip contain date/time info */
-typedef struct tm_zip_s
-{
-    uInt tm_sec;            /* seconds after the minute - [0,59] */
-    uInt tm_min;            /* minutes after the hour - [0,59] */
-    uInt tm_hour;           /* hours since midnight - [0,23] */
-    uInt tm_mday;           /* day of the month - [1,31] */
-    uInt tm_mon;            /* months since January - [0,11] */
-    uInt tm_year;           /* years - [1980..2044] */
-} tm_zip;
-
-typedef struct
-{
-    tm_zip      tmz_date;       /* date in understandable format           */
-    uLong       dosDate;       /* if dos_date == 0, tmu_date is used      */
-/*    uLong       flag;        */   /* general purpose bit flag        2 bytes */
-
-    uLong       internal_fa;    /* internal file attributes        2 bytes */
-    uLong       external_fa;    /* external file attributes        4 bytes */
-} zip_fileinfo;
-
-typedef const char* zipcharpc;
-
-
-#define APPEND_STATUS_CREATE        (0)
-#define APPEND_STATUS_CREATEAFTER   (1)
-#define APPEND_STATUS_ADDINZIP      (2)
-
-extern zipFile ZEXPORT zipOpen OF((const char *pathname, int append));
-extern zipFile ZEXPORT zipOpen64 OF((const void *pathname, int append));
-/*
-  Create a zipfile.
-     pathname contain on Windows XP a filename like "c:\\zlib\\zlib113.zip" or on
-       an Unix computer "zlib/zlib113.zip".
-     if the file pathname exist and append==APPEND_STATUS_CREATEAFTER, the zip
-       will be created at the end of the file.
-         (useful if the file contain a self extractor code)
-     if the file pathname exist and append==APPEND_STATUS_ADDINZIP, we will
-       add files in existing zip (be sure you don't add file that doesn't exist)
-     If the zipfile cannot be opened, the return value is NULL.
-     Else, the return value is a zipFile Handle, usable with other function
-       of this zip package.
-*/
-
-/* Note : there is no delete function into a zipfile.
-   If you want delete file into a zipfile, you must open a zipfile, and create another
-   Of couse, you can use RAW reading and writing to copy the file you did not want delte
-*/
-
-extern zipFile ZEXPORT zipOpen2 OF((const char *pathname,
-                                   int append,
-                                   zipcharpc* globalcomment,
-                                   zlib_filefunc_def* pzlib_filefunc_def));
-
-extern zipFile ZEXPORT zipOpen2_64 OF((const void *pathname,
-                                   int append,
-                                   zipcharpc* globalcomment,
-                                   zlib_filefunc64_def* pzlib_filefunc_def));
-
-extern int ZEXPORT zipOpenNewFileInZip OF((zipFile file,
-                       const char* filename,
-                       const zip_fileinfo* zipfi,
-                       const void* extrafield_local,
-                       uInt size_extrafield_local,
-                       const void* extrafield_global,
-                       uInt size_extrafield_global,
-                       const char* comment,
-                       int method,
-                       int level));
-
-extern int ZEXPORT zipOpenNewFileInZip64 OF((zipFile file,
-                       const char* filename,
-                       const zip_fileinfo* zipfi,
-                       const void* extrafield_local,
-                       uInt size_extrafield_local,
-                       const void* extrafield_global,
-                       uInt size_extrafield_global,
-                       const char* comment,
-                       int method,
-                       int level,
-                       int zip64));
-
-/*
-  Open a file in the ZIP for writing.
-  filename : the filename in zip (if NULL, '-' without quote will be used
-  *zipfi contain supplemental information
-  if extrafield_local!=NULL and size_extrafield_local>0, extrafield_local
-    contains the extrafield data the the local header
-  if extrafield_global!=NULL and size_extrafield_global>0, extrafield_global
-    contains the extrafield data the the local header
-  if comment != NULL, comment contain the comment string
-  method contain the compression method (0 for store, Z_DEFLATED for deflate)
-  level contain the level of compression (can be Z_DEFAULT_COMPRESSION)
-  zip64 is set to 1 if a zip64 extended information block should be added to the local file header.
-                    this MUST be '1' if the uncompressed size is >= 0xffffffff.
-
-*/
-
-
-extern int ZEXPORT zipOpenNewFileInZip2 OF((zipFile file,
-                                            const char* filename,
-                                            const zip_fileinfo* zipfi,
-                                            const void* extrafield_local,
-                                            uInt size_extrafield_local,
-                                            const void* extrafield_global,
-                                            uInt size_extrafield_global,
-                                            const char* comment,
-                                            int method,
-                                            int level,
-                                            int raw));
-
-
-extern int ZEXPORT zipOpenNewFileInZip2_64 OF((zipFile file,
-                                            const char* filename,
-                                            const zip_fileinfo* zipfi,
-                                            const void* extrafield_local,
-                                            uInt size_extrafield_local,
-                                            const void* extrafield_global,
-                                            uInt size_extrafield_global,
-                                            const char* comment,
-                                            int method,
-                                            int level,
-                                            int raw,
-                                            int zip64));
-/*
-  Same than zipOpenNewFileInZip, except if raw=1, we write raw file
- */
-
-extern int ZEXPORT zipOpenNewFileInZip3 OF((zipFile file,
-                                            const char* filename,
-                                            const zip_fileinfo* zipfi,
-                                            const void* extrafield_local,
-                                            uInt size_extrafield_local,
-                                            const void* extrafield_global,
-                                            uInt size_extrafield_global,
-                                            const char* comment,
-                                            int method,
-                                            int level,
-                                            int raw,
-                                            int windowBits,
-                                            int memLevel,
-                                            int strategy,
-                                            const char* password,
-                                            uLong crcForCrypting));
-
-extern int ZEXPORT zipOpenNewFileInZip3_64 OF((zipFile file,
-                                            const char* filename,
-                                            const zip_fileinfo* zipfi,
-                                            const void* extrafield_local,
-                                            uInt size_extrafield_local,
-                                            const void* extrafield_global,
-                                            uInt size_extrafield_global,
-                                            const char* comment,
-                                            int method,
-                                            int level,
-                                            int raw,
-                                            int windowBits,
-                                            int memLevel,
-                                            int strategy,
-                                            const char* password,
-                                            uLong crcForCrypting,
-                                            int zip64
-                                            ));
-
-/*
-  Same than zipOpenNewFileInZip2, except
-    windowBits,memLevel,,strategy : see parameter strategy in deflateInit2
-    password : crypting password (NULL for no crypting)
-    crcForCrypting : crc of file to compress (needed for crypting)
- */
-
-extern int ZEXPORT zipOpenNewFileInZip4 OF((zipFile file,
-                                            const char* filename,
-                                            const zip_fileinfo* zipfi,
-                                            const void* extrafield_local,
-                                            uInt size_extrafield_local,
-                                            const void* extrafield_global,
-                                            uInt size_extrafield_global,
-                                            const char* comment,
-                                            int method,
-                                            int level,
-                                            int raw,
-                                            int windowBits,
-                                            int memLevel,
-                                            int strategy,
-                                            const char* password,
-                                            uLong crcForCrypting,
-                                            uLong versionMadeBy,
-                                            uLong flagBase
-                                            ));
-
-
-extern int ZEXPORT zipOpenNewFileInZip4_64 OF((zipFile file,
-                                            const char* filename,
-                                            const zip_fileinfo* zipfi,
-                                            const void* extrafield_local,
-                                            uInt size_extrafield_local,
-                                            const void* extrafield_global,
-                                            uInt size_extrafield_global,
-                                            const char* comment,
-                                            int method,
-                                            int level,
-                                            int raw,
-                                            int windowBits,
-                                            int memLevel,
-                                            int strategy,
-                                            const char* password,
-                                            uLong crcForCrypting,
-                                            uLong versionMadeBy,
-                                            uLong flagBase,
-                                            int zip64
-                                            ));
-/*
-  Same than zipOpenNewFileInZip4, except
-    versionMadeBy : value for Version made by field
-    flag : value for flag field (compression level info will be added)
- */
-
-
-extern int ZEXPORT zipWriteInFileInZip OF((zipFile file,
-                       const void* buf,
-                       unsigned len));
-/*
-  Write data in the zipfile
-*/
-
-extern int ZEXPORT zipCloseFileInZip OF((zipFile file));
-/*
-  Close the current file in the zipfile
-*/
-
-extern int ZEXPORT zipCloseFileInZipRaw OF((zipFile file,
-                                            uLong uncompressed_size,
-                                            uLong crc32));
-
-extern int ZEXPORT zipCloseFileInZipRaw64 OF((zipFile file,
-                                            ZPOS64_T uncompressed_size,
-                                            uLong crc32));
-
-/*
-  Close the current file in the zipfile, for file opened with
-    parameter raw=1 in zipOpenNewFileInZip2
-  uncompressed_size and crc32 are value for the uncompressed size
-*/
-
-extern int ZEXPORT zipClose OF((zipFile file,
-                const char* global_comment));
-/*
-  Close the zipfile
-*/
-
-
-extern int ZEXPORT zipRemoveExtraInfoBlock OF((char* pData, int* dataLen, short sHeader));
-/*
-  zipRemoveExtraInfoBlock -  Added by Mathias Svensson
-
-  Remove extra information block from a extra information data for the local file header or central directory header
-
-  It is needed to remove ZIP64 extra information blocks when before data is written if using RAW mode.
-
-  0x0001 is the signature header for the ZIP64 extra information blocks
-
-  usage.
-                        Remove ZIP64 Extra information from a central director extra field data
-              zipRemoveExtraInfoBlock(pCenDirExtraFieldData, &nCenDirExtraFieldDataLen, 0x0001);
-
-                        Remove ZIP64 Extra information from a Local File Header extra field data
-        zipRemoveExtraInfoBlock(pLocalHeaderExtraFieldData, &nLocalHeaderExtraFieldDataLen, 0x0001);
-*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _zip64_H */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/zlib/contrib/puff/puff.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/* puff.h
-  Copyright (C) 2002-2013 Mark Adler, all rights reserved
-  version 2.3, 21 Jan 2013
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the author be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  Mark Adler    madler@alumni.caltech.edu
- */
-
-
-/*
- * See puff.c for purpose and usage.
- */
-#ifndef NIL
-#  define NIL ((unsigned char *)0)      /* for no output option */
-#endif
-
-int puff(unsigned char *dest,           /* pointer to destination pointer */
-         unsigned long *destlen,        /* amount of output space */
-         const unsigned char *source,   /* pointer to source data pointer */
-         unsigned long *sourcelen);     /* amount of input available */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/zlib/crc32.h
+++ /dev/null
@@ -1,441 +0,0 @@
-/* crc32.h -- tables for rapid CRC calculation
- * Generated automatically by crc32.c
- */
-
-local const z_crc_t FAR crc_table[TBLS][256] =
-{
-  {
-    0x00000000UL, 0x77073096UL, 0xee0e612cUL, 0x990951baUL, 0x076dc419UL,
-    0x706af48fUL, 0xe963a535UL, 0x9e6495a3UL, 0x0edb8832UL, 0x79dcb8a4UL,
-    0xe0d5e91eUL, 0x97d2d988UL, 0x09b64c2bUL, 0x7eb17cbdUL, 0xe7b82d07UL,
-    0x90bf1d91UL, 0x1db71064UL, 0x6ab020f2UL, 0xf3b97148UL, 0x84be41deUL,
-    0x1adad47dUL, 0x6ddde4ebUL, 0xf4d4b551UL, 0x83d385c7UL, 0x136c9856UL,
-    0x646ba8c0UL, 0xfd62f97aUL, 0x8a65c9ecUL, 0x14015c4fUL, 0x63066cd9UL,
-    0xfa0f3d63UL, 0x8d080df5UL, 0x3b6e20c8UL, 0x4c69105eUL, 0xd56041e4UL,
-    0xa2677172UL, 0x3c03e4d1UL, 0x4b04d447UL, 0xd20d85fdUL, 0xa50ab56bUL,
-    0x35b5a8faUL, 0x42b2986cUL, 0xdbbbc9d6UL, 0xacbcf940UL, 0x32d86ce3UL,
-    0x45df5c75UL, 0xdcd60dcfUL, 0xabd13d59UL, 0x26d930acUL, 0x51de003aUL,
-    0xc8d75180UL, 0xbfd06116UL, 0x21b4f4b5UL, 0x56b3c423UL, 0xcfba9599UL,
-    0xb8bda50fUL, 0x2802b89eUL, 0x5f058808UL, 0xc60cd9b2UL, 0xb10be924UL,
-    0x2f6f7c87UL, 0x58684c11UL, 0xc1611dabUL, 0xb6662d3dUL, 0x76dc4190UL,
-    0x01db7106UL, 0x98d220bcUL, 0xefd5102aUL, 0x71b18589UL, 0x06b6b51fUL,
-    0x9fbfe4a5UL, 0xe8b8d433UL, 0x7807c9a2UL, 0x0f00f934UL, 0x9609a88eUL,
-    0xe10e9818UL, 0x7f6a0dbbUL, 0x086d3d2dUL, 0x91646c97UL, 0xe6635c01UL,
-    0x6b6b51f4UL, 0x1c6c6162UL, 0x856530d8UL, 0xf262004eUL, 0x6c0695edUL,
-    0x1b01a57bUL, 0x8208f4c1UL, 0xf50fc457UL, 0x65b0d9c6UL, 0x12b7e950UL,
-    0x8bbeb8eaUL, 0xfcb9887cUL, 0x62dd1ddfUL, 0x15da2d49UL, 0x8cd37cf3UL,
-    0xfbd44c65UL, 0x4db26158UL, 0x3ab551ceUL, 0xa3bc0074UL, 0xd4bb30e2UL,
-    0x4adfa541UL, 0x3dd895d7UL, 0xa4d1c46dUL, 0xd3d6f4fbUL, 0x4369e96aUL,
-    0x346ed9fcUL, 0xad678846UL, 0xda60b8d0UL, 0x44042d73UL, 0x33031de5UL,
-    0xaa0a4c5fUL, 0xdd0d7cc9UL, 0x5005713cUL, 0x270241aaUL, 0xbe0b1010UL,
-    0xc90c2086UL, 0x5768b525UL, 0x206f85b3UL, 0xb966d409UL, 0xce61e49fUL,
-    0x5edef90eUL, 0x29d9c998UL, 0xb0d09822UL, 0xc7d7a8b4UL, 0x59b33d17UL,
-    0x2eb40d81UL, 0xb7bd5c3bUL, 0xc0ba6cadUL, 0xedb88320UL, 0x9abfb3b6UL,
-    0x03b6e20cUL, 0x74b1d29aUL, 0xead54739UL, 0x9dd277afUL, 0x04db2615UL,
-    0x73dc1683UL, 0xe3630b12UL, 0x94643b84UL, 0x0d6d6a3eUL, 0x7a6a5aa8UL,
-    0xe40ecf0bUL, 0x9309ff9dUL, 0x0a00ae27UL, 0x7d079eb1UL, 0xf00f9344UL,
-    0x8708a3d2UL, 0x1e01f268UL, 0x6906c2feUL, 0xf762575dUL, 0x806567cbUL,
-    0x196c3671UL, 0x6e6b06e7UL, 0xfed41b76UL, 0x89d32be0UL, 0x10da7a5aUL,
-    0x67dd4accUL, 0xf9b9df6fUL, 0x8ebeeff9UL, 0x17b7be43UL, 0x60b08ed5UL,
-    0xd6d6a3e8UL, 0xa1d1937eUL, 0x38d8c2c4UL, 0x4fdff252UL, 0xd1bb67f1UL,
-    0xa6bc5767UL, 0x3fb506ddUL, 0x48b2364bUL, 0xd80d2bdaUL, 0xaf0a1b4cUL,
-    0x36034af6UL, 0x41047a60UL, 0xdf60efc3UL, 0xa867df55UL, 0x316e8eefUL,
-    0x4669be79UL, 0xcb61b38cUL, 0xbc66831aUL, 0x256fd2a0UL, 0x5268e236UL,
-    0xcc0c7795UL, 0xbb0b4703UL, 0x220216b9UL, 0x5505262fUL, 0xc5ba3bbeUL,
-    0xb2bd0b28UL, 0x2bb45a92UL, 0x5cb36a04UL, 0xc2d7ffa7UL, 0xb5d0cf31UL,
-    0x2cd99e8bUL, 0x5bdeae1dUL, 0x9b64c2b0UL, 0xec63f226UL, 0x756aa39cUL,
-    0x026d930aUL, 0x9c0906a9UL, 0xeb0e363fUL, 0x72076785UL, 0x05005713UL,
-    0x95bf4a82UL, 0xe2b87a14UL, 0x7bb12baeUL, 0x0cb61b38UL, 0x92d28e9bUL,
-    0xe5d5be0dUL, 0x7cdcefb7UL, 0x0bdbdf21UL, 0x86d3d2d4UL, 0xf1d4e242UL,
-    0x68ddb3f8UL, 0x1fda836eUL, 0x81be16cdUL, 0xf6b9265bUL, 0x6fb077e1UL,
-    0x18b74777UL, 0x88085ae6UL, 0xff0f6a70UL, 0x66063bcaUL, 0x11010b5cUL,
-    0x8f659effUL, 0xf862ae69UL, 0x616bffd3UL, 0x166ccf45UL, 0xa00ae278UL,
-    0xd70dd2eeUL, 0x4e048354UL, 0x3903b3c2UL, 0xa7672661UL, 0xd06016f7UL,
-    0x4969474dUL, 0x3e6e77dbUL, 0xaed16a4aUL, 0xd9d65adcUL, 0x40df0b66UL,
-    0x37d83bf0UL, 0xa9bcae53UL, 0xdebb9ec5UL, 0x47b2cf7fUL, 0x30b5ffe9UL,
-    0xbdbdf21cUL, 0xcabac28aUL, 0x53b39330UL, 0x24b4a3a6UL, 0xbad03605UL,
-    0xcdd70693UL, 0x54de5729UL, 0x23d967bfUL, 0xb3667a2eUL, 0xc4614ab8UL,
-    0x5d681b02UL, 0x2a6f2b94UL, 0xb40bbe37UL, 0xc30c8ea1UL, 0x5a05df1bUL,
-    0x2d02ef8dUL
-#ifdef BYFOUR
-  },
-  {
-    0x00000000UL, 0x191b3141UL, 0x32366282UL, 0x2b2d53c3UL, 0x646cc504UL,
-    0x7d77f445UL, 0x565aa786UL, 0x4f4196c7UL, 0xc8d98a08UL, 0xd1c2bb49UL,
-    0xfaefe88aUL, 0xe3f4d9cbUL, 0xacb54f0cUL, 0xb5ae7e4dUL, 0x9e832d8eUL,
-    0x87981ccfUL, 0x4ac21251UL, 0x53d92310UL, 0x78f470d3UL, 0x61ef4192UL,
-    0x2eaed755UL, 0x37b5e614UL, 0x1c98b5d7UL, 0x05838496UL, 0x821b9859UL,
-    0x9b00a918UL, 0xb02dfadbUL, 0xa936cb9aUL, 0xe6775d5dUL, 0xff6c6c1cUL,
-    0xd4413fdfUL, 0xcd5a0e9eUL, 0x958424a2UL, 0x8c9f15e3UL, 0xa7b24620UL,
-    0xbea97761UL, 0xf1e8e1a6UL, 0xe8f3d0e7UL, 0xc3de8324UL, 0xdac5b265UL,
-    0x5d5daeaaUL, 0x44469febUL, 0x6f6bcc28UL, 0x7670fd69UL, 0x39316baeUL,
-    0x202a5aefUL, 0x0b07092cUL, 0x121c386dUL, 0xdf4636f3UL, 0xc65d07b2UL,
-    0xed705471UL, 0xf46b6530UL, 0xbb2af3f7UL, 0xa231c2b6UL, 0x891c9175UL,
-    0x9007a034UL, 0x179fbcfbUL, 0x0e848dbaUL, 0x25a9de79UL, 0x3cb2ef38UL,
-    0x73f379ffUL, 0x6ae848beUL, 0x41c51b7dUL, 0x58de2a3cUL, 0xf0794f05UL,
-    0xe9627e44UL, 0xc24f2d87UL, 0xdb541cc6UL, 0x94158a01UL, 0x8d0ebb40UL,
-    0xa623e883UL, 0xbf38d9c2UL, 0x38a0c50dUL, 0x21bbf44cUL, 0x0a96a78fUL,
-    0x138d96ceUL, 0x5ccc0009UL, 0x45d73148UL, 0x6efa628bUL, 0x77e153caUL,
-    0xbabb5d54UL, 0xa3a06c15UL, 0x888d3fd6UL, 0x91960e97UL, 0xded79850UL,
-    0xc7cca911UL, 0xece1fad2UL, 0xf5facb93UL, 0x7262d75cUL, 0x6b79e61dUL,
-    0x4054b5deUL, 0x594f849fUL, 0x160e1258UL, 0x0f152319UL, 0x243870daUL,
-    0x3d23419bUL, 0x65fd6ba7UL, 0x7ce65ae6UL, 0x57cb0925UL, 0x4ed03864UL,
-    0x0191aea3UL, 0x188a9fe2UL, 0x33a7cc21UL, 0x2abcfd60UL, 0xad24e1afUL,
-    0xb43fd0eeUL, 0x9f12832dUL, 0x8609b26cUL, 0xc94824abUL, 0xd05315eaUL,
-    0xfb7e4629UL, 0xe2657768UL, 0x2f3f79f6UL, 0x362448b7UL, 0x1d091b74UL,
-    0x04122a35UL, 0x4b53bcf2UL, 0x52488db3UL, 0x7965de70UL, 0x607eef31UL,
-    0xe7e6f3feUL, 0xfefdc2bfUL, 0xd5d0917cUL, 0xcccba03dUL, 0x838a36faUL,
-    0x9a9107bbUL, 0xb1bc5478UL, 0xa8a76539UL, 0x3b83984bUL, 0x2298a90aUL,
-    0x09b5fac9UL, 0x10aecb88UL, 0x5fef5d4fUL, 0x46f46c0eUL, 0x6dd93fcdUL,
-    0x74c20e8cUL, 0xf35a1243UL, 0xea412302UL, 0xc16c70c1UL, 0xd8774180UL,
-    0x9736d747UL, 0x8e2de606UL, 0xa500b5c5UL, 0xbc1b8484UL, 0x71418a1aUL,
-    0x685abb5bUL, 0x4377e898UL, 0x5a6cd9d9UL, 0x152d4f1eUL, 0x0c367e5fUL,
-    0x271b2d9cUL, 0x3e001cddUL, 0xb9980012UL, 0xa0833153UL, 0x8bae6290UL,
-    0x92b553d1UL, 0xddf4c516UL, 0xc4eff457UL, 0xefc2a794UL, 0xf6d996d5UL,
-    0xae07bce9UL, 0xb71c8da8UL, 0x9c31de6bUL, 0x852aef2aUL, 0xca6b79edUL,
-    0xd37048acUL, 0xf85d1b6fUL, 0xe1462a2eUL, 0x66de36e1UL, 0x7fc507a0UL,
-    0x54e85463UL, 0x4df36522UL, 0x02b2f3e5UL, 0x1ba9c2a4UL, 0x30849167UL,
-    0x299fa026UL, 0xe4c5aeb8UL, 0xfdde9ff9UL, 0xd6f3cc3aUL, 0xcfe8fd7bUL,
-    0x80a96bbcUL, 0x99b25afdUL, 0xb29f093eUL, 0xab84387fUL, 0x2c1c24b0UL,
-    0x350715f1UL, 0x1e2a4632UL, 0x07317773UL, 0x4870e1b4UL, 0x516bd0f5UL,
-    0x7a468336UL, 0x635db277UL, 0xcbfad74eUL, 0xd2e1e60fUL, 0xf9ccb5ccUL,
-    0xe0d7848dUL, 0xaf96124aUL, 0xb68d230bUL, 0x9da070c8UL, 0x84bb4189UL,
-    0x03235d46UL, 0x1a386c07UL, 0x31153fc4UL, 0x280e0e85UL, 0x674f9842UL,
-    0x7e54a903UL, 0x5579fac0UL, 0x4c62cb81UL, 0x8138c51fUL, 0x9823f45eUL,
-    0xb30ea79dUL, 0xaa1596dcUL, 0xe554001bUL, 0xfc4f315aUL, 0xd7626299UL,
-    0xce7953d8UL, 0x49e14f17UL, 0x50fa7e56UL, 0x7bd72d95UL, 0x62cc1cd4UL,
-    0x2d8d8a13UL, 0x3496bb52UL, 0x1fbbe891UL, 0x06a0d9d0UL, 0x5e7ef3ecUL,
-    0x4765c2adUL, 0x6c48916eUL, 0x7553a02fUL, 0x3a1236e8UL, 0x230907a9UL,
-    0x0824546aUL, 0x113f652bUL, 0x96a779e4UL, 0x8fbc48a5UL, 0xa4911b66UL,
-    0xbd8a2a27UL, 0xf2cbbce0UL, 0xebd08da1UL, 0xc0fdde62UL, 0xd9e6ef23UL,
-    0x14bce1bdUL, 0x0da7d0fcUL, 0x268a833fUL, 0x3f91b27eUL, 0x70d024b9UL,
-    0x69cb15f8UL, 0x42e6463bUL, 0x5bfd777aUL, 0xdc656bb5UL, 0xc57e5af4UL,
-    0xee530937UL, 0xf7483876UL, 0xb809aeb1UL, 0xa1129ff0UL, 0x8a3fcc33UL,
-    0x9324fd72UL
-  },
-  {
-    0x00000000UL, 0x01c26a37UL, 0x0384d46eUL, 0x0246be59UL, 0x0709a8dcUL,
-    0x06cbc2ebUL, 0x048d7cb2UL, 0x054f1685UL, 0x0e1351b8UL, 0x0fd13b8fUL,
-    0x0d9785d6UL, 0x0c55efe1UL, 0x091af964UL, 0x08d89353UL, 0x0a9e2d0aUL,
-    0x0b5c473dUL, 0x1c26a370UL, 0x1de4c947UL, 0x1fa2771eUL, 0x1e601d29UL,
-    0x1b2f0bacUL, 0x1aed619bUL, 0x18abdfc2UL, 0x1969b5f5UL, 0x1235f2c8UL,
-    0x13f798ffUL, 0x11b126a6UL, 0x10734c91UL, 0x153c5a14UL, 0x14fe3023UL,
-    0x16b88e7aUL, 0x177ae44dUL, 0x384d46e0UL, 0x398f2cd7UL, 0x3bc9928eUL,
-    0x3a0bf8b9UL, 0x3f44ee3cUL, 0x3e86840bUL, 0x3cc03a52UL, 0x3d025065UL,
-    0x365e1758UL, 0x379c7d6fUL, 0x35dac336UL, 0x3418a901UL, 0x3157bf84UL,
-    0x3095d5b3UL, 0x32d36beaUL, 0x331101ddUL, 0x246be590UL, 0x25a98fa7UL,
-    0x27ef31feUL, 0x262d5bc9UL, 0x23624d4cUL, 0x22a0277bUL, 0x20e69922UL,
-    0x2124f315UL, 0x2a78b428UL, 0x2bbade1fUL, 0x29fc6046UL, 0x283e0a71UL,
-    0x2d711cf4UL, 0x2cb376c3UL, 0x2ef5c89aUL, 0x2f37a2adUL, 0x709a8dc0UL,
-    0x7158e7f7UL, 0x731e59aeUL, 0x72dc3399UL, 0x7793251cUL, 0x76514f2bUL,
-    0x7417f172UL, 0x75d59b45UL, 0x7e89dc78UL, 0x7f4bb64fUL, 0x7d0d0816UL,
-    0x7ccf6221UL, 0x798074a4UL, 0x78421e93UL, 0x7a04a0caUL, 0x7bc6cafdUL,
-    0x6cbc2eb0UL, 0x6d7e4487UL, 0x6f38fadeUL, 0x6efa90e9UL, 0x6bb5866cUL,
-    0x6a77ec5bUL, 0x68315202UL, 0x69f33835UL, 0x62af7f08UL, 0x636d153fUL,
-    0x612bab66UL, 0x60e9c151UL, 0x65a6d7d4UL, 0x6464bde3UL, 0x662203baUL,
-    0x67e0698dUL, 0x48d7cb20UL, 0x4915a117UL, 0x4b531f4eUL, 0x4a917579UL,
-    0x4fde63fcUL, 0x4e1c09cbUL, 0x4c5ab792UL, 0x4d98dda5UL, 0x46c49a98UL,
-    0x4706f0afUL, 0x45404ef6UL, 0x448224c1UL, 0x41cd3244UL, 0x400f5873UL,
-    0x4249e62aUL, 0x438b8c1dUL, 0x54f16850UL, 0x55330267UL, 0x5775bc3eUL,
-    0x56b7d609UL, 0x53f8c08cUL, 0x523aaabbUL, 0x507c14e2UL, 0x51be7ed5UL,
-    0x5ae239e8UL, 0x5b2053dfUL, 0x5966ed86UL, 0x58a487b1UL, 0x5deb9134UL,
-    0x5c29fb03UL, 0x5e6f455aUL, 0x5fad2f6dUL, 0xe1351b80UL, 0xe0f771b7UL,
-    0xe2b1cfeeUL, 0xe373a5d9UL, 0xe63cb35cUL, 0xe7fed96bUL, 0xe5b86732UL,
-    0xe47a0d05UL, 0xef264a38UL, 0xeee4200fUL, 0xeca29e56UL, 0xed60f461UL,
-    0xe82fe2e4UL, 0xe9ed88d3UL, 0xebab368aUL, 0xea695cbdUL, 0xfd13b8f0UL,
-    0xfcd1d2c7UL, 0xfe976c9eUL, 0xff5506a9UL, 0xfa1a102cUL, 0xfbd87a1bUL,
-    0xf99ec442UL, 0xf85cae75UL, 0xf300e948UL, 0xf2c2837fUL, 0xf0843d26UL,
-    0xf1465711UL, 0xf4094194UL, 0xf5cb2ba3UL, 0xf78d95faUL, 0xf64fffcdUL,
-    0xd9785d60UL, 0xd8ba3757UL, 0xdafc890eUL, 0xdb3ee339UL, 0xde71f5bcUL,
-    0xdfb39f8bUL, 0xddf521d2UL, 0xdc374be5UL, 0xd76b0cd8UL, 0xd6a966efUL,
-    0xd4efd8b6UL, 0xd52db281UL, 0xd062a404UL, 0xd1a0ce33UL, 0xd3e6706aUL,
-    0xd2241a5dUL, 0xc55efe10UL, 0xc49c9427UL, 0xc6da2a7eUL, 0xc7184049UL,
-    0xc25756ccUL, 0xc3953cfbUL, 0xc1d382a2UL, 0xc011e895UL, 0xcb4dafa8UL,
-    0xca8fc59fUL, 0xc8c97bc6UL, 0xc90b11f1UL, 0xcc440774UL, 0xcd866d43UL,
-    0xcfc0d31aUL, 0xce02b92dUL, 0x91af9640UL, 0x906dfc77UL, 0x922b422eUL,
-    0x93e92819UL, 0x96a63e9cUL, 0x976454abUL, 0x9522eaf2UL, 0x94e080c5UL,
-    0x9fbcc7f8UL, 0x9e7eadcfUL, 0x9c381396UL, 0x9dfa79a1UL, 0x98b56f24UL,
-    0x99770513UL, 0x9b31bb4aUL, 0x9af3d17dUL, 0x8d893530UL, 0x8c4b5f07UL,
-    0x8e0de15eUL, 0x8fcf8b69UL, 0x8a809decUL, 0x8b42f7dbUL, 0x89044982UL,
-    0x88c623b5UL, 0x839a6488UL, 0x82580ebfUL, 0x801eb0e6UL, 0x81dcdad1UL,
-    0x8493cc54UL, 0x8551a663UL, 0x8717183aUL, 0x86d5720dUL, 0xa9e2d0a0UL,
-    0xa820ba97UL, 0xaa6604ceUL, 0xaba46ef9UL, 0xaeeb787cUL, 0xaf29124bUL,
-    0xad6fac12UL, 0xacadc625UL, 0xa7f18118UL, 0xa633eb2fUL, 0xa4755576UL,
-    0xa5b73f41UL, 0xa0f829c4UL, 0xa13a43f3UL, 0xa37cfdaaUL, 0xa2be979dUL,
-    0xb5c473d0UL, 0xb40619e7UL, 0xb640a7beUL, 0xb782cd89UL, 0xb2cddb0cUL,
-    0xb30fb13bUL, 0xb1490f62UL, 0xb08b6555UL, 0xbbd72268UL, 0xba15485fUL,
-    0xb853f606UL, 0xb9919c31UL, 0xbcde8ab4UL, 0xbd1ce083UL, 0xbf5a5edaUL,
-    0xbe9834edUL
-  },
-  {
-    0x00000000UL, 0xb8bc6765UL, 0xaa09c88bUL, 0x12b5afeeUL, 0x8f629757UL,
-    0x37def032UL, 0x256b5fdcUL, 0x9dd738b9UL, 0xc5b428efUL, 0x7d084f8aUL,
-    0x6fbde064UL, 0xd7018701UL, 0x4ad6bfb8UL, 0xf26ad8ddUL, 0xe0df7733UL,
-    0x58631056UL, 0x5019579fUL, 0xe8a530faUL, 0xfa109f14UL, 0x42acf871UL,
-    0xdf7bc0c8UL, 0x67c7a7adUL, 0x75720843UL, 0xcdce6f26UL, 0x95ad7f70UL,
-    0x2d111815UL, 0x3fa4b7fbUL, 0x8718d09eUL, 0x1acfe827UL, 0xa2738f42UL,
-    0xb0c620acUL, 0x087a47c9UL, 0xa032af3eUL, 0x188ec85bUL, 0x0a3b67b5UL,
-    0xb28700d0UL, 0x2f503869UL, 0x97ec5f0cUL, 0x8559f0e2UL, 0x3de59787UL,
-    0x658687d1UL, 0xdd3ae0b4UL, 0xcf8f4f5aUL, 0x7733283fUL, 0xeae41086UL,
-    0x525877e3UL, 0x40edd80dUL, 0xf851bf68UL, 0xf02bf8a1UL, 0x48979fc4UL,
-    0x5a22302aUL, 0xe29e574fUL, 0x7f496ff6UL, 0xc7f50893UL, 0xd540a77dUL,
-    0x6dfcc018UL, 0x359fd04eUL, 0x8d23b72bUL, 0x9f9618c5UL, 0x272a7fa0UL,
-    0xbafd4719UL, 0x0241207cUL, 0x10f48f92UL, 0xa848e8f7UL, 0x9b14583dUL,
-    0x23a83f58UL, 0x311d90b6UL, 0x89a1f7d3UL, 0x1476cf6aUL, 0xaccaa80fUL,
-    0xbe7f07e1UL, 0x06c36084UL, 0x5ea070d2UL, 0xe61c17b7UL, 0xf4a9b859UL,
-    0x4c15df3cUL, 0xd1c2e785UL, 0x697e80e0UL, 0x7bcb2f0eUL, 0xc377486bUL,
-    0xcb0d0fa2UL, 0x73b168c7UL, 0x6104c729UL, 0xd9b8a04cUL, 0x446f98f5UL,
-    0xfcd3ff90UL, 0xee66507eUL, 0x56da371bUL, 0x0eb9274dUL, 0xb6054028UL,
-    0xa4b0efc6UL, 0x1c0c88a3UL, 0x81dbb01aUL, 0x3967d77fUL, 0x2bd27891UL,
-    0x936e1ff4UL, 0x3b26f703UL, 0x839a9066UL, 0x912f3f88UL, 0x299358edUL,
-    0xb4446054UL, 0x0cf80731UL, 0x1e4da8dfUL, 0xa6f1cfbaUL, 0xfe92dfecUL,
-    0x462eb889UL, 0x549b1767UL, 0xec277002UL, 0x71f048bbUL, 0xc94c2fdeUL,
-    0xdbf98030UL, 0x6345e755UL, 0x6b3fa09cUL, 0xd383c7f9UL, 0xc1366817UL,
-    0x798a0f72UL, 0xe45d37cbUL, 0x5ce150aeUL, 0x4e54ff40UL, 0xf6e89825UL,
-    0xae8b8873UL, 0x1637ef16UL, 0x048240f8UL, 0xbc3e279dUL, 0x21e91f24UL,
-    0x99557841UL, 0x8be0d7afUL, 0x335cb0caUL, 0xed59b63bUL, 0x55e5d15eUL,
-    0x47507eb0UL, 0xffec19d5UL, 0x623b216cUL, 0xda874609UL, 0xc832e9e7UL,
-    0x708e8e82UL, 0x28ed9ed4UL, 0x9051f9b1UL, 0x82e4565fUL, 0x3a58313aUL,
-    0xa78f0983UL, 0x1f336ee6UL, 0x0d86c108UL, 0xb53aa66dUL, 0xbd40e1a4UL,
-    0x05fc86c1UL, 0x1749292fUL, 0xaff54e4aUL, 0x322276f3UL, 0x8a9e1196UL,
-    0x982bbe78UL, 0x2097d91dUL, 0x78f4c94bUL, 0xc048ae2eUL, 0xd2fd01c0UL,
-    0x6a4166a5UL, 0xf7965e1cUL, 0x4f2a3979UL, 0x5d9f9697UL, 0xe523f1f2UL,
-    0x4d6b1905UL, 0xf5d77e60UL, 0xe762d18eUL, 0x5fdeb6ebUL, 0xc2098e52UL,
-    0x7ab5e937UL, 0x680046d9UL, 0xd0bc21bcUL, 0x88df31eaUL, 0x3063568fUL,
-    0x22d6f961UL, 0x9a6a9e04UL, 0x07bda6bdUL, 0xbf01c1d8UL, 0xadb46e36UL,
-    0x15080953UL, 0x1d724e9aUL, 0xa5ce29ffUL, 0xb77b8611UL, 0x0fc7e174UL,
-    0x9210d9cdUL, 0x2aacbea8UL, 0x38191146UL, 0x80a57623UL, 0xd8c66675UL,
-    0x607a0110UL, 0x72cfaefeUL, 0xca73c99bUL, 0x57a4f122UL, 0xef189647UL,
-    0xfdad39a9UL, 0x45115eccUL, 0x764dee06UL, 0xcef18963UL, 0xdc44268dUL,
-    0x64f841e8UL, 0xf92f7951UL, 0x41931e34UL, 0x5326b1daUL, 0xeb9ad6bfUL,
-    0xb3f9c6e9UL, 0x0b45a18cUL, 0x19f00e62UL, 0xa14c6907UL, 0x3c9b51beUL,
-    0x842736dbUL, 0x96929935UL, 0x2e2efe50UL, 0x2654b999UL, 0x9ee8defcUL,
-    0x8c5d7112UL, 0x34e11677UL, 0xa9362eceUL, 0x118a49abUL, 0x033fe645UL,
-    0xbb838120UL, 0xe3e09176UL, 0x5b5cf613UL, 0x49e959fdUL, 0xf1553e98UL,
-    0x6c820621UL, 0xd43e6144UL, 0xc68bceaaUL, 0x7e37a9cfUL, 0xd67f4138UL,
-    0x6ec3265dUL, 0x7c7689b3UL, 0xc4caeed6UL, 0x591dd66fUL, 0xe1a1b10aUL,
-    0xf3141ee4UL, 0x4ba87981UL, 0x13cb69d7UL, 0xab770eb2UL, 0xb9c2a15cUL,
-    0x017ec639UL, 0x9ca9fe80UL, 0x241599e5UL, 0x36a0360bUL, 0x8e1c516eUL,
-    0x866616a7UL, 0x3eda71c2UL, 0x2c6fde2cUL, 0x94d3b949UL, 0x090481f0UL,
-    0xb1b8e695UL, 0xa30d497bUL, 0x1bb12e1eUL, 0x43d23e48UL, 0xfb6e592dUL,
-    0xe9dbf6c3UL, 0x516791a6UL, 0xccb0a91fUL, 0x740cce7aUL, 0x66b96194UL,
-    0xde0506f1UL
-  },
-  {
-    0x00000000UL, 0x96300777UL, 0x2c610eeeUL, 0xba510999UL, 0x19c46d07UL,
-    0x8ff46a70UL, 0x35a563e9UL, 0xa395649eUL, 0x3288db0eUL, 0xa4b8dc79UL,
-    0x1ee9d5e0UL, 0x88d9d297UL, 0x2b4cb609UL, 0xbd7cb17eUL, 0x072db8e7UL,
-    0x911dbf90UL, 0x6410b71dUL, 0xf220b06aUL, 0x4871b9f3UL, 0xde41be84UL,
-    0x7dd4da1aUL, 0xebe4dd6dUL, 0x51b5d4f4UL, 0xc785d383UL, 0x56986c13UL,
-    0xc0a86b64UL, 0x7af962fdUL, 0xecc9658aUL, 0x4f5c0114UL, 0xd96c0663UL,
-    0x633d0ffaUL, 0xf50d088dUL, 0xc8206e3bUL, 0x5e10694cUL, 0xe44160d5UL,
-    0x727167a2UL, 0xd1e4033cUL, 0x47d4044bUL, 0xfd850dd2UL, 0x6bb50aa5UL,
-    0xfaa8b535UL, 0x6c98b242UL, 0xd6c9bbdbUL, 0x40f9bcacUL, 0xe36cd832UL,
-    0x755cdf45UL, 0xcf0dd6dcUL, 0x593dd1abUL, 0xac30d926UL, 0x3a00de51UL,
-    0x8051d7c8UL, 0x1661d0bfUL, 0xb5f4b421UL, 0x23c4b356UL, 0x9995bacfUL,
-    0x0fa5bdb8UL, 0x9eb80228UL, 0x0888055fUL, 0xb2d90cc6UL, 0x24e90bb1UL,
-    0x877c6f2fUL, 0x114c6858UL, 0xab1d61c1UL, 0x3d2d66b6UL, 0x9041dc76UL,
-    0x0671db01UL, 0xbc20d298UL, 0x2a10d5efUL, 0x8985b171UL, 0x1fb5b606UL,
-    0xa5e4bf9fUL, 0x33d4b8e8UL, 0xa2c90778UL, 0x34f9000fUL, 0x8ea80996UL,
-    0x18980ee1UL, 0xbb0d6a7fUL, 0x2d3d6d08UL, 0x976c6491UL, 0x015c63e6UL,
-    0xf4516b6bUL, 0x62616c1cUL, 0xd8306585UL, 0x4e0062f2UL, 0xed95066cUL,
-    0x7ba5011bUL, 0xc1f40882UL, 0x57c40ff5UL, 0xc6d9b065UL, 0x50e9b712UL,
-    0xeab8be8bUL, 0x7c88b9fcUL, 0xdf1ddd62UL, 0x492dda15UL, 0xf37cd38cUL,
-    0x654cd4fbUL, 0x5861b24dUL, 0xce51b53aUL, 0x7400bca3UL, 0xe230bbd4UL,
-    0x41a5df4aUL, 0xd795d83dUL, 0x6dc4d1a4UL, 0xfbf4d6d3UL, 0x6ae96943UL,
-    0xfcd96e34UL, 0x468867adUL, 0xd0b860daUL, 0x732d0444UL, 0xe51d0333UL,
-    0x5f4c0aaaUL, 0xc97c0dddUL, 0x3c710550UL, 0xaa410227UL, 0x10100bbeUL,
-    0x86200cc9UL, 0x25b56857UL, 0xb3856f20UL, 0x09d466b9UL, 0x9fe461ceUL,
-    0x0ef9de5eUL, 0x98c9d929UL, 0x2298d0b0UL, 0xb4a8d7c7UL, 0x173db359UL,
-    0x810db42eUL, 0x3b5cbdb7UL, 0xad6cbac0UL, 0x2083b8edUL, 0xb6b3bf9aUL,
-    0x0ce2b603UL, 0x9ad2b174UL, 0x3947d5eaUL, 0xaf77d29dUL, 0x1526db04UL,
-    0x8316dc73UL, 0x120b63e3UL, 0x843b6494UL, 0x3e6a6d0dUL, 0xa85a6a7aUL,
-    0x0bcf0ee4UL, 0x9dff0993UL, 0x27ae000aUL, 0xb19e077dUL, 0x44930ff0UL,
-    0xd2a30887UL, 0x68f2011eUL, 0xfec20669UL, 0x5d5762f7UL, 0xcb676580UL,
-    0x71366c19UL, 0xe7066b6eUL, 0x761bd4feUL, 0xe02bd389UL, 0x5a7ada10UL,
-    0xcc4add67UL, 0x6fdfb9f9UL, 0xf9efbe8eUL, 0x43beb717UL, 0xd58eb060UL,
-    0xe8a3d6d6UL, 0x7e93d1a1UL, 0xc4c2d838UL, 0x52f2df4fUL, 0xf167bbd1UL,
-    0x6757bca6UL, 0xdd06b53fUL, 0x4b36b248UL, 0xda2b0dd8UL, 0x4c1b0aafUL,
-    0xf64a0336UL, 0x607a0441UL, 0xc3ef60dfUL, 0x55df67a8UL, 0xef8e6e31UL,
-    0x79be6946UL, 0x8cb361cbUL, 0x1a8366bcUL, 0xa0d26f25UL, 0x36e26852UL,
-    0x95770cccUL, 0x03470bbbUL, 0xb9160222UL, 0x2f260555UL, 0xbe3bbac5UL,
-    0x280bbdb2UL, 0x925ab42bUL, 0x046ab35cUL, 0xa7ffd7c2UL, 0x31cfd0b5UL,
-    0x8b9ed92cUL, 0x1daede5bUL, 0xb0c2649bUL, 0x26f263ecUL, 0x9ca36a75UL,
-    0x0a936d02UL, 0xa906099cUL, 0x3f360eebUL, 0x85670772UL, 0x13570005UL,
-    0x824abf95UL, 0x147ab8e2UL, 0xae2bb17bUL, 0x381bb60cUL, 0x9b8ed292UL,
-    0x0dbed5e5UL, 0xb7efdc7cUL, 0x21dfdb0bUL, 0xd4d2d386UL, 0x42e2d4f1UL,
-    0xf8b3dd68UL, 0x6e83da1fUL, 0xcd16be81UL, 0x5b26b9f6UL, 0xe177b06fUL,
-    0x7747b718UL, 0xe65a0888UL, 0x706a0fffUL, 0xca3b0666UL, 0x5c0b0111UL,
-    0xff9e658fUL, 0x69ae62f8UL, 0xd3ff6b61UL, 0x45cf6c16UL, 0x78e20aa0UL,
-    0xeed20dd7UL, 0x5483044eUL, 0xc2b30339UL, 0x612667a7UL, 0xf71660d0UL,
-    0x4d476949UL, 0xdb776e3eUL, 0x4a6ad1aeUL, 0xdc5ad6d9UL, 0x660bdf40UL,
-    0xf03bd837UL, 0x53aebca9UL, 0xc59ebbdeUL, 0x7fcfb247UL, 0xe9ffb530UL,
-    0x1cf2bdbdUL, 0x8ac2bacaUL, 0x3093b353UL, 0xa6a3b424UL, 0x0536d0baUL,
-    0x9306d7cdUL, 0x2957de54UL, 0xbf67d923UL, 0x2e7a66b3UL, 0xb84a61c4UL,
-    0x021b685dUL, 0x942b6f2aUL, 0x37be0bb4UL, 0xa18e0cc3UL, 0x1bdf055aUL,
-    0x8def022dUL
-  },
-  {
-    0x00000000UL, 0x41311b19UL, 0x82623632UL, 0xc3532d2bUL, 0x04c56c64UL,
-    0x45f4777dUL, 0x86a75a56UL, 0xc796414fUL, 0x088ad9c8UL, 0x49bbc2d1UL,
-    0x8ae8effaUL, 0xcbd9f4e3UL, 0x0c4fb5acUL, 0x4d7eaeb5UL, 0x8e2d839eUL,
-    0xcf1c9887UL, 0x5112c24aUL, 0x1023d953UL, 0xd370f478UL, 0x9241ef61UL,
-    0x55d7ae2eUL, 0x14e6b537UL, 0xd7b5981cUL, 0x96848305UL, 0x59981b82UL,
-    0x18a9009bUL, 0xdbfa2db0UL, 0x9acb36a9UL, 0x5d5d77e6UL, 0x1c6c6cffUL,
-    0xdf3f41d4UL, 0x9e0e5acdUL, 0xa2248495UL, 0xe3159f8cUL, 0x2046b2a7UL,
-    0x6177a9beUL, 0xa6e1e8f1UL, 0xe7d0f3e8UL, 0x2483dec3UL, 0x65b2c5daUL,
-    0xaaae5d5dUL, 0xeb9f4644UL, 0x28cc6b6fUL, 0x69fd7076UL, 0xae6b3139UL,
-    0xef5a2a20UL, 0x2c09070bUL, 0x6d381c12UL, 0xf33646dfUL, 0xb2075dc6UL,
-    0x715470edUL, 0x30656bf4UL, 0xf7f32abbUL, 0xb6c231a2UL, 0x75911c89UL,
-    0x34a00790UL, 0xfbbc9f17UL, 0xba8d840eUL, 0x79dea925UL, 0x38efb23cUL,
-    0xff79f373UL, 0xbe48e86aUL, 0x7d1bc541UL, 0x3c2ade58UL, 0x054f79f0UL,
-    0x447e62e9UL, 0x872d4fc2UL, 0xc61c54dbUL, 0x018a1594UL, 0x40bb0e8dUL,
-    0x83e823a6UL, 0xc2d938bfUL, 0x0dc5a038UL, 0x4cf4bb21UL, 0x8fa7960aUL,
-    0xce968d13UL, 0x0900cc5cUL, 0x4831d745UL, 0x8b62fa6eUL, 0xca53e177UL,
-    0x545dbbbaUL, 0x156ca0a3UL, 0xd63f8d88UL, 0x970e9691UL, 0x5098d7deUL,
-    0x11a9ccc7UL, 0xd2fae1ecUL, 0x93cbfaf5UL, 0x5cd76272UL, 0x1de6796bUL,
-    0xdeb55440UL, 0x9f844f59UL, 0x58120e16UL, 0x1923150fUL, 0xda703824UL,
-    0x9b41233dUL, 0xa76bfd65UL, 0xe65ae67cUL, 0x2509cb57UL, 0x6438d04eUL,
-    0xa3ae9101UL, 0xe29f8a18UL, 0x21cca733UL, 0x60fdbc2aUL, 0xafe124adUL,
-    0xeed03fb4UL, 0x2d83129fUL, 0x6cb20986UL, 0xab2448c9UL, 0xea1553d0UL,
-    0x29467efbUL, 0x687765e2UL, 0xf6793f2fUL, 0xb7482436UL, 0x741b091dUL,
-    0x352a1204UL, 0xf2bc534bUL, 0xb38d4852UL, 0x70de6579UL, 0x31ef7e60UL,
-    0xfef3e6e7UL, 0xbfc2fdfeUL, 0x7c91d0d5UL, 0x3da0cbccUL, 0xfa368a83UL,
-    0xbb07919aUL, 0x7854bcb1UL, 0x3965a7a8UL, 0x4b98833bUL, 0x0aa99822UL,
-    0xc9fab509UL, 0x88cbae10UL, 0x4f5def5fUL, 0x0e6cf446UL, 0xcd3fd96dUL,
-    0x8c0ec274UL, 0x43125af3UL, 0x022341eaUL, 0xc1706cc1UL, 0x804177d8UL,
-    0x47d73697UL, 0x06e62d8eUL, 0xc5b500a5UL, 0x84841bbcUL, 0x1a8a4171UL,
-    0x5bbb5a68UL, 0x98e87743UL, 0xd9d96c5aUL, 0x1e4f2d15UL, 0x5f7e360cUL,
-    0x9c2d1b27UL, 0xdd1c003eUL, 0x120098b9UL, 0x533183a0UL, 0x9062ae8bUL,
-    0xd153b592UL, 0x16c5f4ddUL, 0x57f4efc4UL, 0x94a7c2efUL, 0xd596d9f6UL,
-    0xe9bc07aeUL, 0xa88d1cb7UL, 0x6bde319cUL, 0x2aef2a85UL, 0xed796bcaUL,
-    0xac4870d3UL, 0x6f1b5df8UL, 0x2e2a46e1UL, 0xe136de66UL, 0xa007c57fUL,
-    0x6354e854UL, 0x2265f34dUL, 0xe5f3b202UL, 0xa4c2a91bUL, 0x67918430UL,
-    0x26a09f29UL, 0xb8aec5e4UL, 0xf99fdefdUL, 0x3accf3d6UL, 0x7bfde8cfUL,
-    0xbc6ba980UL, 0xfd5ab299UL, 0x3e099fb2UL, 0x7f3884abUL, 0xb0241c2cUL,
-    0xf1150735UL, 0x32462a1eUL, 0x73773107UL, 0xb4e17048UL, 0xf5d06b51UL,
-    0x3683467aUL, 0x77b25d63UL, 0x4ed7facbUL, 0x0fe6e1d2UL, 0xccb5ccf9UL,
-    0x8d84d7e0UL, 0x4a1296afUL, 0x0b238db6UL, 0xc870a09dUL, 0x8941bb84UL,
-    0x465d2303UL, 0x076c381aUL, 0xc43f1531UL, 0x850e0e28UL, 0x42984f67UL,
-    0x03a9547eUL, 0xc0fa7955UL, 0x81cb624cUL, 0x1fc53881UL, 0x5ef42398UL,
-    0x9da70eb3UL, 0xdc9615aaUL, 0x1b0054e5UL, 0x5a314ffcUL, 0x996262d7UL,
-    0xd85379ceUL, 0x174fe149UL, 0x567efa50UL, 0x952dd77bUL, 0xd41ccc62UL,
-    0x138a8d2dUL, 0x52bb9634UL, 0x91e8bb1fUL, 0xd0d9a006UL, 0xecf37e5eUL,
-    0xadc26547UL, 0x6e91486cUL, 0x2fa05375UL, 0xe836123aUL, 0xa9070923UL,
-    0x6a542408UL, 0x2b653f11UL, 0xe479a796UL, 0xa548bc8fUL, 0x661b91a4UL,
-    0x272a8abdUL, 0xe0bccbf2UL, 0xa18dd0ebUL, 0x62defdc0UL, 0x23efe6d9UL,
-    0xbde1bc14UL, 0xfcd0a70dUL, 0x3f838a26UL, 0x7eb2913fUL, 0xb924d070UL,
-    0xf815cb69UL, 0x3b46e642UL, 0x7a77fd5bUL, 0xb56b65dcUL, 0xf45a7ec5UL,
-    0x370953eeUL, 0x763848f7UL, 0xb1ae09b8UL, 0xf09f12a1UL, 0x33cc3f8aUL,
-    0x72fd2493UL
-  },
-  {
-    0x00000000UL, 0x376ac201UL, 0x6ed48403UL, 0x59be4602UL, 0xdca80907UL,
-    0xebc2cb06UL, 0xb27c8d04UL, 0x85164f05UL, 0xb851130eUL, 0x8f3bd10fUL,
-    0xd685970dUL, 0xe1ef550cUL, 0x64f91a09UL, 0x5393d808UL, 0x0a2d9e0aUL,
-    0x3d475c0bUL, 0x70a3261cUL, 0x47c9e41dUL, 0x1e77a21fUL, 0x291d601eUL,
-    0xac0b2f1bUL, 0x9b61ed1aUL, 0xc2dfab18UL, 0xf5b56919UL, 0xc8f23512UL,
-    0xff98f713UL, 0xa626b111UL, 0x914c7310UL, 0x145a3c15UL, 0x2330fe14UL,
-    0x7a8eb816UL, 0x4de47a17UL, 0xe0464d38UL, 0xd72c8f39UL, 0x8e92c93bUL,
-    0xb9f80b3aUL, 0x3cee443fUL, 0x0b84863eUL, 0x523ac03cUL, 0x6550023dUL,
-    0x58175e36UL, 0x6f7d9c37UL, 0x36c3da35UL, 0x01a91834UL, 0x84bf5731UL,
-    0xb3d59530UL, 0xea6bd332UL, 0xdd011133UL, 0x90e56b24UL, 0xa78fa925UL,
-    0xfe31ef27UL, 0xc95b2d26UL, 0x4c4d6223UL, 0x7b27a022UL, 0x2299e620UL,
-    0x15f32421UL, 0x28b4782aUL, 0x1fdeba2bUL, 0x4660fc29UL, 0x710a3e28UL,
-    0xf41c712dUL, 0xc376b32cUL, 0x9ac8f52eUL, 0xada2372fUL, 0xc08d9a70UL,
-    0xf7e75871UL, 0xae591e73UL, 0x9933dc72UL, 0x1c259377UL, 0x2b4f5176UL,
-    0x72f11774UL, 0x459bd575UL, 0x78dc897eUL, 0x4fb64b7fUL, 0x16080d7dUL,
-    0x2162cf7cUL, 0xa4748079UL, 0x931e4278UL, 0xcaa0047aUL, 0xfdcac67bUL,
-    0xb02ebc6cUL, 0x87447e6dUL, 0xdefa386fUL, 0xe990fa6eUL, 0x6c86b56bUL,
-    0x5bec776aUL, 0x02523168UL, 0x3538f369UL, 0x087faf62UL, 0x3f156d63UL,
-    0x66ab2b61UL, 0x51c1e960UL, 0xd4d7a665UL, 0xe3bd6464UL, 0xba032266UL,
-    0x8d69e067UL, 0x20cbd748UL, 0x17a11549UL, 0x4e1f534bUL, 0x7975914aUL,
-    0xfc63de4fUL, 0xcb091c4eUL, 0x92b75a4cUL, 0xa5dd984dUL, 0x989ac446UL,
-    0xaff00647UL, 0xf64e4045UL, 0xc1248244UL, 0x4432cd41UL, 0x73580f40UL,
-    0x2ae64942UL, 0x1d8c8b43UL, 0x5068f154UL, 0x67023355UL, 0x3ebc7557UL,
-    0x09d6b756UL, 0x8cc0f853UL, 0xbbaa3a52UL, 0xe2147c50UL, 0xd57ebe51UL,
-    0xe839e25aUL, 0xdf53205bUL, 0x86ed6659UL, 0xb187a458UL, 0x3491eb5dUL,
-    0x03fb295cUL, 0x5a456f5eUL, 0x6d2fad5fUL, 0x801b35e1UL, 0xb771f7e0UL,
-    0xeecfb1e2UL, 0xd9a573e3UL, 0x5cb33ce6UL, 0x6bd9fee7UL, 0x3267b8e5UL,
-    0x050d7ae4UL, 0x384a26efUL, 0x0f20e4eeUL, 0x569ea2ecUL, 0x61f460edUL,
-    0xe4e22fe8UL, 0xd388ede9UL, 0x8a36abebUL, 0xbd5c69eaUL, 0xf0b813fdUL,
-    0xc7d2d1fcUL, 0x9e6c97feUL, 0xa90655ffUL, 0x2c101afaUL, 0x1b7ad8fbUL,
-    0x42c49ef9UL, 0x75ae5cf8UL, 0x48e900f3UL, 0x7f83c2f2UL, 0x263d84f0UL,
-    0x115746f1UL, 0x944109f4UL, 0xa32bcbf5UL, 0xfa958df7UL, 0xcdff4ff6UL,
-    0x605d78d9UL, 0x5737bad8UL, 0x0e89fcdaUL, 0x39e33edbUL, 0xbcf571deUL,
-    0x8b9fb3dfUL, 0xd221f5ddUL, 0xe54b37dcUL, 0xd80c6bd7UL, 0xef66a9d6UL,
-    0xb6d8efd4UL, 0x81b22dd5UL, 0x04a462d0UL, 0x33cea0d1UL, 0x6a70e6d3UL,
-    0x5d1a24d2UL, 0x10fe5ec5UL, 0x27949cc4UL, 0x7e2adac6UL, 0x494018c7UL,
-    0xcc5657c2UL, 0xfb3c95c3UL, 0xa282d3c1UL, 0x95e811c0UL, 0xa8af4dcbUL,
-    0x9fc58fcaUL, 0xc67bc9c8UL, 0xf1110bc9UL, 0x740744ccUL, 0x436d86cdUL,
-    0x1ad3c0cfUL, 0x2db902ceUL, 0x4096af91UL, 0x77fc6d90UL, 0x2e422b92UL,
-    0x1928e993UL, 0x9c3ea696UL, 0xab546497UL, 0xf2ea2295UL, 0xc580e094UL,
-    0xf8c7bc9fUL, 0xcfad7e9eUL, 0x9613389cUL, 0xa179fa9dUL, 0x246fb598UL,
-    0x13057799UL, 0x4abb319bUL, 0x7dd1f39aUL, 0x3035898dUL, 0x075f4b8cUL,
-    0x5ee10d8eUL, 0x698bcf8fUL, 0xec9d808aUL, 0xdbf7428bUL, 0x82490489UL,
-    0xb523c688UL, 0x88649a83UL, 0xbf0e5882UL, 0xe6b01e80UL, 0xd1dadc81UL,
-    0x54cc9384UL, 0x63a65185UL, 0x3a181787UL, 0x0d72d586UL, 0xa0d0e2a9UL,
-    0x97ba20a8UL, 0xce0466aaUL, 0xf96ea4abUL, 0x7c78ebaeUL, 0x4b1229afUL,
-    0x12ac6fadUL, 0x25c6adacUL, 0x1881f1a7UL, 0x2feb33a6UL, 0x765575a4UL,
-    0x413fb7a5UL, 0xc429f8a0UL, 0xf3433aa1UL, 0xaafd7ca3UL, 0x9d97bea2UL,
-    0xd073c4b5UL, 0xe71906b4UL, 0xbea740b6UL, 0x89cd82b7UL, 0x0cdbcdb2UL,
-    0x3bb10fb3UL, 0x620f49b1UL, 0x55658bb0UL, 0x6822d7bbUL, 0x5f4815baUL,
-    0x06f653b8UL, 0x319c91b9UL, 0xb48adebcUL, 0x83e01cbdUL, 0xda5e5abfUL,
-    0xed3498beUL
-  },
-  {
-    0x00000000UL, 0x6567bcb8UL, 0x8bc809aaUL, 0xeeafb512UL, 0x5797628fUL,
-    0x32f0de37UL, 0xdc5f6b25UL, 0xb938d79dUL, 0xef28b4c5UL, 0x8a4f087dUL,
-    0x64e0bd6fUL, 0x018701d7UL, 0xb8bfd64aUL, 0xddd86af2UL, 0x3377dfe0UL,
-    0x56106358UL, 0x9f571950UL, 0xfa30a5e8UL, 0x149f10faUL, 0x71f8ac42UL,
-    0xc8c07bdfUL, 0xada7c767UL, 0x43087275UL, 0x266fcecdUL, 0x707fad95UL,
-    0x1518112dUL, 0xfbb7a43fUL, 0x9ed01887UL, 0x27e8cf1aUL, 0x428f73a2UL,
-    0xac20c6b0UL, 0xc9477a08UL, 0x3eaf32a0UL, 0x5bc88e18UL, 0xb5673b0aUL,
-    0xd00087b2UL, 0x6938502fUL, 0x0c5fec97UL, 0xe2f05985UL, 0x8797e53dUL,
-    0xd1878665UL, 0xb4e03addUL, 0x5a4f8fcfUL, 0x3f283377UL, 0x8610e4eaUL,
-    0xe3775852UL, 0x0dd8ed40UL, 0x68bf51f8UL, 0xa1f82bf0UL, 0xc49f9748UL,
-    0x2a30225aUL, 0x4f579ee2UL, 0xf66f497fUL, 0x9308f5c7UL, 0x7da740d5UL,
-    0x18c0fc6dUL, 0x4ed09f35UL, 0x2bb7238dUL, 0xc518969fUL, 0xa07f2a27UL,
-    0x1947fdbaUL, 0x7c204102UL, 0x928ff410UL, 0xf7e848a8UL, 0x3d58149bUL,
-    0x583fa823UL, 0xb6901d31UL, 0xd3f7a189UL, 0x6acf7614UL, 0x0fa8caacUL,
-    0xe1077fbeUL, 0x8460c306UL, 0xd270a05eUL, 0xb7171ce6UL, 0x59b8a9f4UL,
-    0x3cdf154cUL, 0x85e7c2d1UL, 0xe0807e69UL, 0x0e2fcb7bUL, 0x6b4877c3UL,
-    0xa20f0dcbUL, 0xc768b173UL, 0x29c70461UL, 0x4ca0b8d9UL, 0xf5986f44UL,
-    0x90ffd3fcUL, 0x7e5066eeUL, 0x1b37da56UL, 0x4d27b90eUL, 0x284005b6UL,
-    0xc6efb0a4UL, 0xa3880c1cUL, 0x1ab0db81UL, 0x7fd76739UL, 0x9178d22bUL,
-    0xf41f6e93UL, 0x03f7263bUL, 0x66909a83UL, 0x883f2f91UL, 0xed589329UL,
-    0x546044b4UL, 0x3107f80cUL, 0xdfa84d1eUL, 0xbacff1a6UL, 0xecdf92feUL,
-    0x89b82e46UL, 0x67179b54UL, 0x027027ecUL, 0xbb48f071UL, 0xde2f4cc9UL,
-    0x3080f9dbUL, 0x55e74563UL, 0x9ca03f6bUL, 0xf9c783d3UL, 0x176836c1UL,
-    0x720f8a79UL, 0xcb375de4UL, 0xae50e15cUL, 0x40ff544eUL, 0x2598e8f6UL,
-    0x73888baeUL, 0x16ef3716UL, 0xf8408204UL, 0x9d273ebcUL, 0x241fe921UL,
-    0x41785599UL, 0xafd7e08bUL, 0xcab05c33UL, 0x3bb659edUL, 0x5ed1e555UL,
-    0xb07e5047UL, 0xd519ecffUL, 0x6c213b62UL, 0x094687daUL, 0xe7e932c8UL,
-    0x828e8e70UL, 0xd49eed28UL, 0xb1f95190UL, 0x5f56e482UL, 0x3a31583aUL,
-    0x83098fa7UL, 0xe66e331fUL, 0x08c1860dUL, 0x6da63ab5UL, 0xa4e140bdUL,
-    0xc186fc05UL, 0x2f294917UL, 0x4a4ef5afUL, 0xf3762232UL, 0x96119e8aUL,
-    0x78be2b98UL, 0x1dd99720UL, 0x4bc9f478UL, 0x2eae48c0UL, 0xc001fdd2UL,
-    0xa566416aUL, 0x1c5e96f7UL, 0x79392a4fUL, 0x97969f5dUL, 0xf2f123e5UL,
-    0x05196b4dUL, 0x607ed7f5UL, 0x8ed162e7UL, 0xebb6de5fUL, 0x528e09c2UL,
-    0x37e9b57aUL, 0xd9460068UL, 0xbc21bcd0UL, 0xea31df88UL, 0x8f566330UL,
-    0x61f9d622UL, 0x049e6a9aUL, 0xbda6bd07UL, 0xd8c101bfUL, 0x366eb4adUL,
-    0x53090815UL, 0x9a4e721dUL, 0xff29cea5UL, 0x11867bb7UL, 0x74e1c70fUL,
-    0xcdd91092UL, 0xa8beac2aUL, 0x46111938UL, 0x2376a580UL, 0x7566c6d8UL,
-    0x10017a60UL, 0xfeaecf72UL, 0x9bc973caUL, 0x22f1a457UL, 0x479618efUL,
-    0xa939adfdUL, 0xcc5e1145UL, 0x06ee4d76UL, 0x6389f1ceUL, 0x8d2644dcUL,
-    0xe841f864UL, 0x51792ff9UL, 0x341e9341UL, 0xdab12653UL, 0xbfd69aebUL,
-    0xe9c6f9b3UL, 0x8ca1450bUL, 0x620ef019UL, 0x07694ca1UL, 0xbe519b3cUL,
-    0xdb362784UL, 0x35999296UL, 0x50fe2e2eUL, 0x99b95426UL, 0xfcdee89eUL,
-    0x12715d8cUL, 0x7716e134UL, 0xce2e36a9UL, 0xab498a11UL, 0x45e63f03UL,
-    0x208183bbUL, 0x7691e0e3UL, 0x13f65c5bUL, 0xfd59e949UL, 0x983e55f1UL,
-    0x2106826cUL, 0x44613ed4UL, 0xaace8bc6UL, 0xcfa9377eUL, 0x38417fd6UL,
-    0x5d26c36eUL, 0xb389767cUL, 0xd6eecac4UL, 0x6fd61d59UL, 0x0ab1a1e1UL,
-    0xe41e14f3UL, 0x8179a84bUL, 0xd769cb13UL, 0xb20e77abUL, 0x5ca1c2b9UL,
-    0x39c67e01UL, 0x80fea99cUL, 0xe5991524UL, 0x0b36a036UL, 0x6e511c8eUL,
-    0xa7166686UL, 0xc271da3eUL, 0x2cde6f2cUL, 0x49b9d394UL, 0xf0810409UL,
-    0x95e6b8b1UL, 0x7b490da3UL, 0x1e2eb11bUL, 0x483ed243UL, 0x2d596efbUL,
-    0xc3f6dbe9UL, 0xa6916751UL, 0x1fa9b0ccUL, 0x7ace0c74UL, 0x9461b966UL,
-    0xf10605deUL
-#endif
-  }
-};
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/zlib/deflate.h
+++ /dev/null
@@ -1,349 +0,0 @@
-/* deflate.h -- internal compression state
- * Copyright (C) 1995-2016 Jean-loup Gailly
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-/* @(#) $Id$ */
-
-#ifndef DEFLATE_H
-#define DEFLATE_H
-
-#include "zutil.h"
-
-/* define NO_GZIP when compiling if you want to disable gzip header and
-   trailer creation by deflate().  NO_GZIP would be used to avoid linking in
-   the crc code when it is not needed.  For shared libraries, gzip encoding
-   should be left enabled. */
-#ifndef NO_GZIP
-#  define GZIP
-#endif
-
-/* ===========================================================================
- * Internal compression state.
- */
-
-#define LENGTH_CODES 29
-/* number of length codes, not counting the special END_BLOCK code */
-
-#define LITERALS  256
-/* number of literal bytes 0..255 */
-
-#define L_CODES (LITERALS+1+LENGTH_CODES)
-/* number of Literal or Length codes, including the END_BLOCK code */
-
-#define D_CODES   30
-/* number of distance codes */
-
-#define BL_CODES  19
-/* number of codes used to transfer the bit lengths */
-
-#define HEAP_SIZE (2*L_CODES+1)
-/* maximum heap size */
-
-#define MAX_BITS 15
-/* All codes must not exceed MAX_BITS bits */
-
-#define Buf_size 16
-/* size of bit buffer in bi_buf */
-
-#define INIT_STATE    42    /* zlib header -> BUSY_STATE */
-#ifdef GZIP
-#  define GZIP_STATE  57    /* gzip header -> BUSY_STATE | EXTRA_STATE */
-#endif
-#define EXTRA_STATE   69    /* gzip extra block -> NAME_STATE */
-#define NAME_STATE    73    /* gzip file name -> COMMENT_STATE */
-#define COMMENT_STATE 91    /* gzip comment -> HCRC_STATE */
-#define HCRC_STATE   103    /* gzip header CRC -> BUSY_STATE */
-#define BUSY_STATE   113    /* deflate -> FINISH_STATE */
-#define FINISH_STATE 666    /* stream complete */
-/* Stream status */
-
-
-/* Data structure describing a single value and its code string. */
-typedef struct ct_data_s {
-    union {
-        ush  freq;       /* frequency count */
-        ush  code;       /* bit string */
-    } fc;
-    union {
-        ush  dad;        /* father node in Huffman tree */
-        ush  len;        /* length of bit string */
-    } dl;
-} FAR ct_data;
-
-#define Freq fc.freq
-#define Code fc.code
-#define Dad  dl.dad
-#define Len  dl.len
-
-typedef struct static_tree_desc_s  static_tree_desc;
-
-typedef struct tree_desc_s {
-    ct_data *dyn_tree;           /* the dynamic tree */
-    int     max_code;            /* largest code with non zero frequency */
-    const static_tree_desc *stat_desc;  /* the corresponding static tree */
-} FAR tree_desc;
-
-typedef ush Pos;
-typedef Pos FAR Posf;
-typedef unsigned IPos;
-
-/* A Pos is an index in the character window. We use short instead of int to
- * save space in the various tables. IPos is used only for parameter passing.
- */
-
-typedef struct internal_state {
-    z_streamp strm;      /* pointer back to this zlib stream */
-    int   status;        /* as the name implies */
-    Bytef *pending_buf;  /* output still pending */
-    ulg   pending_buf_size; /* size of pending_buf */
-    Bytef *pending_out;  /* next pending byte to output to the stream */
-    ulg   pending;       /* nb of bytes in the pending buffer */
-    int   wrap;          /* bit 0 true for zlib, bit 1 true for gzip */
-    gz_headerp  gzhead;  /* gzip header information to write */
-    ulg   gzindex;       /* where in extra, name, or comment */
-    Byte  method;        /* can only be DEFLATED */
-    int   last_flush;    /* value of flush param for previous deflate call */
-
-                /* used by deflate.c: */
-
-    uInt  w_size;        /* LZ77 window size (32K by default) */
-    uInt  w_bits;        /* log2(w_size)  (8..16) */
-    uInt  w_mask;        /* w_size - 1 */
-
-    Bytef *window;
-    /* Sliding window. Input bytes are read into the second half of the window,
-     * and move to the first half later to keep a dictionary of at least wSize
-     * bytes. With this organization, matches are limited to a distance of
-     * wSize-MAX_MATCH bytes, but this ensures that IO is always
-     * performed with a length multiple of the block size. Also, it limits
-     * the window size to 64K, which is quite useful on MSDOS.
-     * To do: use the user input buffer as sliding window.
-     */
-
-    ulg window_size;
-    /* Actual size of window: 2*wSize, except when the user input buffer
-     * is directly used as sliding window.
-     */
-
-    Posf *prev;
-    /* Link to older string with same hash index. To limit the size of this
-     * array to 64K, this link is maintained only for the last 32K strings.
-     * An index in this array is thus a window index modulo 32K.
-     */
-
-    Posf *head; /* Heads of the hash chains or NIL. */
-
-    uInt  ins_h;          /* hash index of string to be inserted */
-    uInt  hash_size;      /* number of elements in hash table */
-    uInt  hash_bits;      /* log2(hash_size) */
-    uInt  hash_mask;      /* hash_size-1 */
-
-    uInt  hash_shift;
-    /* Number of bits by which ins_h must be shifted at each input
-     * step. It must be such that after MIN_MATCH steps, the oldest
-     * byte no longer takes part in the hash key, that is:
-     *   hash_shift * MIN_MATCH >= hash_bits
-     */
-
-    long block_start;
-    /* Window position at the beginning of the current output block. Gets
-     * negative when the window is moved backwards.
-     */
-
-    uInt match_length;           /* length of best match */
-    IPos prev_match;             /* previous match */
-    int match_available;         /* set if previous match exists */
-    uInt strstart;               /* start of string to insert */
-    uInt match_start;            /* start of matching string */
-    uInt lookahead;              /* number of valid bytes ahead in window */
-
-    uInt prev_length;
-    /* Length of the best match at previous step. Matches not greater than this
-     * are discarded. This is used in the lazy match evaluation.
-     */
-
-    uInt max_chain_length;
-    /* To speed up deflation, hash chains are never searched beyond this
-     * length.  A higher limit improves compression ratio but degrades the
-     * speed.
-     */
-
-    uInt max_lazy_match;
-    /* Attempt to find a better match only when the current match is strictly
-     * smaller than this value. This mechanism is used only for compression
-     * levels >= 4.
-     */
-#   define max_insert_length  max_lazy_match
-    /* Insert new strings in the hash table only if the match length is not
-     * greater than this length. This saves time but degrades compression.
-     * max_insert_length is used only for compression levels <= 3.
-     */
-
-    int level;    /* compression level (1..9) */
-    int strategy; /* favor or force Huffman coding*/
-
-    uInt good_match;
-    /* Use a faster search when the previous match is longer than this */
-
-    int nice_match; /* Stop searching when current match exceeds this */
-
-                /* used by trees.c: */
-    /* Didn't use ct_data typedef below to suppress compiler warning */
-    struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
-    struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
-    struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
-
-    struct tree_desc_s l_desc;               /* desc. for literal tree */
-    struct tree_desc_s d_desc;               /* desc. for distance tree */
-    struct tree_desc_s bl_desc;              /* desc. for bit length tree */
-
-    ush bl_count[MAX_BITS+1];
-    /* number of codes at each bit length for an optimal tree */
-
-    int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
-    int heap_len;               /* number of elements in the heap */
-    int heap_max;               /* element of largest frequency */
-    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
-     * The same heap array is used to build all trees.
-     */
-
-    uch depth[2*L_CODES+1];
-    /* Depth of each subtree used as tie breaker for trees of equal frequency
-     */
-
-    uchf *l_buf;          /* buffer for literals or lengths */
-
-    uInt  lit_bufsize;
-    /* Size of match buffer for literals/lengths.  There are 4 reasons for
-     * limiting lit_bufsize to 64K:
-     *   - frequencies can be kept in 16 bit counters
-     *   - if compression is not successful for the first block, all input
-     *     data is still in the window so we can still emit a stored block even
-     *     when input comes from standard input.  (This can also be done for
-     *     all blocks if lit_bufsize is not greater than 32K.)
-     *   - if compression is not successful for a file smaller than 64K, we can
-     *     even emit a stored file instead of a stored block (saving 5 bytes).
-     *     This is applicable only for zip (not gzip or zlib).
-     *   - creating new Huffman trees less frequently may not provide fast
-     *     adaptation to changes in the input data statistics. (Take for
-     *     example a binary file with poorly compressible code followed by
-     *     a highly compressible string table.) Smaller buffer sizes give
-     *     fast adaptation but have of course the overhead of transmitting
-     *     trees more frequently.
-     *   - I can't count above 4
-     */
-
-    uInt last_lit;      /* running index in l_buf */
-
-    ushf *d_buf;
-    /* Buffer for distances. To simplify the code, d_buf and l_buf have
-     * the same number of elements. To use different lengths, an extra flag
-     * array would be necessary.
-     */
-
-    ulg opt_len;        /* bit length of current block with optimal trees */
-    ulg static_len;     /* bit length of current block with static trees */
-    uInt matches;       /* number of string matches in current block */
-    uInt insert;        /* bytes at end of window left to insert */
-
-#ifdef ZLIB_DEBUG
-    ulg compressed_len; /* total bit length of compressed file mod 2^32 */
-    ulg bits_sent;      /* bit length of compressed data sent mod 2^32 */
-#endif
-
-    ush bi_buf;
-    /* Output buffer. bits are inserted starting at the bottom (least
-     * significant bits).
-     */
-    int bi_valid;
-    /* Number of valid bits in bi_buf.  All bits above the last valid bit
-     * are always zero.
-     */
-
-    ulg high_water;
-    /* High water mark offset in window for initialized bytes -- bytes above
-     * this are set to zero in order to avoid memory check warnings when
-     * longest match routines access bytes past the input.  This is then
-     * updated to the new high water mark.
-     */
-
-} FAR deflate_state;
-
-/* Output a byte on the stream.
- * IN assertion: there is enough room in pending_buf.
- */
-#define put_byte(s, c) {s->pending_buf[s->pending++] = (Bytef)(c);}
-
-
-#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
-/* Minimum amount of lookahead, except at the end of the input file.
- * See deflate.c for comments about the MIN_MATCH+1.
- */
-
-#define MAX_DIST(s)  ((s)->w_size-MIN_LOOKAHEAD)
-/* In order to simplify the code, particularly on 16 bit machines, match
- * distances are limited to MAX_DIST instead of WSIZE.
- */
-
-#define WIN_INIT MAX_MATCH
-/* Number of bytes after end of data in window to initialize in order to avoid
-   memory checker errors from longest match routines */
-
-        /* in trees.c */
-void ZLIB_INTERNAL _tr_init OF((deflate_state *s));
-int ZLIB_INTERNAL _tr_tally OF((deflate_state *s, unsigned dist, unsigned lc));
-void ZLIB_INTERNAL _tr_flush_block OF((deflate_state *s, charf *buf,
-                        ulg stored_len, int last));
-void ZLIB_INTERNAL _tr_flush_bits OF((deflate_state *s));
-void ZLIB_INTERNAL _tr_align OF((deflate_state *s));
-void ZLIB_INTERNAL _tr_stored_block OF((deflate_state *s, charf *buf,
-                        ulg stored_len, int last));
-
-#define d_code(dist) \
-   ((dist) < 256 ? _dist_code[dist] : _dist_code[256+((dist)>>7)])
-/* Mapping from a distance to a distance code. dist is the distance - 1 and
- * must not have side effects. _dist_code[256] and _dist_code[257] are never
- * used.
- */
-
-#ifndef ZLIB_DEBUG
-/* Inline versions of _tr_tally for speed: */
-
-#if defined(GEN_TREES_H) || !defined(STDC)
-  extern uch ZLIB_INTERNAL _length_code[];
-  extern uch ZLIB_INTERNAL _dist_code[];
-#else
-  extern const uch ZLIB_INTERNAL _length_code[];
-  extern const uch ZLIB_INTERNAL _dist_code[];
-#endif
-
-# define _tr_tally_lit(s, c, flush) \
-  { uch cc = (c); \
-    s->d_buf[s->last_lit] = 0; \
-    s->l_buf[s->last_lit++] = cc; \
-    s->dyn_ltree[cc].Freq++; \
-    flush = (s->last_lit == s->lit_bufsize-1); \
-   }
-# define _tr_tally_dist(s, distance, length, flush) \
-  { uch len = (uch)(length); \
-    ush dist = (ush)(distance); \
-    s->d_buf[s->last_lit] = dist; \
-    s->l_buf[s->last_lit++] = len; \
-    dist--; \
-    s->dyn_ltree[_length_code[len]+LITERALS+1].Freq++; \
-    s->dyn_dtree[d_code(dist)].Freq++; \
-    flush = (s->last_lit == s->lit_bufsize-1); \
-  }
-#else
-# define _tr_tally_lit(s, c, flush) flush = _tr_tally(s, 0, c)
-# define _tr_tally_dist(s, distance, length, flush) \
-              flush = _tr_tally(s, distance, length)
-#endif
-
-#endif /* DEFLATE_H */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/zlib/examples/gzlog.h
+++ /dev/null
@@ -1,91 +0,0 @@
-/* gzlog.h
-  Copyright (C) 2004, 2008, 2012 Mark Adler, all rights reserved
-  version 2.2, 14 Aug 2012
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the author be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  Mark Adler    madler@alumni.caltech.edu
- */
-
-/* Version History:
-   1.0  26 Nov 2004  First version
-   2.0  25 Apr 2008  Complete redesign for recovery of interrupted operations
-                     Interface changed slightly in that now path is a prefix
-                     Compression now occurs as needed during gzlog_write()
-                     gzlog_write() now always leaves the log file as valid gzip
-   2.1   8 Jul 2012  Fix argument checks in gzlog_compress() and gzlog_write()
-   2.2  14 Aug 2012  Clean up signed comparisons
- */
-
-/*
-   The gzlog object allows writing short messages to a gzipped log file,
-   opening the log file locked for small bursts, and then closing it.  The log
-   object works by appending stored (uncompressed) data to the gzip file until
-   1 MB has been accumulated.  At that time, the stored data is compressed, and
-   replaces the uncompressed data in the file.  The log file is truncated to
-   its new size at that time.  After each write operation, the log file is a
-   valid gzip file that can decompressed to recover what was written.
-
-   The gzlog operations can be interupted at any point due to an application or
-   system crash, and the log file will be recovered the next time the log is
-   opened with gzlog_open().
- */
-
-#ifndef GZLOG_H
-#define GZLOG_H
-
-/* gzlog object type */
-typedef void gzlog;
-
-/* Open a gzlog object, creating the log file if it does not exist.  Return
-   NULL on error.  Note that gzlog_open() could take a while to complete if it
-   has to wait to verify that a lock is stale (possibly for five minutes), or
-   if there is significant contention with other instantiations of this object
-   when locking the resource.  path is the prefix of the file names created by
-   this object.  If path is "foo", then the log file will be "foo.gz", and
-   other auxiliary files will be created and destroyed during the process:
-   "foo.dict" for a compression dictionary, "foo.temp" for a temporary (next)
-   dictionary, "foo.add" for data being added or compressed, "foo.lock" for the
-   lock file, and "foo.repairs" to log recovery operations performed due to
-   interrupted gzlog operations.  A gzlog_open() followed by a gzlog_close()
-   will recover a previously interrupted operation, if any. */
-gzlog *gzlog_open(char *path);
-
-/* Write to a gzlog object.  Return zero on success, -1 if there is a file i/o
-   error on any of the gzlog files (this should not happen if gzlog_open()
-   succeeded, unless the device has run out of space or leftover auxiliary
-   files have permissions or ownership that prevent their use), -2 if there is
-   a memory allocation failure, or -3 if the log argument is invalid (e.g. if
-   it was not created by gzlog_open()).  This function will write data to the
-   file uncompressed, until 1 MB has been accumulated, at which time that data
-   will be compressed.  The log file will be a valid gzip file upon successful
-   return. */
-int gzlog_write(gzlog *log, void *data, size_t len);
-
-/* Force compression of any uncompressed data in the log.  This should be used
-   sparingly, if at all.  The main application would be when a log file will
-   not be appended to again.  If this is used to compress frequently while
-   appending, it will both significantly increase the execution time and
-   reduce the compression ratio.  The return codes are the same as for
-   gzlog_write(). */
-int gzlog_compress(gzlog *log);
-
-/* Close a gzlog object.  Return zero on success, -3 if the log argument is
-   invalid.  The log object is freed, and so cannot be referenced again. */
-int gzlog_close(gzlog *log);
-
-#endif
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/zlib/gzguts.h
+++ /dev/null
@@ -1,218 +0,0 @@
-/* gzguts.h -- zlib internal header definitions for gz* operations
- * Copyright (C) 2004, 2005, 2010, 2011, 2012, 2013, 2016 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#ifdef _LARGEFILE64_SOURCE
-#  ifndef _LARGEFILE_SOURCE
-#    define _LARGEFILE_SOURCE 1
-#  endif
-#  ifdef _FILE_OFFSET_BITS
-#    undef _FILE_OFFSET_BITS
-#  endif
-#endif
-
-#ifdef HAVE_HIDDEN
-#  define ZLIB_INTERNAL __attribute__((visibility ("hidden")))
-#else
-#  define ZLIB_INTERNAL
-#endif
-
-#include <stdio.h>
-#include "zlib.h"
-#ifdef STDC
-#  include <string.h>
-#  include <stdlib.h>
-#  include <limits.h>
-#endif
-
-#ifndef _POSIX_SOURCE
-#  define _POSIX_SOURCE
-#endif
-#include <fcntl.h>
-
-#ifdef _WIN32
-#  include <stddef.h>
-#endif
-
-#if defined(__TURBOC__) || defined(_MSC_VER) || defined(_WIN32)
-#  include <io.h>
-#endif
-
-#if defined(_WIN32) || defined(__CYGWIN__)
-#  define WIDECHAR
-#endif
-
-#ifdef WINAPI_FAMILY
-#  define open _open
-#  define read _read
-#  define write _write
-#  define close _close
-#endif
-
-#ifdef NO_DEFLATE       /* for compatibility with old definition */
-#  define NO_GZCOMPRESS
-#endif
-
-#if defined(STDC99) || (defined(__TURBOC__) && __TURBOC__ >= 0x550)
-#  ifndef HAVE_VSNPRINTF
-#    define HAVE_VSNPRINTF
-#  endif
-#endif
-
-#if defined(__CYGWIN__)
-#  ifndef HAVE_VSNPRINTF
-#    define HAVE_VSNPRINTF
-#  endif
-#endif
-
-#if defined(MSDOS) && defined(__BORLANDC__) && (BORLANDC > 0x410)
-#  ifndef HAVE_VSNPRINTF
-#    define HAVE_VSNPRINTF
-#  endif
-#endif
-
-#ifndef HAVE_VSNPRINTF
-#  ifdef MSDOS
-/* vsnprintf may exist on some MS-DOS compilers (DJGPP?),
-   but for now we just assume it doesn't. */
-#    define NO_vsnprintf
-#  endif
-#  ifdef __TURBOC__
-#    define NO_vsnprintf
-#  endif
-#  ifdef WIN32
-/* In Win32, vsnprintf is available as the "non-ANSI" _vsnprintf. */
-#    if !defined(vsnprintf) && !defined(NO_vsnprintf)
-#      if !defined(_MSC_VER) || ( defined(_MSC_VER) && _MSC_VER < 1500 )
-#         define vsnprintf _vsnprintf
-#      endif
-#    endif
-#  endif
-#  ifdef __SASC
-#    define NO_vsnprintf
-#  endif
-#  ifdef VMS
-#    define NO_vsnprintf
-#  endif
-#  ifdef __OS400__
-#    define NO_vsnprintf
-#  endif
-#  ifdef __MVS__
-#    define NO_vsnprintf
-#  endif
-#endif
-
-/* unlike snprintf (which is required in C99), _snprintf does not guarantee
-   null termination of the result -- however this is only used in gzlib.c where
-   the result is assured to fit in the space provided */
-#if defined(_MSC_VER) && _MSC_VER < 1900
-#  define snprintf _snprintf
-#endif
-
-#ifndef local
-#  define local static
-#endif
-/* since "static" is used to mean two completely different things in C, we
-   define "local" for the non-static meaning of "static", for readability
-   (compile with -Dlocal if your debugger can't find static symbols) */
-
-/* gz* functions always use library allocation functions */
-#ifndef STDC
-  extern voidp  malloc OF((uInt size));
-  extern void   free   OF((voidpf ptr));
-#endif
-
-/* get errno and strerror definition */
-#if defined UNDER_CE
-#  include <windows.h>
-#  define zstrerror() gz_strwinerror((DWORD)GetLastError())
-#else
-#  ifndef NO_STRERROR
-#    include <errno.h>
-#    define zstrerror() strerror(errno)
-#  else
-#    define zstrerror() "stdio error (consult errno)"
-#  endif
-#endif
-
-/* provide prototypes for these when building zlib without LFS */
-#if !defined(_LARGEFILE64_SOURCE) || _LFS64_LARGEFILE-0 == 0
-    ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
-    ZEXTERN z_off64_t ZEXPORT gzseek64 OF((gzFile, z_off64_t, int));
-    ZEXTERN z_off64_t ZEXPORT gztell64 OF((gzFile));
-    ZEXTERN z_off64_t ZEXPORT gzoffset64 OF((gzFile));
-#endif
-
-/* default memLevel */
-#if MAX_MEM_LEVEL >= 8
-#  define DEF_MEM_LEVEL 8
-#else
-#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
-#endif
-
-/* default i/o buffer size -- double this for output when reading (this and
-   twice this must be able to fit in an unsigned type) */
-#define GZBUFSIZE 8192
-
-/* gzip modes, also provide a little integrity check on the passed structure */
-#define GZ_NONE 0
-#define GZ_READ 7247
-#define GZ_WRITE 31153
-#define GZ_APPEND 1     /* mode set to GZ_WRITE after the file is opened */
-
-/* values for gz_state how */
-#define LOOK 0      /* look for a gzip header */
-#define COPY 1      /* copy input directly */
-#define GZIP 2      /* decompress a gzip stream */
-
-/* internal gzip file state data structure */
-typedef struct {
-        /* exposed contents for gzgetc() macro */
-    struct gzFile_s x;      /* "x" for exposed */
-                            /* x.have: number of bytes available at x.next */
-                            /* x.next: next output data to deliver or write */
-                            /* x.pos: current position in uncompressed data */
-        /* used for both reading and writing */
-    int mode;               /* see gzip modes above */
-    int fd;                 /* file descriptor */
-    char *path;             /* path or fd for error messages */
-    unsigned size;          /* buffer size, zero if not allocated yet */
-    unsigned want;          /* requested buffer size, default is GZBUFSIZE */
-    unsigned char *in;      /* input buffer (double-sized when writing) */
-    unsigned char *out;     /* output buffer (double-sized when reading) */
-    int direct;             /* 0 if processing gzip, 1 if transparent */
-        /* just for reading */
-    int how;                /* 0: get header, 1: copy, 2: decompress */
-    z_off64_t start;        /* where the gzip data started, for rewinding */
-    int eof;                /* true if end of input file reached */
-    int past;               /* true if read requested past end */
-        /* just for writing */
-    int level;              /* compression level */
-    int strategy;           /* compression strategy */
-        /* seek request */
-    z_off64_t skip;         /* amount to skip (already rewound if backwards) */
-    int seek;               /* true if seek request pending */
-        /* error information */
-    int err;                /* error code */
-    char *msg;              /* error message */
-        /* zlib inflate or deflate stream */
-    z_stream strm;          /* stream structure in-place (not a pointer) */
-} gz_state;
-typedef gz_state FAR *gz_statep;
-
-/* shared functions */
-void ZLIB_INTERNAL gz_error OF((gz_statep, int, const char *));
-#if defined UNDER_CE
-char ZLIB_INTERNAL *gz_strwinerror OF((DWORD error));
-#endif
-
-/* GT_OFF(x), where x is an unsigned value, is true if x > maximum z_off64_t
-   value -- needed when comparing unsigned to z_off64_t, which is signed
-   (possible z_off64_t types off_t, off64_t, and long are all signed) */
-#ifdef INT_MAX
-#  define GT_OFF(x) (sizeof(int) == sizeof(z_off64_t) && (x) > INT_MAX)
-#else
-unsigned ZLIB_INTERNAL gz_intmax OF((void));
-#  define GT_OFF(x) (sizeof(int) == sizeof(z_off64_t) && (x) > gz_intmax())
-#endif
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/zlib/inffast.h
+++ /dev/null
@@ -1,11 +0,0 @@
-/* inffast.h -- header to use inffast.c
- * Copyright (C) 1995-2003, 2010 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-void ZLIB_INTERNAL inflate_fast OF((z_streamp strm, unsigned start));
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/zlib/inffixed.h
+++ /dev/null
@@ -1,94 +0,0 @@
-    /* inffixed.h -- table for decoding fixed codes
-     * Generated automatically by makefixed().
-     */
-
-    /* WARNING: this file should *not* be used by applications.
-       It is part of the implementation of this library and is
-       subject to change. Applications should only use zlib.h.
-     */
-
-    static const code lenfix[512] = {
-        {96,7,0},{0,8,80},{0,8,16},{20,8,115},{18,7,31},{0,8,112},{0,8,48},
-        {0,9,192},{16,7,10},{0,8,96},{0,8,32},{0,9,160},{0,8,0},{0,8,128},
-        {0,8,64},{0,9,224},{16,7,6},{0,8,88},{0,8,24},{0,9,144},{19,7,59},
-        {0,8,120},{0,8,56},{0,9,208},{17,7,17},{0,8,104},{0,8,40},{0,9,176},
-        {0,8,8},{0,8,136},{0,8,72},{0,9,240},{16,7,4},{0,8,84},{0,8,20},
-        {21,8,227},{19,7,43},{0,8,116},{0,8,52},{0,9,200},{17,7,13},{0,8,100},
-        {0,8,36},{0,9,168},{0,8,4},{0,8,132},{0,8,68},{0,9,232},{16,7,8},
-        {0,8,92},{0,8,28},{0,9,152},{20,7,83},{0,8,124},{0,8,60},{0,9,216},
-        {18,7,23},{0,8,108},{0,8,44},{0,9,184},{0,8,12},{0,8,140},{0,8,76},
-        {0,9,248},{16,7,3},{0,8,82},{0,8,18},{21,8,163},{19,7,35},{0,8,114},
-        {0,8,50},{0,9,196},{17,7,11},{0,8,98},{0,8,34},{0,9,164},{0,8,2},
-        {0,8,130},{0,8,66},{0,9,228},{16,7,7},{0,8,90},{0,8,26},{0,9,148},
-        {20,7,67},{0,8,122},{0,8,58},{0,9,212},{18,7,19},{0,8,106},{0,8,42},
-        {0,9,180},{0,8,10},{0,8,138},{0,8,74},{0,9,244},{16,7,5},{0,8,86},
-        {0,8,22},{64,8,0},{19,7,51},{0,8,118},{0,8,54},{0,9,204},{17,7,15},
-        {0,8,102},{0,8,38},{0,9,172},{0,8,6},{0,8,134},{0,8,70},{0,9,236},
-        {16,7,9},{0,8,94},{0,8,30},{0,9,156},{20,7,99},{0,8,126},{0,8,62},
-        {0,9,220},{18,7,27},{0,8,110},{0,8,46},{0,9,188},{0,8,14},{0,8,142},
-        {0,8,78},{0,9,252},{96,7,0},{0,8,81},{0,8,17},{21,8,131},{18,7,31},
-        {0,8,113},{0,8,49},{0,9,194},{16,7,10},{0,8,97},{0,8,33},{0,9,162},
-        {0,8,1},{0,8,129},{0,8,65},{0,9,226},{16,7,6},{0,8,89},{0,8,25},
-        {0,9,146},{19,7,59},{0,8,121},{0,8,57},{0,9,210},{17,7,17},{0,8,105},
-        {0,8,41},{0,9,178},{0,8,9},{0,8,137},{0,8,73},{0,9,242},{16,7,4},
-        {0,8,85},{0,8,21},{16,8,258},{19,7,43},{0,8,117},{0,8,53},{0,9,202},
-        {17,7,13},{0,8,101},{0,8,37},{0,9,170},{0,8,5},{0,8,133},{0,8,69},
-        {0,9,234},{16,7,8},{0,8,93},{0,8,29},{0,9,154},{20,7,83},{0,8,125},
-        {0,8,61},{0,9,218},{18,7,23},{0,8,109},{0,8,45},{0,9,186},{0,8,13},
-        {0,8,141},{0,8,77},{0,9,250},{16,7,3},{0,8,83},{0,8,19},{21,8,195},
-        {19,7,35},{0,8,115},{0,8,51},{0,9,198},{17,7,11},{0,8,99},{0,8,35},
-        {0,9,166},{0,8,3},{0,8,131},{0,8,67},{0,9,230},{16,7,7},{0,8,91},
-        {0,8,27},{0,9,150},{20,7,67},{0,8,123},{0,8,59},{0,9,214},{18,7,19},
-        {0,8,107},{0,8,43},{0,9,182},{0,8,11},{0,8,139},{0,8,75},{0,9,246},
-        {16,7,5},{0,8,87},{0,8,23},{64,8,0},{19,7,51},{0,8,119},{0,8,55},
-        {0,9,206},{17,7,15},{0,8,103},{0,8,39},{0,9,174},{0,8,7},{0,8,135},
-        {0,8,71},{0,9,238},{16,7,9},{0,8,95},{0,8,31},{0,9,158},{20,7,99},
-        {0,8,127},{0,8,63},{0,9,222},{18,7,27},{0,8,111},{0,8,47},{0,9,190},
-        {0,8,15},{0,8,143},{0,8,79},{0,9,254},{96,7,0},{0,8,80},{0,8,16},
-        {20,8,115},{18,7,31},{0,8,112},{0,8,48},{0,9,193},{16,7,10},{0,8,96},
-        {0,8,32},{0,9,161},{0,8,0},{0,8,128},{0,8,64},{0,9,225},{16,7,6},
-        {0,8,88},{0,8,24},{0,9,145},{19,7,59},{0,8,120},{0,8,56},{0,9,209},
-        {17,7,17},{0,8,104},{0,8,40},{0,9,177},{0,8,8},{0,8,136},{0,8,72},
-        {0,9,241},{16,7,4},{0,8,84},{0,8,20},{21,8,227},{19,7,43},{0,8,116},
-        {0,8,52},{0,9,201},{17,7,13},{0,8,100},{0,8,36},{0,9,169},{0,8,4},
-        {0,8,132},{0,8,68},{0,9,233},{16,7,8},{0,8,92},{0,8,28},{0,9,153},
-        {20,7,83},{0,8,124},{0,8,60},{0,9,217},{18,7,23},{0,8,108},{0,8,44},
-        {0,9,185},{0,8,12},{0,8,140},{0,8,76},{0,9,249},{16,7,3},{0,8,82},
-        {0,8,18},{21,8,163},{19,7,35},{0,8,114},{0,8,50},{0,9,197},{17,7,11},
-        {0,8,98},{0,8,34},{0,9,165},{0,8,2},{0,8,130},{0,8,66},{0,9,229},
-        {16,7,7},{0,8,90},{0,8,26},{0,9,149},{20,7,67},{0,8,122},{0,8,58},
-        {0,9,213},{18,7,19},{0,8,106},{0,8,42},{0,9,181},{0,8,10},{0,8,138},
-        {0,8,74},{0,9,245},{16,7,5},{0,8,86},{0,8,22},{64,8,0},{19,7,51},
-        {0,8,118},{0,8,54},{0,9,205},{17,7,15},{0,8,102},{0,8,38},{0,9,173},
-        {0,8,6},{0,8,134},{0,8,70},{0,9,237},{16,7,9},{0,8,94},{0,8,30},
-        {0,9,157},{20,7,99},{0,8,126},{0,8,62},{0,9,221},{18,7,27},{0,8,110},
-        {0,8,46},{0,9,189},{0,8,14},{0,8,142},{0,8,78},{0,9,253},{96,7,0},
-        {0,8,81},{0,8,17},{21,8,131},{18,7,31},{0,8,113},{0,8,49},{0,9,195},
-        {16,7,10},{0,8,97},{0,8,33},{0,9,163},{0,8,1},{0,8,129},{0,8,65},
-        {0,9,227},{16,7,6},{0,8,89},{0,8,25},{0,9,147},{19,7,59},{0,8,121},
-        {0,8,57},{0,9,211},{17,7,17},{0,8,105},{0,8,41},{0,9,179},{0,8,9},
-        {0,8,137},{0,8,73},{0,9,243},{16,7,4},{0,8,85},{0,8,21},{16,8,258},
-        {19,7,43},{0,8,117},{0,8,53},{0,9,203},{17,7,13},{0,8,101},{0,8,37},
-        {0,9,171},{0,8,5},{0,8,133},{0,8,69},{0,9,235},{16,7,8},{0,8,93},
-        {0,8,29},{0,9,155},{20,7,83},{0,8,125},{0,8,61},{0,9,219},{18,7,23},
-        {0,8,109},{0,8,45},{0,9,187},{0,8,13},{0,8,141},{0,8,77},{0,9,251},
-        {16,7,3},{0,8,83},{0,8,19},{21,8,195},{19,7,35},{0,8,115},{0,8,51},
-        {0,9,199},{17,7,11},{0,8,99},{0,8,35},{0,9,167},{0,8,3},{0,8,131},
-        {0,8,67},{0,9,231},{16,7,7},{0,8,91},{0,8,27},{0,9,151},{20,7,67},
-        {0,8,123},{0,8,59},{0,9,215},{18,7,19},{0,8,107},{0,8,43},{0,9,183},
-        {0,8,11},{0,8,139},{0,8,75},{0,9,247},{16,7,5},{0,8,87},{0,8,23},
-        {64,8,0},{19,7,51},{0,8,119},{0,8,55},{0,9,207},{17,7,15},{0,8,103},
-        {0,8,39},{0,9,175},{0,8,7},{0,8,135},{0,8,71},{0,9,239},{16,7,9},
-        {0,8,95},{0,8,31},{0,9,159},{20,7,99},{0,8,127},{0,8,63},{0,9,223},
-        {18,7,27},{0,8,111},{0,8,47},{0,9,191},{0,8,15},{0,8,143},{0,8,79},
-        {0,9,255}
-    };
-
-    static const code distfix[32] = {
-        {16,5,1},{23,5,257},{19,5,17},{27,5,4097},{17,5,5},{25,5,1025},
-        {21,5,65},{29,5,16385},{16,5,3},{24,5,513},{20,5,33},{28,5,8193},
-        {18,5,9},{26,5,2049},{22,5,129},{64,5,0},{16,5,2},{23,5,385},
-        {19,5,25},{27,5,6145},{17,5,7},{25,5,1537},{21,5,97},{29,5,24577},
-        {16,5,4},{24,5,769},{20,5,49},{28,5,12289},{18,5,13},{26,5,3073},
-        {22,5,193},{64,5,0}
-    };
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/zlib/inflate.h
+++ /dev/null
@@ -1,125 +0,0 @@
-/* inflate.h -- internal inflate state definition
- * Copyright (C) 1995-2016 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-/* define NO_GZIP when compiling if you want to disable gzip header and
-   trailer decoding by inflate().  NO_GZIP would be used to avoid linking in
-   the crc code when it is not needed.  For shared libraries, gzip decoding
-   should be left enabled. */
-#ifndef NO_GZIP
-#  define GUNZIP
-#endif
-
-/* Possible inflate modes between inflate() calls */
-typedef enum {
-    HEAD = 16180,   /* i: waiting for magic header */
-    FLAGS,      /* i: waiting for method and flags (gzip) */
-    TIME,       /* i: waiting for modification time (gzip) */
-    OS,         /* i: waiting for extra flags and operating system (gzip) */
-    EXLEN,      /* i: waiting for extra length (gzip) */
-    EXTRA,      /* i: waiting for extra bytes (gzip) */
-    NAME,       /* i: waiting for end of file name (gzip) */
-    COMMENT,    /* i: waiting for end of comment (gzip) */
-    HCRC,       /* i: waiting for header crc (gzip) */
-    DICTID,     /* i: waiting for dictionary check value */
-    DICT,       /* waiting for inflateSetDictionary() call */
-        TYPE,       /* i: waiting for type bits, including last-flag bit */
-        TYPEDO,     /* i: same, but skip check to exit inflate on new block */
-        STORED,     /* i: waiting for stored size (length and complement) */
-        COPY_,      /* i/o: same as COPY below, but only first time in */
-        COPY,       /* i/o: waiting for input or output to copy stored block */
-        TABLE,      /* i: waiting for dynamic block table lengths */
-        LENLENS,    /* i: waiting for code length code lengths */
-        CODELENS,   /* i: waiting for length/lit and distance code lengths */
-            LEN_,       /* i: same as LEN below, but only first time in */
-            LEN,        /* i: waiting for length/lit/eob code */
-            LENEXT,     /* i: waiting for length extra bits */
-            DIST,       /* i: waiting for distance code */
-            DISTEXT,    /* i: waiting for distance extra bits */
-            MATCH,      /* o: waiting for output space to copy string */
-            LIT,        /* o: waiting for output space to write literal */
-    CHECK,      /* i: waiting for 32-bit check value */
-    LENGTH,     /* i: waiting for 32-bit length (gzip) */
-    DONE,       /* finished check, done -- remain here until reset */
-    BAD,        /* got a data error -- remain here until reset */
-    MEM,        /* got an inflate() memory error -- remain here until reset */
-    SYNC        /* looking for synchronization bytes to restart inflate() */
-} inflate_mode;
-
-/*
-    State transitions between above modes -
-
-    (most modes can go to BAD or MEM on error -- not shown for clarity)
-
-    Process header:
-        HEAD -> (gzip) or (zlib) or (raw)
-        (gzip) -> FLAGS -> TIME -> OS -> EXLEN -> EXTRA -> NAME -> COMMENT ->
-                  HCRC -> TYPE
-        (zlib) -> DICTID or TYPE
-        DICTID -> DICT -> TYPE
-        (raw) -> TYPEDO
-    Read deflate blocks:
-            TYPE -> TYPEDO -> STORED or TABLE or LEN_ or CHECK
-            STORED -> COPY_ -> COPY -> TYPE
-            TABLE -> LENLENS -> CODELENS -> LEN_
-            LEN_ -> LEN
-    Read deflate codes in fixed or dynamic block:
-                LEN -> LENEXT or LIT or TYPE
-                LENEXT -> DIST -> DISTEXT -> MATCH -> LEN
-                LIT -> LEN
-    Process trailer:
-        CHECK -> LENGTH -> DONE
- */
-
-/* State maintained between inflate() calls -- approximately 7K bytes, not
-   including the allocated sliding window, which is up to 32K bytes. */
-struct inflate_state {
-    z_streamp strm;             /* pointer back to this zlib stream */
-    inflate_mode mode;          /* current inflate mode */
-    int last;                   /* true if processing last block */
-    int wrap;                   /* bit 0 true for zlib, bit 1 true for gzip,
-                                   bit 2 true to validate check value */
-    int havedict;               /* true if dictionary provided */
-    int flags;                  /* gzip header method and flags (0 if zlib) */
-    unsigned dmax;              /* zlib header max distance (INFLATE_STRICT) */
-    unsigned long check;        /* protected copy of check value */
-    unsigned long total;        /* protected copy of output count */
-    gz_headerp head;            /* where to save gzip header information */
-        /* sliding window */
-    unsigned wbits;             /* log base 2 of requested window size */
-    unsigned wsize;             /* window size or zero if not using window */
-    unsigned whave;             /* valid bytes in the window */
-    unsigned wnext;             /* window write index */
-    unsigned char FAR *window;  /* allocated sliding window, if needed */
-        /* bit accumulator */
-    unsigned long hold;         /* input bit accumulator */
-    unsigned bits;              /* number of bits in "in" */
-        /* for string and stored block copying */
-    unsigned length;            /* literal or length of data to copy */
-    unsigned offset;            /* distance back to copy string from */
-        /* for table and code decoding */
-    unsigned extra;             /* extra bits needed */
-        /* fixed and dynamic code tables */
-    code const FAR *lencode;    /* starting table for length/literal codes */
-    code const FAR *distcode;   /* starting table for distance codes */
-    unsigned lenbits;           /* index bits for lencode */
-    unsigned distbits;          /* index bits for distcode */
-        /* dynamic table building */
-    unsigned ncode;             /* number of code length code lengths */
-    unsigned nlen;              /* number of length code lengths */
-    unsigned ndist;             /* number of distance code lengths */
-    unsigned have;              /* number of code lengths in lens[] */
-    code FAR *next;             /* next available space in codes[] */
-    unsigned short lens[320];   /* temporary storage for code lengths */
-    unsigned short work[288];   /* work area for code table building */
-    code codes[ENOUGH];         /* space for code tables */
-    int sane;                   /* if false, allow invalid distance too far */
-    int back;                   /* bits back of last unprocessed length/lit */
-    unsigned was;               /* initial length of match */
-};
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/zlib/inftrees.h
+++ /dev/null
@@ -1,62 +0,0 @@
-/* inftrees.h -- header to use inftrees.c
- * Copyright (C) 1995-2005, 2010 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-/* Structure for decoding tables.  Each entry provides either the
-   information needed to do the operation requested by the code that
-   indexed that table entry, or it provides a pointer to another
-   table that indexes more bits of the code.  op indicates whether
-   the entry is a pointer to another table, a literal, a length or
-   distance, an end-of-block, or an invalid code.  For a table
-   pointer, the low four bits of op is the number of index bits of
-   that table.  For a length or distance, the low four bits of op
-   is the number of extra bits to get after the code.  bits is
-   the number of bits in this code or part of the code to drop off
-   of the bit buffer.  val is the actual byte to output in the case
-   of a literal, the base length or distance, or the offset from
-   the current table to the next table.  Each entry is four bytes. */
-typedef struct {
-    unsigned char op;           /* operation, extra bits, table bits */
-    unsigned char bits;         /* bits in this part of the code */
-    unsigned short val;         /* offset in table or code value */
-} code;
-
-/* op values as set by inflate_table():
-    00000000 - literal
-    0000tttt - table link, tttt != 0 is the number of table index bits
-    0001eeee - length or distance, eeee is the number of extra bits
-    01100000 - end of block
-    01000000 - invalid code
- */
-
-/* Maximum size of the dynamic table.  The maximum number of code structures is
-   1444, which is the sum of 852 for literal/length codes and 592 for distance
-   codes.  These values were found by exhaustive searches using the program
-   examples/enough.c found in the zlib distribtution.  The arguments to that
-   program are the number of symbols, the initial root table size, and the
-   maximum bit length of a code.  "enough 286 9 15" for literal/length codes
-   returns returns 852, and "enough 30 6 15" for distance codes returns 592.
-   The initial root table size (9 or 6) is found in the fifth argument of the
-   inflate_table() calls in inflate.c and infback.c.  If the root table size is
-   changed, then these maximum sizes would be need to be recalculated and
-   updated. */
-#define ENOUGH_LENS 852
-#define ENOUGH_DISTS 592
-#define ENOUGH (ENOUGH_LENS+ENOUGH_DISTS)
-
-/* Type of code to build for inflate_table() */
-typedef enum {
-    CODES,
-    LENS,
-    DISTS
-} codetype;
-
-int ZLIB_INTERNAL inflate_table OF((codetype type, unsigned short FAR *lens,
-                             unsigned codes, code FAR * FAR *table,
-                             unsigned FAR *bits, unsigned short FAR *work));
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/zlib/trees.h
+++ /dev/null
@@ -1,128 +0,0 @@
-/* header created automatically with -DGEN_TREES_H */
-
-local const ct_data static_ltree[L_CODES+2] = {
-{{ 12},{  8}}, {{140},{  8}}, {{ 76},{  8}}, {{204},{  8}}, {{ 44},{  8}},
-{{172},{  8}}, {{108},{  8}}, {{236},{  8}}, {{ 28},{  8}}, {{156},{  8}},
-{{ 92},{  8}}, {{220},{  8}}, {{ 60},{  8}}, {{188},{  8}}, {{124},{  8}},
-{{252},{  8}}, {{  2},{  8}}, {{130},{  8}}, {{ 66},{  8}}, {{194},{  8}},
-{{ 34},{  8}}, {{162},{  8}}, {{ 98},{  8}}, {{226},{  8}}, {{ 18},{  8}},
-{{146},{  8}}, {{ 82},{  8}}, {{210},{  8}}, {{ 50},{  8}}, {{178},{  8}},
-{{114},{  8}}, {{242},{  8}}, {{ 10},{  8}}, {{138},{  8}}, {{ 74},{  8}},
-{{202},{  8}}, {{ 42},{  8}}, {{170},{  8}}, {{106},{  8}}, {{234},{  8}},
-{{ 26},{  8}}, {{154},{  8}}, {{ 90},{  8}}, {{218},{  8}}, {{ 58},{  8}},
-{{186},{  8}}, {{122},{  8}}, {{250},{  8}}, {{  6},{  8}}, {{134},{  8}},
-{{ 70},{  8}}, {{198},{  8}}, {{ 38},{  8}}, {{166},{  8}}, {{102},{  8}},
-{{230},{  8}}, {{ 22},{  8}}, {{150},{  8}}, {{ 86},{  8}}, {{214},{  8}},
-{{ 54},{  8}}, {{182},{  8}}, {{118},{  8}}, {{246},{  8}}, {{ 14},{  8}},
-{{142},{  8}}, {{ 78},{  8}}, {{206},{  8}}, {{ 46},{  8}}, {{174},{  8}},
-{{110},{  8}}, {{238},{  8}}, {{ 30},{  8}}, {{158},{  8}}, {{ 94},{  8}},
-{{222},{  8}}, {{ 62},{  8}}, {{190},{  8}}, {{126},{  8}}, {{254},{  8}},
-{{  1},{  8}}, {{129},{  8}}, {{ 65},{  8}}, {{193},{  8}}, {{ 33},{  8}},
-{{161},{  8}}, {{ 97},{  8}}, {{225},{  8}}, {{ 17},{  8}}, {{145},{  8}},
-{{ 81},{  8}}, {{209},{  8}}, {{ 49},{  8}}, {{177},{  8}}, {{113},{  8}},
-{{241},{  8}}, {{  9},{  8}}, {{137},{  8}}, {{ 73},{  8}}, {{201},{  8}},
-{{ 41},{  8}}, {{169},{  8}}, {{105},{  8}}, {{233},{  8}}, {{ 25},{  8}},
-{{153},{  8}}, {{ 89},{  8}}, {{217},{  8}}, {{ 57},{  8}}, {{185},{  8}},
-{{121},{  8}}, {{249},{  8}}, {{  5},{  8}}, {{133},{  8}}, {{ 69},{  8}},
-{{197},{  8}}, {{ 37},{  8}}, {{165},{  8}}, {{101},{  8}}, {{229},{  8}},
-{{ 21},{  8}}, {{149},{  8}}, {{ 85},{  8}}, {{213},{  8}}, {{ 53},{  8}},
-{{181},{  8}}, {{117},{  8}}, {{245},{  8}}, {{ 13},{  8}}, {{141},{  8}},
-{{ 77},{  8}}, {{205},{  8}}, {{ 45},{  8}}, {{173},{  8}}, {{109},{  8}},
-{{237},{  8}}, {{ 29},{  8}}, {{157},{  8}}, {{ 93},{  8}}, {{221},{  8}},
-{{ 61},{  8}}, {{189},{  8}}, {{125},{  8}}, {{253},{  8}}, {{ 19},{  9}},
-{{275},{  9}}, {{147},{  9}}, {{403},{  9}}, {{ 83},{  9}}, {{339},{  9}},
-{{211},{  9}}, {{467},{  9}}, {{ 51},{  9}}, {{307},{  9}}, {{179},{  9}},
-{{435},{  9}}, {{115},{  9}}, {{371},{  9}}, {{243},{  9}}, {{499},{  9}},
-{{ 11},{  9}}, {{267},{  9}}, {{139},{  9}}, {{395},{  9}}, {{ 75},{  9}},
-{{331},{  9}}, {{203},{  9}}, {{459},{  9}}, {{ 43},{  9}}, {{299},{  9}},
-{{171},{  9}}, {{427},{  9}}, {{107},{  9}}, {{363},{  9}}, {{235},{  9}},
-{{491},{  9}}, {{ 27},{  9}}, {{283},{  9}}, {{155},{  9}}, {{411},{  9}},
-{{ 91},{  9}}, {{347},{  9}}, {{219},{  9}}, {{475},{  9}}, {{ 59},{  9}},
-{{315},{  9}}, {{187},{  9}}, {{443},{  9}}, {{123},{  9}}, {{379},{  9}},
-{{251},{  9}}, {{507},{  9}}, {{  7},{  9}}, {{263},{  9}}, {{135},{  9}},
-{{391},{  9}}, {{ 71},{  9}}, {{327},{  9}}, {{199},{  9}}, {{455},{  9}},
-{{ 39},{  9}}, {{295},{  9}}, {{167},{  9}}, {{423},{  9}}, {{103},{  9}},
-{{359},{  9}}, {{231},{  9}}, {{487},{  9}}, {{ 23},{  9}}, {{279},{  9}},
-{{151},{  9}}, {{407},{  9}}, {{ 87},{  9}}, {{343},{  9}}, {{215},{  9}},
-{{471},{  9}}, {{ 55},{  9}}, {{311},{  9}}, {{183},{  9}}, {{439},{  9}},
-{{119},{  9}}, {{375},{  9}}, {{247},{  9}}, {{503},{  9}}, {{ 15},{  9}},
-{{271},{  9}}, {{143},{  9}}, {{399},{  9}}, {{ 79},{  9}}, {{335},{  9}},
-{{207},{  9}}, {{463},{  9}}, {{ 47},{  9}}, {{303},{  9}}, {{175},{  9}},
-{{431},{  9}}, {{111},{  9}}, {{367},{  9}}, {{239},{  9}}, {{495},{  9}},
-{{ 31},{  9}}, {{287},{  9}}, {{159},{  9}}, {{415},{  9}}, {{ 95},{  9}},
-{{351},{  9}}, {{223},{  9}}, {{479},{  9}}, {{ 63},{  9}}, {{319},{  9}},
-{{191},{  9}}, {{447},{  9}}, {{127},{  9}}, {{383},{  9}}, {{255},{  9}},
-{{511},{  9}}, {{  0},{  7}}, {{ 64},{  7}}, {{ 32},{  7}}, {{ 96},{  7}},
-{{ 16},{  7}}, {{ 80},{  7}}, {{ 48},{  7}}, {{112},{  7}}, {{  8},{  7}},
-{{ 72},{  7}}, {{ 40},{  7}}, {{104},{  7}}, {{ 24},{  7}}, {{ 88},{  7}},
-{{ 56},{  7}}, {{120},{  7}}, {{  4},{  7}}, {{ 68},{  7}}, {{ 36},{  7}},
-{{100},{  7}}, {{ 20},{  7}}, {{ 84},{  7}}, {{ 52},{  7}}, {{116},{  7}},
-{{  3},{  8}}, {{131},{  8}}, {{ 67},{  8}}, {{195},{  8}}, {{ 35},{  8}},
-{{163},{  8}}, {{ 99},{  8}}, {{227},{  8}}
-};
-
-local const ct_data static_dtree[D_CODES] = {
-{{ 0},{ 5}}, {{16},{ 5}}, {{ 8},{ 5}}, {{24},{ 5}}, {{ 4},{ 5}},
-{{20},{ 5}}, {{12},{ 5}}, {{28},{ 5}}, {{ 2},{ 5}}, {{18},{ 5}},
-{{10},{ 5}}, {{26},{ 5}}, {{ 6},{ 5}}, {{22},{ 5}}, {{14},{ 5}},
-{{30},{ 5}}, {{ 1},{ 5}}, {{17},{ 5}}, {{ 9},{ 5}}, {{25},{ 5}},
-{{ 5},{ 5}}, {{21},{ 5}}, {{13},{ 5}}, {{29},{ 5}}, {{ 3},{ 5}},
-{{19},{ 5}}, {{11},{ 5}}, {{27},{ 5}}, {{ 7},{ 5}}, {{23},{ 5}}
-};
-
-const uch ZLIB_INTERNAL _dist_code[DIST_CODE_LEN] = {
- 0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,
- 8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10,
-10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
-11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
-12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13,
-13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
-13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
-14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
-14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
-14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15,
-15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
-15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
-15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,  0,  0, 16, 17,
-18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22,
-23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
-24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
-26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
-26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27,
-27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
-27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
-28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
-28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
-28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
-29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
-29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
-29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29
-};
-
-const uch ZLIB_INTERNAL _length_code[MAX_MATCH-MIN_MATCH+1]= {
- 0,  1,  2,  3,  4,  5,  6,  7,  8,  8,  9,  9, 10, 10, 11, 11, 12, 12, 12, 12,
-13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
-17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19,
-19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
-21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22,
-22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23,
-23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
-24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
-25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
-25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26,
-26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
-26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
-27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28
-};
-
-local const int base_length[LENGTH_CODES] = {
-0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56,
-64, 80, 96, 112, 128, 160, 192, 224, 0
-};
-
-local const int base_dist[D_CODES] = {
-    0,     1,     2,     3,     4,     6,     8,    12,    16,    24,
-   32,    48,    64,    96,   128,   192,   256,   384,   512,   768,
- 1024,  1536,  2048,  3072,  4096,  6144,  8192, 12288, 16384, 24576
-};
-
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/zlib/zconf.h
+++ /dev/null
@@ -1,534 +0,0 @@
-/* zconf.h -- configuration of the zlib compression library
- * Copyright (C) 1995-2016 Jean-loup Gailly, Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* @(#) $Id$ */
-
-#ifndef ZCONF_H
-#define ZCONF_H
-
-/*
- * If you *really* need a unique prefix for all types and library functions,
- * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
- * Even better than compiling with -DZ_PREFIX would be to use configure to set
- * this permanently in zconf.h using "./configure --zprefix".
- */
-#ifdef Z_PREFIX     /* may be set to #if 1 by ./configure */
-#  define Z_PREFIX_SET
-
-/* all linked symbols and init macros */
-#  define _dist_code            z__dist_code
-#  define _length_code          z__length_code
-#  define _tr_align             z__tr_align
-#  define _tr_flush_bits        z__tr_flush_bits
-#  define _tr_flush_block       z__tr_flush_block
-#  define _tr_init              z__tr_init
-#  define _tr_stored_block      z__tr_stored_block
-#  define _tr_tally             z__tr_tally
-#  define adler32               z_adler32
-#  define adler32_combine       z_adler32_combine
-#  define adler32_combine64     z_adler32_combine64
-#  define adler32_z             z_adler32_z
-#  ifndef Z_SOLO
-#    define compress              z_compress
-#    define compress2             z_compress2
-#    define compressBound         z_compressBound
-#  endif
-#  define crc32                 z_crc32
-#  define crc32_combine         z_crc32_combine
-#  define crc32_combine64       z_crc32_combine64
-#  define crc32_z               z_crc32_z
-#  define deflate               z_deflate
-#  define deflateBound          z_deflateBound
-#  define deflateCopy           z_deflateCopy
-#  define deflateEnd            z_deflateEnd
-#  define deflateGetDictionary  z_deflateGetDictionary
-#  define deflateInit           z_deflateInit
-#  define deflateInit2          z_deflateInit2
-#  define deflateInit2_         z_deflateInit2_
-#  define deflateInit_          z_deflateInit_
-#  define deflateParams         z_deflateParams
-#  define deflatePending        z_deflatePending
-#  define deflatePrime          z_deflatePrime
-#  define deflateReset          z_deflateReset
-#  define deflateResetKeep      z_deflateResetKeep
-#  define deflateSetDictionary  z_deflateSetDictionary
-#  define deflateSetHeader      z_deflateSetHeader
-#  define deflateTune           z_deflateTune
-#  define deflate_copyright     z_deflate_copyright
-#  define get_crc_table         z_get_crc_table
-#  ifndef Z_SOLO
-#    define gz_error              z_gz_error
-#    define gz_intmax             z_gz_intmax
-#    define gz_strwinerror        z_gz_strwinerror
-#    define gzbuffer              z_gzbuffer
-#    define gzclearerr            z_gzclearerr
-#    define gzclose               z_gzclose
-#    define gzclose_r             z_gzclose_r
-#    define gzclose_w             z_gzclose_w
-#    define gzdirect              z_gzdirect
-#    define gzdopen               z_gzdopen
-#    define gzeof                 z_gzeof
-#    define gzerror               z_gzerror
-#    define gzflush               z_gzflush
-#    define gzfread               z_gzfread
-#    define gzfwrite              z_gzfwrite
-#    define gzgetc                z_gzgetc
-#    define gzgetc_               z_gzgetc_
-#    define gzgets                z_gzgets
-#    define gzoffset              z_gzoffset
-#    define gzoffset64            z_gzoffset64
-#    define gzopen                z_gzopen
-#    define gzopen64              z_gzopen64
-#    ifdef _WIN32
-#      define gzopen_w              z_gzopen_w
-#    endif
-#    define gzprintf              z_gzprintf
-#    define gzputc                z_gzputc
-#    define gzputs                z_gzputs
-#    define gzread                z_gzread
-#    define gzrewind              z_gzrewind
-#    define gzseek                z_gzseek
-#    define gzseek64              z_gzseek64
-#    define gzsetparams           z_gzsetparams
-#    define gztell                z_gztell
-#    define gztell64              z_gztell64
-#    define gzungetc              z_gzungetc
-#    define gzvprintf             z_gzvprintf
-#    define gzwrite               z_gzwrite
-#  endif
-#  define inflate               z_inflate
-#  define inflateBack           z_inflateBack
-#  define inflateBackEnd        z_inflateBackEnd
-#  define inflateBackInit       z_inflateBackInit
-#  define inflateBackInit_      z_inflateBackInit_
-#  define inflateCodesUsed      z_inflateCodesUsed
-#  define inflateCopy           z_inflateCopy
-#  define inflateEnd            z_inflateEnd
-#  define inflateGetDictionary  z_inflateGetDictionary
-#  define inflateGetHeader      z_inflateGetHeader
-#  define inflateInit           z_inflateInit
-#  define inflateInit2          z_inflateInit2
-#  define inflateInit2_         z_inflateInit2_
-#  define inflateInit_          z_inflateInit_
-#  define inflateMark           z_inflateMark
-#  define inflatePrime          z_inflatePrime
-#  define inflateReset          z_inflateReset
-#  define inflateReset2         z_inflateReset2
-#  define inflateResetKeep      z_inflateResetKeep
-#  define inflateSetDictionary  z_inflateSetDictionary
-#  define inflateSync           z_inflateSync
-#  define inflateSyncPoint      z_inflateSyncPoint
-#  define inflateUndermine      z_inflateUndermine
-#  define inflateValidate       z_inflateValidate
-#  define inflate_copyright     z_inflate_copyright
-#  define inflate_fast          z_inflate_fast
-#  define inflate_table         z_inflate_table
-#  ifndef Z_SOLO
-#    define uncompress            z_uncompress
-#    define uncompress2           z_uncompress2
-#  endif
-#  define zError                z_zError
-#  ifndef Z_SOLO
-#    define zcalloc               z_zcalloc
-#    define zcfree                z_zcfree
-#  endif
-#  define zlibCompileFlags      z_zlibCompileFlags
-#  define zlibVersion           z_zlibVersion
-
-/* all zlib typedefs in zlib.h and zconf.h */
-#  define Byte                  z_Byte
-#  define Bytef                 z_Bytef
-#  define alloc_func            z_alloc_func
-#  define charf                 z_charf
-#  define free_func             z_free_func
-#  ifndef Z_SOLO
-#    define gzFile                z_gzFile
-#  endif
-#  define gz_header             z_gz_header
-#  define gz_headerp            z_gz_headerp
-#  define in_func               z_in_func
-#  define intf                  z_intf
-#  define out_func              z_out_func
-#  define uInt                  z_uInt
-#  define uIntf                 z_uIntf
-#  define uLong                 z_uLong
-#  define uLongf                z_uLongf
-#  define voidp                 z_voidp
-#  define voidpc                z_voidpc
-#  define voidpf                z_voidpf
-
-/* all zlib structs in zlib.h and zconf.h */
-#  define gz_header_s           z_gz_header_s
-#  define internal_state        z_internal_state
-
-#endif
-
-#if defined(__MSDOS__) && !defined(MSDOS)
-#  define MSDOS
-#endif
-#if (defined(OS_2) || defined(__OS2__)) && !defined(OS2)
-#  define OS2
-#endif
-#if defined(_WINDOWS) && !defined(WINDOWS)
-#  define WINDOWS
-#endif
-#if defined(_WIN32) || defined(_WIN32_WCE) || defined(__WIN32__)
-#  ifndef WIN32
-#    define WIN32
-#  endif
-#endif
-#if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)
-#  if !defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)
-#    ifndef SYS16BIT
-#      define SYS16BIT
-#    endif
-#  endif
-#endif
-
-/*
- * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
- * than 64k bytes at a time (needed on systems with 16-bit int).
- */
-#ifdef SYS16BIT
-#  define MAXSEG_64K
-#endif
-#ifdef MSDOS
-#  define UNALIGNED_OK
-#endif
-
-#ifdef __STDC_VERSION__
-#  ifndef STDC
-#    define STDC
-#  endif
-#  if __STDC_VERSION__ >= 199901L
-#    ifndef STDC99
-#      define STDC99
-#    endif
-#  endif
-#endif
-#if !defined(STDC) && (defined(__STDC__) || defined(__cplusplus))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(__GNUC__) || defined(__BORLANDC__))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(OS2) || defined(__HOS_AIX__))
-#  define STDC
-#endif
-
-#if defined(__OS400__) && !defined(STDC)    /* iSeries (formerly AS/400). */
-#  define STDC
-#endif
-
-#ifndef STDC
-#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
-#    define const       /* note: need a more gentle solution here */
-#  endif
-#endif
-
-#if defined(ZLIB_CONST) && !defined(z_const)
-#  define z_const const
-#else
-#  define z_const
-#endif
-
-#ifdef Z_SOLO
-   typedef unsigned long z_size_t;
-#else
-#  define z_longlong long long
-#  if defined(NO_SIZE_T)
-     typedef unsigned NO_SIZE_T z_size_t;
-#  elif defined(STDC)
-#    include <stddef.h>
-     typedef size_t z_size_t;
-#  else
-     typedef unsigned long z_size_t;
-#  endif
-#  undef z_longlong
-#endif
-
-/* Maximum value for memLevel in deflateInit2 */
-#ifndef MAX_MEM_LEVEL
-#  ifdef MAXSEG_64K
-#    define MAX_MEM_LEVEL 8
-#  else
-#    define MAX_MEM_LEVEL 9
-#  endif
-#endif
-
-/* Maximum value for windowBits in deflateInit2 and inflateInit2.
- * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
- * created by gzip. (Files created by minigzip can still be extracted by
- * gzip.)
- */
-#ifndef MAX_WBITS
-#  define MAX_WBITS   15 /* 32K LZ77 window */
-#endif
-
-/* The memory requirements for deflate are (in bytes):
-            (1 << (windowBits+2)) +  (1 << (memLevel+9))
- that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
- plus a few kilobytes for small objects. For example, if you want to reduce
- the default memory requirements from 256K to 128K, compile with
-     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
- Of course this will generally degrade compression (there's no free lunch).
-
-   The memory requirements for inflate are (in bytes) 1 << windowBits
- that is, 32K for windowBits=15 (default value) plus about 7 kilobytes
- for small objects.
-*/
-
-                        /* Type declarations */
-
-#ifndef OF /* function prototypes */
-#  ifdef STDC
-#    define OF(args)  args
-#  else
-#    define OF(args)  ()
-#  endif
-#endif
-
-#ifndef Z_ARG /* function prototypes for stdarg */
-#  if defined(STDC) || defined(Z_HAVE_STDARG_H)
-#    define Z_ARG(args)  args
-#  else
-#    define Z_ARG(args)  ()
-#  endif
-#endif
-
-/* The following definitions for FAR are needed only for MSDOS mixed
- * model programming (small or medium model with some far allocations).
- * This was tested only with MSC; for other MSDOS compilers you may have
- * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
- * just define FAR to be empty.
- */
-#ifdef SYS16BIT
-#  if defined(M_I86SM) || defined(M_I86MM)
-     /* MSC small or medium model */
-#    define SMALL_MEDIUM
-#    ifdef _MSC_VER
-#      define FAR _far
-#    else
-#      define FAR far
-#    endif
-#  endif
-#  if (defined(__SMALL__) || defined(__MEDIUM__))
-     /* Turbo C small or medium model */
-#    define SMALL_MEDIUM
-#    ifdef __BORLANDC__
-#      define FAR _far
-#    else
-#      define FAR far
-#    endif
-#  endif
-#endif
-
-#if defined(WINDOWS) || defined(WIN32)
-   /* If building or using zlib as a DLL, define ZLIB_DLL.
-    * This is not mandatory, but it offers a little performance increase.
-    */
-#  ifdef ZLIB_DLL
-#    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))
-#      ifdef ZLIB_INTERNAL
-#        define ZEXTERN extern __declspec(dllexport)
-#      else
-#        define ZEXTERN extern __declspec(dllimport)
-#      endif
-#    endif
-#  endif  /* ZLIB_DLL */
-   /* If building or using zlib with the WINAPI/WINAPIV calling convention,
-    * define ZLIB_WINAPI.
-    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
-    */
-#  ifdef ZLIB_WINAPI
-#    ifdef FAR
-#      undef FAR
-#    endif
-#    include <windows.h>
-     /* No need for _export, use ZLIB.DEF instead. */
-     /* For complete Windows compatibility, use WINAPI, not __stdcall. */
-#    define ZEXPORT WINAPI
-#    ifdef WIN32
-#      define ZEXPORTVA WINAPIV
-#    else
-#      define ZEXPORTVA FAR CDECL
-#    endif
-#  endif
-#endif
-
-#if defined (__BEOS__)
-#  ifdef ZLIB_DLL
-#    ifdef ZLIB_INTERNAL
-#      define ZEXPORT   __declspec(dllexport)
-#      define ZEXPORTVA __declspec(dllexport)
-#    else
-#      define ZEXPORT   __declspec(dllimport)
-#      define ZEXPORTVA __declspec(dllimport)
-#    endif
-#  endif
-#endif
-
-#ifndef ZEXTERN
-#  define ZEXTERN extern
-#endif
-#ifndef ZEXPORT
-#  define ZEXPORT
-#endif
-#ifndef ZEXPORTVA
-#  define ZEXPORTVA
-#endif
-
-#ifndef FAR
-#  define FAR
-#endif
-
-#if !defined(__MACTYPES__)
-typedef unsigned char  Byte;  /* 8 bits */
-#endif
-typedef unsigned int   uInt;  /* 16 bits or more */
-typedef unsigned long  uLong; /* 32 bits or more */
-
-#ifdef SMALL_MEDIUM
-   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
-#  define Bytef Byte FAR
-#else
-   typedef Byte  FAR Bytef;
-#endif
-typedef char  FAR charf;
-typedef int   FAR intf;
-typedef uInt  FAR uIntf;
-typedef uLong FAR uLongf;
-
-#ifdef STDC
-   typedef void const *voidpc;
-   typedef void FAR   *voidpf;
-   typedef void       *voidp;
-#else
-   typedef Byte const *voidpc;
-   typedef Byte FAR   *voidpf;
-   typedef Byte       *voidp;
-#endif
-
-#if !defined(Z_U4) && !defined(Z_SOLO) && defined(STDC)
-#  include <limits.h>
-#  if (UINT_MAX == 0xffffffffUL)
-#    define Z_U4 unsigned
-#  elif (ULONG_MAX == 0xffffffffUL)
-#    define Z_U4 unsigned long
-#  elif (USHRT_MAX == 0xffffffffUL)
-#    define Z_U4 unsigned short
-#  endif
-#endif
-
-#ifdef Z_U4
-   typedef Z_U4 z_crc_t;
-#else
-   typedef unsigned long z_crc_t;
-#endif
-
-#ifdef HAVE_UNISTD_H    /* may be set to #if 1 by ./configure */
-#  define Z_HAVE_UNISTD_H
-#endif
-
-#ifdef HAVE_STDARG_H    /* may be set to #if 1 by ./configure */
-#  define Z_HAVE_STDARG_H
-#endif
-
-#ifdef STDC
-#  ifndef Z_SOLO
-#    include <sys/types.h>      /* for off_t */
-#  endif
-#endif
-
-#if defined(STDC) || defined(Z_HAVE_STDARG_H)
-#  ifndef Z_SOLO
-#    include <stdarg.h>         /* for va_list */
-#  endif
-#endif
-
-#ifdef _WIN32
-#  ifndef Z_SOLO
-#    include <stddef.h>         /* for wchar_t */
-#  endif
-#endif
-
-/* a little trick to accommodate both "#define _LARGEFILE64_SOURCE" and
- * "#define _LARGEFILE64_SOURCE 1" as requesting 64-bit operations, (even
- * though the former does not conform to the LFS document), but considering
- * both "#undef _LARGEFILE64_SOURCE" and "#define _LARGEFILE64_SOURCE 0" as
- * equivalently requesting no 64-bit operations
- */
-#if defined(_LARGEFILE64_SOURCE) && -_LARGEFILE64_SOURCE - -1 == 1
-#  undef _LARGEFILE64_SOURCE
-#endif
-
-#if defined(__WATCOMC__) && !defined(Z_HAVE_UNISTD_H)
-#  define Z_HAVE_UNISTD_H
-#endif
-#ifndef Z_SOLO
-#  if defined(Z_HAVE_UNISTD_H) || defined(_LARGEFILE64_SOURCE)
-#    include <unistd.h>         /* for SEEK_*, off_t, and _LFS64_LARGEFILE */
-#    ifdef VMS
-#      include <unixio.h>       /* for off_t */
-#    endif
-#    ifndef z_off_t
-#      define z_off_t off_t
-#    endif
-#  endif
-#endif
-
-#if defined(_LFS64_LARGEFILE) && _LFS64_LARGEFILE-0
-#  define Z_LFS64
-#endif
-
-#if defined(_LARGEFILE64_SOURCE) && defined(Z_LFS64)
-#  define Z_LARGE64
-#endif
-
-#if defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS-0 == 64 && defined(Z_LFS64)
-#  define Z_WANT64
-#endif
-
-#if !defined(SEEK_SET) && !defined(Z_SOLO)
-#  define SEEK_SET        0       /* Seek from beginning of file.  */
-#  define SEEK_CUR        1       /* Seek from current position.  */
-#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
-#endif
-
-#ifndef z_off_t
-#  define z_off_t long
-#endif
-
-#if !defined(_WIN32) && defined(Z_LARGE64)
-#  define z_off64_t off64_t
-#else
-#  if defined(_WIN32) && !defined(__GNUC__) && !defined(Z_SOLO)
-#    define z_off64_t __int64
-#  else
-#    define z_off64_t z_off_t
-#  endif
-#endif
-
-/* MVS linker does not support external names larger than 8 bytes */
-#if defined(__MVS__)
-  #pragma map(deflateInit_,"DEIN")
-  #pragma map(deflateInit2_,"DEIN2")
-  #pragma map(deflateEnd,"DEEND")
-  #pragma map(deflateBound,"DEBND")
-  #pragma map(inflateInit_,"ININ")
-  #pragma map(inflateInit2_,"ININ2")
-  #pragma map(inflateEnd,"INEND")
-  #pragma map(inflateSync,"INSY")
-  #pragma map(inflateSetDictionary,"INSEDI")
-  #pragma map(compressBound,"CMBND")
-  #pragma map(inflate_table,"INTABL")
-  #pragma map(inflate_fast,"INFA")
-  #pragma map(inflate_copyright,"INCOPY")
-#endif
-
-#endif /* ZCONF_H */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/zlib/zlib.h
+++ /dev/null
@@ -1,1912 +0,0 @@
-/* zlib.h -- interface of the 'zlib' general purpose compression library
-  version 1.2.11, January 15th, 2017
-
-  Copyright (C) 1995-2017 Jean-loup Gailly and Mark Adler
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  Jean-loup Gailly        Mark Adler
-  jloup@gzip.org          madler@alumni.caltech.edu
-
-
-  The data format used by the zlib library is described by RFCs (Request for
-  Comments) 1950 to 1952 in the files http://tools.ietf.org/html/rfc1950
-  (zlib format), rfc1951 (deflate format) and rfc1952 (gzip format).
-*/
-
-#ifndef ZLIB_H
-#define ZLIB_H
-
-#include "zconf.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define ZLIB_VERSION "1.2.11"
-#define ZLIB_VERNUM 0x12b0
-#define ZLIB_VER_MAJOR 1
-#define ZLIB_VER_MINOR 2
-#define ZLIB_VER_REVISION 11
-#define ZLIB_VER_SUBREVISION 0
-
-/*
-    The 'zlib' compression library provides in-memory compression and
-  decompression functions, including integrity checks of the uncompressed data.
-  This version of the library supports only one compression method (deflation)
-  but other algorithms will be added later and will have the same stream
-  interface.
-
-    Compression can be done in a single step if the buffers are large enough,
-  or can be done by repeated calls of the compression function.  In the latter
-  case, the application must provide more input and/or consume the output
-  (providing more output space) before each call.
-
-    The compressed data format used by default by the in-memory functions is
-  the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped
-  around a deflate stream, which is itself documented in RFC 1951.
-
-    The library also supports reading and writing files in gzip (.gz) format
-  with an interface similar to that of stdio using the functions that start
-  with "gz".  The gzip format is different from the zlib format.  gzip is a
-  gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.
-
-    This library can optionally read and write gzip and raw deflate streams in
-  memory as well.
-
-    The zlib format was designed to be compact and fast for use in memory
-  and on communications channels.  The gzip format was designed for single-
-  file compression on file systems, has a larger header than zlib to maintain
-  directory information, and uses a different, slower check method than zlib.
-
-    The library does not install any signal handler.  The decoder checks
-  the consistency of the compressed data, so the library should never crash
-  even in the case of corrupted input.
-*/
-
-typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
-typedef void   (*free_func)  OF((voidpf opaque, voidpf address));
-
-struct internal_state;
-
-typedef struct z_stream_s {
-    z_const Bytef *next_in;     /* next input byte */
-    uInt     avail_in;  /* number of bytes available at next_in */
-    uLong    total_in;  /* total number of input bytes read so far */
-
-    Bytef    *next_out; /* next output byte will go here */
-    uInt     avail_out; /* remaining free space at next_out */
-    uLong    total_out; /* total number of bytes output so far */
-
-    z_const char *msg;  /* last error message, NULL if no error */
-    struct internal_state FAR *state; /* not visible by applications */
-
-    alloc_func zalloc;  /* used to allocate the internal state */
-    free_func  zfree;   /* used to free the internal state */
-    voidpf     opaque;  /* private data object passed to zalloc and zfree */
-
-    int     data_type;  /* best guess about the data type: binary or text
-                           for deflate, or the decoding state for inflate */
-    uLong   adler;      /* Adler-32 or CRC-32 value of the uncompressed data */
-    uLong   reserved;   /* reserved for future use */
-} z_stream;
-
-typedef z_stream FAR *z_streamp;
-
-/*
-     gzip header information passed to and from zlib routines.  See RFC 1952
-  for more details on the meanings of these fields.
-*/
-typedef struct gz_header_s {
-    int     text;       /* true if compressed data believed to be text */
-    uLong   time;       /* modification time */
-    int     xflags;     /* extra flags (not used when writing a gzip file) */
-    int     os;         /* operating system */
-    Bytef   *extra;     /* pointer to extra field or Z_NULL if none */
-    uInt    extra_len;  /* extra field length (valid if extra != Z_NULL) */
-    uInt    extra_max;  /* space at extra (only when reading header) */
-    Bytef   *name;      /* pointer to zero-terminated file name or Z_NULL */
-    uInt    name_max;   /* space at name (only when reading header) */
-    Bytef   *comment;   /* pointer to zero-terminated comment or Z_NULL */
-    uInt    comm_max;   /* space at comment (only when reading header) */
-    int     hcrc;       /* true if there was or will be a header crc */
-    int     done;       /* true when done reading gzip header (not used
-                           when writing a gzip file) */
-} gz_header;
-
-typedef gz_header FAR *gz_headerp;
-
-/*
-     The application must update next_in and avail_in when avail_in has dropped
-   to zero.  It must update next_out and avail_out when avail_out has dropped
-   to zero.  The application must initialize zalloc, zfree and opaque before
-   calling the init function.  All other fields are set by the compression
-   library and must not be updated by the application.
-
-     The opaque value provided by the application will be passed as the first
-   parameter for calls of zalloc and zfree.  This can be useful for custom
-   memory management.  The compression library attaches no meaning to the
-   opaque value.
-
-     zalloc must return Z_NULL if there is not enough memory for the object.
-   If zlib is used in a multi-threaded application, zalloc and zfree must be
-   thread safe.  In that case, zlib is thread-safe.  When zalloc and zfree are
-   Z_NULL on entry to the initialization function, they are set to internal
-   routines that use the standard library functions malloc() and free().
-
-     On 16-bit systems, the functions zalloc and zfree must be able to allocate
-   exactly 65536 bytes, but will not be required to allocate more than this if
-   the symbol MAXSEG_64K is defined (see zconf.h).  WARNING: On MSDOS, pointers
-   returned by zalloc for objects of exactly 65536 bytes *must* have their
-   offset normalized to zero.  The default allocation function provided by this
-   library ensures this (see zutil.c).  To reduce memory requirements and avoid
-   any allocation of 64K objects, at the expense of compression ratio, compile
-   the library with -DMAX_WBITS=14 (see zconf.h).
-
-     The fields total_in and total_out can be used for statistics or progress
-   reports.  After compression, total_in holds the total size of the
-   uncompressed data and may be saved for use by the decompressor (particularly
-   if the decompressor wants to decompress everything in a single step).
-*/
-
-                        /* constants */
-
-#define Z_NO_FLUSH      0
-#define Z_PARTIAL_FLUSH 1
-#define Z_SYNC_FLUSH    2
-#define Z_FULL_FLUSH    3
-#define Z_FINISH        4
-#define Z_BLOCK         5
-#define Z_TREES         6
-/* Allowed flush values; see deflate() and inflate() below for details */
-
-#define Z_OK            0
-#define Z_STREAM_END    1
-#define Z_NEED_DICT     2
-#define Z_ERRNO        (-1)
-#define Z_STREAM_ERROR (-2)
-#define Z_DATA_ERROR   (-3)
-#define Z_MEM_ERROR    (-4)
-#define Z_BUF_ERROR    (-5)
-#define Z_VERSION_ERROR (-6)
-/* Return codes for the compression/decompression functions. Negative values
- * are errors, positive values are used for special but normal events.
- */
-
-#define Z_NO_COMPRESSION         0
-#define Z_BEST_SPEED             1
-#define Z_BEST_COMPRESSION       9
-#define Z_DEFAULT_COMPRESSION  (-1)
-/* compression levels */
-
-#define Z_FILTERED            1
-#define Z_HUFFMAN_ONLY        2
-#define Z_RLE                 3
-#define Z_FIXED               4
-#define Z_DEFAULT_STRATEGY    0
-/* compression strategy; see deflateInit2() below for details */
-
-#define Z_BINARY   0
-#define Z_TEXT     1
-#define Z_ASCII    Z_TEXT   /* for compatibility with 1.2.2 and earlier */
-#define Z_UNKNOWN  2
-/* Possible values of the data_type field for deflate() */
-
-#define Z_DEFLATED   8
-/* The deflate compression method (the only one supported in this version) */
-
-#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
-
-#define zlib_version zlibVersion()
-/* for compatibility with versions < 1.0.2 */
-
-
-                        /* basic functions */
-
-ZEXTERN const char * ZEXPORT zlibVersion OF((void));
-/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
-   If the first character differs, the library code actually used is not
-   compatible with the zlib.h header file used by the application.  This check
-   is automatically made by deflateInit and inflateInit.
- */
-
-/*
-ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));
-
-     Initializes the internal stream state for compression.  The fields
-   zalloc, zfree and opaque must be initialized before by the caller.  If
-   zalloc and zfree are set to Z_NULL, deflateInit updates them to use default
-   allocation functions.
-
-     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
-   1 gives best speed, 9 gives best compression, 0 gives no compression at all
-   (the input data is simply copied a block at a time).  Z_DEFAULT_COMPRESSION
-   requests a default compromise between speed and compression (currently
-   equivalent to level 6).
-
-     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_STREAM_ERROR if level is not a valid compression level, or
-   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
-   with the version assumed by the caller (ZLIB_VERSION).  msg is set to null
-   if there is no error message.  deflateInit does not perform any compression:
-   this will be done by deflate().
-*/
-
-
-ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
-/*
-    deflate compresses as much data as possible, and stops when the input
-  buffer becomes empty or the output buffer becomes full.  It may introduce
-  some output latency (reading input without producing any output) except when
-  forced to flush.
-
-    The detailed semantics are as follows.  deflate performs one or both of the
-  following actions:
-
-  - Compress more input starting at next_in and update next_in and avail_in
-    accordingly.  If not all input can be processed (because there is not
-    enough room in the output buffer), next_in and avail_in are updated and
-    processing will resume at this point for the next call of deflate().
-
-  - Generate more output starting at next_out and update next_out and avail_out
-    accordingly.  This action is forced if the parameter flush is non zero.
-    Forcing flush frequently degrades the compression ratio, so this parameter
-    should be set only when necessary.  Some output may be provided even if
-    flush is zero.
-
-    Before the call of deflate(), the application should ensure that at least
-  one of the actions is possible, by providing more input and/or consuming more
-  output, and updating avail_in or avail_out accordingly; avail_out should
-  never be zero before the call.  The application can consume the compressed
-  output when it wants, for example when the output buffer is full (avail_out
-  == 0), or after each call of deflate().  If deflate returns Z_OK and with
-  zero avail_out, it must be called again after making room in the output
-  buffer because there might be more output pending. See deflatePending(),
-  which can be used if desired to determine whether or not there is more ouput
-  in that case.
-
-    Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to
-  decide how much data to accumulate before producing output, in order to
-  maximize compression.
-
-    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
-  flushed to the output buffer and the output is aligned on a byte boundary, so
-  that the decompressor can get all input data available so far.  (In
-  particular avail_in is zero after the call if enough output space has been
-  provided before the call.) Flushing may degrade compression for some
-  compression algorithms and so it should be used only when necessary.  This
-  completes the current deflate block and follows it with an empty stored block
-  that is three bits plus filler bits to the next byte, followed by four bytes
-  (00 00 ff ff).
-
-    If flush is set to Z_PARTIAL_FLUSH, all pending output is flushed to the
-  output buffer, but the output is not aligned to a byte boundary.  All of the
-  input data so far will be available to the decompressor, as for Z_SYNC_FLUSH.
-  This completes the current deflate block and follows it with an empty fixed
-  codes block that is 10 bits long.  This assures that enough bytes are output
-  in order for the decompressor to finish the block before the empty fixed
-  codes block.
-
-    If flush is set to Z_BLOCK, a deflate block is completed and emitted, as
-  for Z_SYNC_FLUSH, but the output is not aligned on a byte boundary, and up to
-  seven bits of the current block are held to be written as the next byte after
-  the next deflate block is completed.  In this case, the decompressor may not
-  be provided enough bits at this point in order to complete decompression of
-  the data provided so far to the compressor.  It may need to wait for the next
-  block to be emitted.  This is for advanced applications that need to control
-  the emission of deflate blocks.
-
-    If flush is set to Z_FULL_FLUSH, all output is flushed as with
-  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
-  restart from this point if previous compressed data has been damaged or if
-  random access is desired.  Using Z_FULL_FLUSH too often can seriously degrade
-  compression.
-
-    If deflate returns with avail_out == 0, this function must be called again
-  with the same value of the flush parameter and more output space (updated
-  avail_out), until the flush is complete (deflate returns with non-zero
-  avail_out).  In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that
-  avail_out is greater than six to avoid repeated flush markers due to
-  avail_out == 0 on return.
-
-    If the parameter flush is set to Z_FINISH, pending input is processed,
-  pending output is flushed and deflate returns with Z_STREAM_END if there was
-  enough output space.  If deflate returns with Z_OK or Z_BUF_ERROR, this
-  function must be called again with Z_FINISH and more output space (updated
-  avail_out) but no more input data, until it returns with Z_STREAM_END or an
-  error.  After deflate has returned Z_STREAM_END, the only possible operations
-  on the stream are deflateReset or deflateEnd.
-
-    Z_FINISH can be used in the first deflate call after deflateInit if all the
-  compression is to be done in a single step.  In order to complete in one
-  call, avail_out must be at least the value returned by deflateBound (see
-  below).  Then deflate is guaranteed to return Z_STREAM_END.  If not enough
-  output space is provided, deflate will not return Z_STREAM_END, and it must
-  be called again as described above.
-
-    deflate() sets strm->adler to the Adler-32 checksum of all input read
-  so far (that is, total_in bytes).  If a gzip stream is being generated, then
-  strm->adler will be the CRC-32 checksum of the input read so far.  (See
-  deflateInit2 below.)
-
-    deflate() may update strm->data_type if it can make a good guess about
-  the input data type (Z_BINARY or Z_TEXT).  If in doubt, the data is
-  considered binary.  This field is only for information purposes and does not
-  affect the compression algorithm in any manner.
-
-    deflate() returns Z_OK if some progress has been made (more input
-  processed or more output produced), Z_STREAM_END if all input has been
-  consumed and all output has been produced (only when flush is set to
-  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
-  if next_in or next_out was Z_NULL or the state was inadvertently written over
-  by the application), or Z_BUF_ERROR if no progress is possible (for example
-  avail_in or avail_out was zero).  Note that Z_BUF_ERROR is not fatal, and
-  deflate() can be called again with more input and more output space to
-  continue compressing.
-*/
-
-
-ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
-/*
-     All dynamically allocated data structures for this stream are freed.
-   This function discards any unprocessed input and does not flush any pending
-   output.
-
-     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
-   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
-   prematurely (some input or output was discarded).  In the error case, msg
-   may be set but then points to a static string (which must not be
-   deallocated).
-*/
-
-
-/*
-ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));
-
-     Initializes the internal stream state for decompression.  The fields
-   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
-   the caller.  In the current version of inflate, the provided input is not
-   read or consumed.  The allocation of a sliding window will be deferred to
-   the first call of inflate (if the decompression does not complete on the
-   first call).  If zalloc and zfree are set to Z_NULL, inflateInit updates
-   them to use default allocation functions.
-
-     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
-   version assumed by the caller, or Z_STREAM_ERROR if the parameters are
-   invalid, such as a null pointer to the structure.  msg is set to null if
-   there is no error message.  inflateInit does not perform any decompression.
-   Actual decompression will be done by inflate().  So next_in, and avail_in,
-   next_out, and avail_out are unused and unchanged.  The current
-   implementation of inflateInit() does not process any header information --
-   that is deferred until inflate() is called.
-*/
-
-
-ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
-/*
-    inflate decompresses as much data as possible, and stops when the input
-  buffer becomes empty or the output buffer becomes full.  It may introduce
-  some output latency (reading input without producing any output) except when
-  forced to flush.
-
-  The detailed semantics are as follows.  inflate performs one or both of the
-  following actions:
-
-  - Decompress more input starting at next_in and update next_in and avail_in
-    accordingly.  If not all input can be processed (because there is not
-    enough room in the output buffer), then next_in and avail_in are updated
-    accordingly, and processing will resume at this point for the next call of
-    inflate().
-
-  - Generate more output starting at next_out and update next_out and avail_out
-    accordingly.  inflate() provides as much output as possible, until there is
-    no more input data or no more space in the output buffer (see below about
-    the flush parameter).
-
-    Before the call of inflate(), the application should ensure that at least
-  one of the actions is possible, by providing more input and/or consuming more
-  output, and updating the next_* and avail_* values accordingly.  If the
-  caller of inflate() does not provide both available input and available
-  output space, it is possible that there will be no progress made.  The
-  application can consume the uncompressed output when it wants, for example
-  when the output buffer is full (avail_out == 0), or after each call of
-  inflate().  If inflate returns Z_OK and with zero avail_out, it must be
-  called again after making room in the output buffer because there might be
-  more output pending.
-
-    The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FINISH,
-  Z_BLOCK, or Z_TREES.  Z_SYNC_FLUSH requests that inflate() flush as much
-  output as possible to the output buffer.  Z_BLOCK requests that inflate()
-  stop if and when it gets to the next deflate block boundary.  When decoding
-  the zlib or gzip format, this will cause inflate() to return immediately
-  after the header and before the first block.  When doing a raw inflate,
-  inflate() will go ahead and process the first block, and will return when it
-  gets to the end of that block, or when it runs out of data.
-
-    The Z_BLOCK option assists in appending to or combining deflate streams.
-  To assist in this, on return inflate() always sets strm->data_type to the
-  number of unused bits in the last byte taken from strm->next_in, plus 64 if
-  inflate() is currently decoding the last block in the deflate stream, plus
-  128 if inflate() returned immediately after decoding an end-of-block code or
-  decoding the complete header up to just before the first byte of the deflate
-  stream.  The end-of-block will not be indicated until all of the uncompressed
-  data from that block has been written to strm->next_out.  The number of
-  unused bits may in general be greater than seven, except when bit 7 of
-  data_type is set, in which case the number of unused bits will be less than
-  eight.  data_type is set as noted here every time inflate() returns for all
-  flush options, and so can be used to determine the amount of currently
-  consumed input in bits.
-
-    The Z_TREES option behaves as Z_BLOCK does, but it also returns when the
-  end of each deflate block header is reached, before any actual data in that
-  block is decoded.  This allows the caller to determine the length of the
-  deflate block header for later use in random access within a deflate block.
-  256 is added to the value of strm->data_type when inflate() returns
-  immediately after reaching the end of the deflate block header.
-
-    inflate() should normally be called until it returns Z_STREAM_END or an
-  error.  However if all decompression is to be performed in a single step (a
-  single call of inflate), the parameter flush should be set to Z_FINISH.  In
-  this case all pending input is processed and all pending output is flushed;
-  avail_out must be large enough to hold all of the uncompressed data for the
-  operation to complete.  (The size of the uncompressed data may have been
-  saved by the compressor for this purpose.)  The use of Z_FINISH is not
-  required to perform an inflation in one step.  However it may be used to
-  inform inflate that a faster approach can be used for the single inflate()
-  call.  Z_FINISH also informs inflate to not maintain a sliding window if the
-  stream completes, which reduces inflate's memory footprint.  If the stream
-  does not complete, either because not all of the stream is provided or not
-  enough output space is provided, then a sliding window will be allocated and
-  inflate() can be called again to continue the operation as if Z_NO_FLUSH had
-  been used.
-
-     In this implementation, inflate() always flushes as much output as
-  possible to the output buffer, and always uses the faster approach on the
-  first call.  So the effects of the flush parameter in this implementation are
-  on the return value of inflate() as noted below, when inflate() returns early
-  when Z_BLOCK or Z_TREES is used, and when inflate() avoids the allocation of
-  memory for a sliding window when Z_FINISH is used.
-
-     If a preset dictionary is needed after this call (see inflateSetDictionary
-  below), inflate sets strm->adler to the Adler-32 checksum of the dictionary
-  chosen by the compressor and returns Z_NEED_DICT; otherwise it sets
-  strm->adler to the Adler-32 checksum of all output produced so far (that is,
-  total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described
-  below.  At the end of the stream, inflate() checks that its computed Adler-32
-  checksum is equal to that saved by the compressor and returns Z_STREAM_END
-  only if the checksum is correct.
-
-    inflate() can decompress and check either zlib-wrapped or gzip-wrapped
-  deflate data.  The header type is detected automatically, if requested when
-  initializing with inflateInit2().  Any information contained in the gzip
-  header is not retained unless inflateGetHeader() is used.  When processing
-  gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output
-  produced so far.  The CRC-32 is checked against the gzip trailer, as is the
-  uncompressed length, modulo 2^32.
-
-    inflate() returns Z_OK if some progress has been made (more input processed
-  or more output produced), Z_STREAM_END if the end of the compressed data has
-  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
-  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
-  corrupted (input stream not conforming to the zlib format or incorrect check
-  value, in which case strm->msg points to a string with a more specific
-  error), Z_STREAM_ERROR if the stream structure was inconsistent (for example
-  next_in or next_out was Z_NULL, or the state was inadvertently written over
-  by the application), Z_MEM_ERROR if there was not enough memory, Z_BUF_ERROR
-  if no progress was possible or if there was not enough room in the output
-  buffer when Z_FINISH is used.  Note that Z_BUF_ERROR is not fatal, and
-  inflate() can be called again with more input and more output space to
-  continue decompressing.  If Z_DATA_ERROR is returned, the application may
-  then call inflateSync() to look for a good compression block if a partial
-  recovery of the data is to be attempted.
-*/
-
-
-ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
-/*
-     All dynamically allocated data structures for this stream are freed.
-   This function discards any unprocessed input and does not flush any pending
-   output.
-
-     inflateEnd returns Z_OK if success, or Z_STREAM_ERROR if the stream state
-   was inconsistent.
-*/
-
-
-                        /* Advanced functions */
-
-/*
-    The following functions are needed only in some special applications.
-*/
-
-/*
-ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
-                                     int  level,
-                                     int  method,
-                                     int  windowBits,
-                                     int  memLevel,
-                                     int  strategy));
-
-     This is another version of deflateInit with more compression options.  The
-   fields next_in, zalloc, zfree and opaque must be initialized before by the
-   caller.
-
-     The method parameter is the compression method.  It must be Z_DEFLATED in
-   this version of the library.
-
-     The windowBits parameter is the base two logarithm of the window size
-   (the size of the history buffer).  It should be in the range 8..15 for this
-   version of the library.  Larger values of this parameter result in better
-   compression at the expense of memory usage.  The default value is 15 if
-   deflateInit is used instead.
-
-     For the current implementation of deflate(), a windowBits value of 8 (a
-   window size of 256 bytes) is not supported.  As a result, a request for 8
-   will result in 9 (a 512-byte window).  In that case, providing 8 to
-   inflateInit2() will result in an error when the zlib header with 9 is
-   checked against the initialization of inflate().  The remedy is to not use 8
-   with deflateInit2() with this initialization, or at least in that case use 9
-   with inflateInit2().
-
-     windowBits can also be -8..-15 for raw deflate.  In this case, -windowBits
-   determines the window size.  deflate() will then generate raw deflate data
-   with no zlib header or trailer, and will not compute a check value.
-
-     windowBits can also be greater than 15 for optional gzip encoding.  Add
-   16 to windowBits to write a simple gzip header and trailer around the
-   compressed data instead of a zlib wrapper.  The gzip header will have no
-   file name, no extra data, no comment, no modification time (set to zero), no
-   header crc, and the operating system will be set to the appropriate value,
-   if the operating system was determined at compile time.  If a gzip stream is
-   being written, strm->adler is a CRC-32 instead of an Adler-32.
-
-     For raw deflate or gzip encoding, a request for a 256-byte window is
-   rejected as invalid, since only the zlib header provides a means of
-   transmitting the window size to the decompressor.
-
-     The memLevel parameter specifies how much memory should be allocated
-   for the internal compression state.  memLevel=1 uses minimum memory but is
-   slow and reduces compression ratio; memLevel=9 uses maximum memory for
-   optimal speed.  The default value is 8.  See zconf.h for total memory usage
-   as a function of windowBits and memLevel.
-
-     The strategy parameter is used to tune the compression algorithm.  Use the
-   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
-   filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no
-   string match), or Z_RLE to limit match distances to one (run-length
-   encoding).  Filtered data consists mostly of small values with a somewhat
-   random distribution.  In this case, the compression algorithm is tuned to
-   compress them better.  The effect of Z_FILTERED is to force more Huffman
-   coding and less string matching; it is somewhat intermediate between
-   Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY.  Z_RLE is designed to be almost as
-   fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data.  The
-   strategy parameter only affects the compression ratio but not the
-   correctness of the compressed output even if it is not set appropriately.
-   Z_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler
-   decoder for special applications.
-
-     deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_STREAM_ERROR if any parameter is invalid (such as an invalid
-   method), or Z_VERSION_ERROR if the zlib library version (zlib_version) is
-   incompatible with the version assumed by the caller (ZLIB_VERSION).  msg is
-   set to null if there is no error message.  deflateInit2 does not perform any
-   compression: this will be done by deflate().
-*/
-
-ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
-                                             const Bytef *dictionary,
-                                             uInt  dictLength));
-/*
-     Initializes the compression dictionary from the given byte sequence
-   without producing any compressed output.  When using the zlib format, this
-   function must be called immediately after deflateInit, deflateInit2 or
-   deflateReset, and before any call of deflate.  When doing raw deflate, this
-   function must be called either before any call of deflate, or immediately
-   after the completion of a deflate block, i.e. after all input has been
-   consumed and all output has been delivered when using any of the flush
-   options Z_BLOCK, Z_PARTIAL_FLUSH, Z_SYNC_FLUSH, or Z_FULL_FLUSH.  The
-   compressor and decompressor must use exactly the same dictionary (see
-   inflateSetDictionary).
-
-     The dictionary should consist of strings (byte sequences) that are likely
-   to be encountered later in the data to be compressed, with the most commonly
-   used strings preferably put towards the end of the dictionary.  Using a
-   dictionary is most useful when the data to be compressed is short and can be
-   predicted with good accuracy; the data can then be compressed better than
-   with the default empty dictionary.
-
-     Depending on the size of the compression data structures selected by
-   deflateInit or deflateInit2, a part of the dictionary may in effect be
-   discarded, for example if the dictionary is larger than the window size
-   provided in deflateInit or deflateInit2.  Thus the strings most likely to be
-   useful should be put at the end of the dictionary, not at the front.  In
-   addition, the current implementation of deflate will use at most the window
-   size minus 262 bytes of the provided dictionary.
-
-     Upon return of this function, strm->adler is set to the Adler-32 value
-   of the dictionary; the decompressor may later use this value to determine
-   which dictionary has been used by the compressor.  (The Adler-32 value
-   applies to the whole dictionary even if only a subset of the dictionary is
-   actually used by the compressor.) If a raw deflate was requested, then the
-   Adler-32 value is not computed and strm->adler is not set.
-
-     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
-   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is
-   inconsistent (for example if deflate has already been called for this stream
-   or if not at a block boundary for raw deflate).  deflateSetDictionary does
-   not perform any compression: this will be done by deflate().
-*/
-
-ZEXTERN int ZEXPORT deflateGetDictionary OF((z_streamp strm,
-                                             Bytef *dictionary,
-                                             uInt  *dictLength));
-/*
-     Returns the sliding dictionary being maintained by deflate.  dictLength is
-   set to the number of bytes in the dictionary, and that many bytes are copied
-   to dictionary.  dictionary must have enough space, where 32768 bytes is
-   always enough.  If deflateGetDictionary() is called with dictionary equal to
-   Z_NULL, then only the dictionary length is returned, and nothing is copied.
-   Similary, if dictLength is Z_NULL, then it is not set.
-
-     deflateGetDictionary() may return a length less than the window size, even
-   when more than the window size in input has been provided. It may return up
-   to 258 bytes less in that case, due to how zlib's implementation of deflate
-   manages the sliding window and lookahead for matches, where matches can be
-   up to 258 bytes long. If the application needs the last window-size bytes of
-   input, then that would need to be saved by the application outside of zlib.
-
-     deflateGetDictionary returns Z_OK on success, or Z_STREAM_ERROR if the
-   stream state is inconsistent.
-*/
-
-ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
-                                    z_streamp source));
-/*
-     Sets the destination stream as a complete copy of the source stream.
-
-     This function can be useful when several compression strategies will be
-   tried, for example when there are several ways of pre-processing the input
-   data with a filter.  The streams that will be discarded should then be freed
-   by calling deflateEnd.  Note that deflateCopy duplicates the internal
-   compression state which can be quite large, so this strategy is slow and can
-   consume lots of memory.
-
-     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
-   (such as zalloc being Z_NULL).  msg is left unchanged in both source and
-   destination.
-*/
-
-ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
-/*
-     This function is equivalent to deflateEnd followed by deflateInit, but
-   does not free and reallocate the internal compression state.  The stream
-   will leave the compression level and any other attributes that may have been
-   set unchanged.
-
-     deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent (such as zalloc or state being Z_NULL).
-*/
-
-ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
-                                      int level,
-                                      int strategy));
-/*
-     Dynamically update the compression level and compression strategy.  The
-   interpretation of level and strategy is as in deflateInit2().  This can be
-   used to switch between compression and straight copy of the input data, or
-   to switch to a different kind of input data requiring a different strategy.
-   If the compression approach (which is a function of the level) or the
-   strategy is changed, and if any input has been consumed in a previous
-   deflate() call, then the input available so far is compressed with the old
-   level and strategy using deflate(strm, Z_BLOCK).  There are three approaches
-   for the compression levels 0, 1..3, and 4..9 respectively.  The new level
-   and strategy will take effect at the next call of deflate().
-
-     If a deflate(strm, Z_BLOCK) is performed by deflateParams(), and it does
-   not have enough output space to complete, then the parameter change will not
-   take effect.  In this case, deflateParams() can be called again with the
-   same parameters and more output space to try again.
-
-     In order to assure a change in the parameters on the first try, the
-   deflate stream should be flushed using deflate() with Z_BLOCK or other flush
-   request until strm.avail_out is not zero, before calling deflateParams().
-   Then no more input data should be provided before the deflateParams() call.
-   If this is done, the old level and strategy will be applied to the data
-   compressed before deflateParams(), and the new level and strategy will be
-   applied to the the data compressed after deflateParams().
-
-     deflateParams returns Z_OK on success, Z_STREAM_ERROR if the source stream
-   state was inconsistent or if a parameter was invalid, or Z_BUF_ERROR if
-   there was not enough output space to complete the compression of the
-   available input data before a change in the strategy or approach.  Note that
-   in the case of a Z_BUF_ERROR, the parameters are not changed.  A return
-   value of Z_BUF_ERROR is not fatal, in which case deflateParams() can be
-   retried with more output space.
-*/
-
-ZEXTERN int ZEXPORT deflateTune OF((z_streamp strm,
-                                    int good_length,
-                                    int max_lazy,
-                                    int nice_length,
-                                    int max_chain));
-/*
-     Fine tune deflate's internal compression parameters.  This should only be
-   used by someone who understands the algorithm used by zlib's deflate for
-   searching for the best matching string, and even then only by the most
-   fanatic optimizer trying to squeeze out the last compressed bit for their
-   specific input data.  Read the deflate.c source code for the meaning of the
-   max_lazy, good_length, nice_length, and max_chain parameters.
-
-     deflateTune() can be called after deflateInit() or deflateInit2(), and
-   returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.
- */
-
-ZEXTERN uLong ZEXPORT deflateBound OF((z_streamp strm,
-                                       uLong sourceLen));
-/*
-     deflateBound() returns an upper bound on the compressed size after
-   deflation of sourceLen bytes.  It must be called after deflateInit() or
-   deflateInit2(), and after deflateSetHeader(), if used.  This would be used
-   to allocate an output buffer for deflation in a single pass, and so would be
-   called before deflate().  If that first deflate() call is provided the
-   sourceLen input bytes, an output buffer allocated to the size returned by
-   deflateBound(), and the flush value Z_FINISH, then deflate() is guaranteed
-   to return Z_STREAM_END.  Note that it is possible for the compressed size to
-   be larger than the value returned by deflateBound() if flush options other
-   than Z_FINISH or Z_NO_FLUSH are used.
-*/
-
-ZEXTERN int ZEXPORT deflatePending OF((z_streamp strm,
-                                       unsigned *pending,
-                                       int *bits));
-/*
-     deflatePending() returns the number of bytes and bits of output that have
-   been generated, but not yet provided in the available output.  The bytes not
-   provided would be due to the available output space having being consumed.
-   The number of bits of output not provided are between 0 and 7, where they
-   await more bits to join them in order to fill out a full byte.  If pending
-   or bits are Z_NULL, then those values are not set.
-
-     deflatePending returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent.
- */
-
-ZEXTERN int ZEXPORT deflatePrime OF((z_streamp strm,
-                                     int bits,
-                                     int value));
-/*
-     deflatePrime() inserts bits in the deflate output stream.  The intent
-   is that this function is used to start off the deflate output with the bits
-   leftover from a previous deflate stream when appending to it.  As such, this
-   function can only be used for raw deflate, and must be used before the first
-   deflate() call after a deflateInit2() or deflateReset().  bits must be less
-   than or equal to 16, and that many of the least significant bits of value
-   will be inserted in the output.
-
-     deflatePrime returns Z_OK if success, Z_BUF_ERROR if there was not enough
-   room in the internal buffer to insert the bits, or Z_STREAM_ERROR if the
-   source stream state was inconsistent.
-*/
-
-ZEXTERN int ZEXPORT deflateSetHeader OF((z_streamp strm,
-                                         gz_headerp head));
-/*
-     deflateSetHeader() provides gzip header information for when a gzip
-   stream is requested by deflateInit2().  deflateSetHeader() may be called
-   after deflateInit2() or deflateReset() and before the first call of
-   deflate().  The text, time, os, extra field, name, and comment information
-   in the provided gz_header structure are written to the gzip header (xflag is
-   ignored -- the extra flags are set according to the compression level).  The
-   caller must assure that, if not Z_NULL, name and comment are terminated with
-   a zero byte, and that if extra is not Z_NULL, that extra_len bytes are
-   available there.  If hcrc is true, a gzip header crc is included.  Note that
-   the current versions of the command-line version of gzip (up through version
-   1.3.x) do not support header crc's, and will report that it is a "multi-part
-   gzip file" and give up.
-
-     If deflateSetHeader is not used, the default gzip header has text false,
-   the time set to zero, and os set to 255, with no extra, name, or comment
-   fields.  The gzip header is returned to the default state by deflateReset().
-
-     deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent.
-*/
-
-/*
-ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
-                                     int  windowBits));
-
-     This is another version of inflateInit with an extra parameter.  The
-   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
-   before by the caller.
-
-     The windowBits parameter is the base two logarithm of the maximum window
-   size (the size of the history buffer).  It should be in the range 8..15 for
-   this version of the library.  The default value is 15 if inflateInit is used
-   instead.  windowBits must be greater than or equal to the windowBits value
-   provided to deflateInit2() while compressing, or it must be equal to 15 if
-   deflateInit2() was not used.  If a compressed stream with a larger window
-   size is given as input, inflate() will return with the error code
-   Z_DATA_ERROR instead of trying to allocate a larger window.
-
-     windowBits can also be zero to request that inflate use the window size in
-   the zlib header of the compressed stream.
-
-     windowBits can also be -8..-15 for raw inflate.  In this case, -windowBits
-   determines the window size.  inflate() will then process raw deflate data,
-   not looking for a zlib or gzip header, not generating a check value, and not
-   looking for any check values for comparison at the end of the stream.  This
-   is for use with other formats that use the deflate compressed data format
-   such as zip.  Those formats provide their own check values.  If a custom
-   format is developed using the raw deflate format for compressed data, it is
-   recommended that a check value such as an Adler-32 or a CRC-32 be applied to
-   the uncompressed data as is done in the zlib, gzip, and zip formats.  For
-   most applications, the zlib format should be used as is.  Note that comments
-   above on the use in deflateInit2() applies to the magnitude of windowBits.
-
-     windowBits can also be greater than 15 for optional gzip decoding.  Add
-   32 to windowBits to enable zlib and gzip decoding with automatic header
-   detection, or add 16 to decode only the gzip format (the zlib format will
-   return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm->adler is a
-   CRC-32 instead of an Adler-32.  Unlike the gunzip utility and gzread() (see
-   below), inflate() will not automatically decode concatenated gzip streams.
-   inflate() will return Z_STREAM_END at the end of the gzip stream.  The state
-   would need to be reset to continue decoding a subsequent gzip stream.
-
-     inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
-   version assumed by the caller, or Z_STREAM_ERROR if the parameters are
-   invalid, such as a null pointer to the structure.  msg is set to null if
-   there is no error message.  inflateInit2 does not perform any decompression
-   apart from possibly reading the zlib header if present: actual decompression
-   will be done by inflate().  (So next_in and avail_in may be modified, but
-   next_out and avail_out are unused and unchanged.) The current implementation
-   of inflateInit2() does not process any header information -- that is
-   deferred until inflate() is called.
-*/
-
-ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
-                                             const Bytef *dictionary,
-                                             uInt  dictLength));
-/*
-     Initializes the decompression dictionary from the given uncompressed byte
-   sequence.  This function must be called immediately after a call of inflate,
-   if that call returned Z_NEED_DICT.  The dictionary chosen by the compressor
-   can be determined from the Adler-32 value returned by that call of inflate.
-   The compressor and decompressor must use exactly the same dictionary (see
-   deflateSetDictionary).  For raw inflate, this function can be called at any
-   time to set the dictionary.  If the provided dictionary is smaller than the
-   window and there is already data in the window, then the provided dictionary
-   will amend what's there.  The application must insure that the dictionary
-   that was used for compression is provided.
-
-     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
-   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is
-   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
-   expected one (incorrect Adler-32 value).  inflateSetDictionary does not
-   perform any decompression: this will be done by subsequent calls of
-   inflate().
-*/
-
-ZEXTERN int ZEXPORT inflateGetDictionary OF((z_streamp strm,
-                                             Bytef *dictionary,
-                                             uInt  *dictLength));
-/*
-     Returns the sliding dictionary being maintained by inflate.  dictLength is
-   set to the number of bytes in the dictionary, and that many bytes are copied
-   to dictionary.  dictionary must have enough space, where 32768 bytes is
-   always enough.  If inflateGetDictionary() is called with dictionary equal to
-   Z_NULL, then only the dictionary length is returned, and nothing is copied.
-   Similary, if dictLength is Z_NULL, then it is not set.
-
-     inflateGetDictionary returns Z_OK on success, or Z_STREAM_ERROR if the
-   stream state is inconsistent.
-*/
-
-ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
-/*
-     Skips invalid compressed data until a possible full flush point (see above
-   for the description of deflate with Z_FULL_FLUSH) can be found, or until all
-   available input is skipped.  No output is provided.
-
-     inflateSync searches for a 00 00 FF FF pattern in the compressed data.
-   All full flush points have this pattern, but not all occurrences of this
-   pattern are full flush points.
-
-     inflateSync returns Z_OK if a possible full flush point has been found,
-   Z_BUF_ERROR if no more input was provided, Z_DATA_ERROR if no flush point
-   has been found, or Z_STREAM_ERROR if the stream structure was inconsistent.
-   In the success case, the application may save the current current value of
-   total_in which indicates where valid compressed data was found.  In the
-   error case, the application may repeatedly call inflateSync, providing more
-   input each time, until success or end of the input data.
-*/
-
-ZEXTERN int ZEXPORT inflateCopy OF((z_streamp dest,
-                                    z_streamp source));
-/*
-     Sets the destination stream as a complete copy of the source stream.
-
-     This function can be useful when randomly accessing a large stream.  The
-   first pass through the stream can periodically record the inflate state,
-   allowing restarting inflate at those points when randomly accessing the
-   stream.
-
-     inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
-   (such as zalloc being Z_NULL).  msg is left unchanged in both source and
-   destination.
-*/
-
-ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
-/*
-     This function is equivalent to inflateEnd followed by inflateInit,
-   but does not free and reallocate the internal decompression state.  The
-   stream will keep attributes that may have been set by inflateInit2.
-
-     inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent (such as zalloc or state being Z_NULL).
-*/
-
-ZEXTERN int ZEXPORT inflateReset2 OF((z_streamp strm,
-                                      int windowBits));
-/*
-     This function is the same as inflateReset, but it also permits changing
-   the wrap and window size requests.  The windowBits parameter is interpreted
-   the same as it is for inflateInit2.  If the window size is changed, then the
-   memory allocated for the window is freed, and the window will be reallocated
-   by inflate() if needed.
-
-     inflateReset2 returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent (such as zalloc or state being Z_NULL), or if
-   the windowBits parameter is invalid.
-*/
-
-ZEXTERN int ZEXPORT inflatePrime OF((z_streamp strm,
-                                     int bits,
-                                     int value));
-/*
-     This function inserts bits in the inflate input stream.  The intent is
-   that this function is used to start inflating at a bit position in the
-   middle of a byte.  The provided bits will be used before any bytes are used
-   from next_in.  This function should only be used with raw inflate, and
-   should be used before the first inflate() call after inflateInit2() or
-   inflateReset().  bits must be less than or equal to 16, and that many of the
-   least significant bits of value will be inserted in the input.
-
-     If bits is negative, then the input stream bit buffer is emptied.  Then
-   inflatePrime() can be called again to put bits in the buffer.  This is used
-   to clear out bits leftover after feeding inflate a block description prior
-   to feeding inflate codes.
-
-     inflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent.
-*/
-
-ZEXTERN long ZEXPORT inflateMark OF((z_streamp strm));
-/*
-     This function returns two values, one in the lower 16 bits of the return
-   value, and the other in the remaining upper bits, obtained by shifting the
-   return value down 16 bits.  If the upper value is -1 and the lower value is
-   zero, then inflate() is currently decoding information outside of a block.
-   If the upper value is -1 and the lower value is non-zero, then inflate is in
-   the middle of a stored block, with the lower value equaling the number of
-   bytes from the input remaining to copy.  If the upper value is not -1, then
-   it is the number of bits back from the current bit position in the input of
-   the code (literal or length/distance pair) currently being processed.  In
-   that case the lower value is the number of bytes already emitted for that
-   code.
-
-     A code is being processed if inflate is waiting for more input to complete
-   decoding of the code, or if it has completed decoding but is waiting for
-   more output space to write the literal or match data.
-
-     inflateMark() is used to mark locations in the input data for random
-   access, which may be at bit positions, and to note those cases where the
-   output of a code may span boundaries of random access blocks.  The current
-   location in the input stream can be determined from avail_in and data_type
-   as noted in the description for the Z_BLOCK flush parameter for inflate.
-
-     inflateMark returns the value noted above, or -65536 if the provided
-   source stream state was inconsistent.
-*/
-
-ZEXTERN int ZEXPORT inflateGetHeader OF((z_streamp strm,
-                                         gz_headerp head));
-/*
-     inflateGetHeader() requests that gzip header information be stored in the
-   provided gz_header structure.  inflateGetHeader() may be called after
-   inflateInit2() or inflateReset(), and before the first call of inflate().
-   As inflate() processes the gzip stream, head->done is zero until the header
-   is completed, at which time head->done is set to one.  If a zlib stream is
-   being decoded, then head->done is set to -1 to indicate that there will be
-   no gzip header information forthcoming.  Note that Z_BLOCK or Z_TREES can be
-   used to force inflate() to return immediately after header processing is
-   complete and before any actual data is decompressed.
-
-     The text, time, xflags, and os fields are filled in with the gzip header
-   contents.  hcrc is set to true if there is a header CRC.  (The header CRC
-   was valid if done is set to one.) If extra is not Z_NULL, then extra_max
-   contains the maximum number of bytes to write to extra.  Once done is true,
-   extra_len contains the actual extra field length, and extra contains the
-   extra field, or that field truncated if extra_max is less than extra_len.
-   If name is not Z_NULL, then up to name_max characters are written there,
-   terminated with a zero unless the length is greater than name_max.  If
-   comment is not Z_NULL, then up to comm_max characters are written there,
-   terminated with a zero unless the length is greater than comm_max.  When any
-   of extra, name, or comment are not Z_NULL and the respective field is not
-   present in the header, then that field is set to Z_NULL to signal its
-   absence.  This allows the use of deflateSetHeader() with the returned
-   structure to duplicate the header.  However if those fields are set to
-   allocated memory, then the application will need to save those pointers
-   elsewhere so that they can be eventually freed.
-
-     If inflateGetHeader is not used, then the header information is simply
-   discarded.  The header is always checked for validity, including the header
-   CRC if present.  inflateReset() will reset the process to discard the header
-   information.  The application would need to call inflateGetHeader() again to
-   retrieve the header from the next gzip stream.
-
-     inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent.
-*/
-
-/*
-ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,
-                                        unsigned char FAR *window));
-
-     Initialize the internal stream state for decompression using inflateBack()
-   calls.  The fields zalloc, zfree and opaque in strm must be initialized
-   before the call.  If zalloc and zfree are Z_NULL, then the default library-
-   derived memory allocation routines are used.  windowBits is the base two
-   logarithm of the window size, in the range 8..15.  window is a caller
-   supplied buffer of that size.  Except for special applications where it is
-   assured that deflate was used with small window sizes, windowBits must be 15
-   and a 32K byte window must be supplied to be able to decompress general
-   deflate streams.
-
-     See inflateBack() for the usage of these routines.
-
-     inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of
-   the parameters are invalid, Z_MEM_ERROR if the internal state could not be
-   allocated, or Z_VERSION_ERROR if the version of the library does not match
-   the version of the header file.
-*/
-
-typedef unsigned (*in_func) OF((void FAR *,
-                                z_const unsigned char FAR * FAR *));
-typedef int (*out_func) OF((void FAR *, unsigned char FAR *, unsigned));
-
-ZEXTERN int ZEXPORT inflateBack OF((z_streamp strm,
-                                    in_func in, void FAR *in_desc,
-                                    out_func out, void FAR *out_desc));
-/*
-     inflateBack() does a raw inflate with a single call using a call-back
-   interface for input and output.  This is potentially more efficient than
-   inflate() for file i/o applications, in that it avoids copying between the
-   output and the sliding window by simply making the window itself the output
-   buffer.  inflate() can be faster on modern CPUs when used with large
-   buffers.  inflateBack() trusts the application to not change the output
-   buffer passed by the output function, at least until inflateBack() returns.
-
-     inflateBackInit() must be called first to allocate the internal state
-   and to initialize the state with the user-provided window buffer.
-   inflateBack() may then be used multiple times to inflate a complete, raw
-   deflate stream with each call.  inflateBackEnd() is then called to free the
-   allocated state.
-
-     A raw deflate stream is one with no zlib or gzip header or trailer.
-   This routine would normally be used in a utility that reads zip or gzip
-   files and writes out uncompressed files.  The utility would decode the
-   header and process the trailer on its own, hence this routine expects only
-   the raw deflate stream to decompress.  This is different from the default
-   behavior of inflate(), which expects a zlib header and trailer around the
-   deflate stream.
-
-     inflateBack() uses two subroutines supplied by the caller that are then
-   called by inflateBack() for input and output.  inflateBack() calls those
-   routines until it reads a complete deflate stream and writes out all of the
-   uncompressed data, or until it encounters an error.  The function's
-   parameters and return types are defined above in the in_func and out_func
-   typedefs.  inflateBack() will call in(in_desc, &buf) which should return the
-   number of bytes of provided input, and a pointer to that input in buf.  If
-   there is no input available, in() must return zero -- buf is ignored in that
-   case -- and inflateBack() will return a buffer error.  inflateBack() will
-   call out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].
-   out() should return zero on success, or non-zero on failure.  If out()
-   returns non-zero, inflateBack() will return with an error.  Neither in() nor
-   out() are permitted to change the contents of the window provided to
-   inflateBackInit(), which is also the buffer that out() uses to write from.
-   The length written by out() will be at most the window size.  Any non-zero
-   amount of input may be provided by in().
-
-     For convenience, inflateBack() can be provided input on the first call by
-   setting strm->next_in and strm->avail_in.  If that input is exhausted, then
-   in() will be called.  Therefore strm->next_in must be initialized before
-   calling inflateBack().  If strm->next_in is Z_NULL, then in() will be called
-   immediately for input.  If strm->next_in is not Z_NULL, then strm->avail_in
-   must also be initialized, and then if strm->avail_in is not zero, input will
-   initially be taken from strm->next_in[0 ..  strm->avail_in - 1].
-
-     The in_desc and out_desc parameters of inflateBack() is passed as the
-   first parameter of in() and out() respectively when they are called.  These
-   descriptors can be optionally used to pass any information that the caller-
-   supplied in() and out() functions need to do their job.
-
-     On return, inflateBack() will set strm->next_in and strm->avail_in to
-   pass back any unused input that was provided by the last in() call.  The
-   return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR
-   if in() or out() returned an error, Z_DATA_ERROR if there was a format error
-   in the deflate stream (in which case strm->msg is set to indicate the nature
-   of the error), or Z_STREAM_ERROR if the stream was not properly initialized.
-   In the case of Z_BUF_ERROR, an input or output error can be distinguished
-   using strm->next_in which will be Z_NULL only if in() returned an error.  If
-   strm->next_in is not Z_NULL, then the Z_BUF_ERROR was due to out() returning
-   non-zero.  (in() will always be called before out(), so strm->next_in is
-   assured to be defined if out() returns non-zero.)  Note that inflateBack()
-   cannot return Z_OK.
-*/
-
-ZEXTERN int ZEXPORT inflateBackEnd OF((z_streamp strm));
-/*
-     All memory allocated by inflateBackInit() is freed.
-
-     inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the stream
-   state was inconsistent.
-*/
-
-ZEXTERN uLong ZEXPORT zlibCompileFlags OF((void));
-/* Return flags indicating compile-time options.
-
-    Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:
-     1.0: size of uInt
-     3.2: size of uLong
-     5.4: size of voidpf (pointer)
-     7.6: size of z_off_t
-
-    Compiler, assembler, and debug options:
-     8: ZLIB_DEBUG
-     9: ASMV or ASMINF -- use ASM code
-     10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention
-     11: 0 (reserved)
-
-    One-time table building (smaller code, but not thread-safe if true):
-     12: BUILDFIXED -- build static block decoding tables when needed
-     13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed
-     14,15: 0 (reserved)
-
-    Library content (indicates missing functionality):
-     16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking
-                          deflate code when not needed)
-     17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect
-                    and decode gzip streams (to avoid linking crc code)
-     18-19: 0 (reserved)
-
-    Operation variations (changes in library functionality):
-     20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate
-     21: FASTEST -- deflate algorithm with only one, lowest compression level
-     22,23: 0 (reserved)
-
-    The sprintf variant used by gzprintf (zero is best):
-     24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format
-     25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!
-     26: 0 = returns value, 1 = void -- 1 means inferred string length returned
-
-    Remainder:
-     27-31: 0 (reserved)
- */
-
-#ifndef Z_SOLO
-
-                        /* utility functions */
-
-/*
-     The following utility functions are implemented on top of the basic
-   stream-oriented functions.  To simplify the interface, some default options
-   are assumed (compression level and memory usage, standard memory allocation
-   functions).  The source code of these utility functions can be modified if
-   you need special options.
-*/
-
-ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
-                                 const Bytef *source, uLong sourceLen));
-/*
-     Compresses the source buffer into the destination buffer.  sourceLen is
-   the byte length of the source buffer.  Upon entry, destLen is the total size
-   of the destination buffer, which must be at least the value returned by
-   compressBound(sourceLen).  Upon exit, destLen is the actual size of the
-   compressed data.  compress() is equivalent to compress2() with a level
-   parameter of Z_DEFAULT_COMPRESSION.
-
-     compress returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_BUF_ERROR if there was not enough room in the output
-   buffer.
-*/
-
-ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
-                                  const Bytef *source, uLong sourceLen,
-                                  int level));
-/*
-     Compresses the source buffer into the destination buffer.  The level
-   parameter has the same meaning as in deflateInit.  sourceLen is the byte
-   length of the source buffer.  Upon entry, destLen is the total size of the
-   destination buffer, which must be at least the value returned by
-   compressBound(sourceLen).  Upon exit, destLen is the actual size of the
-   compressed data.
-
-     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
-   Z_STREAM_ERROR if the level parameter is invalid.
-*/
-
-ZEXTERN uLong ZEXPORT compressBound OF((uLong sourceLen));
-/*
-     compressBound() returns an upper bound on the compressed size after
-   compress() or compress2() on sourceLen bytes.  It would be used before a
-   compress() or compress2() call to allocate the destination buffer.
-*/
-
-ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
-                                   const Bytef *source, uLong sourceLen));
-/*
-     Decompresses the source buffer into the destination buffer.  sourceLen is
-   the byte length of the source buffer.  Upon entry, destLen is the total size
-   of the destination buffer, which must be large enough to hold the entire
-   uncompressed data.  (The size of the uncompressed data must have been saved
-   previously by the compressor and transmitted to the decompressor by some
-   mechanism outside the scope of this compression library.) Upon exit, destLen
-   is the actual size of the uncompressed data.
-
-     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_BUF_ERROR if there was not enough room in the output
-   buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.  In
-   the case where there is not enough room, uncompress() will fill the output
-   buffer with the uncompressed data up to that point.
-*/
-
-ZEXTERN int ZEXPORT uncompress2 OF((Bytef *dest,   uLongf *destLen,
-                                    const Bytef *source, uLong *sourceLen));
-/*
-     Same as uncompress, except that sourceLen is a pointer, where the
-   length of the source is *sourceLen.  On return, *sourceLen is the number of
-   source bytes consumed.
-*/
-
-                        /* gzip file access functions */
-
-/*
-     This library supports reading and writing files in gzip (.gz) format with
-   an interface similar to that of stdio, using the functions that start with
-   "gz".  The gzip format is different from the zlib format.  gzip is a gzip
-   wrapper, documented in RFC 1952, wrapped around a deflate stream.
-*/
-
-typedef struct gzFile_s *gzFile;    /* semi-opaque gzip file descriptor */
-
-/*
-ZEXTERN gzFile ZEXPORT gzopen OF((const char *path, const char *mode));
-
-     Opens a gzip (.gz) file for reading or writing.  The mode parameter is as
-   in fopen ("rb" or "wb") but can also include a compression level ("wb9") or
-   a strategy: 'f' for filtered data as in "wb6f", 'h' for Huffman-only
-   compression as in "wb1h", 'R' for run-length encoding as in "wb1R", or 'F'
-   for fixed code compression as in "wb9F".  (See the description of
-   deflateInit2 for more information about the strategy parameter.)  'T' will
-   request transparent writing or appending with no compression and not using
-   the gzip format.
-
-     "a" can be used instead of "w" to request that the gzip stream that will
-   be written be appended to the file.  "+" will result in an error, since
-   reading and writing to the same gzip file is not supported.  The addition of
-   "x" when writing will create the file exclusively, which fails if the file
-   already exists.  On systems that support it, the addition of "e" when
-   reading or writing will set the flag to close the file on an execve() call.
-
-     These functions, as well as gzip, will read and decode a sequence of gzip
-   streams in a file.  The append function of gzopen() can be used to create
-   such a file.  (Also see gzflush() for another way to do this.)  When
-   appending, gzopen does not test whether the file begins with a gzip stream,
-   nor does it look for the end of the gzip streams to begin appending.  gzopen
-   will simply append a gzip stream to the existing file.
-
-     gzopen can be used to read a file which is not in gzip format; in this
-   case gzread will directly read from the file without decompression.  When
-   reading, this will be detected automatically by looking for the magic two-
-   byte gzip header.
-
-     gzopen returns NULL if the file could not be opened, if there was
-   insufficient memory to allocate the gzFile state, or if an invalid mode was
-   specified (an 'r', 'w', or 'a' was not provided, or '+' was provided).
-   errno can be checked to determine if the reason gzopen failed was that the
-   file could not be opened.
-*/
-
-ZEXTERN gzFile ZEXPORT gzdopen OF((int fd, const char *mode));
-/*
-     gzdopen associates a gzFile with the file descriptor fd.  File descriptors
-   are obtained from calls like open, dup, creat, pipe or fileno (if the file
-   has been previously opened with fopen).  The mode parameter is as in gzopen.
-
-     The next call of gzclose on the returned gzFile will also close the file
-   descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor
-   fd.  If you want to keep fd open, use fd = dup(fd_keep); gz = gzdopen(fd,
-   mode);.  The duplicated descriptor should be saved to avoid a leak, since
-   gzdopen does not close fd if it fails.  If you are using fileno() to get the
-   file descriptor from a FILE *, then you will have to use dup() to avoid
-   double-close()ing the file descriptor.  Both gzclose() and fclose() will
-   close the associated file descriptor, so they need to have different file
-   descriptors.
-
-     gzdopen returns NULL if there was insufficient memory to allocate the
-   gzFile state, if an invalid mode was specified (an 'r', 'w', or 'a' was not
-   provided, or '+' was provided), or if fd is -1.  The file descriptor is not
-   used until the next gz* read, write, seek, or close operation, so gzdopen
-   will not detect if fd is invalid (unless fd is -1).
-*/
-
-ZEXTERN int ZEXPORT gzbuffer OF((gzFile file, unsigned size));
-/*
-     Set the internal buffer size used by this library's functions.  The
-   default buffer size is 8192 bytes.  This function must be called after
-   gzopen() or gzdopen(), and before any other calls that read or write the
-   file.  The buffer memory allocation is always deferred to the first read or
-   write.  Three times that size in buffer space is allocated.  A larger buffer
-   size of, for example, 64K or 128K bytes will noticeably increase the speed
-   of decompression (reading).
-
-     The new buffer size also affects the maximum length for gzprintf().
-
-     gzbuffer() returns 0 on success, or -1 on failure, such as being called
-   too late.
-*/
-
-ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
-/*
-     Dynamically update the compression level or strategy.  See the description
-   of deflateInit2 for the meaning of these parameters.  Previously provided
-   data is flushed before the parameter change.
-
-     gzsetparams returns Z_OK if success, Z_STREAM_ERROR if the file was not
-   opened for writing, Z_ERRNO if there is an error writing the flushed data,
-   or Z_MEM_ERROR if there is a memory allocation error.
-*/
-
-ZEXTERN int ZEXPORT gzread OF((gzFile file, voidp buf, unsigned len));
-/*
-     Reads the given number of uncompressed bytes from the compressed file.  If
-   the input file is not in gzip format, gzread copies the given number of
-   bytes into the buffer directly from the file.
-
-     After reaching the end of a gzip stream in the input, gzread will continue
-   to read, looking for another gzip stream.  Any number of gzip streams may be
-   concatenated in the input file, and will all be decompressed by gzread().
-   If something other than a gzip stream is encountered after a gzip stream,
-   that remaining trailing garbage is ignored (and no error is returned).
-
-     gzread can be used to read a gzip file that is being concurrently written.
-   Upon reaching the end of the input, gzread will return with the available
-   data.  If the error code returned by gzerror is Z_OK or Z_BUF_ERROR, then
-   gzclearerr can be used to clear the end of file indicator in order to permit
-   gzread to be tried again.  Z_OK indicates that a gzip stream was completed
-   on the last gzread.  Z_BUF_ERROR indicates that the input file ended in the
-   middle of a gzip stream.  Note that gzread does not return -1 in the event
-   of an incomplete gzip stream.  This error is deferred until gzclose(), which
-   will return Z_BUF_ERROR if the last gzread ended in the middle of a gzip
-   stream.  Alternatively, gzerror can be used before gzclose to detect this
-   case.
-
-     gzread returns the number of uncompressed bytes actually read, less than
-   len for end of file, or -1 for error.  If len is too large to fit in an int,
-   then nothing is read, -1 is returned, and the error state is set to
-   Z_STREAM_ERROR.
-*/
-
-ZEXTERN z_size_t ZEXPORT gzfread OF((voidp buf, z_size_t size, z_size_t nitems,
-                                     gzFile file));
-/*
-     Read up to nitems items of size size from file to buf, otherwise operating
-   as gzread() does.  This duplicates the interface of stdio's fread(), with
-   size_t request and return types.  If the library defines size_t, then
-   z_size_t is identical to size_t.  If not, then z_size_t is an unsigned
-   integer type that can contain a pointer.
-
-     gzfread() returns the number of full items read of size size, or zero if
-   the end of the file was reached and a full item could not be read, or if
-   there was an error.  gzerror() must be consulted if zero is returned in
-   order to determine if there was an error.  If the multiplication of size and
-   nitems overflows, i.e. the product does not fit in a z_size_t, then nothing
-   is read, zero is returned, and the error state is set to Z_STREAM_ERROR.
-
-     In the event that the end of file is reached and only a partial item is
-   available at the end, i.e. the remaining uncompressed data length is not a
-   multiple of size, then the final partial item is nevetheless read into buf
-   and the end-of-file flag is set.  The length of the partial item read is not
-   provided, but could be inferred from the result of gztell().  This behavior
-   is the same as the behavior of fread() implementations in common libraries,
-   but it prevents the direct use of gzfread() to read a concurrently written
-   file, reseting and retrying on end-of-file, when size is not 1.
-*/
-
-ZEXTERN int ZEXPORT gzwrite OF((gzFile file,
-                                voidpc buf, unsigned len));
-/*
-     Writes the given number of uncompressed bytes into the compressed file.
-   gzwrite returns the number of uncompressed bytes written or 0 in case of
-   error.
-*/
-
-ZEXTERN z_size_t ZEXPORT gzfwrite OF((voidpc buf, z_size_t size,
-                                      z_size_t nitems, gzFile file));
-/*
-     gzfwrite() writes nitems items of size size from buf to file, duplicating
-   the interface of stdio's fwrite(), with size_t request and return types.  If
-   the library defines size_t, then z_size_t is identical to size_t.  If not,
-   then z_size_t is an unsigned integer type that can contain a pointer.
-
-     gzfwrite() returns the number of full items written of size size, or zero
-   if there was an error.  If the multiplication of size and nitems overflows,
-   i.e. the product does not fit in a z_size_t, then nothing is written, zero
-   is returned, and the error state is set to Z_STREAM_ERROR.
-*/
-
-ZEXTERN int ZEXPORTVA gzprintf Z_ARG((gzFile file, const char *format, ...));
-/*
-     Converts, formats, and writes the arguments to the compressed file under
-   control of the format string, as in fprintf.  gzprintf returns the number of
-   uncompressed bytes actually written, or a negative zlib error code in case
-   of error.  The number of uncompressed bytes written is limited to 8191, or
-   one less than the buffer size given to gzbuffer().  The caller should assure
-   that this limit is not exceeded.  If it is exceeded, then gzprintf() will
-   return an error (0) with nothing written.  In this case, there may also be a
-   buffer overflow with unpredictable consequences, which is possible only if
-   zlib was compiled with the insecure functions sprintf() or vsprintf()
-   because the secure snprintf() or vsnprintf() functions were not available.
-   This can be determined using zlibCompileFlags().
-*/
-
-ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
-/*
-     Writes the given null-terminated string to the compressed file, excluding
-   the terminating null character.
-
-     gzputs returns the number of characters written, or -1 in case of error.
-*/
-
-ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
-/*
-     Reads bytes from the compressed file until len-1 characters are read, or a
-   newline character is read and transferred to buf, or an end-of-file
-   condition is encountered.  If any characters are read or if len == 1, the
-   string is terminated with a null character.  If no characters are read due
-   to an end-of-file or len < 1, then the buffer is left untouched.
-
-     gzgets returns buf which is a null-terminated string, or it returns NULL
-   for end-of-file or in case of error.  If there was an error, the contents at
-   buf are indeterminate.
-*/
-
-ZEXTERN int ZEXPORT gzputc OF((gzFile file, int c));
-/*
-     Writes c, converted to an unsigned char, into the compressed file.  gzputc
-   returns the value that was written, or -1 in case of error.
-*/
-
-ZEXTERN int ZEXPORT gzgetc OF((gzFile file));
-/*
-     Reads one byte from the compressed file.  gzgetc returns this byte or -1
-   in case of end of file or error.  This is implemented as a macro for speed.
-   As such, it does not do all of the checking the other functions do.  I.e.
-   it does not check to see if file is NULL, nor whether the structure file
-   points to has been clobbered or not.
-*/
-
-ZEXTERN int ZEXPORT gzungetc OF((int c, gzFile file));
-/*
-     Push one character back onto the stream to be read as the first character
-   on the next read.  At least one character of push-back is allowed.
-   gzungetc() returns the character pushed, or -1 on failure.  gzungetc() will
-   fail if c is -1, and may fail if a character has been pushed but not read
-   yet.  If gzungetc is used immediately after gzopen or gzdopen, at least the
-   output buffer size of pushed characters is allowed.  (See gzbuffer above.)
-   The pushed character will be discarded if the stream is repositioned with
-   gzseek() or gzrewind().
-*/
-
-ZEXTERN int ZEXPORT gzflush OF((gzFile file, int flush));
-/*
-     Flushes all pending output into the compressed file.  The parameter flush
-   is as in the deflate() function.  The return value is the zlib error number
-   (see function gzerror below).  gzflush is only permitted when writing.
-
-     If the flush parameter is Z_FINISH, the remaining data is written and the
-   gzip stream is completed in the output.  If gzwrite() is called again, a new
-   gzip stream will be started in the output.  gzread() is able to read such
-   concatenated gzip streams.
-
-     gzflush should be called only when strictly necessary because it will
-   degrade compression if called too often.
-*/
-
-/*
-ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile file,
-                                   z_off_t offset, int whence));
-
-     Sets the starting position for the next gzread or gzwrite on the given
-   compressed file.  The offset represents a number of bytes in the
-   uncompressed data stream.  The whence parameter is defined as in lseek(2);
-   the value SEEK_END is not supported.
-
-     If the file is opened for reading, this function is emulated but can be
-   extremely slow.  If the file is opened for writing, only forward seeks are
-   supported; gzseek then compresses a sequence of zeroes up to the new
-   starting position.
-
-     gzseek returns the resulting offset location as measured in bytes from
-   the beginning of the uncompressed stream, or -1 in case of error, in
-   particular if the file is opened for writing and the new starting position
-   would be before the current position.
-*/
-
-ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
-/*
-     Rewinds the given file. This function is supported only for reading.
-
-     gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
-*/
-
-/*
-ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
-
-     Returns the starting position for the next gzread or gzwrite on the given
-   compressed file.  This position represents a number of bytes in the
-   uncompressed data stream, and is zero when starting, even if appending or
-   reading a gzip stream from the middle of a file using gzdopen().
-
-     gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
-*/
-
-/*
-ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile file));
-
-     Returns the current offset in the file being read or written.  This offset
-   includes the count of bytes that precede the gzip stream, for example when
-   appending or when using gzdopen() for reading.  When reading, the offset
-   does not include as yet unused buffered input.  This information can be used
-   for a progress indicator.  On error, gzoffset() returns -1.
-*/
-
-ZEXTERN int ZEXPORT gzeof OF((gzFile file));
-/*
-     Returns true (1) if the end-of-file indicator has been set while reading,
-   false (0) otherwise.  Note that the end-of-file indicator is set only if the
-   read tried to go past the end of the input, but came up short.  Therefore,
-   just like feof(), gzeof() may return false even if there is no more data to
-   read, in the event that the last read request was for the exact number of
-   bytes remaining in the input file.  This will happen if the input file size
-   is an exact multiple of the buffer size.
-
-     If gzeof() returns true, then the read functions will return no more data,
-   unless the end-of-file indicator is reset by gzclearerr() and the input file
-   has grown since the previous end of file was detected.
-*/
-
-ZEXTERN int ZEXPORT gzdirect OF((gzFile file));
-/*
-     Returns true (1) if file is being copied directly while reading, or false
-   (0) if file is a gzip stream being decompressed.
-
-     If the input file is empty, gzdirect() will return true, since the input
-   does not contain a gzip stream.
-
-     If gzdirect() is used immediately after gzopen() or gzdopen() it will
-   cause buffers to be allocated to allow reading the file to determine if it
-   is a gzip file.  Therefore if gzbuffer() is used, it should be called before
-   gzdirect().
-
-     When writing, gzdirect() returns true (1) if transparent writing was
-   requested ("wT" for the gzopen() mode), or false (0) otherwise.  (Note:
-   gzdirect() is not needed when writing.  Transparent writing must be
-   explicitly requested, so the application already knows the answer.  When
-   linking statically, using gzdirect() will include all of the zlib code for
-   gzip file reading and decompression, which may not be desired.)
-*/
-
-ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
-/*
-     Flushes all pending output if necessary, closes the compressed file and
-   deallocates the (de)compression state.  Note that once file is closed, you
-   cannot call gzerror with file, since its structures have been deallocated.
-   gzclose must not be called more than once on the same file, just as free
-   must not be called more than once on the same allocation.
-
-     gzclose will return Z_STREAM_ERROR if file is not valid, Z_ERRNO on a
-   file operation error, Z_MEM_ERROR if out of memory, Z_BUF_ERROR if the
-   last read ended in the middle of a gzip stream, or Z_OK on success.
-*/
-
-ZEXTERN int ZEXPORT gzclose_r OF((gzFile file));
-ZEXTERN int ZEXPORT gzclose_w OF((gzFile file));
-/*
-     Same as gzclose(), but gzclose_r() is only for use when reading, and
-   gzclose_w() is only for use when writing or appending.  The advantage to
-   using these instead of gzclose() is that they avoid linking in zlib
-   compression or decompression code that is not used when only reading or only
-   writing respectively.  If gzclose() is used, then both compression and
-   decompression code will be included the application when linking to a static
-   zlib library.
-*/
-
-ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
-/*
-     Returns the error message for the last error which occurred on the given
-   compressed file.  errnum is set to zlib error number.  If an error occurred
-   in the file system and not in the compression library, errnum is set to
-   Z_ERRNO and the application may consult errno to get the exact error code.
-
-     The application must not modify the returned string.  Future calls to
-   this function may invalidate the previously returned string.  If file is
-   closed, then the string previously returned by gzerror will no longer be
-   available.
-
-     gzerror() should be used to distinguish errors from end-of-file for those
-   functions above that do not distinguish those cases in their return values.
-*/
-
-ZEXTERN void ZEXPORT gzclearerr OF((gzFile file));
-/*
-     Clears the error and end-of-file flags for file.  This is analogous to the
-   clearerr() function in stdio.  This is useful for continuing to read a gzip
-   file that is being written concurrently.
-*/
-
-#endif /* !Z_SOLO */
-
-                        /* checksum functions */
-
-/*
-     These functions are not related to compression but are exported
-   anyway because they might be useful in applications using the compression
-   library.
-*/
-
-ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));
-/*
-     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
-   return the updated checksum.  If buf is Z_NULL, this function returns the
-   required initial value for the checksum.
-
-     An Adler-32 checksum is almost as reliable as a CRC-32 but can be computed
-   much faster.
-
-   Usage example:
-
-     uLong adler = adler32(0L, Z_NULL, 0);
-
-     while (read_buffer(buffer, length) != EOF) {
-       adler = adler32(adler, buffer, length);
-     }
-     if (adler != original_adler) error();
-*/
-
-ZEXTERN uLong ZEXPORT adler32_z OF((uLong adler, const Bytef *buf,
-                                    z_size_t len));
-/*
-     Same as adler32(), but with a size_t length.
-*/
-
-/*
-ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,
-                                          z_off_t len2));
-
-     Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1
-   and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for
-   each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of
-   seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.  Note
-   that the z_off_t type (like off_t) is a signed integer.  If len2 is
-   negative, the result has no meaning or utility.
-*/
-
-ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
-/*
-     Update a running CRC-32 with the bytes buf[0..len-1] and return the
-   updated CRC-32.  If buf is Z_NULL, this function returns the required
-   initial value for the crc.  Pre- and post-conditioning (one's complement) is
-   performed within this function so it shouldn't be done by the application.
-
-   Usage example:
-
-     uLong crc = crc32(0L, Z_NULL, 0);
-
-     while (read_buffer(buffer, length) != EOF) {
-       crc = crc32(crc, buffer, length);
-     }
-     if (crc != original_crc) error();
-*/
-
-ZEXTERN uLong ZEXPORT crc32_z OF((uLong adler, const Bytef *buf,
-                                  z_size_t len));
-/*
-     Same as crc32(), but with a size_t length.
-*/
-
-/*
-ZEXTERN uLong ZEXPORT crc32_combine OF((uLong crc1, uLong crc2, z_off_t len2));
-
-     Combine two CRC-32 check values into one.  For two sequences of bytes,
-   seq1 and seq2 with lengths len1 and len2, CRC-32 check values were
-   calculated for each, crc1 and crc2.  crc32_combine() returns the CRC-32
-   check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and
-   len2.
-*/
-
-
-                        /* various hacks, don't look :) */
-
-/* deflateInit and inflateInit are macros to allow checking the zlib version
- * and the compiler's view of z_stream:
- */
-ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
-                                     const char *version, int stream_size));
-ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
-                                     const char *version, int stream_size));
-ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
-                                      int windowBits, int memLevel,
-                                      int strategy, const char *version,
-                                      int stream_size));
-ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
-                                      const char *version, int stream_size));
-ZEXTERN int ZEXPORT inflateBackInit_ OF((z_streamp strm, int windowBits,
-                                         unsigned char FAR *window,
-                                         const char *version,
-                                         int stream_size));
-#ifdef Z_PREFIX_SET
-#  define z_deflateInit(strm, level) \
-          deflateInit_((strm), (level), ZLIB_VERSION, (int)sizeof(z_stream))
-#  define z_inflateInit(strm) \
-          inflateInit_((strm), ZLIB_VERSION, (int)sizeof(z_stream))
-#  define z_deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
-          deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
-                        (strategy), ZLIB_VERSION, (int)sizeof(z_stream))
-#  define z_inflateInit2(strm, windowBits) \
-          inflateInit2_((strm), (windowBits), ZLIB_VERSION, \
-                        (int)sizeof(z_stream))
-#  define z_inflateBackInit(strm, windowBits, window) \
-          inflateBackInit_((strm), (windowBits), (window), \
-                           ZLIB_VERSION, (int)sizeof(z_stream))
-#else
-#  define deflateInit(strm, level) \
-          deflateInit_((strm), (level), ZLIB_VERSION, (int)sizeof(z_stream))
-#  define inflateInit(strm) \
-          inflateInit_((strm), ZLIB_VERSION, (int)sizeof(z_stream))
-#  define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
-          deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
-                        (strategy), ZLIB_VERSION, (int)sizeof(z_stream))
-#  define inflateInit2(strm, windowBits) \
-          inflateInit2_((strm), (windowBits), ZLIB_VERSION, \
-                        (int)sizeof(z_stream))
-#  define inflateBackInit(strm, windowBits, window) \
-          inflateBackInit_((strm), (windowBits), (window), \
-                           ZLIB_VERSION, (int)sizeof(z_stream))
-#endif
-
-#ifndef Z_SOLO
-
-/* gzgetc() macro and its supporting function and exposed data structure.  Note
- * that the real internal state is much larger than the exposed structure.
- * This abbreviated structure exposes just enough for the gzgetc() macro.  The
- * user should not mess with these exposed elements, since their names or
- * behavior could change in the future, perhaps even capriciously.  They can
- * only be used by the gzgetc() macro.  You have been warned.
- */
-struct gzFile_s {
-    unsigned have;
-    unsigned char *next;
-    z_off64_t pos;
-};
-ZEXTERN int ZEXPORT gzgetc_ OF((gzFile file));  /* backward compatibility */
-#ifdef Z_PREFIX_SET
-#  undef z_gzgetc
-#  define z_gzgetc(g) \
-          ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : (gzgetc)(g))
-#else
-#  define gzgetc(g) \
-          ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : (gzgetc)(g))
-#endif
-
-/* provide 64-bit offset functions if _LARGEFILE64_SOURCE defined, and/or
- * change the regular functions to 64 bits if _FILE_OFFSET_BITS is 64 (if
- * both are true, the application gets the *64 functions, and the regular
- * functions are changed to 64 bits) -- in case these are set on systems
- * without large file support, _LFS64_LARGEFILE must also be true
- */
-#ifdef Z_LARGE64
-   ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
-   ZEXTERN z_off64_t ZEXPORT gzseek64 OF((gzFile, z_off64_t, int));
-   ZEXTERN z_off64_t ZEXPORT gztell64 OF((gzFile));
-   ZEXTERN z_off64_t ZEXPORT gzoffset64 OF((gzFile));
-   ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off64_t));
-   ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off64_t));
-#endif
-
-#if !defined(ZLIB_INTERNAL) && defined(Z_WANT64)
-#  ifdef Z_PREFIX_SET
-#    define z_gzopen z_gzopen64
-#    define z_gzseek z_gzseek64
-#    define z_gztell z_gztell64
-#    define z_gzoffset z_gzoffset64
-#    define z_adler32_combine z_adler32_combine64
-#    define z_crc32_combine z_crc32_combine64
-#  else
-#    define gzopen gzopen64
-#    define gzseek gzseek64
-#    define gztell gztell64
-#    define gzoffset gzoffset64
-#    define adler32_combine adler32_combine64
-#    define crc32_combine crc32_combine64
-#  endif
-#  ifndef Z_LARGE64
-     ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
-     ZEXTERN z_off_t ZEXPORT gzseek64 OF((gzFile, z_off_t, int));
-     ZEXTERN z_off_t ZEXPORT gztell64 OF((gzFile));
-     ZEXTERN z_off_t ZEXPORT gzoffset64 OF((gzFile));
-     ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));
-     ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));
-#  endif
-#else
-   ZEXTERN gzFile ZEXPORT gzopen OF((const char *, const char *));
-   ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile, z_off_t, int));
-   ZEXTERN z_off_t ZEXPORT gztell OF((gzFile));
-   ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile));
-   ZEXTERN uLong ZEXPORT adler32_combine OF((uLong, uLong, z_off_t));
-   ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));
-#endif
-
-#else /* Z_SOLO */
-
-   ZEXTERN uLong ZEXPORT adler32_combine OF((uLong, uLong, z_off_t));
-   ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));
-
-#endif /* !Z_SOLO */
-
-/* undocumented functions */
-ZEXTERN const char   * ZEXPORT zError           OF((int));
-ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp));
-ZEXTERN const z_crc_t FAR * ZEXPORT get_crc_table    OF((void));
-ZEXTERN int            ZEXPORT inflateUndermine OF((z_streamp, int));
-ZEXTERN int            ZEXPORT inflateValidate OF((z_streamp, int));
-ZEXTERN unsigned long  ZEXPORT inflateCodesUsed OF ((z_streamp));
-ZEXTERN int            ZEXPORT inflateResetKeep OF((z_streamp));
-ZEXTERN int            ZEXPORT deflateResetKeep OF((z_streamp));
-#if (defined(_WIN32) || defined(__CYGWIN__)) && !defined(Z_SOLO)
-ZEXTERN gzFile         ZEXPORT gzopen_w OF((const wchar_t *path,
-                                            const char *mode));
-#endif
-#if defined(STDC) || defined(Z_HAVE_STDARG_H)
-#  ifndef Z_SOLO
-ZEXTERN int            ZEXPORTVA gzvprintf Z_ARG((gzFile file,
-                                                  const char *format,
-                                                  va_list va));
-#  endif
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ZLIB_H */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/deps/zlib/zutil.h
+++ /dev/null
@@ -1,271 +0,0 @@
-/* zutil.h -- internal interface and configuration of the compression library
- * Copyright (C) 1995-2016 Jean-loup Gailly, Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-/* @(#) $Id$ */
-
-#ifndef ZUTIL_H
-#define ZUTIL_H
-
-#ifdef HAVE_HIDDEN
-#  define ZLIB_INTERNAL __attribute__((visibility ("hidden")))
-#else
-#  define ZLIB_INTERNAL
-#endif
-
-#include "zlib.h"
-
-#if defined(STDC) && !defined(Z_SOLO)
-#  if !(defined(_WIN32_WCE) && defined(_MSC_VER))
-#    include <stddef.h>
-#  endif
-#  include <string.h>
-#  include <stdlib.h>
-#endif
-
-#ifdef Z_SOLO
-   typedef long ptrdiff_t;  /* guess -- will be caught if guess is wrong */
-#endif
-
-#ifndef local
-#  define local static
-#endif
-/* since "static" is used to mean two completely different things in C, we
-   define "local" for the non-static meaning of "static", for readability
-   (compile with -Dlocal if your debugger can't find static symbols) */
-
-typedef unsigned char  uch;
-typedef uch FAR uchf;
-typedef unsigned short ush;
-typedef ush FAR ushf;
-typedef unsigned long  ulg;
-
-extern z_const char * const z_errmsg[10]; /* indexed by 2-zlib_error */
-/* (size given to avoid silly warnings with Visual C++) */
-
-#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]
-
-#define ERR_RETURN(strm,err) \
-  return (strm->msg = ERR_MSG(err), (err))
-/* To be used only when the state is known to be valid */
-
-        /* common constants */
-
-#ifndef DEF_WBITS
-#  define DEF_WBITS MAX_WBITS
-#endif
-/* default windowBits for decompression. MAX_WBITS is for compression only */
-
-#if MAX_MEM_LEVEL >= 8
-#  define DEF_MEM_LEVEL 8
-#else
-#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
-#endif
-/* default memLevel */
-
-#define STORED_BLOCK 0
-#define STATIC_TREES 1
-#define DYN_TREES    2
-/* The three kinds of block type */
-
-#define MIN_MATCH  3
-#define MAX_MATCH  258
-/* The minimum and maximum match lengths */
-
-#define PRESET_DICT 0x20 /* preset dictionary flag in zlib header */
-
-        /* target dependencies */
-
-#if defined(MSDOS) || (defined(WINDOWS) && !defined(WIN32))
-#  define OS_CODE  0x00
-#  ifndef Z_SOLO
-#    if defined(__TURBOC__) || defined(__BORLANDC__)
-#      if (__STDC__ == 1) && (defined(__LARGE__) || defined(__COMPACT__))
-         /* Allow compilation with ANSI keywords only enabled */
-         void _Cdecl farfree( void *block );
-         void *_Cdecl farmalloc( unsigned long nbytes );
-#      else
-#        include <alloc.h>
-#      endif
-#    else /* MSC or DJGPP */
-#      include <malloc.h>
-#    endif
-#  endif
-#endif
-
-#ifdef AMIGA
-#  define OS_CODE  1
-#endif
-
-#if defined(VAXC) || defined(VMS)
-#  define OS_CODE  2
-#  define F_OPEN(name, mode) \
-     fopen((name), (mode), "mbc=60", "ctx=stm", "rfm=fix", "mrs=512")
-#endif
-
-#ifdef __370__
-#  if __TARGET_LIB__ < 0x20000000
-#    define OS_CODE 4
-#  elif __TARGET_LIB__ < 0x40000000
-#    define OS_CODE 11
-#  else
-#    define OS_CODE 8
-#  endif
-#endif
-
-#if defined(ATARI) || defined(atarist)
-#  define OS_CODE  5
-#endif
-
-#ifdef OS2
-#  define OS_CODE  6
-#  if defined(M_I86) && !defined(Z_SOLO)
-#    include <malloc.h>
-#  endif
-#endif
-
-#if defined(MACOS) || defined(TARGET_OS_MAC)
-#  define OS_CODE  7
-#  ifndef Z_SOLO
-#    if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
-#      include <unix.h> /* for fdopen */
-#    else
-#      ifndef fdopen
-#        define fdopen(fd,mode) NULL /* No fdopen() */
-#      endif
-#    endif
-#  endif
-#endif
-
-#ifdef __acorn
-#  define OS_CODE 13
-#endif
-
-#if defined(WIN32) && !defined(__CYGWIN__)
-#  define OS_CODE  10
-#endif
-
-#ifdef _BEOS_
-#  define OS_CODE  16
-#endif
-
-#ifdef __TOS_OS400__
-#  define OS_CODE 18
-#endif
-
-#ifdef __APPLE__
-#  define OS_CODE 19
-#endif
-
-#if defined(_BEOS_) || defined(RISCOS)
-#  define fdopen(fd,mode) NULL /* No fdopen() */
-#endif
-
-#if (defined(_MSC_VER) && (_MSC_VER > 600)) && !defined __INTERIX
-#  if defined(_WIN32_WCE)
-#    define fdopen(fd,mode) NULL /* No fdopen() */
-#    ifndef _PTRDIFF_T_DEFINED
-       typedef int ptrdiff_t;
-#      define _PTRDIFF_T_DEFINED
-#    endif
-#  else
-#    define fdopen(fd,type)  _fdopen(fd,type)
-#  endif
-#endif
-
-#if defined(__BORLANDC__) && !defined(MSDOS)
-  #pragma warn -8004
-  #pragma warn -8008
-  #pragma warn -8066
-#endif
-
-/* provide prototypes for these when building zlib without LFS */
-#if !defined(_WIN32) && \
-    (!defined(_LARGEFILE64_SOURCE) || _LFS64_LARGEFILE-0 == 0)
-    ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));
-    ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));
-#endif
-
-        /* common defaults */
-
-#ifndef OS_CODE
-#  define OS_CODE  3     /* assume Unix */
-#endif
-
-#ifndef F_OPEN
-#  define F_OPEN(name, mode) fopen((name), (mode))
-#endif
-
-         /* functions */
-
-#if defined(pyr) || defined(Z_SOLO)
-#  define NO_MEMCPY
-#endif
-#if defined(SMALL_MEDIUM) && !defined(_MSC_VER) && !defined(__SC__)
- /* Use our own functions for small and medium model with MSC <= 5.0.
-  * You may have to use the same strategy for Borland C (untested).
-  * The __SC__ check is for Symantec.
-  */
-#  define NO_MEMCPY
-#endif
-#if defined(STDC) && !defined(HAVE_MEMCPY) && !defined(NO_MEMCPY)
-#  define HAVE_MEMCPY
-#endif
-#ifdef HAVE_MEMCPY
-#  ifdef SMALL_MEDIUM /* MSDOS small or medium model */
-#    define zmemcpy _fmemcpy
-#    define zmemcmp _fmemcmp
-#    define zmemzero(dest, len) _fmemset(dest, 0, len)
-#  else
-#    define zmemcpy memcpy
-#    define zmemcmp memcmp
-#    define zmemzero(dest, len) memset(dest, 0, len)
-#  endif
-#else
-   void ZLIB_INTERNAL zmemcpy OF((Bytef* dest, const Bytef* source, uInt len));
-   int ZLIB_INTERNAL zmemcmp OF((const Bytef* s1, const Bytef* s2, uInt len));
-   void ZLIB_INTERNAL zmemzero OF((Bytef* dest, uInt len));
-#endif
-
-/* Diagnostic functions */
-#ifdef ZLIB_DEBUG
-#  include <stdio.h>
-   extern int ZLIB_INTERNAL z_verbose;
-   extern void ZLIB_INTERNAL z_error OF((char *m));
-#  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
-#  define Trace(x) {if (z_verbose>=0) fprintf x ;}
-#  define Tracev(x) {if (z_verbose>0) fprintf x ;}
-#  define Tracevv(x) {if (z_verbose>1) fprintf x ;}
-#  define Tracec(c,x) {if (z_verbose>0 && (c)) fprintf x ;}
-#  define Tracecv(c,x) {if (z_verbose>1 && (c)) fprintf x ;}
-#else
-#  define Assert(cond,msg)
-#  define Trace(x)
-#  define Tracev(x)
-#  define Tracevv(x)
-#  define Tracec(c,x)
-#  define Tracecv(c,x)
-#endif
-
-#ifndef Z_SOLO
-   voidpf ZLIB_INTERNAL zcalloc OF((voidpf opaque, unsigned items,
-                                    unsigned size));
-   void ZLIB_INTERNAL zcfree  OF((voidpf opaque, voidpf ptr));
-#endif
-
-#define ZALLOC(strm, items, size) \
-           (*((strm)->zalloc))((strm)->opaque, (items), (size))
-#define ZFREE(strm, addr)  (*((strm)->zfree))((strm)->opaque, (voidpf)(addr))
-#define TRY_FREE(s, p) {if (p) ZFREE(s, p);}
-
-/* Reverse the bytes in a 32-bit value */
-#define ZSWAP32(q) ((((q) >> 24) & 0xff) + (((q) >> 8) & 0xff00) + \
-                    (((q) & 0xff00) << 8) + (((q) & 0xff) << 24))
-
-#endif /* ZUTIL_H */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/installVersion
+++ /dev/null
@@ -1 +0,0 @@
-9
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/async-wrap-inl.h
+++ /dev/null
@@ -1,56 +0,0 @@
-#ifndef SRC_ASYNC_WRAP_INL_H_
-#define SRC_ASYNC_WRAP_INL_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "async-wrap.h"
-#include "base-object.h"
-#include "base-object-inl.h"
-#include "env.h"
-#include "env-inl.h"
-#include "node_internals.h"
-#include "util.h"
-#include "util-inl.h"
-#include "v8.h"
-
-namespace node {
-
-inline bool AsyncWrap::ran_init_callback() const {
-  return static_cast<bool>(bits_ & 1);
-}
-
-
-inline AsyncWrap::ProviderType AsyncWrap::provider_type() const {
-  return static_cast<ProviderType>(bits_ >> 1);
-}
-
-
-inline int64_t AsyncWrap::get_uid() const {
-  return uid_;
-}
-
-
-inline v8::Local<v8::Value> AsyncWrap::MakeCallback(
-    const v8::Local<v8::String> symbol,
-    int argc,
-    v8::Local<v8::Value>* argv) {
-  v8::Local<v8::Value> cb_v = object()->Get(symbol);
-  CHECK(cb_v->IsFunction());
-  return MakeCallback(cb_v.As<v8::Function>(), argc, argv);
-}
-
-
-inline v8::Local<v8::Value> AsyncWrap::MakeCallback(
-    uint32_t index,
-    int argc,
-    v8::Local<v8::Value>* argv) {
-  v8::Local<v8::Value> cb_v = object()->Get(index);
-  CHECK(cb_v->IsFunction());
-  return MakeCallback(cb_v.As<v8::Function>(), argc, argv);
-}
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_ASYNC_WRAP_INL_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/async-wrap.h
+++ /dev/null
@@ -1,100 +0,0 @@
-#ifndef SRC_ASYNC_WRAP_H_
-#define SRC_ASYNC_WRAP_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "base-object.h"
-#include "uv.h"
-#include "v8.h"
-
-#include <stdint.h>
-
-namespace node {
-
-#define NODE_ASYNC_ID_OFFSET 0xA1C
-
-#define NODE_ASYNC_PROVIDER_TYPES(V)                                          \
-  V(NONE)                                                                     \
-  V(CRYPTO)                                                                   \
-  V(FSEVENTWRAP)                                                              \
-  V(FSREQWRAP)                                                                \
-  V(GETADDRINFOREQWRAP)                                                       \
-  V(GETNAMEINFOREQWRAP)                                                       \
-  V(HTTPPARSER)                                                               \
-  V(JSSTREAM)                                                                 \
-  V(PIPEWRAP)                                                                 \
-  V(PIPECONNECTWRAP)                                                          \
-  V(PROCESSWRAP)                                                              \
-  V(QUERYWRAP)                                                                \
-  V(SHUTDOWNWRAP)                                                             \
-  V(SIGNALWRAP)                                                               \
-  V(STATWATCHER)                                                              \
-  V(TCPWRAP)                                                                  \
-  V(TCPCONNECTWRAP)                                                           \
-  V(TIMERWRAP)                                                                \
-  V(TLSWRAP)                                                                  \
-  V(TTYWRAP)                                                                  \
-  V(UDPWRAP)                                                                  \
-  V(UDPSENDWRAP)                                                              \
-  V(WRITEWRAP)                                                                \
-  V(ZLIB)
-
-class Environment;
-
-class AsyncWrap : public BaseObject {
- public:
-  enum ProviderType {
-#define V(PROVIDER)                                                           \
-    PROVIDER_ ## PROVIDER,
-    NODE_ASYNC_PROVIDER_TYPES(V)
-#undef V
-  };
-
-  AsyncWrap(Environment* env,
-            v8::Local<v8::Object> object,
-            ProviderType provider,
-            AsyncWrap* parent = nullptr);
-
-  virtual ~AsyncWrap();
-
-  static void Initialize(v8::Local<v8::Object> target,
-                         v8::Local<v8::Value> unused,
-                         v8::Local<v8::Context> context);
-
-  static void DestroyIdsCb(uv_idle_t* handle);
-
-  inline ProviderType provider_type() const;
-
-  inline int64_t get_uid() const;
-
-  // Only call these within a valid HandleScope.
-  v8::Local<v8::Value> MakeCallback(const v8::Local<v8::Function> cb,
-                                     int argc,
-                                     v8::Local<v8::Value>* argv);
-  inline v8::Local<v8::Value> MakeCallback(const v8::Local<v8::String> symbol,
-                                            int argc,
-                                            v8::Local<v8::Value>* argv);
-  inline v8::Local<v8::Value> MakeCallback(uint32_t index,
-                                            int argc,
-                                            v8::Local<v8::Value>* argv);
-
-  virtual size_t self_size() const = 0;
-
- private:
-  inline AsyncWrap();
-  inline bool ran_init_callback() const;
-
-  // When the async hooks init JS function is called from the constructor it is
-  // expected the context object will receive a _asyncQueue object property
-  // that will be used to call pre/post in MakeCallback.
-  uint32_t bits_;
-  const int64_t uid_;
-};
-
-void LoadAsyncWrapperInfo(Environment* env);
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_ASYNC_WRAP_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/base-object-inl.h
+++ /dev/null
@@ -1,75 +0,0 @@
-#ifndef SRC_BASE_OBJECT_INL_H_
-#define SRC_BASE_OBJECT_INL_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "base-object.h"
-#include "env.h"
-#include "env-inl.h"
-#include "util.h"
-#include "util-inl.h"
-#include "v8.h"
-
-namespace node {
-
-inline BaseObject::BaseObject(Environment* env, v8::Local<v8::Object> handle)
-    : persistent_handle_(env->isolate(), handle),
-      env_(env) {
-  CHECK_EQ(false, handle.IsEmpty());
-  // The zero field holds a pointer to the handle. Immediately set it to
-  // nullptr in case it's accessed by the user before construction is complete.
-  if (handle->InternalFieldCount() > 0)
-    handle->SetAlignedPointerInInternalField(0, nullptr);
-}
-
-
-inline BaseObject::~BaseObject() {
-  CHECK(persistent_handle_.IsEmpty());
-}
-
-
-inline v8::Persistent<v8::Object>& BaseObject::persistent() {
-  return persistent_handle_;
-}
-
-
-inline v8::Local<v8::Object> BaseObject::object() {
-  return PersistentToLocal(env_->isolate(), persistent_handle_);
-}
-
-
-inline Environment* BaseObject::env() const {
-  return env_;
-}
-
-
-template <typename Type>
-inline void BaseObject::WeakCallback(
-    const v8::WeakCallbackInfo<Type>& data) {
-  Type* self = data.GetParameter();
-  self->persistent().Reset();
-  delete self;
-}
-
-
-template <typename Type>
-inline void BaseObject::MakeWeak(Type* ptr) {
-  v8::HandleScope scope(env_->isolate());
-  v8::Local<v8::Object> handle = object();
-  CHECK_GT(handle->InternalFieldCount(), 0);
-  Wrap(handle, ptr);
-  persistent_handle_.MarkIndependent();
-  persistent_handle_.SetWeak<Type>(ptr, WeakCallback<Type>,
-                                   v8::WeakCallbackType::kParameter);
-}
-
-
-inline void BaseObject::ClearWeak() {
-  persistent_handle_.ClearWeak();
-}
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_BASE_OBJECT_INL_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/base-object.h
+++ /dev/null
@@ -1,55 +0,0 @@
-#ifndef SRC_BASE_OBJECT_H_
-#define SRC_BASE_OBJECT_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "v8.h"
-
-namespace node {
-
-class Environment;
-
-class BaseObject {
- public:
-  inline BaseObject(Environment* env, v8::Local<v8::Object> handle);
-  inline virtual ~BaseObject();
-
-  // Returns the wrapped object.  Returns an empty handle when
-  // persistent.IsEmpty() is true.
-  inline v8::Local<v8::Object> object();
-
-  // The parent class is responsible for calling .Reset() on destruction
-  // when the persistent handle is strong because there is no way for
-  // BaseObject to know when the handle goes out of scope.
-  // Weak handles have been reset by the time the destructor runs but
-  // calling .Reset() again is harmless.
-  inline v8::Persistent<v8::Object>& persistent();
-
-  inline Environment* env() const;
-
-  // The handle_ must have an internal field count > 0, and the first
-  // index is reserved for a pointer to this class. This is an
-  // implicit requirement, but Node does not have a case where it's
-  // required that MakeWeak() be called and the internal field not
-  // be set.
-  template <typename Type>
-  inline void MakeWeak(Type* ptr);
-
-  inline void ClearWeak();
-
- private:
-  BaseObject();
-
-  template <typename Type>
-  static inline void WeakCallback(
-      const v8::WeakCallbackInfo<Type>& data);
-
-  v8::Persistent<v8::Object> persistent_handle_;
-  Environment* env_;
-};
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_BASE_OBJECT_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/base64.h
+++ /dev/null
@@ -1,195 +0,0 @@
-#ifndef SRC_BASE64_H_
-#define SRC_BASE64_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "util.h"
-
-#include <stddef.h>
-
-namespace node {
-//// Base 64 ////
-#define base64_encoded_size(size) ((size + 2 - ((size + 2) % 3)) / 3 * 4)
-
-
-// Doesn't check for padding at the end.  Can be 1-2 bytes over.
-static inline size_t base64_decoded_size_fast(size_t size) {
-  size_t remainder = size % 4;
-
-  size = (size / 4) * 3;
-  if (remainder) {
-    if (size == 0 && remainder == 1) {
-      // special case: 1-byte input cannot be decoded
-      size = 0;
-    } else {
-      // non-padded input, add 1 or 2 extra bytes
-      size += 1 + (remainder == 3);
-    }
-  }
-
-  return size;
-}
-
-template <typename TypeName>
-size_t base64_decoded_size(const TypeName* src, size_t size) {
-  if (size == 0)
-    return 0;
-
-  if (src[size - 1] == '=')
-    size--;
-  if (size > 0 && src[size - 1] == '=')
-    size--;
-
-  return base64_decoded_size_fast(size);
-}
-
-
-extern const int8_t unbase64_table[256];
-
-
-#define unbase64(x)                                                           \
-  static_cast<uint8_t>(unbase64_table[static_cast<uint8_t>(x)])
-
-
-template <typename TypeName>
-bool base64_decode_group_slow(char* const dst, const size_t dstlen,
-                              const TypeName* const src, const size_t srclen,
-                              size_t* const i, size_t* const k) {
-  uint8_t hi;
-  uint8_t lo;
-#define V(expr)                                                               \
-  for (;;) {                                                                  \
-    const uint8_t c = src[*i];                                                \
-    lo = unbase64(c);                                                         \
-    *i += 1;                                                                  \
-    if (lo < 64)                                                              \
-      break;  /* Legal character. */                                          \
-    if (c == '=' || *i >= srclen)                                             \
-      return false;  /* Stop decoding. */                                     \
-  }                                                                           \
-  expr;                                                                       \
-  if (*i >= srclen)                                                           \
-    return false;                                                             \
-  if (*k >= dstlen)                                                           \
-    return false;                                                             \
-  hi = lo;
-  V(/* Nothing. */);
-  V(dst[(*k)++] = ((hi & 0x3F) << 2) | ((lo & 0x30) >> 4));
-  V(dst[(*k)++] = ((hi & 0x0F) << 4) | ((lo & 0x3C) >> 2));
-  V(dst[(*k)++] = ((hi & 0x03) << 6) | ((lo & 0x3F) >> 0));
-#undef V
-  return true;  // Continue decoding.
-}
-
-
-template <typename TypeName>
-size_t base64_decode_fast(char* const dst, const size_t dstlen,
-                          const TypeName* const src, const size_t srclen,
-                          const size_t decoded_size) {
-  const size_t available = dstlen < decoded_size ? dstlen : decoded_size;
-  const size_t max_k = available / 3 * 3;
-  size_t max_i = srclen / 4 * 4;
-  size_t i = 0;
-  size_t k = 0;
-  while (i < max_i && k < max_k) {
-    const uint32_t v =
-        unbase64(src[i + 0]) << 24 |
-        unbase64(src[i + 1]) << 16 |
-        unbase64(src[i + 2]) << 8 |
-        unbase64(src[i + 3]);
-    // If MSB is set, input contains whitespace or is not valid base64.
-    if (v & 0x80808080) {
-      const size_t old_i = i;
-      if (!base64_decode_group_slow(dst, dstlen, src, srclen, &i, &k))
-        return k;
-      max_i = old_i + (srclen - i) / 4 * 4;  // Align max_i again.
-    } else {
-      dst[k + 0] = ((v >> 22) & 0xFC) | ((v >> 20) & 0x03);
-      dst[k + 1] = ((v >> 12) & 0xF0) | ((v >> 10) & 0x0F);
-      dst[k + 2] = ((v >>  2) & 0xC0) | ((v >>  0) & 0x3F);
-      i += 4;
-      k += 3;
-    }
-  }
-  if (i < srclen && k < dstlen) {
-    base64_decode_group_slow(dst, dstlen, src, srclen, &i, &k);
-  }
-  return k;
-}
-
-
-template <typename TypeName>
-size_t base64_decode(char* const dst, const size_t dstlen,
-                     const TypeName* const src, const size_t srclen) {
-  const size_t decoded_size = base64_decoded_size(src, srclen);
-  return base64_decode_fast(dst, dstlen, src, srclen, decoded_size);
-}
-
-static size_t base64_encode(const char* src,
-                            size_t slen,
-                            char* dst,
-                            size_t dlen) {
-  // We know how much we'll write, just make sure that there's space.
-  CHECK(dlen >= base64_encoded_size(slen) &&
-        "not enough space provided for base64 encode");
-
-  dlen = base64_encoded_size(slen);
-
-  unsigned a;
-  unsigned b;
-  unsigned c;
-  unsigned i;
-  unsigned k;
-  unsigned n;
-
-  static const char table[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
-                              "abcdefghijklmnopqrstuvwxyz"
-                              "0123456789+/";
-
-  i = 0;
-  k = 0;
-  n = slen / 3 * 3;
-
-  while (i < n) {
-    a = src[i + 0] & 0xff;
-    b = src[i + 1] & 0xff;
-    c = src[i + 2] & 0xff;
-
-    dst[k + 0] = table[a >> 2];
-    dst[k + 1] = table[((a & 3) << 4) | (b >> 4)];
-    dst[k + 2] = table[((b & 0x0f) << 2) | (c >> 6)];
-    dst[k + 3] = table[c & 0x3f];
-
-    i += 3;
-    k += 4;
-  }
-
-  if (n != slen) {
-    switch (slen - n) {
-      case 1:
-        a = src[i + 0] & 0xff;
-        dst[k + 0] = table[a >> 2];
-        dst[k + 1] = table[(a & 3) << 4];
-        dst[k + 2] = '=';
-        dst[k + 3] = '=';
-        break;
-
-      case 2:
-        a = src[i + 0] & 0xff;
-        b = src[i + 1] & 0xff;
-        dst[k + 0] = table[a >> 2];
-        dst[k + 1] = table[((a & 3) << 4) | (b >> 4)];
-        dst[k + 2] = table[(b & 0x0f) << 2];
-        dst[k + 3] = '=';
-        break;
-    }
-  }
-
-  return dlen;
-}
-}  // namespace node
-
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_BASE64_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/connect_wrap.h
+++ /dev/null
@@ -1,26 +0,0 @@
-#ifndef SRC_CONNECT_WRAP_H_
-#define SRC_CONNECT_WRAP_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "env.h"
-#include "req-wrap.h"
-#include "async-wrap.h"
-#include "v8.h"
-
-namespace node {
-
-class ConnectWrap : public ReqWrap<uv_connect_t> {
- public:
-  ConnectWrap(Environment* env,
-              v8::Local<v8::Object> req_wrap_obj,
-              AsyncWrap::ProviderType provider);
-
-  size_t self_size() const override { return sizeof(*this); }
-};
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_CONNECT_WRAP_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/connection_wrap.h
+++ /dev/null
@@ -1,38 +0,0 @@
-#ifndef SRC_CONNECTION_WRAP_H_
-#define SRC_CONNECTION_WRAP_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "env.h"
-#include "stream_wrap.h"
-#include "v8.h"
-
-namespace node {
-
-template <typename WrapType, typename UVType>
-class ConnectionWrap : public StreamWrap {
- public:
-  UVType* UVHandle() {
-    return &handle_;
-  }
-
-  static void OnConnection(uv_stream_t* handle, int status);
-  static void AfterConnect(uv_connect_t* req, int status);
-
- protected:
-  ConnectionWrap(Environment* env,
-                 v8::Local<v8::Object> object,
-                 ProviderType provider,
-                 AsyncWrap* parent);
-  ~ConnectionWrap() {
-  }
-
-  UVType handle_;
-};
-
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_CONNECTION_WRAP_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/debug-agent.h
+++ /dev/null
@@ -1,142 +0,0 @@
-// Copyright Fedor Indutny and other Node contributors.
-//
-// Permission is hereby granted, free of charge, to any person obtaining a
-// copy of this software and associated documentation files (the
-// "Software"), to deal in the Software without restriction, including
-// without limitation the rights to use, copy, modify, merge, publish,
-// distribute, sublicense, and/or sell copies of the Software, and to permit
-// persons to whom the Software is furnished to do so, subject to the
-// following conditions:
-//
-// The above copyright notice and this permission notice shall be included
-// in all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
-// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
-// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
-// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
-// USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-#ifndef SRC_DEBUG_AGENT_H_
-#define SRC_DEBUG_AGENT_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "node_mutex.h"
-#include "node_debug_options.h"
-#include "util.h"
-#include "util-inl.h"
-#include "uv.h"
-#include "v8.h"
-#include "v8-debug.h"
-
-#include <string.h>
-#include <string>
-
-// Forward declaration to break recursive dependency chain with src/env.h.
-namespace node {
-class Environment;
-}  // namespace node
-
-namespace node {
-namespace debugger {
-
-class AgentMessage {
- public:
-  AgentMessage(uint16_t* val, int length) : length_(length) {
-    if (val == nullptr) {
-      data_ = val;
-    } else {
-      data_ = new uint16_t[length];
-      memcpy(data_, val, length * sizeof(*data_));
-    }
-  }
-
-  ~AgentMessage() {
-    delete[] data_;
-    data_ = nullptr;
-  }
-
-  inline const uint16_t* data() const { return data_; }
-  inline int length() const { return length_; }
-
-  ListNode<AgentMessage> member;
-
- private:
-  uint16_t* data_;
-  int length_;
-};
-
-class Agent {
- public:
-  explicit Agent(node::Environment* env);
-  ~Agent();
-
-  typedef void (*DispatchHandler)(node::Environment* env);
-
-  // Start the debugger agent thread
-  bool Start(const DebugOptions& options);
-  // Listen for debug events
-  void Enable();
-  // Stop the debugger agent
-  void Stop();
-
-  inline void set_dispatch_handler(DispatchHandler handler) {
-    dispatch_handler_ = handler;
-  }
-
-  inline node::Environment* parent_env() const { return parent_env_; }
-  inline node::Environment* child_env() const { return child_env_; }
-
- protected:
-  void InitAdaptor(Environment* env);
-
-  // Worker body
-  void WorkerRun();
-
-  static void ThreadCb(Agent* agent);
-  static void ParentSignalCb(uv_async_t* signal);
-  static void ChildSignalCb(uv_async_t* signal);
-  static void MessageHandler(const v8::Debug::Message& message);
-
-  // V8 API
-  static Agent* Unwrap(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void NotifyListen(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void NotifyWait(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void SendCommand(const v8::FunctionCallbackInfo<v8::Value>& args);
-
-  void EnqueueMessage(AgentMessage* message);
-
-  enum State {
-    kNone,
-    kRunning
-  };
-
-  State state_;
-  DebugOptions options_;
-
-  bool wait_;
-
-  uv_sem_t start_sem_;
-  node::Mutex message_mutex_;
-  uv_async_t child_signal_;
-
-  uv_thread_t thread_;
-  node::Environment* parent_env_;
-  node::Environment* child_env_;
-  uv_loop_t child_loop_;
-  v8::Persistent<v8::Object> api_;
-
-  ListHead<AgentMessage, &AgentMessage::member> messages_;
-
-  DispatchHandler dispatch_handler_;
-};
-
-}  // namespace debugger
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_DEBUG_AGENT_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/env-inl.h
+++ /dev/null
@@ -1,514 +0,0 @@
-#ifndef SRC_ENV_INL_H_
-#define SRC_ENV_INL_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "env.h"
-#include "node.h"
-#include "util.h"
-#include "util-inl.h"
-#include "uv.h"
-#include "v8.h"
-
-#include <stddef.h>
-#include <stdint.h>
-
-namespace node {
-
-// Create string properties as internalized one byte strings.
-//
-// Internalized because it makes property lookups a little faster and because
-// the string is created in the old space straight away.  It's going to end up
-// in the old space sooner or later anyway but now it doesn't go through
-// v8::Eternal's new space handling first.
-//
-// One byte because our strings are ASCII and we can safely skip V8's UTF-8
-// decoding step.  It's a one-time cost, but why pay it when you don't have to?
-inline IsolateData::IsolateData(v8::Isolate* isolate, uv_loop_t* event_loop,
-                                uint32_t* zero_fill_field)
-    :
-#define V(PropertyName, StringValue)                                          \
-    PropertyName ## _(                                                        \
-        isolate,                                                              \
-        v8::Private::New(                                                     \
-            isolate,                                                          \
-            v8::String::NewFromOneByte(                                       \
-                isolate,                                                      \
-                reinterpret_cast<const uint8_t*>(StringValue),                \
-                v8::NewStringType::kInternalized,                             \
-                sizeof(StringValue) - 1).ToLocalChecked())),
-  PER_ISOLATE_PRIVATE_SYMBOL_PROPERTIES(V)
-#undef V
-#define V(PropertyName, StringValue)                                          \
-    PropertyName ## _(                                                        \
-        isolate,                                                              \
-        v8::String::NewFromOneByte(                                           \
-            isolate,                                                          \
-            reinterpret_cast<const uint8_t*>(StringValue),                    \
-            v8::NewStringType::kInternalized,                                 \
-            sizeof(StringValue) - 1).ToLocalChecked()),
-    PER_ISOLATE_STRING_PROPERTIES(V)
-#undef V
-    event_loop_(event_loop), zero_fill_field_(zero_fill_field) {}
-
-inline uv_loop_t* IsolateData::event_loop() const {
-  return event_loop_;
-}
-
-inline uint32_t* IsolateData::zero_fill_field() const {
-  return zero_fill_field_;
-}
-
-inline Environment::AsyncHooks::AsyncHooks() {
-  for (int i = 0; i < kFieldsCount; i++) fields_[i] = 0;
-}
-
-inline uint32_t* Environment::AsyncHooks::fields() {
-  return fields_;
-}
-
-inline int Environment::AsyncHooks::fields_count() const {
-  return kFieldsCount;
-}
-
-inline bool Environment::AsyncHooks::callbacks_enabled() {
-  return fields_[kEnableCallbacks] != 0;
-}
-
-inline void Environment::AsyncHooks::set_enable_callbacks(uint32_t flag) {
-  fields_[kEnableCallbacks] = flag;
-}
-
-inline Environment::AsyncCallbackScope::AsyncCallbackScope(Environment* env)
-    : env_(env) {
-  env_->makecallback_cntr_++;
-}
-
-inline Environment::AsyncCallbackScope::~AsyncCallbackScope() {
-  env_->makecallback_cntr_--;
-}
-
-inline bool Environment::AsyncCallbackScope::in_makecallback() {
-  return env_->makecallback_cntr_ > 1;
-}
-
-inline Environment::DomainFlag::DomainFlag() {
-  for (int i = 0; i < kFieldsCount; ++i) fields_[i] = 0;
-}
-
-inline uint32_t* Environment::DomainFlag::fields() {
-  return fields_;
-}
-
-inline int Environment::DomainFlag::fields_count() const {
-  return kFieldsCount;
-}
-
-inline uint32_t Environment::DomainFlag::count() const {
-  return fields_[kCount];
-}
-
-inline Environment::TickInfo::TickInfo() {
-  for (int i = 0; i < kFieldsCount; ++i)
-    fields_[i] = 0;
-}
-
-inline uint32_t* Environment::TickInfo::fields() {
-  return fields_;
-}
-
-inline int Environment::TickInfo::fields_count() const {
-  return kFieldsCount;
-}
-
-inline uint32_t Environment::TickInfo::index() const {
-  return fields_[kIndex];
-}
-
-inline uint32_t Environment::TickInfo::length() const {
-  return fields_[kLength];
-}
-
-inline void Environment::TickInfo::set_index(uint32_t value) {
-  fields_[kIndex] = value;
-}
-
-inline void Environment::AssignToContext(v8::Local<v8::Context> context) {
-  context->SetAlignedPointerInEmbedderData(kContextEmbedderDataIndex, this);
-}
-
-inline Environment* Environment::GetCurrent(v8::Isolate* isolate) {
-  return GetCurrent(isolate->GetCurrentContext());
-}
-
-inline Environment* Environment::GetCurrent(v8::Local<v8::Context> context) {
-  return static_cast<Environment*>(
-      context->GetAlignedPointerFromEmbedderData(kContextEmbedderDataIndex));
-}
-
-inline Environment* Environment::GetCurrent(
-    const v8::FunctionCallbackInfo<v8::Value>& info) {
-  ASSERT(info.Data()->IsExternal());
-  return static_cast<Environment*>(info.Data().As<v8::External>()->Value());
-}
-
-template <typename T>
-inline Environment* Environment::GetCurrent(
-    const v8::PropertyCallbackInfo<T>& info) {
-  ASSERT(info.Data()->IsExternal());
-  // XXX(bnoordhuis) Work around a g++ 4.9.2 template type inferrer bug
-  // when the expression is written as info.Data().As<v8::External>().
-  v8::Local<v8::Value> data = info.Data();
-  return static_cast<Environment*>(data.As<v8::External>()->Value());
-}
-
-inline Environment::Environment(IsolateData* isolate_data,
-                                v8::Local<v8::Context> context)
-    : isolate_(context->GetIsolate()),
-      isolate_data_(isolate_data),
-      timer_base_(uv_now(isolate_data->event_loop())),
-      using_domains_(false),
-      printed_error_(false),
-      trace_sync_io_(false),
-      makecallback_cntr_(0),
-      async_wrap_uid_(0),
-      debugger_agent_(this),
-#if HAVE_INSPECTOR
-      inspector_agent_(this),
-#endif
-      handle_cleanup_waiting_(0),
-      http_parser_buffer_(nullptr),
-      context_(context->GetIsolate(), context) {
-  // We'll be creating new objects so make sure we've entered the context.
-  v8::HandleScope handle_scope(isolate());
-  v8::Context::Scope context_scope(context);
-  set_as_external(v8::External::New(isolate(), this));
-  set_binding_cache_object(v8::Object::New(isolate()));
-  set_module_load_list_array(v8::Array::New(isolate()));
-
-  v8::Local<v8::FunctionTemplate> fn = v8::FunctionTemplate::New(isolate());
-  fn->SetClassName(FIXED_ONE_BYTE_STRING(isolate(), "InternalFieldObject"));
-  v8::Local<v8::ObjectTemplate> obj = fn->InstanceTemplate();
-  obj->SetInternalFieldCount(1);
-  set_generic_internal_field_template(obj);
-
-  RB_INIT(&cares_task_list_);
-  AssignToContext(context);
-
-  destroy_ids_list_.reserve(512);
-}
-
-inline Environment::~Environment() {
-  v8::HandleScope handle_scope(isolate());
-
-  while (HandleCleanup* hc = handle_cleanup_queue_.PopFront()) {
-    handle_cleanup_waiting_++;
-    hc->cb_(this, hc->handle_, hc->arg_);
-    delete hc;
-  }
-
-  while (handle_cleanup_waiting_ != 0)
-    uv_run(event_loop(), UV_RUN_ONCE);
-
-  // Closing the destroy_ids_idle_handle_ within the handle cleanup queue
-  // prevents the async wrap destroy hook from being called.
-  uv_handle_t* handle =
-    reinterpret_cast<uv_handle_t*>(&destroy_ids_idle_handle_);
-  handle->data = this;
-  handle_cleanup_waiting_ = 1;
-  uv_close(handle, [](uv_handle_t* handle) {
-    static_cast<Environment*>(handle->data)->FinishHandleCleanup(handle);
-  });
-
-  while (handle_cleanup_waiting_ != 0)
-    uv_run(event_loop(), UV_RUN_ONCE);
-
-  context()->SetAlignedPointerInEmbedderData(kContextEmbedderDataIndex,
-                                             nullptr);
-#define V(PropertyName, TypeName) PropertyName ## _.Reset();
-  ENVIRONMENT_STRONG_PERSISTENT_PROPERTIES(V)
-#undef V
-
-  delete[] heap_statistics_buffer_;
-  delete[] heap_space_statistics_buffer_;
-  delete[] http_parser_buffer_;
-}
-
-inline v8::Isolate* Environment::isolate() const {
-  return isolate_;
-}
-
-inline bool Environment::async_wrap_callbacks_enabled() const {
-  // The const_cast is okay, it doesn't violate conceptual const-ness.
-  return const_cast<Environment*>(this)->async_hooks()->callbacks_enabled();
-}
-
-inline bool Environment::in_domain() const {
-  // The const_cast is okay, it doesn't violate conceptual const-ness.
-  return using_domains() &&
-         const_cast<Environment*>(this)->domain_flag()->count() > 0;
-}
-
-inline Environment* Environment::from_immediate_check_handle(
-    uv_check_t* handle) {
-  return ContainerOf(&Environment::immediate_check_handle_, handle);
-}
-
-inline uv_check_t* Environment::immediate_check_handle() {
-  return &immediate_check_handle_;
-}
-
-inline uv_idle_t* Environment::immediate_idle_handle() {
-  return &immediate_idle_handle_;
-}
-
-inline Environment* Environment::from_destroy_ids_idle_handle(
-    uv_idle_t* handle) {
-  return ContainerOf(&Environment::destroy_ids_idle_handle_, handle);
-}
-
-inline uv_idle_t* Environment::destroy_ids_idle_handle() {
-  return &destroy_ids_idle_handle_;
-}
-
-inline void Environment::RegisterHandleCleanup(uv_handle_t* handle,
-                                               HandleCleanupCb cb,
-                                               void *arg) {
-  handle_cleanup_queue_.PushBack(new HandleCleanup(handle, cb, arg));
-}
-
-inline void Environment::FinishHandleCleanup(uv_handle_t* handle) {
-  handle_cleanup_waiting_--;
-}
-
-inline uv_loop_t* Environment::event_loop() const {
-  return isolate_data()->event_loop();
-}
-
-inline Environment::AsyncHooks* Environment::async_hooks() {
-  return &async_hooks_;
-}
-
-inline Environment::DomainFlag* Environment::domain_flag() {
-  return &domain_flag_;
-}
-
-inline Environment::TickInfo* Environment::tick_info() {
-  return &tick_info_;
-}
-
-inline uint64_t Environment::timer_base() const {
-  return timer_base_;
-}
-
-inline bool Environment::using_domains() const {
-  return using_domains_;
-}
-
-inline void Environment::set_using_domains(bool value) {
-  using_domains_ = value;
-}
-
-inline bool Environment::printed_error() const {
-  return printed_error_;
-}
-
-inline void Environment::set_printed_error(bool value) {
-  printed_error_ = value;
-}
-
-inline void Environment::set_trace_sync_io(bool value) {
-  trace_sync_io_ = value;
-}
-
-inline int64_t Environment::get_async_wrap_uid() {
-  return ++async_wrap_uid_;
-}
-
-inline std::vector<int64_t>* Environment::destroy_ids_list() {
-  return &destroy_ids_list_;
-}
-
-inline double* Environment::heap_statistics_buffer() const {
-  CHECK_NE(heap_statistics_buffer_, nullptr);
-  return heap_statistics_buffer_;
-}
-
-inline void Environment::set_heap_statistics_buffer(double* pointer) {
-  CHECK_EQ(heap_statistics_buffer_, nullptr);  // Should be set only once.
-  heap_statistics_buffer_ = pointer;
-}
-
-inline double* Environment::heap_space_statistics_buffer() const {
-  CHECK_NE(heap_space_statistics_buffer_, nullptr);
-  return heap_space_statistics_buffer_;
-}
-
-inline void Environment::set_heap_space_statistics_buffer(double* pointer) {
-  CHECK_EQ(heap_space_statistics_buffer_, nullptr);  // Should be set only once.
-  heap_space_statistics_buffer_ = pointer;
-}
-
-
-inline char* Environment::http_parser_buffer() const {
-  return http_parser_buffer_;
-}
-
-inline void Environment::set_http_parser_buffer(char* buffer) {
-  CHECK_EQ(http_parser_buffer_, nullptr);  // Should be set only once.
-  http_parser_buffer_ = buffer;
-}
-
-inline Environment* Environment::from_cares_timer_handle(uv_timer_t* handle) {
-  return ContainerOf(&Environment::cares_timer_handle_, handle);
-}
-
-inline uv_timer_t* Environment::cares_timer_handle() {
-  return &cares_timer_handle_;
-}
-
-inline ares_channel Environment::cares_channel() {
-  return cares_channel_;
-}
-
-// Only used in the call to ares_init_options().
-inline ares_channel* Environment::cares_channel_ptr() {
-  return &cares_channel_;
-}
-
-inline node_ares_task_list* Environment::cares_task_list() {
-  return &cares_task_list_;
-}
-
-inline IsolateData* Environment::isolate_data() const {
-  return isolate_data_;
-}
-
-inline void Environment::ThrowError(const char* errmsg) {
-  ThrowError(v8::Exception::Error, errmsg);
-}
-
-inline void Environment::ThrowTypeError(const char* errmsg) {
-  ThrowError(v8::Exception::TypeError, errmsg);
-}
-
-inline void Environment::ThrowRangeError(const char* errmsg) {
-  ThrowError(v8::Exception::RangeError, errmsg);
-}
-
-inline void Environment::ThrowError(
-    v8::Local<v8::Value> (*fun)(v8::Local<v8::String>),
-    const char* errmsg) {
-  v8::HandleScope handle_scope(isolate());
-  isolate()->ThrowException(fun(OneByteString(isolate(), errmsg)));
-}
-
-inline void Environment::ThrowErrnoException(int errorno,
-                                             const char* syscall,
-                                             const char* message,
-                                             const char* path) {
-  isolate()->ThrowException(
-      ErrnoException(isolate(), errorno, syscall, message, path));
-}
-
-inline void Environment::ThrowUVException(int errorno,
-                                          const char* syscall,
-                                          const char* message,
-                                          const char* path,
-                                          const char* dest) {
-  isolate()->ThrowException(
-      UVException(isolate(), errorno, syscall, message, path, dest));
-}
-
-inline v8::Local<v8::FunctionTemplate>
-    Environment::NewFunctionTemplate(v8::FunctionCallback callback,
-                                     v8::Local<v8::Signature> signature) {
-  v8::Local<v8::External> external = as_external();
-  return v8::FunctionTemplate::New(isolate(), callback, external, signature);
-}
-
-inline void Environment::SetMethod(v8::Local<v8::Object> that,
-                                   const char* name,
-                                   v8::FunctionCallback callback) {
-  v8::Local<v8::Function> function =
-      NewFunctionTemplate(callback)->GetFunction();
-  // kInternalized strings are created in the old space.
-  const v8::NewStringType type = v8::NewStringType::kInternalized;
-  v8::Local<v8::String> name_string =
-      v8::String::NewFromUtf8(isolate(), name, type).ToLocalChecked();
-  that->Set(name_string, function);
-  function->SetName(name_string);  // NODE_SET_METHOD() compatibility.
-}
-
-inline void Environment::SetProtoMethod(v8::Local<v8::FunctionTemplate> that,
-                                        const char* name,
-                                        v8::FunctionCallback callback) {
-  v8::Local<v8::Signature> signature = v8::Signature::New(isolate(), that);
-  v8::Local<v8::FunctionTemplate> t = NewFunctionTemplate(callback, signature);
-  // kInternalized strings are created in the old space.
-  const v8::NewStringType type = v8::NewStringType::kInternalized;
-  v8::Local<v8::String> name_string =
-      v8::String::NewFromUtf8(isolate(), name, type).ToLocalChecked();
-  that->PrototypeTemplate()->Set(name_string, t);
-  t->SetClassName(name_string);  // NODE_SET_PROTOTYPE_METHOD() compatibility.
-}
-
-inline void Environment::SetTemplateMethod(v8::Local<v8::FunctionTemplate> that,
-                                           const char* name,
-                                           v8::FunctionCallback callback) {
-  v8::Local<v8::FunctionTemplate> t = NewFunctionTemplate(callback);
-  // kInternalized strings are created in the old space.
-  const v8::NewStringType type = v8::NewStringType::kInternalized;
-  v8::Local<v8::String> name_string =
-      v8::String::NewFromUtf8(isolate(), name, type).ToLocalChecked();
-  that->Set(name_string, t);
-  t->SetClassName(name_string);  // NODE_SET_METHOD() compatibility.
-}
-
-inline v8::Local<v8::Object> Environment::NewInternalFieldObject() {
-  v8::MaybeLocal<v8::Object> m_obj =
-      generic_internal_field_template()->NewInstance(context());
-  return m_obj.ToLocalChecked();
-}
-
-#define VP(PropertyName, StringValue) V(v8::Private, PropertyName)
-#define VS(PropertyName, StringValue) V(v8::String, PropertyName)
-#define V(TypeName, PropertyName)                                             \
-  inline                                                                      \
-  v8::Local<TypeName> IsolateData::PropertyName(v8::Isolate* isolate) const { \
-    /* Strings are immutable so casting away const-ness here is okay. */      \
-    return const_cast<IsolateData*>(this)->PropertyName ## _.Get(isolate);    \
-  }
-  PER_ISOLATE_PRIVATE_SYMBOL_PROPERTIES(VP)
-  PER_ISOLATE_STRING_PROPERTIES(VS)
-#undef V
-#undef VS
-#undef VP
-
-#define VP(PropertyName, StringValue) V(v8::Private, PropertyName)
-#define VS(PropertyName, StringValue) V(v8::String, PropertyName)
-#define V(TypeName, PropertyName)                                             \
-  inline v8::Local<TypeName> Environment::PropertyName() const {              \
-    return isolate_data()->PropertyName(isolate());                           \
-  }
-  PER_ISOLATE_PRIVATE_SYMBOL_PROPERTIES(VP)
-  PER_ISOLATE_STRING_PROPERTIES(VS)
-#undef V
-#undef VS
-#undef VP
-
-#define V(PropertyName, TypeName)                                             \
-  inline v8::Local<TypeName> Environment::PropertyName() const {              \
-    return StrongPersistentToLocal(PropertyName ## _);                        \
-  }                                                                           \
-  inline void Environment::set_ ## PropertyName(v8::Local<TypeName> value) {  \
-    PropertyName ## _.Reset(isolate(), value);                                \
-  }
-  ENVIRONMENT_STRONG_PERSISTENT_PROPERTIES(V)
-#undef V
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_ENV_INL_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/env.h
+++ /dev/null
@@ -1,594 +0,0 @@
-#ifndef SRC_ENV_H_
-#define SRC_ENV_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "ares.h"
-#include "debug-agent.h"
-#if HAVE_INSPECTOR
-#include "inspector_agent.h"
-#endif
-#include "handle_wrap.h"
-#include "req-wrap.h"
-#include "tree.h"
-#include "util.h"
-#include "uv.h"
-#include "v8.h"
-
-#include <stdint.h>
-#include <vector>
-
-// Caveat emptor: we're going slightly crazy with macros here but the end
-// hopefully justifies the means. We have a lot of per-context properties
-// and adding and maintaining their getters and setters by hand would be
-// a nightmare so let's make the preprocessor generate them for us.
-//
-// Make sure that any macros defined here are undefined again at the bottom
-// of context-inl.h. The exceptions are NODE_CONTEXT_EMBEDDER_DATA_INDEX
-// and NODE_ISOLATE_SLOT, they may have been defined externally.
-namespace node {
-
-// Pick an index that's hopefully out of the way when we're embedded inside
-// another application. Performance-wise or memory-wise it doesn't matter:
-// Context::SetAlignedPointerInEmbedderData() is backed by a FixedArray,
-// worst case we pay a one-time penalty for resizing the array.
-#ifndef NODE_CONTEXT_EMBEDDER_DATA_INDEX
-#define NODE_CONTEXT_EMBEDDER_DATA_INDEX 32
-#endif
-
-// The number of items passed to push_values_to_array_function has diminishing
-// returns around 8. This should be used at all call sites using said function.
-#ifndef NODE_PUSH_VAL_TO_ARRAY_MAX
-#define NODE_PUSH_VAL_TO_ARRAY_MAX 8
-#endif
-
-// Private symbols are per-isolate primitives but Environment proxies them
-// for the sake of convenience.  Strings should be ASCII-only and have a
-// "node:" prefix to avoid name clashes with third-party code.
-#define PER_ISOLATE_PRIVATE_SYMBOL_PROPERTIES(V)                              \
-  V(alpn_buffer_private_symbol, "node:alpnBuffer")                            \
-  V(arrow_message_private_symbol, "node:arrowMessage")                        \
-  V(contextify_context_private_symbol, "node:contextify:context")             \
-  V(contextify_global_private_symbol, "node:contextify:global")               \
-  V(decorated_private_symbol, "node:decorated")                               \
-  V(npn_buffer_private_symbol, "node:npnBuffer")                              \
-  V(processed_private_symbol, "node:processed")                               \
-  V(selected_npn_buffer_private_symbol, "node:selectedNpnBuffer")             \
-
-// Strings are per-isolate primitives but Environment proxies them
-// for the sake of convenience.  Strings should be ASCII-only.
-#define PER_ISOLATE_STRING_PROPERTIES(V)                                      \
-  V(address_string, "address")                                                \
-  V(args_string, "args")                                                      \
-  V(async, "async")                                                           \
-  V(async_queue_string, "_asyncQueue")                                        \
-  V(buffer_string, "buffer")                                                  \
-  V(bytes_string, "bytes")                                                    \
-  V(bytes_parsed_string, "bytesParsed")                                       \
-  V(bytes_read_string, "bytesRead")                                           \
-  V(cached_data_string, "cachedData")                                         \
-  V(cached_data_produced_string, "cachedDataProduced")                        \
-  V(cached_data_rejected_string, "cachedDataRejected")                        \
-  V(callback_string, "callback")                                              \
-  V(change_string, "change")                                                  \
-  V(oncertcb_string, "oncertcb")                                              \
-  V(onclose_string, "_onclose")                                               \
-  V(code_string, "code")                                                      \
-  V(configurable_string, "configurable")                                      \
-  V(cwd_string, "cwd")                                                        \
-  V(dest_string, "dest")                                                      \
-  V(detached_string, "detached")                                              \
-  V(disposed_string, "_disposed")                                             \
-  V(domain_string, "domain")                                                  \
-  V(emitting_top_level_domain_error_string, "_emittingTopLevelDomainError")   \
-  V(exchange_string, "exchange")                                              \
-  V(enumerable_string, "enumerable")                                          \
-  V(idle_string, "idle")                                                      \
-  V(irq_string, "irq")                                                        \
-  V(encoding_string, "encoding")                                              \
-  V(enter_string, "enter")                                                    \
-  V(env_pairs_string, "envPairs")                                             \
-  V(errno_string, "errno")                                                    \
-  V(error_string, "error")                                                    \
-  V(events_string, "_events")                                                 \
-  V(exiting_string, "_exiting")                                               \
-  V(exit_code_string, "exitCode")                                             \
-  V(exit_string, "exit")                                                      \
-  V(expire_string, "expire")                                                  \
-  V(exponent_string, "exponent")                                              \
-  V(exports_string, "exports")                                                \
-  V(ext_key_usage_string, "ext_key_usage")                                    \
-  V(external_stream_string, "_externalStream")                                \
-  V(family_string, "family")                                                  \
-  V(fatal_exception_string, "_fatalException")                                \
-  V(fd_string, "fd")                                                          \
-  V(file_string, "file")                                                      \
-  V(fingerprint_string, "fingerprint")                                        \
-  V(flags_string, "flags")                                                    \
-  V(get_string, "get")                                                        \
-  V(gid_string, "gid")                                                        \
-  V(handle_string, "handle")                                                  \
-  V(homedir_string, "homedir")                                                \
-  V(hostmaster_string, "hostmaster")                                          \
-  V(ignore_string, "ignore")                                                  \
-  V(immediate_callback_string, "_immediateCallback")                          \
-  V(infoaccess_string, "infoAccess")                                          \
-  V(inherit_string, "inherit")                                                \
-  V(input_string, "input")                                                    \
-  V(internal_string, "internal")                                              \
-  V(ipv4_string, "IPv4")                                                      \
-  V(ipv6_string, "IPv6")                                                      \
-  V(isalive_string, "isAlive")                                                \
-  V(isclosing_string, "isClosing")                                            \
-  V(issuer_string, "issuer")                                                  \
-  V(issuercert_string, "issuerCertificate")                                   \
-  V(kill_signal_string, "killSignal")                                         \
-  V(mac_string, "mac")                                                        \
-  V(max_buffer_string, "maxBuffer")                                           \
-  V(message_string, "message")                                                \
-  V(minttl_string, "minttl")                                                  \
-  V(model_string, "model")                                                    \
-  V(modulus_string, "modulus")                                                \
-  V(name_string, "name")                                                      \
-  V(netmask_string, "netmask")                                                \
-  V(nice_string, "nice")                                                      \
-  V(nsname_string, "nsname")                                                  \
-  V(ocsp_request_string, "OCSPRequest")                                       \
-  V(onchange_string, "onchange")                                              \
-  V(onclienthello_string, "onclienthello")                                    \
-  V(oncomplete_string, "oncomplete")                                          \
-  V(onconnection_string, "onconnection")                                      \
-  V(ondone_string, "ondone")                                                  \
-  V(onerror_string, "onerror")                                                \
-  V(onexit_string, "onexit")                                                  \
-  V(onhandshakedone_string, "onhandshakedone")                                \
-  V(onhandshakestart_string, "onhandshakestart")                              \
-  V(onmessage_string, "onmessage")                                            \
-  V(onnewsession_string, "onnewsession")                                      \
-  V(onnewsessiondone_string, "onnewsessiondone")                              \
-  V(onocspresponse_string, "onocspresponse")                                  \
-  V(onread_string, "onread")                                                  \
-  V(onreadstart_string, "onreadstart")                                        \
-  V(onreadstop_string, "onreadstop")                                          \
-  V(onselect_string, "onselect")                                              \
-  V(onshutdown_string, "onshutdown")                                          \
-  V(onsignal_string, "onsignal")                                              \
-  V(onstop_string, "onstop")                                                  \
-  V(onwrite_string, "onwrite")                                                \
-  V(output_string, "output")                                                  \
-  V(order_string, "order")                                                    \
-  V(owner_string, "owner")                                                    \
-  V(parse_error_string, "Parse Error")                                        \
-  V(path_string, "path")                                                      \
-  V(pbkdf2_error_string, "PBKDF2 Error")                                      \
-  V(pid_string, "pid")                                                        \
-  V(pipe_string, "pipe")                                                      \
-  V(port_string, "port")                                                      \
-  V(preference_string, "preference")                                          \
-  V(priority_string, "priority")                                              \
-  V(produce_cached_data_string, "produceCachedData")                          \
-  V(raw_string, "raw")                                                        \
-  V(readable_string, "readable")                                              \
-  V(received_shutdown_string, "receivedShutdown")                             \
-  V(refresh_string, "refresh")                                                \
-  V(regexp_string, "regexp")                                                  \
-  V(rename_string, "rename")                                                  \
-  V(replacement_string, "replacement")                                        \
-  V(retry_string, "retry")                                                    \
-  V(serial_string, "serial")                                                  \
-  V(scopeid_string, "scopeid")                                                \
-  V(sent_shutdown_string, "sentShutdown")                                     \
-  V(serial_number_string, "serialNumber")                                     \
-  V(service_string, "service")                                                \
-  V(servername_string, "servername")                                          \
-  V(session_id_string, "sessionId")                                           \
-  V(set_string, "set")                                                        \
-  V(shell_string, "shell")                                                    \
-  V(signal_string, "signal")                                                  \
-  V(size_string, "size")                                                      \
-  V(sni_context_err_string, "Invalid SNI context")                            \
-  V(sni_context_string, "sni_context")                                        \
-  V(speed_string, "speed")                                                    \
-  V(stack_string, "stack")                                                    \
-  V(status_string, "status")                                                  \
-  V(stdio_string, "stdio")                                                    \
-  V(subject_string, "subject")                                                \
-  V(subjectaltname_string, "subjectaltname")                                  \
-  V(sys_string, "sys")                                                        \
-  V(syscall_string, "syscall")                                                \
-  V(tick_callback_string, "_tickCallback")                                    \
-  V(tick_domain_cb_string, "_tickDomainCallback")                             \
-  V(ticketkeycallback_string, "onticketkeycallback")                          \
-  V(timeout_string, "timeout")                                                \
-  V(times_string, "times")                                                    \
-  V(tls_ticket_string, "tlsTicket")                                           \
-  V(type_string, "type")                                                      \
-  V(uid_string, "uid")                                                        \
-  V(unknown_string, "<unknown>")                                              \
-  V(user_string, "user")                                                      \
-  V(username_string, "username")                                              \
-  V(valid_from_string, "valid_from")                                          \
-  V(valid_to_string, "valid_to")                                              \
-  V(value_string, "value")                                                    \
-  V(verify_error_string, "verifyError")                                       \
-  V(version_string, "version")                                                \
-  V(weight_string, "weight")                                                  \
-  V(windows_verbatim_arguments_string, "windowsVerbatimArguments")            \
-  V(wrap_string, "wrap")                                                      \
-  V(writable_string, "writable")                                              \
-  V(write_queue_size_string, "writeQueueSize")                                \
-  V(x_forwarded_string, "x-forwarded-for")                                    \
-  V(zero_return_string, "ZERO_RETURN")                                        \
-
-#define ENVIRONMENT_STRONG_PERSISTENT_PROPERTIES(V)                           \
-  V(as_external, v8::External)                                                \
-  V(async_hooks_destroy_function, v8::Function)                               \
-  V(async_hooks_init_function, v8::Function)                                  \
-  V(async_hooks_post_function, v8::Function)                                  \
-  V(async_hooks_pre_function, v8::Function)                                   \
-  V(binding_cache_object, v8::Object)                                         \
-  V(buffer_constructor_function, v8::Function)                                \
-  V(buffer_prototype_object, v8::Object)                                      \
-  V(context, v8::Context)                                                     \
-  V(domain_array, v8::Array)                                                  \
-  V(domains_stack_array, v8::Array)                                           \
-  V(fs_stats_constructor_function, v8::Function)                              \
-  V(generic_internal_field_template, v8::ObjectTemplate)                      \
-  V(jsstream_constructor_template, v8::FunctionTemplate)                      \
-  V(module_load_list_array, v8::Array)                                        \
-  V(pipe_constructor_template, v8::FunctionTemplate)                          \
-  V(process_object, v8::Object)                                               \
-  V(promise_reject_function, v8::Function)                                    \
-  V(push_values_to_array_function, v8::Function)                              \
-  V(script_context_constructor_template, v8::FunctionTemplate)                \
-  V(script_data_constructor_function, v8::Function)                           \
-  V(secure_context_constructor_template, v8::FunctionTemplate)                \
-  V(tcp_constructor_template, v8::FunctionTemplate)                           \
-  V(tick_callback_function, v8::Function)                                     \
-  V(tls_wrap_constructor_function, v8::Function)                              \
-  V(tls_wrap_constructor_template, v8::FunctionTemplate)                      \
-  V(tty_constructor_template, v8::FunctionTemplate)                           \
-  V(udp_constructor_function, v8::Function)                                   \
-  V(write_wrap_constructor_function, v8::Function)                            \
-
-class Environment;
-
-struct node_ares_task {
-  Environment* env;
-  ares_socket_t sock;
-  uv_poll_t poll_watcher;
-  RB_ENTRY(node_ares_task) node;
-};
-
-RB_HEAD(node_ares_task_list, node_ares_task);
-
-class IsolateData {
- public:
-  inline IsolateData(v8::Isolate* isolate, uv_loop_t* event_loop,
-                     uint32_t* zero_fill_field = nullptr);
-  inline uv_loop_t* event_loop() const;
-  inline uint32_t* zero_fill_field() const;
-
-#define VP(PropertyName, StringValue) V(v8::Private, PropertyName)
-#define VS(PropertyName, StringValue) V(v8::String, PropertyName)
-#define V(TypeName, PropertyName)                                             \
-  inline v8::Local<TypeName> PropertyName(v8::Isolate* isolate) const;
-  PER_ISOLATE_PRIVATE_SYMBOL_PROPERTIES(VP)
-  PER_ISOLATE_STRING_PROPERTIES(VS)
-#undef V
-#undef VS
-#undef VP
-
- private:
-#define VP(PropertyName, StringValue) V(v8::Private, PropertyName)
-#define VS(PropertyName, StringValue) V(v8::String, PropertyName)
-#define V(TypeName, PropertyName)                                             \
-  v8::Eternal<TypeName> PropertyName ## _;
-  PER_ISOLATE_PRIVATE_SYMBOL_PROPERTIES(VP)
-  PER_ISOLATE_STRING_PROPERTIES(VS)
-#undef V
-#undef VS
-#undef VP
-
-  uv_loop_t* const event_loop_;
-  uint32_t* const zero_fill_field_;
-
-  DISALLOW_COPY_AND_ASSIGN(IsolateData);
-};
-
-class Environment {
- public:
-  class AsyncHooks {
-   public:
-    inline uint32_t* fields();
-    inline int fields_count() const;
-    inline bool callbacks_enabled();
-    inline void set_enable_callbacks(uint32_t flag);
-
-   private:
-    friend class Environment;  // So we can call the constructor.
-    inline AsyncHooks();
-
-    enum Fields {
-      // Set this to not zero if the init hook should be called.
-      kEnableCallbacks,
-      kFieldsCount
-    };
-
-    uint32_t fields_[kFieldsCount];
-
-    DISALLOW_COPY_AND_ASSIGN(AsyncHooks);
-  };
-
-  class AsyncCallbackScope {
-   public:
-    explicit AsyncCallbackScope(Environment* env);
-    ~AsyncCallbackScope();
-
-    inline bool in_makecallback();
-
-   private:
-    Environment* env_;
-
-    DISALLOW_COPY_AND_ASSIGN(AsyncCallbackScope);
-  };
-
-  class DomainFlag {
-   public:
-    inline uint32_t* fields();
-    inline int fields_count() const;
-    inline uint32_t count() const;
-
-   private:
-    friend class Environment;  // So we can call the constructor.
-    inline DomainFlag();
-
-    enum Fields {
-      kCount,
-      kFieldsCount
-    };
-
-    uint32_t fields_[kFieldsCount];
-
-    DISALLOW_COPY_AND_ASSIGN(DomainFlag);
-  };
-
-  class TickInfo {
-   public:
-    inline uint32_t* fields();
-    inline int fields_count() const;
-    inline uint32_t index() const;
-    inline uint32_t length() const;
-    inline void set_index(uint32_t value);
-
-   private:
-    friend class Environment;  // So we can call the constructor.
-    inline TickInfo();
-
-    enum Fields {
-      kIndex,
-      kLength,
-      kFieldsCount
-    };
-
-    uint32_t fields_[kFieldsCount];
-
-    DISALLOW_COPY_AND_ASSIGN(TickInfo);
-  };
-
-  typedef void (*HandleCleanupCb)(Environment* env,
-                                  uv_handle_t* handle,
-                                  void* arg);
-
-  class HandleCleanup {
-   private:
-    friend class Environment;
-
-    HandleCleanup(uv_handle_t* handle, HandleCleanupCb cb, void* arg)
-        : handle_(handle),
-          cb_(cb),
-          arg_(arg) {
-    }
-
-    uv_handle_t* handle_;
-    HandleCleanupCb cb_;
-    void* arg_;
-    ListNode<HandleCleanup> handle_cleanup_queue_;
-  };
-
-  static inline Environment* GetCurrent(v8::Isolate* isolate);
-  static inline Environment* GetCurrent(v8::Local<v8::Context> context);
-  static inline Environment* GetCurrent(
-      const v8::FunctionCallbackInfo<v8::Value>& info);
-
-  template <typename T>
-  static inline Environment* GetCurrent(
-      const v8::PropertyCallbackInfo<T>& info);
-
-  inline Environment(IsolateData* isolate_data, v8::Local<v8::Context> context);
-  inline ~Environment();
-
-  void Start(int argc,
-             const char* const* argv,
-             int exec_argc,
-             const char* const* exec_argv,
-             bool start_profiler_idle_notifier);
-  void AssignToContext(v8::Local<v8::Context> context);
-
-  void StartProfilerIdleNotifier();
-  void StopProfilerIdleNotifier();
-
-  inline v8::Isolate* isolate() const;
-  inline uv_loop_t* event_loop() const;
-  inline bool async_wrap_callbacks_enabled() const;
-  inline bool in_domain() const;
-  inline uint32_t watched_providers() const;
-
-  static inline Environment* from_immediate_check_handle(uv_check_t* handle);
-  static inline Environment* from_destroy_ids_idle_handle(uv_idle_t* handle);
-  inline uv_check_t* immediate_check_handle();
-  inline uv_idle_t* immediate_idle_handle();
-  inline uv_idle_t* destroy_ids_idle_handle();
-
-  // Register clean-up cb to be called on environment destruction.
-  inline void RegisterHandleCleanup(uv_handle_t* handle,
-                                    HandleCleanupCb cb,
-                                    void *arg);
-  inline void FinishHandleCleanup(uv_handle_t* handle);
-
-  inline AsyncHooks* async_hooks();
-  inline DomainFlag* domain_flag();
-  inline TickInfo* tick_info();
-  inline uint64_t timer_base() const;
-
-  static inline Environment* from_cares_timer_handle(uv_timer_t* handle);
-  inline uv_timer_t* cares_timer_handle();
-  inline ares_channel cares_channel();
-  inline ares_channel* cares_channel_ptr();
-  inline node_ares_task_list* cares_task_list();
-  inline IsolateData* isolate_data() const;
-
-  inline bool using_domains() const;
-  inline void set_using_domains(bool value);
-
-  inline bool printed_error() const;
-  inline void set_printed_error(bool value);
-
-  void PrintSyncTrace() const;
-  inline void set_trace_sync_io(bool value);
-
-  inline int64_t get_async_wrap_uid();
-
-  // List of id's that have been destroyed and need the destroy() cb called.
-  inline std::vector<int64_t>* destroy_ids_list();
-
-  inline double* heap_statistics_buffer() const;
-  inline void set_heap_statistics_buffer(double* pointer);
-
-  inline double* heap_space_statistics_buffer() const;
-  inline void set_heap_space_statistics_buffer(double* pointer);
-
-  inline char* http_parser_buffer() const;
-  inline void set_http_parser_buffer(char* buffer);
-
-  inline void ThrowError(const char* errmsg);
-  inline void ThrowTypeError(const char* errmsg);
-  inline void ThrowRangeError(const char* errmsg);
-  inline void ThrowErrnoException(int errorno,
-                                  const char* syscall = nullptr,
-                                  const char* message = nullptr,
-                                  const char* path = nullptr);
-  inline void ThrowUVException(int errorno,
-                               const char* syscall = nullptr,
-                               const char* message = nullptr,
-                               const char* path = nullptr,
-                               const char* dest = nullptr);
-
-  inline v8::Local<v8::FunctionTemplate>
-      NewFunctionTemplate(v8::FunctionCallback callback,
-                          v8::Local<v8::Signature> signature =
-                              v8::Local<v8::Signature>());
-
-  // Convenience methods for NewFunctionTemplate().
-  inline void SetMethod(v8::Local<v8::Object> that,
-                        const char* name,
-                        v8::FunctionCallback callback);
-  inline void SetProtoMethod(v8::Local<v8::FunctionTemplate> that,
-                             const char* name,
-                             v8::FunctionCallback callback);
-  inline void SetTemplateMethod(v8::Local<v8::FunctionTemplate> that,
-                                const char* name,
-                                v8::FunctionCallback callback);
-
-  inline v8::Local<v8::Object> NewInternalFieldObject();
-
-  // Strings and private symbols are shared across shared contexts
-  // The getters simply proxy to the per-isolate primitive.
-#define VP(PropertyName, StringValue) V(v8::Private, PropertyName)
-#define VS(PropertyName, StringValue) V(v8::String, PropertyName)
-#define V(TypeName, PropertyName)                                             \
-  inline v8::Local<TypeName> PropertyName() const;
-  PER_ISOLATE_PRIVATE_SYMBOL_PROPERTIES(VP)
-  PER_ISOLATE_STRING_PROPERTIES(VS)
-#undef V
-#undef VS
-#undef VP
-
-#define V(PropertyName, TypeName)                                             \
-  inline v8::Local<TypeName> PropertyName() const;                            \
-  inline void set_ ## PropertyName(v8::Local<TypeName> value);
-  ENVIRONMENT_STRONG_PERSISTENT_PROPERTIES(V)
-#undef V
-
-  inline debugger::Agent* debugger_agent() {
-    return &debugger_agent_;
-  }
-
-#if HAVE_INSPECTOR
-  inline inspector::Agent* inspector_agent() {
-    return &inspector_agent_;
-  }
-#endif
-
-  typedef ListHead<HandleWrap, &HandleWrap::handle_wrap_queue_> HandleWrapQueue;
-  typedef ListHead<ReqWrap<uv_req_t>, &ReqWrap<uv_req_t>::req_wrap_queue_>
-          ReqWrapQueue;
-
-  inline HandleWrapQueue* handle_wrap_queue() { return &handle_wrap_queue_; }
-  inline ReqWrapQueue* req_wrap_queue() { return &req_wrap_queue_; }
-
-  static const int kContextEmbedderDataIndex = NODE_CONTEXT_EMBEDDER_DATA_INDEX;
-
- private:
-  inline void ThrowError(v8::Local<v8::Value> (*fun)(v8::Local<v8::String>),
-                         const char* errmsg);
-
-  v8::Isolate* const isolate_;
-  IsolateData* const isolate_data_;
-  uv_check_t immediate_check_handle_;
-  uv_idle_t immediate_idle_handle_;
-  uv_idle_t destroy_ids_idle_handle_;
-  uv_prepare_t idle_prepare_handle_;
-  uv_check_t idle_check_handle_;
-  AsyncHooks async_hooks_;
-  DomainFlag domain_flag_;
-  TickInfo tick_info_;
-  const uint64_t timer_base_;
-  uv_timer_t cares_timer_handle_;
-  ares_channel cares_channel_;
-  node_ares_task_list cares_task_list_;
-  bool using_domains_;
-  bool printed_error_;
-  bool trace_sync_io_;
-  size_t makecallback_cntr_;
-  int64_t async_wrap_uid_;
-  std::vector<int64_t> destroy_ids_list_;
-  debugger::Agent debugger_agent_;
-#if HAVE_INSPECTOR
-  inspector::Agent inspector_agent_;
-#endif
-
-  HandleWrapQueue handle_wrap_queue_;
-  ReqWrapQueue req_wrap_queue_;
-  ListHead<HandleCleanup,
-           &HandleCleanup::handle_cleanup_queue_> handle_cleanup_queue_;
-  int handle_cleanup_waiting_;
-
-  double* heap_statistics_buffer_ = nullptr;
-  double* heap_space_statistics_buffer_ = nullptr;
-
-  char* http_parser_buffer_;
-
-#define V(PropertyName, TypeName)                                             \
-  v8::Persistent<TypeName> PropertyName ## _;
-  ENVIRONMENT_STRONG_PERSISTENT_PROPERTIES(V)
-#undef V
-
-  DISALLOW_COPY_AND_ASSIGN(Environment);
-};
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_ENV_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/handle_wrap.h
+++ /dev/null
@@ -1,74 +0,0 @@
-#ifndef SRC_HANDLE_WRAP_H_
-#define SRC_HANDLE_WRAP_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "async-wrap.h"
-#include "util.h"
-#include "uv.h"
-#include "v8.h"
-
-namespace node {
-
-class Environment;
-
-// Rules:
-//
-// - Do not throw from handle methods. Set errno.
-//
-// - MakeCallback may only be made directly off the event loop.
-//   That is there can be no JavaScript stack frames underneath it.
-//   (Is there any way to assert that?)
-//
-// - No use of v8::WeakReferenceCallback. The close callback signifies that
-//   we're done with a handle - external resources can be freed.
-//
-// - Reusable?
-//
-// - The uv_close_cb is used to free the c++ object. The close callback
-//   is not made into javascript land.
-//
-// - uv_ref, uv_unref counts are managed at this layer to avoid needless
-//   js/c++ boundary crossing. At the javascript layer that should all be
-//   taken care of.
-
-class HandleWrap : public AsyncWrap {
- public:
-  static void Close(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void Ref(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void Unref(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void HasRef(const v8::FunctionCallbackInfo<v8::Value>& args);
-
-  static inline bool IsAlive(const HandleWrap* wrap) {
-    return wrap != nullptr && wrap->state_ != kClosed;
-  }
-
-  static inline bool HasRef(const HandleWrap* wrap) {
-    return IsAlive(wrap) && uv_has_ref(wrap->GetHandle());
-  }
-
-  inline uv_handle_t* GetHandle() const { return handle_; }
-
- protected:
-  HandleWrap(Environment* env,
-             v8::Local<v8::Object> object,
-             uv_handle_t* handle,
-             AsyncWrap::ProviderType provider,
-             AsyncWrap* parent = nullptr);
-  ~HandleWrap() override;
-
- private:
-  friend class Environment;
-  friend void GetActiveHandles(const v8::FunctionCallbackInfo<v8::Value>&);
-  static void OnClose(uv_handle_t* handle);
-  ListNode<HandleWrap> handle_wrap_queue_;
-  enum { kInitialized, kClosing, kClosingWithCallback, kClosed } state_;
-  uv_handle_t* const handle_;
-};
-
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_HANDLE_WRAP_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/inspector_agent.h
+++ /dev/null
@@ -1,54 +0,0 @@
-#ifndef SRC_INSPECTOR_AGENT_H_
-#define SRC_INSPECTOR_AGENT_H_
-
-#include <stddef.h>
-
-#if !HAVE_INSPECTOR
-#error("This header can only be used when inspector is enabled")
-#endif
-
-#include "node.h"
-#include "node_debug_options.h"
-
-// Forward declaration to break recursive dependency chain with src/env.h.
-namespace node {
-class Environment;
-}  // namespace node
-
-namespace v8 {
-class Platform;
-template<typename T>
-class Local;
-class Value;
-class Message;
-}  // namespace v8
-
-namespace node {
-namespace inspector {
-
-class AgentImpl;
-
-class NODE_EXTERN Agent {
- public:
-  explicit Agent(node::Environment* env);
-  ~Agent();
-
-  // Start the inspector agent thread
-  bool Start(v8::Platform* platform, const char* path,
-             const DebugOptions& options);
-  // Stop the inspector agent
-  void Stop();
-
-  bool IsStarted();
-  bool IsConnected();
-  void WaitForDisconnect();
-  void FatalException(v8::Local<v8::Value> error,
-                      v8::Local<v8::Message> message);
- private:
-  AgentImpl* impl;
-};
-
-}  // namespace inspector
-}  // namespace node
-
-#endif  // SRC_INSPECTOR_AGENT_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/inspector_socket.h
+++ /dev/null
@@ -1,100 +0,0 @@
-#ifndef SRC_INSPECTOR_SOCKET_H_
-#define SRC_INSPECTOR_SOCKET_H_
-
-#include "http_parser.h"
-#include "util.h"
-#include "util-inl.h"
-#include "uv.h"
-
-#include <string>
-#include <vector>
-
-namespace node {
-namespace inspector {
-
-enum inspector_handshake_event {
-  kInspectorHandshakeUpgrading,
-  kInspectorHandshakeUpgraded,
-  kInspectorHandshakeHttpGet,
-  kInspectorHandshakeFailed
-};
-
-class InspectorSocket;
-
-typedef void (*inspector_cb)(InspectorSocket*, int);
-// Notifies as handshake is progressing. Returning false as a response to
-// kInspectorHandshakeUpgrading or kInspectorHandshakeHttpGet event will abort
-// the connection. inspector_write can be used from the callback.
-typedef bool (*handshake_cb)(InspectorSocket*,
-                             enum inspector_handshake_event state,
-                             const std::string& path);
-
-struct http_parsing_state_s {
-  http_parser parser;
-  http_parser_settings parser_settings;
-  handshake_cb callback;
-  bool done;
-  bool parsing_value;
-  std::string ws_key;
-  std::string path;
-  std::string current_header;
-};
-
-struct ws_state_s {
-  uv_alloc_cb alloc_cb;
-  uv_read_cb read_cb;
-  inspector_cb close_cb;
-  bool close_sent;
-  bool received_close;
-};
-
-class InspectorSocket {
- public:
-  InspectorSocket() : data(nullptr), http_parsing_state(nullptr),
-                      ws_state(nullptr), buffer(0), ws_mode(false),
-                      shutting_down(false), connection_eof(false) { }
-  void reinit();
-  void* data;
-  struct http_parsing_state_s* http_parsing_state;
-  struct ws_state_s* ws_state;
-  std::vector<char> buffer;
-  uv_tcp_t client;
-  bool ws_mode;
-  bool shutting_down;
-  bool connection_eof;
- private:
-  DISALLOW_COPY_AND_ASSIGN(InspectorSocket);
-};
-
-int inspector_accept(uv_stream_t* server, InspectorSocket* inspector,
-                     handshake_cb callback);
-
-void inspector_close(InspectorSocket* inspector,
-                     inspector_cb callback);
-
-// Callbacks will receive stream handles. Use inspector_from_stream to get
-// InspectorSocket* from the stream handle.
-int inspector_read_start(InspectorSocket* inspector, uv_alloc_cb,
-                          uv_read_cb);
-void inspector_read_stop(InspectorSocket* inspector);
-void inspector_write(InspectorSocket* inspector,
-    const char* data, size_t len);
-bool inspector_is_active(const InspectorSocket* inspector);
-
-inline InspectorSocket* inspector_from_stream(uv_tcp_t* stream) {
-  return node::ContainerOf(&InspectorSocket::client, stream);
-}
-
-inline InspectorSocket* inspector_from_stream(uv_stream_t* stream) {
-  return inspector_from_stream(reinterpret_cast<uv_tcp_t*>(stream));
-}
-
-inline InspectorSocket* inspector_from_stream(uv_handle_t* stream) {
-  return inspector_from_stream(reinterpret_cast<uv_tcp_t*>(stream));
-}
-
-}  // namespace inspector
-}  // namespace node
-
-
-#endif  // SRC_INSPECTOR_SOCKET_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/inspector_socket_server.h
+++ /dev/null
@@ -1,85 +0,0 @@
-#ifndef SRC_INSPECTOR_SOCKET_SERVER_H_
-#define SRC_INSPECTOR_SOCKET_SERVER_H_
-
-#include "inspector_agent.h"
-#include "inspector_socket.h"
-#include "uv.h"
-
-#include <map>
-#include <string>
-#include <vector>
-
-#if !HAVE_INSPECTOR
-#error("This header can only be used when inspector is enabled")
-#endif
-
-namespace node {
-namespace inspector {
-
-class Closer;
-class SocketSession;
-
-class SocketServerDelegate {
- public:
-  virtual bool StartSession(int session_id, const std::string& target_id) = 0;
-  virtual void EndSession(int session_id) = 0;
-  virtual void MessageReceived(int session_id, const std::string& message) = 0;
-  virtual std::vector<std::string> GetTargetIds() = 0;
-  virtual std::string GetTargetTitle(const std::string& id) = 0;
-  virtual std::string GetTargetUrl(const std::string& id) = 0;
-};
-
-class InspectorSocketServer {
- public:
-  using ServerCallback = void (*)(InspectorSocketServer*);
-  InspectorSocketServer(SocketServerDelegate* delegate,
-                        const std::string& host,
-                        int port,
-                        FILE* out = stderr);
-  bool Start(uv_loop_t* loop);
-  void Stop(ServerCallback callback);
-  void Send(int session_id, const std::string& message);
-  void TerminateConnections(ServerCallback callback);
-  int port() {
-    return port_;
-  }
-
- private:
-  static bool HandshakeCallback(InspectorSocket* socket,
-                                enum inspector_handshake_event state,
-                                const std::string& path);
-  static void SocketConnectedCallback(uv_stream_t* server, int status);
-  static void ServerClosedCallback(uv_handle_t* server);
-  template<typename SomeUvStruct>
-  static InspectorSocketServer* From(SomeUvStruct* server) {
-    return node::ContainerOf(&InspectorSocketServer::server_,
-                             reinterpret_cast<uv_tcp_t*>(server));
-  }
-  bool RespondToGet(InspectorSocket* socket, const std::string& path);
-  void SendListResponse(InspectorSocket* socket);
-  void ReadCallback(InspectorSocket* socket, ssize_t read, const uv_buf_t* buf);
-  bool SessionStarted(SocketSession* session, const std::string& id);
-  void SessionTerminated(int id);
-  bool TargetExists(const std::string& id);
-  static void SocketSessionDeleter(SocketSession*);
-  SocketServerDelegate* Delegate() { return delegate_; }
-
-  uv_loop_t* loop_;
-  SocketServerDelegate* const delegate_;
-  const std::string host_;
-  int port_;
-  std::string path_;
-  uv_tcp_t server_;
-  Closer* closer_;
-  std::map<int, SocketSession*> connected_sessions_;
-  int next_session_id_;
-  FILE* out_;
-
-  friend class SocketSession;
-  friend class Closer;
-};
-
-}  // namespace inspector
-}  // namespace node
-
-#endif  // SRC_INSPECTOR_SOCKET_SERVER_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/js_stream.h
+++ /dev/null
@@ -1,55 +0,0 @@
-#ifndef SRC_JS_STREAM_H_
-#define SRC_JS_STREAM_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "async-wrap.h"
-#include "env.h"
-#include "stream_base.h"
-#include "v8.h"
-
-namespace node {
-
-class JSStream : public AsyncWrap, public StreamBase {
- public:
-  static void Initialize(v8::Local<v8::Object> target,
-                         v8::Local<v8::Value> unused,
-                         v8::Local<v8::Context> context);
-
-  ~JSStream();
-
-  void* Cast() override;
-  bool IsAlive() override;
-  bool IsClosing() override;
-  int ReadStart() override;
-  int ReadStop() override;
-
-  int DoShutdown(ShutdownWrap* req_wrap) override;
-  int DoWrite(WriteWrap* w,
-              uv_buf_t* bufs,
-              size_t count,
-              uv_stream_t* send_handle) override;
-
-  size_t self_size() const override { return sizeof(*this); }
-
- protected:
-  JSStream(Environment* env, v8::Local<v8::Object> obj, AsyncWrap* parent);
-
-  AsyncWrap* GetAsyncWrap() override;
-
-  static void New(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void DoAlloc(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void DoRead(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void DoAfterWrite(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void ReadBuffer(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void EmitEOF(const v8::FunctionCallbackInfo<v8::Value>& args);
-
-  template <class Wrap>
-  static void Finish(const v8::FunctionCallbackInfo<v8::Value>& args);
-};
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_JS_STREAM_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/node.h
+++ /dev/null
@@ -1,499 +0,0 @@
-#ifndef SRC_NODE_H_
-#define SRC_NODE_H_
-
-#ifdef _WIN32
-# ifndef BUILDING_NODE_EXTENSION
-#   define NODE_EXTERN __declspec(dllexport)
-# else
-#   define NODE_EXTERN __declspec(dllimport)
-# endif
-#else
-# define NODE_EXTERN /* nothing */
-#endif
-
-#ifdef BUILDING_NODE_EXTENSION
-# undef BUILDING_V8_SHARED
-# undef BUILDING_UV_SHARED
-# define USING_V8_SHARED 1
-# define USING_UV_SHARED 1
-#endif
-
-// This should be defined in make system.
-// See issue https://github.com/joyent/node/issues/1236
-#if defined(__MINGW32__) || defined(_MSC_VER)
-#ifndef _WIN32_WINNT
-# define _WIN32_WINNT   0x0501
-#endif
-
-#ifndef NOMINMAX
-# define NOMINMAX
-#endif
-
-#endif
-
-#if defined(_MSC_VER)
-#define PATH_MAX MAX_PATH
-#endif
-
-#ifdef _WIN32
-# define SIGKILL         9
-#endif
-
-#include "v8.h"  // NOLINT(build/include_order)
-#include "node_version.h"  // NODE_MODULE_VERSION
-
-#define NODE_MAKE_VERSION(major, minor, patch)                                \
-  ((major) * 0x1000 + (minor) * 0x100 + (patch))
-
-#ifdef __clang__
-# define NODE_CLANG_AT_LEAST(major, minor, patch)                             \
-  (NODE_MAKE_VERSION(major, minor, patch) <=                                  \
-      NODE_MAKE_VERSION(__clang_major__, __clang_minor__, __clang_patchlevel__))
-#else
-# define NODE_CLANG_AT_LEAST(major, minor, patch) (0)
-#endif
-
-#ifdef __GNUC__
-# define NODE_GNUC_AT_LEAST(major, minor, patch)                              \
-  (NODE_MAKE_VERSION(major, minor, patch) <=                                  \
-      NODE_MAKE_VERSION(__GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__))
-#else
-# define NODE_GNUC_AT_LEAST(major, minor, patch) (0)
-#endif
-
-#if NODE_CLANG_AT_LEAST(2, 9, 0) || NODE_GNUC_AT_LEAST(4, 5, 0)
-# define NODE_DEPRECATED(message, declarator)                                 \
-    __attribute__((deprecated(message))) declarator
-#elif defined(_MSC_VER)
-# define NODE_DEPRECATED(message, declarator)                                 \
-    __declspec(deprecated) declarator
-#else
-# define NODE_DEPRECATED(message, declarator)                                 \
-    declarator
-#endif
-
-// Forward-declare libuv loop
-struct uv_loop_s;
-
-// Forward-declare these functions now to stop MSVS from becoming
-// terminally confused when it's done in node_internals.h
-namespace node {
-
-NODE_EXTERN v8::Local<v8::Value> ErrnoException(v8::Isolate* isolate,
-                                                int errorno,
-                                                const char* syscall = NULL,
-                                                const char* message = NULL,
-                                                const char* path = NULL);
-NODE_EXTERN v8::Local<v8::Value> UVException(v8::Isolate* isolate,
-                                             int errorno,
-                                             const char* syscall = NULL,
-                                             const char* message = NULL,
-                                             const char* path = NULL);
-NODE_EXTERN v8::Local<v8::Value> UVException(v8::Isolate* isolate,
-                                             int errorno,
-                                             const char* syscall,
-                                             const char* message,
-                                             const char* path,
-                                             const char* dest);
-
-NODE_DEPRECATED("Use ErrnoException(isolate, ...)",
-                inline v8::Local<v8::Value> ErrnoException(
-      int errorno,
-      const char* syscall = NULL,
-      const char* message = NULL,
-      const char* path = NULL) {
-  return ErrnoException(v8::Isolate::GetCurrent(),
-                        errorno,
-                        syscall,
-                        message,
-                        path);
-})
-
-inline v8::Local<v8::Value> UVException(int errorno,
-                                        const char* syscall = NULL,
-                                        const char* message = NULL,
-                                        const char* path = NULL) {
-  return UVException(v8::Isolate::GetCurrent(),
-                     errorno,
-                     syscall,
-                     message,
-                     path);
-}
-
-/*
- * MakeCallback doesn't have a HandleScope. That means the callers scope
- * will retain ownership of created handles from MakeCallback and related.
- * There is by default a wrapping HandleScope before uv_run, if the caller
- * doesn't have a HandleScope on the stack the global will take ownership
- * which won't be reaped until the uv loop exits.
- *
- * If a uv callback is fired, and there is no enclosing HandleScope in the
- * cb, you will appear to leak 4-bytes for every invocation. Take heed.
- */
-
-NODE_EXTERN v8::Local<v8::Value> MakeCallback(
-    v8::Isolate* isolate,
-    v8::Local<v8::Object> recv,
-    const char* method,
-    int argc,
-    v8::Local<v8::Value>* argv);
-NODE_EXTERN v8::Local<v8::Value> MakeCallback(
-    v8::Isolate* isolate,
-    v8::Local<v8::Object> recv,
-    v8::Local<v8::String> symbol,
-    int argc,
-    v8::Local<v8::Value>* argv);
-NODE_EXTERN v8::Local<v8::Value> MakeCallback(
-    v8::Isolate* isolate,
-    v8::Local<v8::Object> recv,
-    v8::Local<v8::Function> callback,
-    int argc,
-    v8::Local<v8::Value>* argv);
-
-}  // namespace node
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-#include "node_internals.h"
-#endif
-
-#include <assert.h>
-#include <stdint.h>
-
-#ifndef NODE_STRINGIFY
-#define NODE_STRINGIFY(n) NODE_STRINGIFY_HELPER(n)
-#define NODE_STRINGIFY_HELPER(n) #n
-#endif
-
-#ifdef _WIN32
-// TODO(tjfontaine) consider changing the usage of ssize_t to ptrdiff_t
-#if !defined(_SSIZE_T_) && !defined(_SSIZE_T_DEFINED)
-typedef intptr_t ssize_t;
-# define _SSIZE_T_
-# define _SSIZE_T_DEFINED
-#endif
-#else  // !_WIN32
-# include <sys/types.h>  // size_t, ssize_t
-#endif  // _WIN32
-
-
-namespace node {
-
-NODE_EXTERN extern bool no_deprecation;
-#if HAVE_OPENSSL
-NODE_EXTERN extern bool ssl_openssl_cert_store;
-# if NODE_FIPS_MODE
-NODE_EXTERN extern bool enable_fips_crypto;
-NODE_EXTERN extern bool force_fips_crypto;
-# endif
-#endif
-
-// Whether node should open some low level hooks.
-NODE_EXTERN extern bool g_standalone_mode;
-NODE_EXTERN extern bool g_upstream_node_mode;
-
-NODE_EXTERN int Start(int argc, char *argv[]);
-NODE_EXTERN void Init(int* argc,
-                      const char** argv,
-                      int* exec_argc,
-                      const char*** exec_argv);
-
-class IsolateData;
-class Environment;
-
-NODE_EXTERN IsolateData* CreateIsolateData(v8::Isolate* isolate,
-                                           struct uv_loop_s* loop);
-NODE_EXTERN void FreeIsolateData(IsolateData* isolate_data);
-
-NODE_EXTERN Environment* CreateEnvironment(IsolateData* isolate_data,
-                                           v8::Local<v8::Context> context,
-                                           int argc,
-                                           const char* const* argv,
-                                           int exec_argc,
-                                           const char* const* exec_argv);
-
-NODE_EXTERN void LoadEnvironment(Environment* env);
-NODE_EXTERN void FreeEnvironment(Environment* env);
-
-NODE_EXTERN void EmitBeforeExit(Environment* env);
-NODE_EXTERN int EmitExit(Environment* env);
-NODE_EXTERN void RunAtExit(Environment* env);
-
-/* Converts a unixtime to V8 Date */
-#define NODE_UNIXTIME_V8(t) v8::Date::New(v8::Isolate::GetCurrent(),          \
-    1000 * static_cast<double>(t))
-#define NODE_V8_UNIXTIME(v) (static_cast<double>((v)->NumberValue())/1000.0);
-
-// Used to be a macro, hence the uppercase name.
-#define NODE_DEFINE_CONSTANT(target, constant)                                \
-  do {                                                                        \
-    v8::Isolate* isolate = target->GetIsolate();                              \
-    v8::Local<v8::Context> context = isolate->GetCurrentContext();            \
-    v8::Local<v8::String> constant_name =                                     \
-        v8::String::NewFromUtf8(isolate, #constant);                          \
-    v8::Local<v8::Number> constant_value =                                    \
-        v8::Number::New(isolate, static_cast<double>(constant));              \
-    v8::PropertyAttribute constant_attributes =                               \
-        static_cast<v8::PropertyAttribute>(v8::ReadOnly | v8::DontDelete);    \
-    (target)->DefineOwnProperty(context,                                      \
-                                constant_name,                                \
-                                constant_value,                               \
-                                constant_attributes).FromJust();              \
-  }                                                                           \
-  while (0)
-
-// Used to be a macro, hence the uppercase name.
-inline void NODE_SET_METHOD(v8::Local<v8::Template> recv,
-                            const char* name,
-                            v8::FunctionCallback callback) {
-  v8::Isolate* isolate = v8::Isolate::GetCurrent();
-  v8::HandleScope handle_scope(isolate);
-  v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate,
-                                                                callback);
-  v8::Local<v8::String> fn_name = v8::String::NewFromUtf8(isolate, name);
-  t->SetClassName(fn_name);
-  recv->Set(fn_name, t);
-}
-
-// Used to be a macro, hence the uppercase name.
-inline void NODE_SET_METHOD(v8::Local<v8::Object> recv,
-                            const char* name,
-                            v8::FunctionCallback callback) {
-  v8::Isolate* isolate = v8::Isolate::GetCurrent();
-  v8::HandleScope handle_scope(isolate);
-  v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate,
-                                                                callback);
-  v8::Local<v8::Function> fn = t->GetFunction();
-  v8::Local<v8::String> fn_name = v8::String::NewFromUtf8(isolate, name);
-  fn->SetName(fn_name);
-  recv->Set(fn_name, fn);
-}
-#define NODE_SET_METHOD node::NODE_SET_METHOD
-
-// Used to be a macro, hence the uppercase name.
-// Not a template because it only makes sense for FunctionTemplates.
-inline void NODE_SET_PROTOTYPE_METHOD(v8::Local<v8::FunctionTemplate> recv,
-                                      const char* name,
-                                      v8::FunctionCallback callback) {
-  v8::Isolate* isolate = v8::Isolate::GetCurrent();
-  v8::HandleScope handle_scope(isolate);
-  v8::Local<v8::Signature> s = v8::Signature::New(isolate, recv);
-  v8::Local<v8::FunctionTemplate> t =
-      v8::FunctionTemplate::New(isolate, callback, v8::Local<v8::Value>(), s);
-  v8::Local<v8::String> fn_name = v8::String::NewFromUtf8(isolate, name);
-  t->SetClassName(fn_name);
-  recv->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, name), t);
-}
-#define NODE_SET_PROTOTYPE_METHOD node::NODE_SET_PROTOTYPE_METHOD
-
-// BINARY is a deprecated alias of LATIN1.
-enum encoding {ASCII, UTF8, BASE64, UCS2, BINARY, HEX, BUFFER, LATIN1 = BINARY};
-
-NODE_EXTERN enum encoding ParseEncoding(
-    v8::Isolate* isolate,
-    v8::Local<v8::Value> encoding_v,
-    enum encoding default_encoding = LATIN1);
-NODE_DEPRECATED("Use ParseEncoding(isolate, ...)",
-                inline enum encoding ParseEncoding(
-      v8::Local<v8::Value> encoding_v,
-      enum encoding default_encoding = LATIN1) {
-  return ParseEncoding(v8::Isolate::GetCurrent(), encoding_v, default_encoding);
-})
-
-NODE_EXTERN void FatalException(v8::Isolate* isolate,
-                                const v8::TryCatch& try_catch);
-
-NODE_DEPRECATED("Use FatalException(isolate, ...)",
-                inline void FatalException(const v8::TryCatch& try_catch) {
-  return FatalException(v8::Isolate::GetCurrent(), try_catch);
-})
-
-// Don't call with encoding=UCS2.
-NODE_EXTERN v8::Local<v8::Value> Encode(v8::Isolate* isolate,
-                                        const char* buf,
-                                        size_t len,
-                                        enum encoding encoding = LATIN1);
-
-// The input buffer should be in host endianness.
-NODE_EXTERN v8::Local<v8::Value> Encode(v8::Isolate* isolate,
-                                        const uint16_t* buf,
-                                        size_t len);
-
-NODE_DEPRECATED("Use Encode(isolate, ...)",
-                inline v8::Local<v8::Value> Encode(
-    const void* buf,
-    size_t len,
-    enum encoding encoding = LATIN1) {
-  v8::Isolate* isolate = v8::Isolate::GetCurrent();
-  if (encoding == UCS2) {
-    assert(reinterpret_cast<uintptr_t>(buf) % sizeof(uint16_t) == 0 &&
-           "UCS2 buffer must be aligned on two-byte boundary.");
-    const uint16_t* that = static_cast<const uint16_t*>(buf);
-    return Encode(isolate, that, len / sizeof(*that));
-  }
-  return Encode(isolate, static_cast<const char*>(buf), len, encoding);
-})
-
-// Returns -1 if the handle was not valid for decoding
-NODE_EXTERN ssize_t DecodeBytes(v8::Isolate* isolate,
-                                v8::Local<v8::Value>,
-                                enum encoding encoding = LATIN1);
-NODE_DEPRECATED("Use DecodeBytes(isolate, ...)",
-                inline ssize_t DecodeBytes(
-    v8::Local<v8::Value> val,
-    enum encoding encoding = LATIN1) {
-  return DecodeBytes(v8::Isolate::GetCurrent(), val, encoding);
-})
-
-// returns bytes written.
-NODE_EXTERN ssize_t DecodeWrite(v8::Isolate* isolate,
-                                char* buf,
-                                size_t buflen,
-                                v8::Local<v8::Value>,
-                                enum encoding encoding = LATIN1);
-NODE_DEPRECATED("Use DecodeWrite(isolate, ...)",
-                inline ssize_t DecodeWrite(char* buf,
-                                           size_t buflen,
-                                           v8::Local<v8::Value> val,
-                                           enum encoding encoding = LATIN1) {
-  return DecodeWrite(v8::Isolate::GetCurrent(), buf, buflen, val, encoding);
-})
-
-#ifdef _WIN32
-NODE_EXTERN v8::Local<v8::Value> WinapiErrnoException(
-    v8::Isolate* isolate,
-    int errorno,
-    const char *syscall = NULL,
-    const char *msg = "",
-    const char *path = NULL);
-
-NODE_DEPRECATED("Use WinapiErrnoException(isolate, ...)",
-                inline v8::Local<v8::Value> WinapiErrnoException(int errorno,
-    const char *syscall = NULL,  const char *msg = "",
-    const char *path = NULL) {
-  return WinapiErrnoException(v8::Isolate::GetCurrent(),
-                              errorno,
-                              syscall,
-                              msg,
-                              path);
-})
-#endif
-
-const char *signo_string(int errorno);
-
-
-typedef void (*addon_register_func)(
-    v8::Local<v8::Object> exports,
-    v8::Local<v8::Value> module,
-    void* priv);
-
-typedef void (*addon_context_register_func)(
-    v8::Local<v8::Object> exports,
-    v8::Local<v8::Value> module,
-    v8::Local<v8::Context> context,
-    void* priv);
-
-#define NM_F_BUILTIN 0x01
-#define NM_F_LINKED  0x02
-
-struct node_module {
-  int nm_version;
-  unsigned int nm_flags;
-  void* nm_dso_handle;
-  const char* nm_filename;
-  node::addon_register_func nm_register_func;
-  node::addon_context_register_func nm_context_register_func;
-  const char* nm_modname;
-  void* nm_priv;
-  struct node_module* nm_link;
-};
-
-NODE_EXTERN node_module* get_builtin_module(const char *name);
-node_module* get_linked_module(const char *name);
-
-extern "C" NODE_EXTERN void node_module_register(void* mod);
-
-#ifdef _WIN32
-# define NODE_MODULE_EXPORT __declspec(dllexport)
-#else
-# define NODE_MODULE_EXPORT __attribute__((visibility("default")))
-#endif
-
-#ifdef NODE_SHARED_MODE
-# define NODE_CTOR_PREFIX
-#else
-# define NODE_CTOR_PREFIX static
-#endif
-
-#if defined(_MSC_VER)
-#pragma section(".CRT$XCU", read)
-#define NODE_C_CTOR(fn)                                               \
-  NODE_CTOR_PREFIX void __cdecl fn(void);                             \
-  __declspec(dllexport, allocate(".CRT$XCU"))                         \
-      void (__cdecl*fn ## _)(void) = fn;                              \
-  NODE_CTOR_PREFIX void __cdecl fn(void)
-#else
-#define NODE_C_CTOR(fn)                                               \
-  NODE_CTOR_PREFIX void fn(void) __attribute__((constructor));        \
-  NODE_CTOR_PREFIX void fn(void)
-#endif
-
-#define NODE_MODULE_X(modname, regfunc, priv, flags)                  \
-  extern "C" {                                                        \
-    static node::node_module _module =                                \
-    {                                                                 \
-      NODE_MODULE_VERSION,                                            \
-      flags,                                                          \
-      NULL,                                                           \
-      __FILE__,                                                       \
-      (node::addon_register_func) (regfunc),                          \
-      NULL,                                                           \
-      NODE_STRINGIFY(modname),                                        \
-      priv,                                                           \
-      NULL                                                            \
-    };                                                                \
-    NODE_C_CTOR(_register_ ## modname) {                              \
-      node_module_register(&_module);                                 \
-    }                                                                 \
-  }
-
-#define NODE_MODULE_CONTEXT_AWARE_X(modname, regfunc, priv, flags)    \
-  extern "C" {                                                        \
-    static node::node_module _module =                                \
-    {                                                                 \
-      NODE_MODULE_VERSION,                                            \
-      flags,                                                          \
-      NULL,                                                           \
-      __FILE__,                                                       \
-      NULL,                                                           \
-      (node::addon_context_register_func) (regfunc),                  \
-      NODE_STRINGIFY(modname),                                        \
-      priv,                                                           \
-      NULL                                                            \
-    };                                                                \
-    NODE_C_CTOR(_register_ ## modname) {                              \
-      node_module_register(&_module);                                 \
-    }                                                                 \
-  }
-
-#define NODE_MODULE(modname, regfunc)                                 \
-  NODE_MODULE_X(modname, regfunc, NULL, 0)
-
-#define NODE_MODULE_CONTEXT_AWARE(modname, regfunc)                   \
-  NODE_MODULE_CONTEXT_AWARE_X(modname, regfunc, NULL, 0)
-
-#define NODE_MODULE_CONTEXT_AWARE_BUILTIN(modname, regfunc)           \
-  NODE_MODULE_CONTEXT_AWARE_X(modname, regfunc, NULL, NM_F_BUILTIN)   \
-
-/*
- * For backward compatibility in add-on modules.
- */
-#define NODE_MODULE_DECL /* nothing */
-
-/* Called after the event loop exits but before the VM is disposed.
- * Callbacks are run in reverse order of registration, i.e. newest first.
- */
-NODE_EXTERN void AtExit(void (*cb)(void* arg), void* arg = 0);
-
-}  // namespace node
-
-#endif  // SRC_NODE_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/node_buffer.h
+++ /dev/null
@@ -1,68 +0,0 @@
-#ifndef SRC_NODE_BUFFER_H_
-#define SRC_NODE_BUFFER_H_
-
-#include "node.h"
-#include "v8.h"
-
-namespace node {
-
-extern bool zero_fill_all_buffers;
-
-namespace Buffer {
-
-static const unsigned int kMaxLength =
-    sizeof(int32_t) == sizeof(intptr_t) ? 0x3fffffff : 0x7fffffff;
-
-NODE_EXTERN typedef void (*FreeCallback)(char* data, void* hint);
-
-NODE_EXTERN bool HasInstance(v8::Local<v8::Value> val);
-NODE_EXTERN bool HasInstance(v8::Local<v8::Object> val);
-NODE_EXTERN char* Data(v8::Local<v8::Value> val);
-NODE_EXTERN char* Data(v8::Local<v8::Object> val);
-NODE_EXTERN size_t Length(v8::Local<v8::Value> val);
-NODE_EXTERN size_t Length(v8::Local<v8::Object> val);
-
-// public constructor - data is copied
-NODE_EXTERN v8::MaybeLocal<v8::Object> Copy(v8::Isolate* isolate,
-                                            const char* data,
-                                            size_t len);
-
-// public constructor
-NODE_EXTERN v8::MaybeLocal<v8::Object> New(v8::Isolate* isolate, size_t length);
-
-// public constructor from string
-NODE_EXTERN v8::MaybeLocal<v8::Object> New(v8::Isolate* isolate,
-                                           v8::Local<v8::String> string,
-                                           enum encoding enc = UTF8);
-
-// public constructor - data is used, callback is passed data on object gc
-NODE_EXTERN v8::MaybeLocal<v8::Object> New(v8::Isolate* isolate,
-                                           char* data,
-                                           size_t length,
-                                           FreeCallback callback,
-                                           void* hint);
-
-// public constructor - data is used.
-NODE_EXTERN v8::MaybeLocal<v8::Object> New(v8::Isolate* isolate,
-                                           char* data,
-                                           size_t len);
-
-// This is verbose to be explicit with inline commenting
-static inline bool IsWithinBounds(size_t off, size_t len, size_t max) {
-  // Asking to seek too far into the buffer
-  // check to avoid wrapping in subsequent subtraction
-  if (off > max)
-    return false;
-
-  // Asking for more than is left over in the buffer
-  if (max - off < len)
-    return false;
-
-  // Otherwise we're in bounds
-  return true;
-}
-
-}  // namespace Buffer
-}  // namespace node
-
-#endif  // SRC_NODE_BUFFER_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/node_constants.h
+++ /dev/null
@@ -1,44 +0,0 @@
-#ifndef SRC_NODE_CONSTANTS_H_
-#define SRC_NODE_CONSTANTS_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "node.h"
-#include "v8.h"
-
-#if HAVE_OPENSSL
-#define DEFAULT_CIPHER_LIST_CORE "ECDHE-RSA-AES128-GCM-SHA256:"     \
-                                 "ECDHE-ECDSA-AES128-GCM-SHA256:"   \
-                                 "ECDHE-RSA-AES256-GCM-SHA384:"     \
-                                 "ECDHE-ECDSA-AES256-GCM-SHA384:"   \
-                                 "DHE-RSA-AES128-GCM-SHA256:"       \
-                                 "ECDHE-RSA-AES128-SHA256:"         \
-                                 "DHE-RSA-AES128-SHA256:"           \
-                                 "ECDHE-RSA-AES256-SHA384:"         \
-                                 "DHE-RSA-AES256-SHA384:"           \
-                                 "ECDHE-RSA-AES256-SHA256:"         \
-                                 "DHE-RSA-AES256-SHA256:"           \
-                                 "HIGH:"                            \
-                                 "!aNULL:"                          \
-                                 "!eNULL:"                          \
-                                 "!EXPORT:"                         \
-                                 "!DES:"                            \
-                                 "!RC4:"                            \
-                                 "!MD5:"                            \
-                                 "!PSK:"                            \
-                                 "!SRP:"                            \
-                                 "!CAMELLIA"
-#endif
-
-namespace node {
-
-#if HAVE_OPENSSL
-extern const char* default_cipher_list;
-#endif
-
-void DefineConstants(v8::Isolate* isolate, v8::Local<v8::Object> target);
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_NODE_CONSTANTS_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/node_counters.h
+++ /dev/null
@@ -1,38 +0,0 @@
-#ifndef SRC_NODE_COUNTERS_H_
-#define SRC_NODE_COUNTERS_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "node.h"
-
-#ifdef HAVE_PERFCTR
-#include "node_win32_perfctr_provider.h"
-#else
-#define NODE_COUNTER_ENABLED() (false)
-#define NODE_COUNT_GC_PERCENTTIME(percent) do { } while (false)
-#define NODE_COUNT_GET_GC_RAWTIME() do { } while (false)
-#define NODE_COUNT_HTTP_CLIENT_REQUEST() do { } while (false)
-#define NODE_COUNT_HTTP_CLIENT_RESPONSE() do { } while (false)
-#define NODE_COUNT_HTTP_SERVER_REQUEST() do { } while (false)
-#define NODE_COUNT_HTTP_SERVER_RESPONSE() do { } while (false)
-#define NODE_COUNT_NET_BYTES_RECV(bytes) do { } while (false)
-#define NODE_COUNT_NET_BYTES_SENT(bytes) do { } while (false)
-#define NODE_COUNT_PIPE_BYTES_RECV(bytes) do { } while (false)
-#define NODE_COUNT_PIPE_BYTES_SENT(bytes) do { } while (false)
-#define NODE_COUNT_SERVER_CONN_CLOSE() do { } while (false)
-#define NODE_COUNT_SERVER_CONN_OPEN() do { } while (false)
-#endif
-
-#include "v8.h"
-#include "env.h"
-
-namespace node {
-
-void InitPerfCounters(Environment* env, v8::Local<v8::Object> target);
-void TermPerfCounters(v8::Local<v8::Object> target);
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_NODE_COUNTERS_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/node_crypto.h
+++ /dev/null
@@ -1,734 +0,0 @@
-#ifndef SRC_NODE_CRYPTO_H_
-#define SRC_NODE_CRYPTO_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "node.h"
-#include "node_crypto_clienthello.h"  // ClientHelloParser
-#include "node_crypto_clienthello-inl.h"
-
-#include "node_buffer.h"
-
-#include "env.h"
-#include "async-wrap.h"
-#include "async-wrap-inl.h"
-#include "base-object.h"
-#include "base-object-inl.h"
-
-#include "v8.h"
-
-#include <openssl/ssl.h>
-#include <openssl/ec.h>
-#include <openssl/ecdh.h>
-#ifndef OPENSSL_NO_ENGINE
-# include <openssl/engine.h>
-#endif  // !OPENSSL_NO_ENGINE
-#include <openssl/err.h>
-#include <openssl/evp.h>
-#include <openssl/pem.h>
-#include <openssl/x509.h>
-#include <openssl/x509v3.h>
-#include <openssl/hmac.h>
-#include <openssl/rand.h>
-#include <openssl/pkcs12.h>
-
-#define EVP_F_EVP_DECRYPTFINAL 101
-
-#if !defined(OPENSSL_NO_TLSEXT) && defined(SSL_CTX_set_tlsext_status_cb)
-# define NODE__HAVE_TLSEXT_STATUS_CB
-#endif  // !defined(OPENSSL_NO_TLSEXT) && defined(SSL_CTX_set_tlsext_status_cb)
-
-namespace node {
-namespace crypto {
-
-// Forcibly clear OpenSSL's error stack on return. This stops stale errors
-// from popping up later in the lifecycle of crypto operations where they
-// would cause spurious failures. It's a rather blunt method, though.
-// ERR_clear_error() isn't necessarily cheap either.
-struct ClearErrorOnReturn {
-  ~ClearErrorOnReturn() { ERR_clear_error(); }
-};
-
-// Pop errors from OpenSSL's error stack that were added
-// between when this was constructed and destructed.
-struct MarkPopErrorOnReturn {
-  MarkPopErrorOnReturn() { ERR_set_mark(); }
-  ~MarkPopErrorOnReturn() { ERR_pop_to_mark(); }
-};
-
-enum CheckResult {
-  CHECK_CERT_REVOKED = 0,
-  CHECK_OK = 1
-};
-
-extern int VerifyCallback(int preverify_ok, X509_STORE_CTX* ctx);
-
-extern X509_STORE* root_cert_store;
-
-extern void UseExtraCaCerts(const std::string& file);
-
-// Forward declaration
-class Connection;
-
-class SecureContext : public BaseObject {
- public:
-  ~SecureContext() override {
-    FreeCTXMem();
-  }
-
-  static void Initialize(Environment* env, v8::Local<v8::Object> target);
-
-  SSL_CTX* ctx_;
-  X509* cert_;
-  X509* issuer_;
-
-  static const int kMaxSessionSize = 10 * 1024;
-
-  // See TicketKeyCallback
-  static const int kTicketKeyReturnIndex = 0;
-  static const int kTicketKeyHMACIndex = 1;
-  static const int kTicketKeyAESIndex = 2;
-  static const int kTicketKeyNameIndex = 3;
-  static const int kTicketKeyIVIndex = 4;
-
- protected:
-  static const int64_t kExternalSize = sizeof(SSL_CTX);
-
-  static void New(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void Init(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void SetKey(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void SetCert(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void AddCACert(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void AddCRL(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void AddRootCerts(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void SetCiphers(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void SetECDHCurve(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void SetDHParam(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void SetOptions(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void SetSessionIdContext(
-      const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void SetSessionTimeout(
-      const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void Close(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void LoadPKCS12(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void GetTicketKeys(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void SetTicketKeys(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void SetFreeListLength(
-      const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void EnableTicketKeyCallback(
-      const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void CtxGetter(v8::Local<v8::String> property,
-                        const v8::PropertyCallbackInfo<v8::Value>& info);
-
-  template <bool primary>
-  static void GetCertificate(const v8::FunctionCallbackInfo<v8::Value>& args);
-
-  static int TicketKeyCallback(SSL* ssl,
-                               unsigned char* name,
-                               unsigned char* iv,
-                               EVP_CIPHER_CTX* ectx,
-                               HMAC_CTX* hctx,
-                               int enc);
-
-  SecureContext(Environment* env, v8::Local<v8::Object> wrap)
-      : BaseObject(env, wrap),
-        ctx_(nullptr),
-        cert_(nullptr),
-        issuer_(nullptr) {
-    MakeWeak<SecureContext>(this);
-    env->isolate()->AdjustAmountOfExternalAllocatedMemory(kExternalSize);
-  }
-
-  void FreeCTXMem() {
-    if (!ctx_) {
-      return;
-    }
-
-    env()->isolate()->AdjustAmountOfExternalAllocatedMemory(-kExternalSize);
-    SSL_CTX_free(ctx_);
-    if (cert_ != nullptr)
-      X509_free(cert_);
-    if (issuer_ != nullptr)
-      X509_free(issuer_);
-    ctx_ = nullptr;
-    cert_ = nullptr;
-    issuer_ = nullptr;
-  }
-};
-
-// SSLWrap implicitly depends on the inheriting class' handle having an
-// internal pointer to the Base class.
-template <class Base>
-class SSLWrap {
- public:
-  enum Kind {
-    kClient,
-    kServer
-  };
-
-  SSLWrap(Environment* env, SecureContext* sc, Kind kind)
-      : env_(env),
-        kind_(kind),
-        next_sess_(nullptr),
-        session_callbacks_(false),
-        new_session_wait_(false),
-        cert_cb_(nullptr),
-        cert_cb_arg_(nullptr),
-        cert_cb_running_(false) {
-    ssl_ = SSL_new(sc->ctx_);
-    env_->isolate()->AdjustAmountOfExternalAllocatedMemory(kExternalSize);
-    CHECK_NE(ssl_, nullptr);
-  }
-
-  virtual ~SSLWrap() {
-    DestroySSL();
-    if (next_sess_ != nullptr) {
-      SSL_SESSION_free(next_sess_);
-      next_sess_ = nullptr;
-    }
-
-#ifdef SSL_CTRL_SET_TLSEXT_SERVERNAME_CB
-    sni_context_.Reset();
-#endif
-
-#ifdef NODE__HAVE_TLSEXT_STATUS_CB
-    ocsp_response_.Reset();
-#endif  // NODE__HAVE_TLSEXT_STATUS_CB
-  }
-
-  inline SSL* ssl() const { return ssl_; }
-  inline void enable_session_callbacks() { session_callbacks_ = true; }
-  inline bool is_server() const { return kind_ == kServer; }
-  inline bool is_client() const { return kind_ == kClient; }
-  inline bool is_waiting_new_session() const { return new_session_wait_; }
-  inline bool is_waiting_cert_cb() const { return cert_cb_ != nullptr; }
-
- protected:
-  typedef void (*CertCb)(void* arg);
-
-  // Size allocated by OpenSSL: one for SSL structure, one for SSL3_STATE and
-  // some for buffers.
-  // NOTE: Actually it is much more than this
-  static const int64_t kExternalSize =
-      sizeof(SSL) + sizeof(SSL3_STATE) + 42 * 1024;
-
-  static void InitNPN(SecureContext* sc);
-  static void AddMethods(Environment* env, v8::Local<v8::FunctionTemplate> t);
-
-  static SSL_SESSION* GetSessionCallback(SSL* s,
-                                         unsigned char* key,
-                                         int len,
-                                         int* copy);
-  static int NewSessionCallback(SSL* s, SSL_SESSION* sess);
-  static void OnClientHello(void* arg,
-                            const ClientHelloParser::ClientHello& hello);
-
-  static void GetPeerCertificate(
-      const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void GetSession(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void SetSession(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void LoadSession(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void IsSessionReused(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void IsInitFinished(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void VerifyError(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void GetCurrentCipher(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void EndParser(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void CertCbDone(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void Renegotiate(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void Shutdown(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void GetTLSTicket(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void NewSessionDone(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void SetOCSPResponse(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void RequestOCSP(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void GetEphemeralKeyInfo(
-      const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void GetProtocol(const v8::FunctionCallbackInfo<v8::Value>& args);
-
-#ifdef SSL_set_max_send_fragment
-  static void SetMaxSendFragment(
-      const v8::FunctionCallbackInfo<v8::Value>& args);
-#endif  // SSL_set_max_send_fragment
-
-#ifndef OPENSSL_NO_NEXTPROTONEG
-  static void GetNegotiatedProto(
-      const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void SetNPNProtocols(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static int AdvertiseNextProtoCallback(SSL* s,
-                                        const unsigned char** data,
-                                        unsigned int* len,
-                                        void* arg);
-  static int SelectNextProtoCallback(SSL* s,
-                                     unsigned char** out,
-                                     unsigned char* outlen,
-                                     const unsigned char* in,
-                                     unsigned int inlen,
-                                     void* arg);
-#endif  // OPENSSL_NO_NEXTPROTONEG
-
-  static void GetALPNNegotiatedProto(
-      const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void SetALPNProtocols(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static int SelectALPNCallback(SSL* s,
-                                const unsigned char** out,
-                                unsigned char* outlen,
-                                const unsigned char* in,
-                                unsigned int inlen,
-                                void* arg);
-  static int TLSExtStatusCallback(SSL* s, void* arg);
-  static int SSLCertCallback(SSL* s, void* arg);
-  static void SSLGetter(v8::Local<v8::String> property,
-                        const v8::PropertyCallbackInfo<v8::Value>& info);
-
-  void DestroySSL();
-  void WaitForCertCb(CertCb cb, void* arg);
-  void SetSNIContext(SecureContext* sc);
-  int SetCACerts(SecureContext* sc);
-
-  inline Environment* ssl_env() const {
-    return env_;
-  }
-
-  Environment* const env_;
-  Kind kind_;
-  SSL_SESSION* next_sess_;
-  SSL* ssl_;
-  bool session_callbacks_;
-  bool new_session_wait_;
-
-  // SSL_set_cert_cb
-  CertCb cert_cb_;
-  void* cert_cb_arg_;
-  bool cert_cb_running_;
-
-  ClientHelloParser hello_parser_;
-
-#ifdef NODE__HAVE_TLSEXT_STATUS_CB
-  v8::Persistent<v8::Object> ocsp_response_;
-#endif  // NODE__HAVE_TLSEXT_STATUS_CB
-
-#ifdef SSL_CTRL_SET_TLSEXT_SERVERNAME_CB
-  v8::Persistent<v8::Value> sni_context_;
-#endif
-
-  friend class SecureContext;
-};
-
-// Connection inherits from AsyncWrap because SSLWrap makes calls to
-// MakeCallback, but SSLWrap doesn't store the handle itself. Instead it
-// assumes that any args.This() called will be the handle from Connection.
-class Connection : public AsyncWrap, public SSLWrap<Connection> {
- public:
-  ~Connection() override {
-#ifdef SSL_CTRL_SET_TLSEXT_SERVERNAME_CB
-    sniObject_.Reset();
-    servername_.Reset();
-#endif
-  }
-
-  static void Initialize(Environment* env, v8::Local<v8::Object> target);
-  void NewSessionDoneCb();
-
-#ifndef OPENSSL_NO_NEXTPROTONEG
-  v8::Persistent<v8::Object> npnProtos_;
-  v8::Persistent<v8::Value> selectedNPNProto_;
-#endif
-
-#ifdef SSL_CTRL_SET_TLSEXT_SERVERNAME_CB
-  v8::Persistent<v8::Object> sniObject_;
-  v8::Persistent<v8::String> servername_;
-#endif
-
-  size_t self_size() const override { return sizeof(*this); }
-
- protected:
-  static void New(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void EncIn(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void ClearOut(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void ClearPending(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void EncPending(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void EncOut(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void ClearIn(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void Start(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void Close(const v8::FunctionCallbackInfo<v8::Value>& args);
-
-#ifdef SSL_CTRL_SET_TLSEXT_SERVERNAME_CB
-  // SNI
-  static void GetServername(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void SetSNICallback(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static int SelectSNIContextCallback_(SSL* s, int* ad, void* arg);
-#endif
-
-  static void OnClientHelloParseEnd(void* arg);
-
-  int HandleBIOError(BIO* bio, const char* func, int rv);
-
-  enum ZeroStatus {
-    kZeroIsNotAnError,
-    kZeroIsAnError
-  };
-
-  enum SyscallStatus {
-    kIgnoreSyscall,
-    kSyscallError
-  };
-
-  int HandleSSLError(const char* func, int rv, ZeroStatus zs, SyscallStatus ss);
-
-  void ClearError();
-  void SetShutdownFlags();
-
-  Connection(Environment* env,
-             v8::Local<v8::Object> wrap,
-             SecureContext* sc,
-             SSLWrap<Connection>::Kind kind)
-      : AsyncWrap(env, wrap, AsyncWrap::PROVIDER_CRYPTO),
-        SSLWrap<Connection>(env, sc, kind),
-        bio_read_(nullptr),
-        bio_write_(nullptr),
-        hello_offset_(0) {
-    MakeWeak<Connection>(this);
-    hello_parser_.Start(SSLWrap<Connection>::OnClientHello,
-                        OnClientHelloParseEnd,
-                        this);
-    enable_session_callbacks();
-  }
-
- private:
-  static void SSLInfoCallback(const SSL *ssl, int where, int ret);
-
-  BIO *bio_read_;
-  BIO *bio_write_;
-
-  uint8_t hello_data_[18432];
-  size_t hello_offset_;
-
-  friend class ClientHelloParser;
-  friend class SecureContext;
-};
-
-class CipherBase : public BaseObject {
- public:
-  ~CipherBase() override {
-    if (!initialised_)
-      return;
-    delete[] auth_tag_;
-    EVP_CIPHER_CTX_cleanup(&ctx_);
-  }
-
-  static void Initialize(Environment* env, v8::Local<v8::Object> target);
-
- protected:
-  enum CipherKind {
-    kCipher,
-    kDecipher
-  };
-
-  void Init(const char* cipher_type, const char* key_buf, int key_buf_len);
-  void InitIv(const char* cipher_type,
-              const char* key,
-              int key_len,
-              const char* iv,
-              int iv_len);
-  bool Update(const char* data, int len, unsigned char** out, int* out_len);
-  bool Final(unsigned char** out, int *out_len);
-  bool SetAutoPadding(bool auto_padding);
-
-  bool IsAuthenticatedMode() const;
-  bool GetAuthTag(char** out, unsigned int* out_len) const;
-  bool SetAuthTag(const char* data, unsigned int len);
-  bool SetAAD(const char* data, unsigned int len);
-
-  static void New(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void Init(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void InitIv(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void Update(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void Final(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void SetAutoPadding(const v8::FunctionCallbackInfo<v8::Value>& args);
-
-  static void GetAuthTag(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void SetAuthTag(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void SetAAD(const v8::FunctionCallbackInfo<v8::Value>& args);
-
-  CipherBase(Environment* env,
-             v8::Local<v8::Object> wrap,
-             CipherKind kind)
-      : BaseObject(env, wrap),
-        cipher_(nullptr),
-        initialised_(false),
-        kind_(kind),
-        auth_tag_(nullptr),
-        auth_tag_len_(0) {
-    MakeWeak<CipherBase>(this);
-  }
-
- private:
-  EVP_CIPHER_CTX ctx_; /* coverity[member_decl] */
-  const EVP_CIPHER* cipher_; /* coverity[member_decl] */
-  bool initialised_;
-  CipherKind kind_;
-  char* auth_tag_;
-  unsigned int auth_tag_len_;
-};
-
-class Hmac : public BaseObject {
- public:
-  ~Hmac() override {
-    if (!initialised_)
-      return;
-    HMAC_CTX_cleanup(&ctx_);
-  }
-
-  static void Initialize(Environment* env, v8::Local<v8::Object> target);
-
- protected:
-  void HmacInit(const char* hash_type, const char* key, int key_len);
-  bool HmacUpdate(const char* data, int len);
-  bool HmacDigest(unsigned char** md_value, unsigned int* md_len);
-
-  static void New(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void HmacInit(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void HmacUpdate(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void HmacDigest(const v8::FunctionCallbackInfo<v8::Value>& args);
-
-  Hmac(Environment* env, v8::Local<v8::Object> wrap)
-      : BaseObject(env, wrap),
-        initialised_(false) {
-    MakeWeak<Hmac>(this);
-  }
-
- private:
-  HMAC_CTX ctx_; /* coverity[member_decl] */
-  bool initialised_;
-};
-
-class Hash : public BaseObject {
- public:
-  ~Hash() override {
-    if (!initialised_)
-      return;
-    EVP_MD_CTX_cleanup(&mdctx_);
-  }
-
-  static void Initialize(Environment* env, v8::Local<v8::Object> target);
-
-  bool HashInit(const char* hash_type);
-  bool HashUpdate(const char* data, int len);
-
- protected:
-  static void New(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void HashUpdate(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void HashDigest(const v8::FunctionCallbackInfo<v8::Value>& args);
-
-  Hash(Environment* env, v8::Local<v8::Object> wrap)
-      : BaseObject(env, wrap),
-        initialised_(false) {
-    MakeWeak<Hash>(this);
-  }
-
- private:
-  EVP_MD_CTX mdctx_; /* coverity[member_decl] */
-  bool initialised_;
-  bool finalized_;
-};
-
-class SignBase : public BaseObject {
- public:
-  typedef enum {
-    kSignOk,
-    kSignUnknownDigest,
-    kSignInit,
-    kSignNotInitialised,
-    kSignUpdate,
-    kSignPrivateKey,
-    kSignPublicKey
-  } Error;
-
-  SignBase(Environment* env, v8::Local<v8::Object> wrap)
-      : BaseObject(env, wrap),
-        initialised_(false) {
-  }
-
-  ~SignBase() override {
-    if (!initialised_)
-      return;
-    EVP_MD_CTX_cleanup(&mdctx_);
-  }
-
- protected:
-  void CheckThrow(Error error);
-
-  EVP_MD_CTX mdctx_; /* coverity[member_decl] */
-  bool initialised_;
-};
-
-class Sign : public SignBase {
- public:
-  static void Initialize(Environment* env, v8::Local<v8::Object> target);
-
-  Error SignInit(const char* sign_type);
-  Error SignUpdate(const char* data, int len);
-  Error SignFinal(const char* key_pem,
-                  int key_pem_len,
-                  const char* passphrase,
-                  unsigned char** sig,
-                  unsigned int *sig_len);
-
- protected:
-  static void New(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void SignInit(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void SignUpdate(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void SignFinal(const v8::FunctionCallbackInfo<v8::Value>& args);
-
-  Sign(Environment* env, v8::Local<v8::Object> wrap) : SignBase(env, wrap) {
-    MakeWeak<Sign>(this);
-  }
-};
-
-class Verify : public SignBase {
- public:
-  static void Initialize(Environment* env, v8::Local<v8::Object> target);
-
-  Error VerifyInit(const char* verify_type);
-  Error VerifyUpdate(const char* data, int len);
-  Error VerifyFinal(const char* key_pem,
-                    int key_pem_len,
-                    const char* sig,
-                    int siglen,
-                    bool* verify_result);
-
- protected:
-  static void New(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void VerifyInit(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void VerifyUpdate(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void VerifyFinal(const v8::FunctionCallbackInfo<v8::Value>& args);
-
-  Verify(Environment* env, v8::Local<v8::Object> wrap) : SignBase(env, wrap) {
-    MakeWeak<Verify>(this);
-  }
-};
-
-class PublicKeyCipher {
- public:
-  typedef int (*EVP_PKEY_cipher_init_t)(EVP_PKEY_CTX *ctx);
-  typedef int (*EVP_PKEY_cipher_t)(EVP_PKEY_CTX *ctx,
-                                   unsigned char *out, size_t *outlen,
-                                   const unsigned char *in, size_t inlen);
-
-  enum Operation {
-    kPublic,
-    kPrivate
-  };
-
-  template <Operation operation,
-            EVP_PKEY_cipher_init_t EVP_PKEY_cipher_init,
-            EVP_PKEY_cipher_t EVP_PKEY_cipher>
-  static bool Cipher(const char* key_pem,
-                     int key_pem_len,
-                     const char* passphrase,
-                     int padding,
-                     const unsigned char* data,
-                     int len,
-                     unsigned char** out,
-                     size_t* out_len);
-
-  template <Operation operation,
-            EVP_PKEY_cipher_init_t EVP_PKEY_cipher_init,
-            EVP_PKEY_cipher_t EVP_PKEY_cipher>
-  static void Cipher(const v8::FunctionCallbackInfo<v8::Value>& args);
-};
-
-class DiffieHellman : public BaseObject {
- public:
-  ~DiffieHellman() override {
-    if (dh != nullptr) {
-      DH_free(dh);
-    }
-  }
-
-  static void Initialize(Environment* env, v8::Local<v8::Object> target);
-
-  bool Init(int primeLength, int g);
-  bool Init(const char* p, int p_len, int g);
-  bool Init(const char* p, int p_len, const char* g, int g_len);
-
- protected:
-  static void DiffieHellmanGroup(
-      const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void New(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void GenerateKeys(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void GetPrime(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void GetGenerator(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void GetPublicKey(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void GetPrivateKey(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void ComputeSecret(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void SetPublicKey(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void SetPrivateKey(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void VerifyErrorGetter(
-      v8::Local<v8::String> property,
-      const v8::PropertyCallbackInfo<v8::Value>& args);
-
-  DiffieHellman(Environment* env, v8::Local<v8::Object> wrap)
-      : BaseObject(env, wrap),
-        initialised_(false),
-        verifyError_(0),
-        dh(nullptr) {
-    MakeWeak<DiffieHellman>(this);
-  }
-
- private:
-  bool VerifyContext();
-
-  bool initialised_;
-  int verifyError_;
-  DH* dh;
-};
-
-class ECDH : public BaseObject {
- public:
-  ~ECDH() override {
-    if (key_ != nullptr)
-      EC_KEY_free(key_);
-    key_ = nullptr;
-    group_ = nullptr;
-  }
-
-  static void Initialize(Environment* env, v8::Local<v8::Object> target);
-
- protected:
-  ECDH(Environment* env, v8::Local<v8::Object> wrap, EC_KEY* key)
-      : BaseObject(env, wrap),
-        key_(key),
-        group_(EC_KEY_get0_group(key_)) {
-    MakeWeak<ECDH>(this);
-    ASSERT_NE(group_, nullptr);
-  }
-
-  static void New(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void GenerateKeys(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void ComputeSecret(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void GetPrivateKey(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void SetPrivateKey(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void GetPublicKey(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void SetPublicKey(const v8::FunctionCallbackInfo<v8::Value>& args);
-
-  EC_POINT* BufferToPoint(char* data, size_t len);
-
-  bool IsKeyPairValid();
-  bool IsKeyValidForCurve(const BIGNUM* private_key);
-
-  EC_KEY* key_;
-  const EC_GROUP* group_;
-};
-
-bool EntropySource(unsigned char* buffer, size_t length);
-#ifndef OPENSSL_NO_ENGINE
-void SetEngine(const v8::FunctionCallbackInfo<v8::Value>& args);
-#endif  // !OPENSSL_NO_ENGINE
-void InitCrypto(v8::Local<v8::Object> target);
-
-}  // namespace crypto
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_NODE_CRYPTO_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/node_crypto_bio.h
+++ /dev/null
@@ -1,142 +0,0 @@
-#ifndef SRC_NODE_CRYPTO_BIO_H_
-#define SRC_NODE_CRYPTO_BIO_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "openssl/bio.h"
-#include "env.h"
-#include "env-inl.h"
-#include "util.h"
-#include "util-inl.h"
-#include "v8.h"
-
-namespace node {
-
-class NodeBIO {
- public:
-  NodeBIO() : env_(nullptr),
-              initial_(kInitialBufferLength),
-              length_(0),
-              read_head_(nullptr),
-              write_head_(nullptr) {
-  }
-
-  ~NodeBIO();
-
-  static BIO* New();
-
-  // NewFixed takes a copy of `len` bytes from `data` and returns a BIO that,
-  // when read from, returns those bytes followed by EOF.
-  static BIO* NewFixed(const char* data, size_t len);
-
-  void AssignEnvironment(Environment* env);
-
-  // Move read head to next buffer if needed
-  void TryMoveReadHead();
-
-  // Allocate new buffer for write if needed
-  void TryAllocateForWrite(size_t hint);
-
-  // Read `len` bytes maximum into `out`, return actual number of read bytes
-  size_t Read(char* out, size_t size);
-
-  // Memory optimization:
-  // Deallocate children of write head's child if they're empty
-  void FreeEmpty();
-
-  // Return pointer to internal data and amount of
-  // contiguous data available to read
-  char* Peek(size_t* size);
-
-  // Return pointers and sizes of multiple internal data chunks available for
-  // reading
-  size_t PeekMultiple(char** out, size_t* size, size_t* count);
-
-  // Find first appearance of `delim` in buffer or `limit` if `delim`
-  // wasn't found.
-  size_t IndexOf(char delim, size_t limit);
-
-  // Discard all available data
-  void Reset();
-
-  // Put `len` bytes from `data` into buffer
-  void Write(const char* data, size_t size);
-
-  // Return pointer to internal data and amount of
-  // contiguous data available for future writes
-  char* PeekWritable(size_t* size);
-
-  // Commit reserved data
-  void Commit(size_t size);
-
-
-  // Return size of buffer in bytes
-  inline size_t Length() const {
-    return length_;
-  }
-
-  inline void set_initial(size_t initial) {
-    initial_ = initial;
-  }
-
-  static inline NodeBIO* FromBIO(BIO* bio) {
-    CHECK_NE(bio->ptr, nullptr);
-    return static_cast<NodeBIO*>(bio->ptr);
-  }
-
- private:
-  static int New(BIO* bio);
-  static int Free(BIO* bio);
-  static int Read(BIO* bio, char* out, int len);
-  static int Write(BIO* bio, const char* data, int len);
-  static int Puts(BIO* bio, const char* str);
-  static int Gets(BIO* bio, char* out, int size);
-  static long Ctrl(BIO* bio, int cmd, long num,  // NOLINT(runtime/int)
-                   void* ptr);
-
-  // Enough to handle the most of the client hellos
-  static const size_t kInitialBufferLength = 1024;
-  static const size_t kThroughputBufferLength = 16384;
-
-  static const BIO_METHOD method;
-
-  class Buffer {
-   public:
-    Buffer(Environment* env, size_t len) : env_(env),
-                                           read_pos_(0),
-                                           write_pos_(0),
-                                           len_(len),
-                                           next_(nullptr) {
-      data_ = new char[len];
-      if (env_ != nullptr)
-        env_->isolate()->AdjustAmountOfExternalAllocatedMemory(len);
-    }
-
-    ~Buffer() {
-      delete[] data_;
-      if (env_ != nullptr) {
-        const int64_t len = static_cast<int64_t>(len_);
-        env_->isolate()->AdjustAmountOfExternalAllocatedMemory(-len);
-      }
-    }
-
-    Environment* env_;
-    size_t read_pos_;
-    size_t write_pos_;
-    size_t len_;
-    Buffer* next_;
-    char* data_;
-  };
-
-  Environment* env_;
-  size_t initial_;
-  size_t length_;
-  Buffer* read_head_;
-  Buffer* write_head_;
-};
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_NODE_CRYPTO_BIO_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/node_crypto_clienthello-inl.h
+++ /dev/null
@@ -1,60 +0,0 @@
-#ifndef SRC_NODE_CRYPTO_CLIENTHELLO_INL_H_
-#define SRC_NODE_CRYPTO_CLIENTHELLO_INL_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "util.h"
-#include "util-inl.h"
-
-namespace node {
-
-inline void ClientHelloParser::Reset() {
-  frame_len_ = 0;
-  body_offset_ = 0;
-  extension_offset_ = 0;
-  session_size_ = 0;
-  session_id_ = nullptr;
-  tls_ticket_size_ = -1;
-  tls_ticket_ = nullptr;
-  servername_size_ = 0;
-  servername_ = nullptr;
-}
-
-inline void ClientHelloParser::Start(ClientHelloParser::OnHelloCb onhello_cb,
-                                     ClientHelloParser::OnEndCb onend_cb,
-                                     void* onend_arg) {
-  if (!IsEnded())
-    return;
-  Reset();
-
-  CHECK_NE(onhello_cb, nullptr);
-
-  state_ = kWaiting;
-  onhello_cb_ = onhello_cb;
-  onend_cb_ = onend_cb;
-  cb_arg_ = onend_arg;
-}
-
-inline void ClientHelloParser::End() {
-  if (state_ == kEnded)
-    return;
-  state_ = kEnded;
-  if (onend_cb_ != nullptr) {
-    onend_cb_(cb_arg_);
-    onend_cb_ = nullptr;
-  }
-}
-
-inline bool ClientHelloParser::IsEnded() const {
-  return state_ == kEnded;
-}
-
-inline bool ClientHelloParser::IsPaused() const {
-  return state_ == kPaused;
-}
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_NODE_CRYPTO_CLIENTHELLO_INL_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/node_crypto_clienthello.h
+++ /dev/null
@@ -1,119 +0,0 @@
-#ifndef SRC_NODE_CRYPTO_CLIENTHELLO_H_
-#define SRC_NODE_CRYPTO_CLIENTHELLO_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "node.h"
-
-#include <stddef.h>  // size_t
-#include <stdlib.h>  // nullptr
-
-namespace node {
-
-class ClientHelloParser {
- public:
-  ClientHelloParser() : state_(kEnded),
-                        onhello_cb_(nullptr),
-                        onend_cb_(nullptr),
-                        cb_arg_(nullptr),
-                        session_size_(0),
-                        session_id_(nullptr),
-                        servername_size_(0),
-                        servername_(nullptr),
-                        ocsp_request_(0),
-                        tls_ticket_size_(0),
-                        tls_ticket_(nullptr) {
-    Reset();
-  }
-
-  class ClientHello {
-   public:
-    inline uint8_t session_size() const { return session_size_; }
-    inline const uint8_t* session_id() const { return session_id_; }
-    inline bool has_ticket() const { return has_ticket_; }
-    inline uint8_t servername_size() const { return servername_size_; }
-    inline const uint8_t* servername() const { return servername_; }
-    inline int ocsp_request() const { return ocsp_request_; }
-
-   private:
-    uint8_t session_size_;
-    const uint8_t* session_id_;
-    bool has_ticket_;
-    uint8_t servername_size_;
-    const uint8_t* servername_;
-    int ocsp_request_;
-
-    friend class ClientHelloParser;
-  };
-
-  typedef void (*OnHelloCb)(void* arg, const ClientHello& hello);
-  typedef void (*OnEndCb)(void* arg);
-
-  void Parse(const uint8_t* data, size_t avail);
-
-  inline void Reset();
-  inline void Start(OnHelloCb onhello_cb, OnEndCb onend_cb, void* onend_arg);
-  inline void End();
-  inline bool IsPaused() const;
-  inline bool IsEnded() const;
-
- private:
-  static const size_t kMaxTLSFrameLen = 16 * 1024 + 5;
-  static const size_t kMaxSSLExFrameLen = 32 * 1024;
-  static const uint8_t kServernameHostname = 0;
-  static const uint8_t kStatusRequestOCSP = 1;
-  static const size_t kMinStatusRequestSize = 5;
-
-  enum ParseState {
-    kWaiting,
-    kTLSHeader,
-    kPaused,
-    kEnded
-  };
-
-  enum FrameType {
-    kChangeCipherSpec = 20,
-    kAlert = 21,
-    kHandshake = 22,
-    kApplicationData = 23,
-    kOther = 255
-  };
-
-  enum HandshakeType {
-    kClientHello = 1
-  };
-
-  enum ExtensionType {
-    kServerName = 0,
-    kStatusRequest = 5,
-    kTLSSessionTicket = 35
-  };
-
-  bool ParseRecordHeader(const uint8_t* data, size_t avail);
-  void ParseHeader(const uint8_t* data, size_t avail);
-  void ParseExtension(const uint16_t type,
-                      const uint8_t* data,
-                      size_t len);
-  bool ParseTLSClientHello(const uint8_t* data, size_t avail);
-
-  ParseState state_;
-  OnHelloCb onhello_cb_;
-  OnEndCb onend_cb_;
-  void* cb_arg_;
-  size_t frame_len_;
-  size_t body_offset_;
-  size_t extension_offset_;
-  uint8_t session_size_;
-  const uint8_t* session_id_;
-  uint16_t servername_size_;
-  const uint8_t* servername_;
-  uint8_t ocsp_request_;
-  uint16_t tls_ticket_size_;
-  const uint8_t* tls_ticket_;
-};
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_NODE_CRYPTO_CLIENTHELLO_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/node_crypto_groups.h
+++ /dev/null
@@ -1,395 +0,0 @@
-#ifndef SRC_NODE_CRYPTO_GROUPS_H_
-#define SRC_NODE_CRYPTO_GROUPS_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-/*
-    These modular groups were literally taken from:
-       * RFC 2412 (groups 1 and 2)
-       * RFC 3526 (groups 5, 14, 15, 16, 17 and 18)
-    They all use 2 as a generator.
-*/
-
-
-static const unsigned char two_generator[] = { 2 };
-
-static const unsigned char group_modp1[] = {
-  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc9, 0x0f,
-  0xda, 0xa2, 0x21, 0x68, 0xc2, 0x34, 0xc4, 0xc6, 0x62, 0x8b,
-  0x80, 0xdc, 0x1c, 0xd1, 0x29, 0x02, 0x4e, 0x08, 0x8a, 0x67,
-  0xcc, 0x74, 0x02, 0x0b, 0xbe, 0xa6, 0x3b, 0x13, 0x9b, 0x22,
-  0x51, 0x4a, 0x08, 0x79, 0x8e, 0x34, 0x04, 0xdd, 0xef, 0x95,
-  0x19, 0xb3, 0xcd, 0x3a, 0x43, 0x1b, 0x30, 0x2b, 0x0a, 0x6d,
-  0xf2, 0x5f, 0x14, 0x37, 0x4f, 0xe1, 0x35, 0x6d, 0x6d, 0x51,
-  0xc2, 0x45, 0xe4, 0x85, 0xb5, 0x76, 0x62, 0x5e, 0x7e, 0xc6,
-  0xf4, 0x4c, 0x42, 0xe9, 0xa6, 0x3a, 0x36, 0x20, 0xff, 0xff,
-  0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
-
-static const unsigned char group_modp2[] = {
-  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc9, 0x0f,
-  0xda, 0xa2, 0x21, 0x68, 0xc2, 0x34, 0xc4, 0xc6, 0x62, 0x8b,
-  0x80, 0xdc, 0x1c, 0xd1, 0x29, 0x02, 0x4e, 0x08, 0x8a, 0x67,
-  0xcc, 0x74, 0x02, 0x0b, 0xbe, 0xa6, 0x3b, 0x13, 0x9b, 0x22,
-  0x51, 0x4a, 0x08, 0x79, 0x8e, 0x34, 0x04, 0xdd, 0xef, 0x95,
-  0x19, 0xb3, 0xcd, 0x3a, 0x43, 0x1b, 0x30, 0x2b, 0x0a, 0x6d,
-  0xf2, 0x5f, 0x14, 0x37, 0x4f, 0xe1, 0x35, 0x6d, 0x6d, 0x51,
-  0xc2, 0x45, 0xe4, 0x85, 0xb5, 0x76, 0x62, 0x5e, 0x7e, 0xc6,
-  0xf4, 0x4c, 0x42, 0xe9, 0xa6, 0x37, 0xed, 0x6b, 0x0b, 0xff,
-  0x5c, 0xb6, 0xf4, 0x06, 0xb7, 0xed, 0xee, 0x38, 0x6b, 0xfb,
-  0x5a, 0x89, 0x9f, 0xa5, 0xae, 0x9f, 0x24, 0x11, 0x7c, 0x4b,
-  0x1f, 0xe6, 0x49, 0x28, 0x66, 0x51, 0xec, 0xe6, 0x53, 0x81,
-  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
-
-static const unsigned char group_modp5[] = {
-  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc9, 0x0f,
-  0xda, 0xa2, 0x21, 0x68, 0xc2, 0x34, 0xc4, 0xc6, 0x62, 0x8b,
-  0x80, 0xdc, 0x1c, 0xd1, 0x29, 0x02, 0x4e, 0x08, 0x8a, 0x67,
-  0xcc, 0x74, 0x02, 0x0b, 0xbe, 0xa6, 0x3b, 0x13, 0x9b, 0x22,
-  0x51, 0x4a, 0x08, 0x79, 0x8e, 0x34, 0x04, 0xdd, 0xef, 0x95,
-  0x19, 0xb3, 0xcd, 0x3a, 0x43, 0x1b, 0x30, 0x2b, 0x0a, 0x6d,
-  0xf2, 0x5f, 0x14, 0x37, 0x4f, 0xe1, 0x35, 0x6d, 0x6d, 0x51,
-  0xc2, 0x45, 0xe4, 0x85, 0xb5, 0x76, 0x62, 0x5e, 0x7e, 0xc6,
-  0xf4, 0x4c, 0x42, 0xe9, 0xa6, 0x37, 0xed, 0x6b, 0x0b, 0xff,
-  0x5c, 0xb6, 0xf4, 0x06, 0xb7, 0xed, 0xee, 0x38, 0x6b, 0xfb,
-  0x5a, 0x89, 0x9f, 0xa5, 0xae, 0x9f, 0x24, 0x11, 0x7c, 0x4b,
-  0x1f, 0xe6, 0x49, 0x28, 0x66, 0x51, 0xec, 0xe4, 0x5b, 0x3d,
-  0xc2, 0x00, 0x7c, 0xb8, 0xa1, 0x63, 0xbf, 0x05, 0x98, 0xda,
-  0x48, 0x36, 0x1c, 0x55, 0xd3, 0x9a, 0x69, 0x16, 0x3f, 0xa8,
-  0xfd, 0x24, 0xcf, 0x5f, 0x83, 0x65, 0x5d, 0x23, 0xdc, 0xa3,
-  0xad, 0x96, 0x1c, 0x62, 0xf3, 0x56, 0x20, 0x85, 0x52, 0xbb,
-  0x9e, 0xd5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6d, 0x67, 0x0c,
-  0x35, 0x4e, 0x4a, 0xbc, 0x98, 0x04, 0xf1, 0x74, 0x6c, 0x08,
-  0xca, 0x23, 0x73, 0x27, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-  0xff, 0xff };
-
-static const unsigned char group_modp14[] = {
-  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc9, 0x0f,
-  0xda, 0xa2, 0x21, 0x68, 0xc2, 0x34, 0xc4, 0xc6, 0x62, 0x8b,
-  0x80, 0xdc, 0x1c, 0xd1, 0x29, 0x02, 0x4e, 0x08, 0x8a, 0x67,
-  0xcc, 0x74, 0x02, 0x0b, 0xbe, 0xa6, 0x3b, 0x13, 0x9b, 0x22,
-  0x51, 0x4a, 0x08, 0x79, 0x8e, 0x34, 0x04, 0xdd, 0xef, 0x95,
-  0x19, 0xb3, 0xcd, 0x3a, 0x43, 0x1b, 0x30, 0x2b, 0x0a, 0x6d,
-  0xf2, 0x5f, 0x14, 0x37, 0x4f, 0xe1, 0x35, 0x6d, 0x6d, 0x51,
-  0xc2, 0x45, 0xe4, 0x85, 0xb5, 0x76, 0x62, 0x5e, 0x7e, 0xc6,
-  0xf4, 0x4c, 0x42, 0xe9, 0xa6, 0x37, 0xed, 0x6b, 0x0b, 0xff,
-  0x5c, 0xb6, 0xf4, 0x06, 0xb7, 0xed, 0xee, 0x38, 0x6b, 0xfb,
-  0x5a, 0x89, 0x9f, 0xa5, 0xae, 0x9f, 0x24, 0x11, 0x7c, 0x4b,
-  0x1f, 0xe6, 0x49, 0x28, 0x66, 0x51, 0xec, 0xe4, 0x5b, 0x3d,
-  0xc2, 0x00, 0x7c, 0xb8, 0xa1, 0x63, 0xbf, 0x05, 0x98, 0xda,
-  0x48, 0x36, 0x1c, 0x55, 0xd3, 0x9a, 0x69, 0x16, 0x3f, 0xa8,
-  0xfd, 0x24, 0xcf, 0x5f, 0x83, 0x65, 0x5d, 0x23, 0xdc, 0xa3,
-  0xad, 0x96, 0x1c, 0x62, 0xf3, 0x56, 0x20, 0x85, 0x52, 0xbb,
-  0x9e, 0xd5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6d, 0x67, 0x0c,
-  0x35, 0x4e, 0x4a, 0xbc, 0x98, 0x04, 0xf1, 0x74, 0x6c, 0x08,
-  0xca, 0x18, 0x21, 0x7c, 0x32, 0x90, 0x5e, 0x46, 0x2e, 0x36,
-  0xce, 0x3b, 0xe3, 0x9e, 0x77, 0x2c, 0x18, 0x0e, 0x86, 0x03,
-  0x9b, 0x27, 0x83, 0xa2, 0xec, 0x07, 0xa2, 0x8f, 0xb5, 0xc5,
-  0x5d, 0xf0, 0x6f, 0x4c, 0x52, 0xc9, 0xde, 0x2b, 0xcb, 0xf6,
-  0x95, 0x58, 0x17, 0x18, 0x39, 0x95, 0x49, 0x7c, 0xea, 0x95,
-  0x6a, 0xe5, 0x15, 0xd2, 0x26, 0x18, 0x98, 0xfa, 0x05, 0x10,
-  0x15, 0x72, 0x8e, 0x5a, 0x8a, 0xac, 0xaa, 0x68, 0xff, 0xff,
-  0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
-
-static const unsigned char group_modp15[] = {
-  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc9, 0x0f,
-  0xda, 0xa2, 0x21, 0x68, 0xc2, 0x34, 0xc4, 0xc6, 0x62, 0x8b,
-  0x80, 0xdc, 0x1c, 0xd1, 0x29, 0x02, 0x4e, 0x08, 0x8a, 0x67,
-  0xcc, 0x74, 0x02, 0x0b, 0xbe, 0xa6, 0x3b, 0x13, 0x9b, 0x22,
-  0x51, 0x4a, 0x08, 0x79, 0x8e, 0x34, 0x04, 0xdd, 0xef, 0x95,
-  0x19, 0xb3, 0xcd, 0x3a, 0x43, 0x1b, 0x30, 0x2b, 0x0a, 0x6d,
-  0xf2, 0x5f, 0x14, 0x37, 0x4f, 0xe1, 0x35, 0x6d, 0x6d, 0x51,
-  0xc2, 0x45, 0xe4, 0x85, 0xb5, 0x76, 0x62, 0x5e, 0x7e, 0xc6,
-  0xf4, 0x4c, 0x42, 0xe9, 0xa6, 0x37, 0xed, 0x6b, 0x0b, 0xff,
-  0x5c, 0xb6, 0xf4, 0x06, 0xb7, 0xed, 0xee, 0x38, 0x6b, 0xfb,
-  0x5a, 0x89, 0x9f, 0xa5, 0xae, 0x9f, 0x24, 0x11, 0x7c, 0x4b,
-  0x1f, 0xe6, 0x49, 0x28, 0x66, 0x51, 0xec, 0xe4, 0x5b, 0x3d,
-  0xc2, 0x00, 0x7c, 0xb8, 0xa1, 0x63, 0xbf, 0x05, 0x98, 0xda,
-  0x48, 0x36, 0x1c, 0x55, 0xd3, 0x9a, 0x69, 0x16, 0x3f, 0xa8,
-  0xfd, 0x24, 0xcf, 0x5f, 0x83, 0x65, 0x5d, 0x23, 0xdc, 0xa3,
-  0xad, 0x96, 0x1c, 0x62, 0xf3, 0x56, 0x20, 0x85, 0x52, 0xbb,
-  0x9e, 0xd5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6d, 0x67, 0x0c,
-  0x35, 0x4e, 0x4a, 0xbc, 0x98, 0x04, 0xf1, 0x74, 0x6c, 0x08,
-  0xca, 0x18, 0x21, 0x7c, 0x32, 0x90, 0x5e, 0x46, 0x2e, 0x36,
-  0xce, 0x3b, 0xe3, 0x9e, 0x77, 0x2c, 0x18, 0x0e, 0x86, 0x03,
-  0x9b, 0x27, 0x83, 0xa2, 0xec, 0x07, 0xa2, 0x8f, 0xb5, 0xc5,
-  0x5d, 0xf0, 0x6f, 0x4c, 0x52, 0xc9, 0xde, 0x2b, 0xcb, 0xf6,
-  0x95, 0x58, 0x17, 0x18, 0x39, 0x95, 0x49, 0x7c, 0xea, 0x95,
-  0x6a, 0xe5, 0x15, 0xd2, 0x26, 0x18, 0x98, 0xfa, 0x05, 0x10,
-  0x15, 0x72, 0x8e, 0x5a, 0x8a, 0xaa, 0xc4, 0x2d, 0xad, 0x33,
-  0x17, 0x0d, 0x04, 0x50, 0x7a, 0x33, 0xa8, 0x55, 0x21, 0xab,
-  0xdf, 0x1c, 0xba, 0x64, 0xec, 0xfb, 0x85, 0x04, 0x58, 0xdb,
-  0xef, 0x0a, 0x8a, 0xea, 0x71, 0x57, 0x5d, 0x06, 0x0c, 0x7d,
-  0xb3, 0x97, 0x0f, 0x85, 0xa6, 0xe1, 0xe4, 0xc7, 0xab, 0xf5,
-  0xae, 0x8c, 0xdb, 0x09, 0x33, 0xd7, 0x1e, 0x8c, 0x94, 0xe0,
-  0x4a, 0x25, 0x61, 0x9d, 0xce, 0xe3, 0xd2, 0x26, 0x1a, 0xd2,
-  0xee, 0x6b, 0xf1, 0x2f, 0xfa, 0x06, 0xd9, 0x8a, 0x08, 0x64,
-  0xd8, 0x76, 0x02, 0x73, 0x3e, 0xc8, 0x6a, 0x64, 0x52, 0x1f,
-  0x2b, 0x18, 0x17, 0x7b, 0x20, 0x0c, 0xbb, 0xe1, 0x17, 0x57,
-  0x7a, 0x61, 0x5d, 0x6c, 0x77, 0x09, 0x88, 0xc0, 0xba, 0xd9,
-  0x46, 0xe2, 0x08, 0xe2, 0x4f, 0xa0, 0x74, 0xe5, 0xab, 0x31,
-  0x43, 0xdb, 0x5b, 0xfc, 0xe0, 0xfd, 0x10, 0x8e, 0x4b, 0x82,
-  0xd1, 0x20, 0xa9, 0x3a, 0xd2, 0xca, 0xff, 0xff, 0xff, 0xff,
-  0xff, 0xff, 0xff, 0xff };
-
-static const unsigned char group_modp16[] = {
-  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc9, 0x0f,
-  0xda, 0xa2, 0x21, 0x68, 0xc2, 0x34, 0xc4, 0xc6, 0x62, 0x8b,
-  0x80, 0xdc, 0x1c, 0xd1, 0x29, 0x02, 0x4e, 0x08, 0x8a, 0x67,
-  0xcc, 0x74, 0x02, 0x0b, 0xbe, 0xa6, 0x3b, 0x13, 0x9b, 0x22,
-  0x51, 0x4a, 0x08, 0x79, 0x8e, 0x34, 0x04, 0xdd, 0xef, 0x95,
-  0x19, 0xb3, 0xcd, 0x3a, 0x43, 0x1b, 0x30, 0x2b, 0x0a, 0x6d,
-  0xf2, 0x5f, 0x14, 0x37, 0x4f, 0xe1, 0x35, 0x6d, 0x6d, 0x51,
-  0xc2, 0x45, 0xe4, 0x85, 0xb5, 0x76, 0x62, 0x5e, 0x7e, 0xc6,
-  0xf4, 0x4c, 0x42, 0xe9, 0xa6, 0x37, 0xed, 0x6b, 0x0b, 0xff,
-  0x5c, 0xb6, 0xf4, 0x06, 0xb7, 0xed, 0xee, 0x38, 0x6b, 0xfb,
-  0x5a, 0x89, 0x9f, 0xa5, 0xae, 0x9f, 0x24, 0x11, 0x7c, 0x4b,
-  0x1f, 0xe6, 0x49, 0x28, 0x66, 0x51, 0xec, 0xe4, 0x5b, 0x3d,
-  0xc2, 0x00, 0x7c, 0xb8, 0xa1, 0x63, 0xbf, 0x05, 0x98, 0xda,
-  0x48, 0x36, 0x1c, 0x55, 0xd3, 0x9a, 0x69, 0x16, 0x3f, 0xa8,
-  0xfd, 0x24, 0xcf, 0x5f, 0x83, 0x65, 0x5d, 0x23, 0xdc, 0xa3,
-  0xad, 0x96, 0x1c, 0x62, 0xf3, 0x56, 0x20, 0x85, 0x52, 0xbb,
-  0x9e, 0xd5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6d, 0x67, 0x0c,
-  0x35, 0x4e, 0x4a, 0xbc, 0x98, 0x04, 0xf1, 0x74, 0x6c, 0x08,
-  0xca, 0x18, 0x21, 0x7c, 0x32, 0x90, 0x5e, 0x46, 0x2e, 0x36,
-  0xce, 0x3b, 0xe3, 0x9e, 0x77, 0x2c, 0x18, 0x0e, 0x86, 0x03,
-  0x9b, 0x27, 0x83, 0xa2, 0xec, 0x07, 0xa2, 0x8f, 0xb5, 0xc5,
-  0x5d, 0xf0, 0x6f, 0x4c, 0x52, 0xc9, 0xde, 0x2b, 0xcb, 0xf6,
-  0x95, 0x58, 0x17, 0x18, 0x39, 0x95, 0x49, 0x7c, 0xea, 0x95,
-  0x6a, 0xe5, 0x15, 0xd2, 0x26, 0x18, 0x98, 0xfa, 0x05, 0x10,
-  0x15, 0x72, 0x8e, 0x5a, 0x8a, 0xaa, 0xc4, 0x2d, 0xad, 0x33,
-  0x17, 0x0d, 0x04, 0x50, 0x7a, 0x33, 0xa8, 0x55, 0x21, 0xab,
-  0xdf, 0x1c, 0xba, 0x64, 0xec, 0xfb, 0x85, 0x04, 0x58, 0xdb,
-  0xef, 0x0a, 0x8a, 0xea, 0x71, 0x57, 0x5d, 0x06, 0x0c, 0x7d,
-  0xb3, 0x97, 0x0f, 0x85, 0xa6, 0xe1, 0xe4, 0xc7, 0xab, 0xf5,
-  0xae, 0x8c, 0xdb, 0x09, 0x33, 0xd7, 0x1e, 0x8c, 0x94, 0xe0,
-  0x4a, 0x25, 0x61, 0x9d, 0xce, 0xe3, 0xd2, 0x26, 0x1a, 0xd2,
-  0xee, 0x6b, 0xf1, 0x2f, 0xfa, 0x06, 0xd9, 0x8a, 0x08, 0x64,
-  0xd8, 0x76, 0x02, 0x73, 0x3e, 0xc8, 0x6a, 0x64, 0x52, 0x1f,
-  0x2b, 0x18, 0x17, 0x7b, 0x20, 0x0c, 0xbb, 0xe1, 0x17, 0x57,
-  0x7a, 0x61, 0x5d, 0x6c, 0x77, 0x09, 0x88, 0xc0, 0xba, 0xd9,
-  0x46, 0xe2, 0x08, 0xe2, 0x4f, 0xa0, 0x74, 0xe5, 0xab, 0x31,
-  0x43, 0xdb, 0x5b, 0xfc, 0xe0, 0xfd, 0x10, 0x8e, 0x4b, 0x82,
-  0xd1, 0x20, 0xa9, 0x21, 0x08, 0x01, 0x1a, 0x72, 0x3c, 0x12,
-  0xa7, 0x87, 0xe6, 0xd7, 0x88, 0x71, 0x9a, 0x10, 0xbd, 0xba,
-  0x5b, 0x26, 0x99, 0xc3, 0x27, 0x18, 0x6a, 0xf4, 0xe2, 0x3c,
-  0x1a, 0x94, 0x68, 0x34, 0xb6, 0x15, 0x0b, 0xda, 0x25, 0x83,
-  0xe9, 0xca, 0x2a, 0xd4, 0x4c, 0xe8, 0xdb, 0xbb, 0xc2, 0xdb,
-  0x04, 0xde, 0x8e, 0xf9, 0x2e, 0x8e, 0xfc, 0x14, 0x1f, 0xbe,
-  0xca, 0xa6, 0x28, 0x7c, 0x59, 0x47, 0x4e, 0x6b, 0xc0, 0x5d,
-  0x99, 0xb2, 0x96, 0x4f, 0xa0, 0x90, 0xc3, 0xa2, 0x23, 0x3b,
-  0xa1, 0x86, 0x51, 0x5b, 0xe7, 0xed, 0x1f, 0x61, 0x29, 0x70,
-  0xce, 0xe2, 0xd7, 0xaf, 0xb8, 0x1b, 0xdd, 0x76, 0x21, 0x70,
-  0x48, 0x1c, 0xd0, 0x06, 0x91, 0x27, 0xd5, 0xb0, 0x5a, 0xa9,
-  0x93, 0xb4, 0xea, 0x98, 0x8d, 0x8f, 0xdd, 0xc1, 0x86, 0xff,
-  0xb7, 0xdc, 0x90, 0xa6, 0xc0, 0x8f, 0x4d, 0xf4, 0x35, 0xc9,
-  0x34, 0x06, 0x31, 0x99, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-  0xff, 0xff };
-
-static const unsigned char group_modp17[] = {
-  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc9, 0x0f,
-  0xda, 0xa2, 0x21, 0x68, 0xc2, 0x34, 0xc4, 0xc6, 0x62, 0x8b,
-  0x80, 0xdc, 0x1c, 0xd1, 0x29, 0x02, 0x4e, 0x08, 0x8a, 0x67,
-  0xcc, 0x74, 0x02, 0x0b, 0xbe, 0xa6, 0x3b, 0x13, 0x9b, 0x22,
-  0x51, 0x4a, 0x08, 0x79, 0x8e, 0x34, 0x04, 0xdd, 0xef, 0x95,
-  0x19, 0xb3, 0xcd, 0x3a, 0x43, 0x1b, 0x30, 0x2b, 0x0a, 0x6d,
-  0xf2, 0x5f, 0x14, 0x37, 0x4f, 0xe1, 0x35, 0x6d, 0x6d, 0x51,
-  0xc2, 0x45, 0xe4, 0x85, 0xb5, 0x76, 0x62, 0x5e, 0x7e, 0xc6,
-  0xf4, 0x4c, 0x42, 0xe9, 0xa6, 0x37, 0xed, 0x6b, 0x0b, 0xff,
-  0x5c, 0xb6, 0xf4, 0x06, 0xb7, 0xed, 0xee, 0x38, 0x6b, 0xfb,
-  0x5a, 0x89, 0x9f, 0xa5, 0xae, 0x9f, 0x24, 0x11, 0x7c, 0x4b,
-  0x1f, 0xe6, 0x49, 0x28, 0x66, 0x51, 0xec, 0xe4, 0x5b, 0x3d,
-  0xc2, 0x00, 0x7c, 0xb8, 0xa1, 0x63, 0xbf, 0x05, 0x98, 0xda,
-  0x48, 0x36, 0x1c, 0x55, 0xd3, 0x9a, 0x69, 0x16, 0x3f, 0xa8,
-  0xfd, 0x24, 0xcf, 0x5f, 0x83, 0x65, 0x5d, 0x23, 0xdc, 0xa3,
-  0xad, 0x96, 0x1c, 0x62, 0xf3, 0x56, 0x20, 0x85, 0x52, 0xbb,
-  0x9e, 0xd5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6d, 0x67, 0x0c,
-  0x35, 0x4e, 0x4a, 0xbc, 0x98, 0x04, 0xf1, 0x74, 0x6c, 0x08,
-  0xca, 0x18, 0x21, 0x7c, 0x32, 0x90, 0x5e, 0x46, 0x2e, 0x36,
-  0xce, 0x3b, 0xe3, 0x9e, 0x77, 0x2c, 0x18, 0x0e, 0x86, 0x03,
-  0x9b, 0x27, 0x83, 0xa2, 0xec, 0x07, 0xa2, 0x8f, 0xb5, 0xc5,
-  0x5d, 0xf0, 0x6f, 0x4c, 0x52, 0xc9, 0xde, 0x2b, 0xcb, 0xf6,
-  0x95, 0x58, 0x17, 0x18, 0x39, 0x95, 0x49, 0x7c, 0xea, 0x95,
-  0x6a, 0xe5, 0x15, 0xd2, 0x26, 0x18, 0x98, 0xfa, 0x05, 0x10,
-  0x15, 0x72, 0x8e, 0x5a, 0x8a, 0xaa, 0xc4, 0x2d, 0xad, 0x33,
-  0x17, 0x0d, 0x04, 0x50, 0x7a, 0x33, 0xa8, 0x55, 0x21, 0xab,
-  0xdf, 0x1c, 0xba, 0x64, 0xec, 0xfb, 0x85, 0x04, 0x58, 0xdb,
-  0xef, 0x0a, 0x8a, 0xea, 0x71, 0x57, 0x5d, 0x06, 0x0c, 0x7d,
-  0xb3, 0x97, 0x0f, 0x85, 0xa6, 0xe1, 0xe4, 0xc7, 0xab, 0xf5,
-  0xae, 0x8c, 0xdb, 0x09, 0x33, 0xd7, 0x1e, 0x8c, 0x94, 0xe0,
-  0x4a, 0x25, 0x61, 0x9d, 0xce, 0xe3, 0xd2, 0x26, 0x1a, 0xd2,
-  0xee, 0x6b, 0xf1, 0x2f, 0xfa, 0x06, 0xd9, 0x8a, 0x08, 0x64,
-  0xd8, 0x76, 0x02, 0x73, 0x3e, 0xc8, 0x6a, 0x64, 0x52, 0x1f,
-  0x2b, 0x18, 0x17, 0x7b, 0x20, 0x0c, 0xbb, 0xe1, 0x17, 0x57,
-  0x7a, 0x61, 0x5d, 0x6c, 0x77, 0x09, 0x88, 0xc0, 0xba, 0xd9,
-  0x46, 0xe2, 0x08, 0xe2, 0x4f, 0xa0, 0x74, 0xe5, 0xab, 0x31,
-  0x43, 0xdb, 0x5b, 0xfc, 0xe0, 0xfd, 0x10, 0x8e, 0x4b, 0x82,
-  0xd1, 0x20, 0xa9, 0x21, 0x08, 0x01, 0x1a, 0x72, 0x3c, 0x12,
-  0xa7, 0x87, 0xe6, 0xd7, 0x88, 0x71, 0x9a, 0x10, 0xbd, 0xba,
-  0x5b, 0x26, 0x99, 0xc3, 0x27, 0x18, 0x6a, 0xf4, 0xe2, 0x3c,
-  0x1a, 0x94, 0x68, 0x34, 0xb6, 0x15, 0x0b, 0xda, 0x25, 0x83,
-  0xe9, 0xca, 0x2a, 0xd4, 0x4c, 0xe8, 0xdb, 0xbb, 0xc2, 0xdb,
-  0x04, 0xde, 0x8e, 0xf9, 0x2e, 0x8e, 0xfc, 0x14, 0x1f, 0xbe,
-  0xca, 0xa6, 0x28, 0x7c, 0x59, 0x47, 0x4e, 0x6b, 0xc0, 0x5d,
-  0x99, 0xb2, 0x96, 0x4f, 0xa0, 0x90, 0xc3, 0xa2, 0x23, 0x3b,
-  0xa1, 0x86, 0x51, 0x5b, 0xe7, 0xed, 0x1f, 0x61, 0x29, 0x70,
-  0xce, 0xe2, 0xd7, 0xaf, 0xb8, 0x1b, 0xdd, 0x76, 0x21, 0x70,
-  0x48, 0x1c, 0xd0, 0x06, 0x91, 0x27, 0xd5, 0xb0, 0x5a, 0xa9,
-  0x93, 0xb4, 0xea, 0x98, 0x8d, 0x8f, 0xdd, 0xc1, 0x86, 0xff,
-  0xb7, 0xdc, 0x90, 0xa6, 0xc0, 0x8f, 0x4d, 0xf4, 0x35, 0xc9,
-  0x34, 0x02, 0x84, 0x92, 0x36, 0xc3, 0xfa, 0xb4, 0xd2, 0x7c,
-  0x70, 0x26, 0xc1, 0xd4, 0xdc, 0xb2, 0x60, 0x26, 0x46, 0xde,
-  0xc9, 0x75, 0x1e, 0x76, 0x3d, 0xba, 0x37, 0xbd, 0xf8, 0xff,
-  0x94, 0x06, 0xad, 0x9e, 0x53, 0x0e, 0xe5, 0xdb, 0x38, 0x2f,
-  0x41, 0x30, 0x01, 0xae, 0xb0, 0x6a, 0x53, 0xed, 0x90, 0x27,
-  0xd8, 0x31, 0x17, 0x97, 0x27, 0xb0, 0x86, 0x5a, 0x89, 0x18,
-  0xda, 0x3e, 0xdb, 0xeb, 0xcf, 0x9b, 0x14, 0xed, 0x44, 0xce,
-  0x6c, 0xba, 0xce, 0xd4, 0xbb, 0x1b, 0xdb, 0x7f, 0x14, 0x47,
-  0xe6, 0xcc, 0x25, 0x4b, 0x33, 0x20, 0x51, 0x51, 0x2b, 0xd7,
-  0xaf, 0x42, 0x6f, 0xb8, 0xf4, 0x01, 0x37, 0x8c, 0xd2, 0xbf,
-  0x59, 0x83, 0xca, 0x01, 0xc6, 0x4b, 0x92, 0xec, 0xf0, 0x32,
-  0xea, 0x15, 0xd1, 0x72, 0x1d, 0x03, 0xf4, 0x82, 0xd7, 0xce,
-  0x6e, 0x74, 0xfe, 0xf6, 0xd5, 0x5e, 0x70, 0x2f, 0x46, 0x98,
-  0x0c, 0x82, 0xb5, 0xa8, 0x40, 0x31, 0x90, 0x0b, 0x1c, 0x9e,
-  0x59, 0xe7, 0xc9, 0x7f, 0xbe, 0xc7, 0xe8, 0xf3, 0x23, 0xa9,
-  0x7a, 0x7e, 0x36, 0xcc, 0x88, 0xbe, 0x0f, 0x1d, 0x45, 0xb7,
-  0xff, 0x58, 0x5a, 0xc5, 0x4b, 0xd4, 0x07, 0xb2, 0x2b, 0x41,
-  0x54, 0xaa, 0xcc, 0x8f, 0x6d, 0x7e, 0xbf, 0x48, 0xe1, 0xd8,
-  0x14, 0xcc, 0x5e, 0xd2, 0x0f, 0x80, 0x37, 0xe0, 0xa7, 0x97,
-  0x15, 0xee, 0xf2, 0x9b, 0xe3, 0x28, 0x06, 0xa1, 0xd5, 0x8b,
-  0xb7, 0xc5, 0xda, 0x76, 0xf5, 0x50, 0xaa, 0x3d, 0x8a, 0x1f,
-  0xbf, 0xf0, 0xeb, 0x19, 0xcc, 0xb1, 0xa3, 0x13, 0xd5, 0x5c,
-  0xda, 0x56, 0xc9, 0xec, 0x2e, 0xf2, 0x96, 0x32, 0x38, 0x7f,
-  0xe8, 0xd7, 0x6e, 0x3c, 0x04, 0x68, 0x04, 0x3e, 0x8f, 0x66,
-  0x3f, 0x48, 0x60, 0xee, 0x12, 0xbf, 0x2d, 0x5b, 0x0b, 0x74,
-  0x74, 0xd6, 0xe6, 0x94, 0xf9, 0x1e, 0x6d, 0xcc, 0x40, 0x24,
-  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
-
-static const unsigned char group_modp18[] = {
-  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc9, 0x0f,
-  0xda, 0xa2, 0x21, 0x68, 0xc2, 0x34, 0xc4, 0xc6, 0x62, 0x8b,
-  0x80, 0xdc, 0x1c, 0xd1, 0x29, 0x02, 0x4e, 0x08, 0x8a, 0x67,
-  0xcc, 0x74, 0x02, 0x0b, 0xbe, 0xa6, 0x3b, 0x13, 0x9b, 0x22,
-  0x51, 0x4a, 0x08, 0x79, 0x8e, 0x34, 0x04, 0xdd, 0xef, 0x95,
-  0x19, 0xb3, 0xcd, 0x3a, 0x43, 0x1b, 0x30, 0x2b, 0x0a, 0x6d,
-  0xf2, 0x5f, 0x14, 0x37, 0x4f, 0xe1, 0x35, 0x6d, 0x6d, 0x51,
-  0xc2, 0x45, 0xe4, 0x85, 0xb5, 0x76, 0x62, 0x5e, 0x7e, 0xc6,
-  0xf4, 0x4c, 0x42, 0xe9, 0xa6, 0x37, 0xed, 0x6b, 0x0b, 0xff,
-  0x5c, 0xb6, 0xf4, 0x06, 0xb7, 0xed, 0xee, 0x38, 0x6b, 0xfb,
-  0x5a, 0x89, 0x9f, 0xa5, 0xae, 0x9f, 0x24, 0x11, 0x7c, 0x4b,
-  0x1f, 0xe6, 0x49, 0x28, 0x66, 0x51, 0xec, 0xe4, 0x5b, 0x3d,
-  0xc2, 0x00, 0x7c, 0xb8, 0xa1, 0x63, 0xbf, 0x05, 0x98, 0xda,
-  0x48, 0x36, 0x1c, 0x55, 0xd3, 0x9a, 0x69, 0x16, 0x3f, 0xa8,
-  0xfd, 0x24, 0xcf, 0x5f, 0x83, 0x65, 0x5d, 0x23, 0xdc, 0xa3,
-  0xad, 0x96, 0x1c, 0x62, 0xf3, 0x56, 0x20, 0x85, 0x52, 0xbb,
-  0x9e, 0xd5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6d, 0x67, 0x0c,
-  0x35, 0x4e, 0x4a, 0xbc, 0x98, 0x04, 0xf1, 0x74, 0x6c, 0x08,
-  0xca, 0x18, 0x21, 0x7c, 0x32, 0x90, 0x5e, 0x46, 0x2e, 0x36,
-  0xce, 0x3b, 0xe3, 0x9e, 0x77, 0x2c, 0x18, 0x0e, 0x86, 0x03,
-  0x9b, 0x27, 0x83, 0xa2, 0xec, 0x07, 0xa2, 0x8f, 0xb5, 0xc5,
-  0x5d, 0xf0, 0x6f, 0x4c, 0x52, 0xc9, 0xde, 0x2b, 0xcb, 0xf6,
-  0x95, 0x58, 0x17, 0x18, 0x39, 0x95, 0x49, 0x7c, 0xea, 0x95,
-  0x6a, 0xe5, 0x15, 0xd2, 0x26, 0x18, 0x98, 0xfa, 0x05, 0x10,
-  0x15, 0x72, 0x8e, 0x5a, 0x8a, 0xaa, 0xc4, 0x2d, 0xad, 0x33,
-  0x17, 0x0d, 0x04, 0x50, 0x7a, 0x33, 0xa8, 0x55, 0x21, 0xab,
-  0xdf, 0x1c, 0xba, 0x64, 0xec, 0xfb, 0x85, 0x04, 0x58, 0xdb,
-  0xef, 0x0a, 0x8a, 0xea, 0x71, 0x57, 0x5d, 0x06, 0x0c, 0x7d,
-  0xb3, 0x97, 0x0f, 0x85, 0xa6, 0xe1, 0xe4, 0xc7, 0xab, 0xf5,
-  0xae, 0x8c, 0xdb, 0x09, 0x33, 0xd7, 0x1e, 0x8c, 0x94, 0xe0,
-  0x4a, 0x25, 0x61, 0x9d, 0xce, 0xe3, 0xd2, 0x26, 0x1a, 0xd2,
-  0xee, 0x6b, 0xf1, 0x2f, 0xfa, 0x06, 0xd9, 0x8a, 0x08, 0x64,
-  0xd8, 0x76, 0x02, 0x73, 0x3e, 0xc8, 0x6a, 0x64, 0x52, 0x1f,
-  0x2b, 0x18, 0x17, 0x7b, 0x20, 0x0c, 0xbb, 0xe1, 0x17, 0x57,
-  0x7a, 0x61, 0x5d, 0x6c, 0x77, 0x09, 0x88, 0xc0, 0xba, 0xd9,
-  0x46, 0xe2, 0x08, 0xe2, 0x4f, 0xa0, 0x74, 0xe5, 0xab, 0x31,
-  0x43, 0xdb, 0x5b, 0xfc, 0xe0, 0xfd, 0x10, 0x8e, 0x4b, 0x82,
-  0xd1, 0x20, 0xa9, 0x21, 0x08, 0x01, 0x1a, 0x72, 0x3c, 0x12,
-  0xa7, 0x87, 0xe6, 0xd7, 0x88, 0x71, 0x9a, 0x10, 0xbd, 0xba,
-  0x5b, 0x26, 0x99, 0xc3, 0x27, 0x18, 0x6a, 0xf4, 0xe2, 0x3c,
-  0x1a, 0x94, 0x68, 0x34, 0xb6, 0x15, 0x0b, 0xda, 0x25, 0x83,
-  0xe9, 0xca, 0x2a, 0xd4, 0x4c, 0xe8, 0xdb, 0xbb, 0xc2, 0xdb,
-  0x04, 0xde, 0x8e, 0xf9, 0x2e, 0x8e, 0xfc, 0x14, 0x1f, 0xbe,
-  0xca, 0xa6, 0x28, 0x7c, 0x59, 0x47, 0x4e, 0x6b, 0xc0, 0x5d,
-  0x99, 0xb2, 0x96, 0x4f, 0xa0, 0x90, 0xc3, 0xa2, 0x23, 0x3b,
-  0xa1, 0x86, 0x51, 0x5b, 0xe7, 0xed, 0x1f, 0x61, 0x29, 0x70,
-  0xce, 0xe2, 0xd7, 0xaf, 0xb8, 0x1b, 0xdd, 0x76, 0x21, 0x70,
-  0x48, 0x1c, 0xd0, 0x06, 0x91, 0x27, 0xd5, 0xb0, 0x5a, 0xa9,
-  0x93, 0xb4, 0xea, 0x98, 0x8d, 0x8f, 0xdd, 0xc1, 0x86, 0xff,
-  0xb7, 0xdc, 0x90, 0xa6, 0xc0, 0x8f, 0x4d, 0xf4, 0x35, 0xc9,
-  0x34, 0x02, 0x84, 0x92, 0x36, 0xc3, 0xfa, 0xb4, 0xd2, 0x7c,
-  0x70, 0x26, 0xc1, 0xd4, 0xdc, 0xb2, 0x60, 0x26, 0x46, 0xde,
-  0xc9, 0x75, 0x1e, 0x76, 0x3d, 0xba, 0x37, 0xbd, 0xf8, 0xff,
-  0x94, 0x06, 0xad, 0x9e, 0x53, 0x0e, 0xe5, 0xdb, 0x38, 0x2f,
-  0x41, 0x30, 0x01, 0xae, 0xb0, 0x6a, 0x53, 0xed, 0x90, 0x27,
-  0xd8, 0x31, 0x17, 0x97, 0x27, 0xb0, 0x86, 0x5a, 0x89, 0x18,
-  0xda, 0x3e, 0xdb, 0xeb, 0xcf, 0x9b, 0x14, 0xed, 0x44, 0xce,
-  0x6c, 0xba, 0xce, 0xd4, 0xbb, 0x1b, 0xdb, 0x7f, 0x14, 0x47,
-  0xe6, 0xcc, 0x25, 0x4b, 0x33, 0x20, 0x51, 0x51, 0x2b, 0xd7,
-  0xaf, 0x42, 0x6f, 0xb8, 0xf4, 0x01, 0x37, 0x8c, 0xd2, 0xbf,
-  0x59, 0x83, 0xca, 0x01, 0xc6, 0x4b, 0x92, 0xec, 0xf0, 0x32,
-  0xea, 0x15, 0xd1, 0x72, 0x1d, 0x03, 0xf4, 0x82, 0xd7, 0xce,
-  0x6e, 0x74, 0xfe, 0xf6, 0xd5, 0x5e, 0x70, 0x2f, 0x46, 0x98,
-  0x0c, 0x82, 0xb5, 0xa8, 0x40, 0x31, 0x90, 0x0b, 0x1c, 0x9e,
-  0x59, 0xe7, 0xc9, 0x7f, 0xbe, 0xc7, 0xe8, 0xf3, 0x23, 0xa9,
-  0x7a, 0x7e, 0x36, 0xcc, 0x88, 0xbe, 0x0f, 0x1d, 0x45, 0xb7,
-  0xff, 0x58, 0x5a, 0xc5, 0x4b, 0xd4, 0x07, 0xb2, 0x2b, 0x41,
-  0x54, 0xaa, 0xcc, 0x8f, 0x6d, 0x7e, 0xbf, 0x48, 0xe1, 0xd8,
-  0x14, 0xcc, 0x5e, 0xd2, 0x0f, 0x80, 0x37, 0xe0, 0xa7, 0x97,
-  0x15, 0xee, 0xf2, 0x9b, 0xe3, 0x28, 0x06, 0xa1, 0xd5, 0x8b,
-  0xb7, 0xc5, 0xda, 0x76, 0xf5, 0x50, 0xaa, 0x3d, 0x8a, 0x1f,
-  0xbf, 0xf0, 0xeb, 0x19, 0xcc, 0xb1, 0xa3, 0x13, 0xd5, 0x5c,
-  0xda, 0x56, 0xc9, 0xec, 0x2e, 0xf2, 0x96, 0x32, 0x38, 0x7f,
-  0xe8, 0xd7, 0x6e, 0x3c, 0x04, 0x68, 0x04, 0x3e, 0x8f, 0x66,
-  0x3f, 0x48, 0x60, 0xee, 0x12, 0xbf, 0x2d, 0x5b, 0x0b, 0x74,
-  0x74, 0xd6, 0xe6, 0x94, 0xf9, 0x1e, 0x6d, 0xbe, 0x11, 0x59,
-  0x74, 0xa3, 0x92, 0x6f, 0x12, 0xfe, 0xe5, 0xe4, 0x38, 0x77,
-  0x7c, 0xb6, 0xa9, 0x32, 0xdf, 0x8c, 0xd8, 0xbe, 0xc4, 0xd0,
-  0x73, 0xb9, 0x31, 0xba, 0x3b, 0xc8, 0x32, 0xb6, 0x8d, 0x9d,
-  0xd3, 0x00, 0x74, 0x1f, 0xa7, 0xbf, 0x8a, 0xfc, 0x47, 0xed,
-  0x25, 0x76, 0xf6, 0x93, 0x6b, 0xa4, 0x24, 0x66, 0x3a, 0xab,
-  0x63, 0x9c, 0x5a, 0xe4, 0xf5, 0x68, 0x34, 0x23, 0xb4, 0x74,
-  0x2b, 0xf1, 0xc9, 0x78, 0x23, 0x8f, 0x16, 0xcb, 0xe3, 0x9d,
-  0x65, 0x2d, 0xe3, 0xfd, 0xb8, 0xbe, 0xfc, 0x84, 0x8a, 0xd9,
-  0x22, 0x22, 0x2e, 0x04, 0xa4, 0x03, 0x7c, 0x07, 0x13, 0xeb,
-  0x57, 0xa8, 0x1a, 0x23, 0xf0, 0xc7, 0x34, 0x73, 0xfc, 0x64,
-  0x6c, 0xea, 0x30, 0x6b, 0x4b, 0xcb, 0xc8, 0x86, 0x2f, 0x83,
-  0x85, 0xdd, 0xfa, 0x9d, 0x4b, 0x7f, 0xa2, 0xc0, 0x87, 0xe8,
-  0x79, 0x68, 0x33, 0x03, 0xed, 0x5b, 0xdd, 0x3a, 0x06, 0x2b,
-  0x3c, 0xf5, 0xb3, 0xa2, 0x78, 0xa6, 0x6d, 0x2a, 0x13, 0xf8,
-  0x3f, 0x44, 0xf8, 0x2d, 0xdf, 0x31, 0x0e, 0xe0, 0x74, 0xab,
-  0x6a, 0x36, 0x45, 0x97, 0xe8, 0x99, 0xa0, 0x25, 0x5d, 0xc1,
-  0x64, 0xf3, 0x1c, 0xc5, 0x08, 0x46, 0x85, 0x1d, 0xf9, 0xab,
-  0x48, 0x19, 0x5d, 0xed, 0x7e, 0xa1, 0xb1, 0xd5, 0x10, 0xbd,
-  0x7e, 0xe7, 0x4d, 0x73, 0xfa, 0xf3, 0x6b, 0xc3, 0x1e, 0xcf,
-  0xa2, 0x68, 0x35, 0x90, 0x46, 0xf4, 0xeb, 0x87, 0x9f, 0x92,
-  0x40, 0x09, 0x43, 0x8b, 0x48, 0x1c, 0x6c, 0xd7, 0x88, 0x9a,
-  0x00, 0x2e, 0xd5, 0xee, 0x38, 0x2b, 0xc9, 0x19, 0x0d, 0xa6,
-  0xfc, 0x02, 0x6e, 0x47, 0x95, 0x58, 0xe4, 0x47, 0x56, 0x77,
-  0xe9, 0xaa, 0x9e, 0x30, 0x50, 0xe2, 0x76, 0x56, 0x94, 0xdf,
-  0xc8, 0x1f, 0x56, 0xe8, 0x80, 0xb9, 0x6e, 0x71, 0x60, 0xc9,
-  0x80, 0xdd, 0x98, 0xed, 0xd3, 0xdf, 0xff, 0xff, 0xff, 0xff,
-  0xff, 0xff, 0xff, 0xff };
-
-typedef struct {
-  const char* name;
-  const char* prime;
-  unsigned int prime_size;
-  const char* gen;
-  unsigned int gen_size;
-} modp_group;
-
-static const modp_group modp_groups[] = {
-#define V(var) reinterpret_cast<const char*>(var)
-  { "modp1", V(group_modp1), sizeof(group_modp1), V(two_generator), 1 },
-  { "modp2", V(group_modp2), sizeof(group_modp2), V(two_generator), 1 },
-  { "modp5", V(group_modp5), sizeof(group_modp5), V(two_generator), 1 },
-  { "modp14", V(group_modp14), sizeof(group_modp14), V(two_generator), 1 },
-  { "modp15", V(group_modp15), sizeof(group_modp15), V(two_generator), 1 },
-  { "modp16", V(group_modp16), sizeof(group_modp16), V(two_generator), 1 },
-  { "modp17", V(group_modp17), sizeof(group_modp17), V(two_generator), 1 },
-  { "modp18", V(group_modp18), sizeof(group_modp18), V(two_generator), 1 }
-#undef V
-};
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_NODE_CRYPTO_GROUPS_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/node_debug_options.h
+++ /dev/null
@@ -1,53 +0,0 @@
-#ifndef SRC_NODE_DEBUG_OPTIONS_H_
-#define SRC_NODE_DEBUG_OPTIONS_H_
-
-#include <string>
-
-#include "node.h"
-
-// Forward declaration to break recursive dependency chain with src/env.h.
-namespace node {
-
-enum class DebugAgentType {
-  kNone,
-  kDebugger,
-#if HAVE_INSPECTOR
-  kInspector
-#endif  // HAVE_INSPECTOR
-};
-
-class NODE_EXTERN DebugOptions {
- public:
-  DebugOptions();
-  bool ParseOption(const std::string& option);
-  bool debugger_enabled() const {
-    return debugger_enabled_ && !inspector_enabled();
-  }
-  bool inspector_enabled() const {
-#if HAVE_INSPECTOR
-    return inspector_enabled_;
-#else
-    return false;
-#endif  // HAVE_INSPECTOR
-  }
-  void EnableDebugAgent(DebugAgentType type);
-  bool ToolsServerEnabled();
-  bool wait_for_connect() const { return wait_connect_; }
-  std::string host_name() const { return host_name_; }
-  int port() const;
-  void set_port(int port) { port_ = port; }
-
- private:
-  bool debugger_enabled_;
-#if HAVE_INSPECTOR
-  bool inspector_enabled_;
-#endif  // HAVE_INSPECTOR
-  bool wait_connect_;
-  bool http_enabled_;
-  std::string host_name_;
-  int port_;
-};
-
-}  // namespace node
-
-#endif  // SRC_NODE_DEBUG_OPTIONS_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/node_dtrace.h
+++ /dev/null
@@ -1,65 +0,0 @@
-#ifndef SRC_NODE_DTRACE_H_
-#define SRC_NODE_DTRACE_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "node.h"
-#include "v8.h"
-#include "env.h"
-
-extern "C" {
-/*
- * The following structures are passed directly to DTrace when probes are fired.
- * Translators in node.d translate these structures into the corresponding D
- * structures, taking care of dealing with the user process data model (32-bit
- * or 64-bit) and structure versions (see node_dtrace_http_server_request_t
- * below).
- */
-
-typedef struct {
-  int32_t fd;
-  int32_t port;
-  char* remote;
-  int32_t buffered;
-} node_dtrace_connection_t;
-
-typedef struct {
-  char* url;
-  char* method;
-} node_dtrace_http_client_request_t;
-
-/*
- * The original version of this structure contained only a url and method, just
- * like the client request above.  To add the new forwardedFor field, the
- * structure layout was changed to begin with an integer version.  The
- * translator knows whether it's looking at an old- or new-version structure
- * based on whether the version field's value is a reasonable pointer (i.e.
- * address greater than 4K).  No doubt this is filthy, but there's not much else
- * we can do, and it works reliably.
- *
- * This version of the structure also contains padding that should be zeroed out
- * by the consumer so that future versions of the translator can simply check if
- * a field is present by checking it against nullptr.
- */
-typedef struct {
-  union {
-    uint32_t version;
-    uintptr_t unused;  /* for compat. with old 64-bit struct */
-  } _un;
-  char* url;
-  char* method;
-  char* forwardedFor;
-  char* _pad[8];
-} node_dtrace_http_server_request_t;
-
-}  // extern "C"
-
-namespace node {
-
-void InitDTrace(Environment* env, v8::Local<v8::Object> target);
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_NODE_DTRACE_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/node_file.h
+++ /dev/null
@@ -1,17 +0,0 @@
-#ifndef SRC_NODE_FILE_H_
-#define SRC_NODE_FILE_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "node.h"
-#include "v8.h"
-
-namespace node {
-
-void InitFs(v8::Local<v8::Object> target);
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_NODE_FILE_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/node_http_parser.h
+++ /dev/null
@@ -1,18 +0,0 @@
-#ifndef SRC_NODE_HTTP_PARSER_H_
-#define SRC_NODE_HTTP_PARSER_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "v8.h"
-
-#include "http_parser.h"
-
-namespace node {
-
-void InitHttpParser(v8::Local<v8::Object> target);
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_NODE_HTTP_PARSER_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/node_i18n.h
+++ /dev/null
@@ -1,35 +0,0 @@
-#ifndef SRC_NODE_I18N_H_
-#define SRC_NODE_I18N_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "node.h"
-#include <string>
-
-#if defined(NODE_HAVE_I18N_SUPPORT)
-
-namespace node {
-
-extern std::string icu_data_dir;  // NOLINT(runtime/string)
-
-namespace i18n {
-
-bool InitializeICUDirectory(const std::string& path);
-
-int32_t ToASCII(MaybeStackBuffer<char>* buf,
-                const char* input,
-                size_t length,
-                bool lenient = false);
-int32_t ToUnicode(MaybeStackBuffer<char>* buf,
-                  const char* input,
-                  size_t length,
-                  bool lenient = false);
-
-}  // namespace i18n
-}  // namespace node
-
-#endif  // NODE_HAVE_I18N_SUPPORT
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_NODE_I18N_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/node_internals.h
+++ /dev/null
@@ -1,236 +0,0 @@
-#ifndef SRC_NODE_INTERNALS_H_
-#define SRC_NODE_INTERNALS_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "node.h"
-#include "util.h"
-#include "util-inl.h"
-#include "uv.h"
-#include "v8.h"
-
-#include <stdint.h>
-#include <stdlib.h>
-
-#include <string>
-
-struct sockaddr;
-
-// Variation on NODE_DEFINE_CONSTANT that sets a String value.
-#define NODE_DEFINE_STRING_CONSTANT(target, name, constant)                   \
-  do {                                                                        \
-    v8::Isolate* isolate = target->GetIsolate();                              \
-    v8::Local<v8::String> constant_name =                                     \
-        v8::String::NewFromUtf8(isolate, name);                               \
-    v8::Local<v8::String> constant_value =                                    \
-        v8::String::NewFromUtf8(isolate, constant);                           \
-    v8::PropertyAttribute constant_attributes =                               \
-        static_cast<v8::PropertyAttribute>(v8::ReadOnly | v8::DontDelete);    \
-    target->DefineOwnProperty(isolate->GetCurrentContext(),                   \
-                              constant_name,                                  \
-                              constant_value,                                 \
-                              constant_attributes).FromJust();                \
-  } while (0)
-
-namespace node {
-
-// Set in node.cc by ParseArgs with the value of --openssl-config.
-// Used in node_crypto.cc when initializing OpenSSL.
-extern std::string openssl_config;
-
-// Set in node.cc by ParseArgs when --preserve-symlinks is used.
-// Used in node_config.cc to set a constant on process.binding('config')
-// that is used by lib/module.js
-extern bool config_preserve_symlinks;
-
-// Tells whether it is safe to call v8::Isolate::GetCurrent().
-extern bool v8_initialized;
-
-// Forward declaration
-class Environment;
-
-// If persistent.IsWeak() == false, then do not call persistent.Reset()
-// while the returned Local<T> is still in scope, it will destroy the
-// reference to the object.
-template <class TypeName>
-inline v8::Local<TypeName> PersistentToLocal(
-    v8::Isolate* isolate,
-    const v8::Persistent<TypeName>& persistent);
-
-// Call with valid HandleScope and while inside Context scope.
-v8::Local<v8::Value> MakeCallback(Environment* env,
-                                   v8::Local<v8::Object> recv,
-                                   const char* method,
-                                   int argc = 0,
-                                   v8::Local<v8::Value>* argv = nullptr);
-
-// Call with valid HandleScope and while inside Context scope.
-v8::Local<v8::Value> MakeCallback(Environment* env,
-                                   v8::Local<v8::Object> recv,
-                                   v8::Local<v8::String> symbol,
-                                   int argc = 0,
-                                   v8::Local<v8::Value>* argv = nullptr);
-
-// Call with valid HandleScope and while inside Context scope.
-v8::Local<v8::Value> MakeCallback(Environment* env,
-                                   v8::Local<v8::Value> recv,
-                                   v8::Local<v8::Function> callback,
-                                   int argc = 0,
-                                   v8::Local<v8::Value>* argv = nullptr);
-
-// Convert a struct sockaddr to a { address: '1.2.3.4', port: 1234 } JS object.
-// Sets address and port properties on the info object and returns it.
-// If |info| is omitted, a new object is returned.
-v8::Local<v8::Object> AddressToJS(
-    Environment* env,
-    const sockaddr* addr,
-    v8::Local<v8::Object> info = v8::Local<v8::Object>());
-
-template <typename T, int (*F)(const typename T::HandleType*, sockaddr*, int*)>
-void GetSockOrPeerName(const v8::FunctionCallbackInfo<v8::Value>& args) {
-  T* const wrap = Unwrap<T>(args.Holder());
-  if (wrap == nullptr)
-    return args.GetReturnValue().Set(UV_EBADF);
-  CHECK(args[0]->IsObject());
-  sockaddr_storage storage;
-  int addrlen = sizeof(storage);
-  sockaddr* const addr = reinterpret_cast<sockaddr*>(&storage);
-  const int err = F(&wrap->handle_, addr, &addrlen);
-  if (err == 0)
-    AddressToJS(wrap->env(), addr, args[0].As<v8::Object>());
-  args.GetReturnValue().Set(err);
-}
-
-void SignalExit(int signo);
-#ifdef __POSIX__
-void RegisterSignalHandler(int signal,
-                           void (*handler)(int signal),
-                           bool reset_handler = false);
-#endif
-
-bool SafeGetenv(const char* key, std::string* text);
-
-template <typename T, size_t N>
-constexpr size_t arraysize(const T(&)[N]) { return N; }
-
-#ifndef ROUND_UP
-# define ROUND_UP(a, b) ((a) % (b) ? ((a) + (b)) - ((a) % (b)) : (a))
-#endif
-
-#ifdef __GNUC__
-# define MUST_USE_RESULT __attribute__((warn_unused_result))
-#else
-# define MUST_USE_RESULT
-#endif
-
-bool IsExceptionDecorated(Environment* env, v8::Local<v8::Value> er);
-
-enum ErrorHandlingMode { FATAL_ERROR, CONTEXTIFY_ERROR };
-void AppendExceptionLine(Environment* env,
-                         v8::Local<v8::Value> er,
-                         v8::Local<v8::Message> message,
-                         enum ErrorHandlingMode mode);
-
-NO_RETURN void FatalError(const char* location, const char* message);
-
-void ProcessEmitWarning(Environment* env, const char* fmt, ...);
-
-v8::Local<v8::Value> BuildStatsObject(Environment* env, const uv_stat_t* s);
-
-void SetupProcessObject(Environment* env,
-                        int argc,
-                        const char* const* argv,
-                        int exec_argc,
-                        const char* const* exec_argv);
-
-enum Endianness {
-  kLittleEndian,  // _Not_ LITTLE_ENDIAN, clashes with endian.h.
-  kBigEndian
-};
-
-inline enum Endianness GetEndianness() {
-  // Constant-folded by the compiler.
-  const union {
-    uint8_t u8[2];
-    uint16_t u16;
-  } u = {
-    { 1, 0 }
-  };
-  return u.u16 == 1 ? kLittleEndian : kBigEndian;
-}
-
-inline bool IsLittleEndian() {
-  return GetEndianness() == kLittleEndian;
-}
-
-inline bool IsBigEndian() {
-  return GetEndianness() == kBigEndian;
-}
-
-class ArrayBufferAllocator : public v8::ArrayBuffer::Allocator {
- public:
-  inline uint32_t* zero_fill_field() { return &zero_fill_field_; }
-
-  virtual void* Allocate(size_t size);  // Defined in src/node.cc
-  virtual void* AllocateUninitialized(size_t size)
-    { return node::UncheckedMalloc(size); }
-  virtual void Free(void* data, size_t) { free(data); }
-
- private:
-  uint32_t zero_fill_field_ = 1;  // Boolean but exposed as uint32 to JS land.
-};
-
-// Clear any domain and/or uncaughtException handlers to force the error's
-// propagation and shutdown the process. Use this to force the process to exit
-// by clearing all callbacks that could handle the error.
-void ClearFatalExceptionHandlers(Environment* env);
-
-namespace Buffer {
-v8::MaybeLocal<v8::Object> Copy(Environment* env, const char* data, size_t len);
-v8::MaybeLocal<v8::Object> New(Environment* env, size_t size);
-// Takes ownership of |data|.
-v8::MaybeLocal<v8::Object> New(Environment* env,
-                               char* data,
-                               size_t length,
-                               void (*callback)(char* data, void* hint),
-                               void* hint);
-// Takes ownership of |data|.  Must allocate |data| with malloc() or realloc()
-// because ArrayBufferAllocator::Free() deallocates it again with free().
-// Mixing operator new and free() is undefined behavior so don't do that.
-v8::MaybeLocal<v8::Object> New(Environment* env, char* data, size_t length);
-
-// Construct a Buffer from a MaybeStackBuffer (and also its subclasses like
-// Utf8Value and TwoByteValue).
-// If |buf| is invalidated, an empty MaybeLocal is returned, and nothing is
-// changed.
-// If |buf| contains actual data, this method takes ownership of |buf|'s
-// underlying buffer. However, |buf| itself can be reused even after this call,
-// but its capacity, if increased through AllocateSufficientStorage, is not
-// guaranteed to stay the same.
-template <typename T>
-static v8::MaybeLocal<v8::Object> New(Environment* env,
-                                      MaybeStackBuffer<T>* buf) {
-  v8::MaybeLocal<v8::Object> ret;
-  char* src = reinterpret_cast<char*>(buf->out());
-  const size_t len_in_bytes = buf->length() * sizeof(buf->out()[0]);
-
-  if (buf->IsAllocated())
-    ret = New(env, src, len_in_bytes);
-  else if (!buf->IsInvalidated())
-    ret = Copy(env, src, len_in_bytes);
-
-  if (ret.IsEmpty())
-    return ret;
-
-  if (buf->IsAllocated())
-    buf->Release();
-
-  return ret;
-}
-}  // namespace Buffer
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_NODE_INTERNALS_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/node_javascript.h
+++ /dev/null
@@ -1,18 +0,0 @@
-#ifndef SRC_NODE_JAVASCRIPT_H_
-#define SRC_NODE_JAVASCRIPT_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "v8.h"
-#include "env.h"
-
-namespace node {
-
-void DefineJavaScript(Environment* env, v8::Local<v8::Object> target);
-v8::Local<v8::String> MainSource(Environment* env);
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_NODE_JAVASCRIPT_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/node_lttng.h
+++ /dev/null
@@ -1,44 +0,0 @@
-#ifndef SRC_NODE_LTTNG_H_
-#define SRC_NODE_LTTNG_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "node.h"
-#include "v8.h"
-#include "env.h"
-
-extern "C" {
-typedef struct {
-  int32_t fd;
-  int32_t port;
-  const char* remote;
-  int32_t buffered;
-} node_lttng_connection_t;
-
-typedef struct {
-  const char* url;
-  const char* method;
-} node_lttng_http_client_request_t;
-
-typedef struct {
-  union {
-    uint32_t version;
-    uintptr_t unused;  /* for compat. with old 64-bit struct */
-  } _un;
-  const char* url;
-  const char* method;
-  const char* forwarded_for;
-  const char* _pad[8];
-} node_lttng_http_server_request_t;
-
-}  // extern "C"
-
-namespace node {
-
-void InitLTTNG(Environment* env, v8::Local<v8::Object> target);
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_NODE_LTTNG_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/node_lttng_provider.h
+++ /dev/null
@@ -1,106 +0,0 @@
-#ifndef SRC_NODE_LTTNG_PROVIDER_H_
-#define SRC_NODE_LTTNG_PROVIDER_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#define TRACEPOINT_CREATE_PROBES
-#define TRACEPOINT_DEFINE
-#include "node_lttng_tp.h"
-
-namespace node {
-
-#define FOR_ALL_GC_TYPES(APPLY) \
-  APPLY(kGCTypeScavenge) \
-  APPLY(kGCTypeMarkSweepCompact) \
-  APPLY(kGCTypeAll)
-
-#define FOR_ALL_GC_CALLBACK_FLAGS(APPLY) \
-  APPLY(kNoGCCallbackFlags) \
-  APPLY(kGCCallbackFlagConstructRetainedObjectInfos) \
-  APPLY(kGCCallbackFlagForced) \
-  APPLY(kGCCallbackFlagSynchronousPhantomCallbackProcessing)
-
-void NODE_HTTP_SERVER_REQUEST(node_lttng_http_server_request_t* req,
-                              node_lttng_connection_t* conn,
-                              const char *remote, int port,
-                              const char *method, const char *url,
-                              int fd) {
-  tracepoint(node, http_server_request, req->url, req->method, \
-             req->forwarded_for);
-}
-
-void NODE_HTTP_SERVER_RESPONSE(node_lttng_connection_t* conn,
-                              const char *remote, int port, int fd) {
-  tracepoint(node, http_server_response, port, conn->remote, fd);
-}
-
-void NODE_HTTP_CLIENT_REQUEST(node_lttng_http_client_request_t* req,
-                              node_lttng_connection_t* conn,
-                              const char *remote, int port,
-                              const char *method, const char *url,
-                              int fd) {
-  tracepoint(node, http_client_request, req->url, req->method);
-}
-
-void NODE_HTTP_CLIENT_RESPONSE(node_lttng_connection_t* conn,
-                               const char *remote, int port, int fd) {
-  tracepoint(node, http_client_response, port, conn->remote, fd);
-}
-
-void NODE_NET_SERVER_CONNECTION(node_lttng_connection_t* conn,
-                                const char *remote, int port, int fd) {
-  tracepoint(node, net_server_connection, conn->remote, port, fd, \
-             conn->buffered);
-}
-
-void NODE_NET_STREAM_END(node_lttng_connection_t* conn,
-                        const char *remote, int port, int fd) {
-  tracepoint(node, net_stream_end, conn->remote, port, fd);
-}
-
-void NODE_GC_START(v8::GCType type,
-                   v8::GCCallbackFlags flags,
-                   v8::Isolate* isolate) {
-  const char* typeStr = "Unkown GC Type";
-  const char* flagsStr = "Unknown GC Flag";
-
-#define BUILD_IF(f) if (type == v8::GCType::f) { typeStr = #f; }
-  FOR_ALL_GC_TYPES(BUILD_IF);
-#undef BUILD_IF
-
-#define BUILD_IF(f) if (flags == v8::GCCallbackFlags::f) { flagsStr = #f; }
-  FOR_ALL_GC_CALLBACK_FLAGS(BUILD_IF);
-#undef BUILD_IF
-
-  tracepoint(node, gc_start, typeStr, flagsStr);
-}
-
-void NODE_GC_DONE(v8::GCType type,
-                  v8::GCCallbackFlags flags,
-                  v8::Isolate* isolate) {
-  const char* typeStr = "Unkown GC Type";
-  const char* flagsStr = "Unknown GC Flag";
-
-#define BUILD_IF(f) if (type == v8::GCType::f) { typeStr = #f; }
-  FOR_ALL_GC_TYPES(BUILD_IF);
-#undef BUILD_IF
-
-#define BUILD_IF(f) if (flags == v8::GCCallbackFlags::f) { flagsStr = #f; }
-  FOR_ALL_GC_CALLBACK_FLAGS(BUILD_IF);
-#undef BUILD_IF
-
-  tracepoint(node, gc_done, typeStr, flagsStr);
-}
-
-bool NODE_HTTP_SERVER_REQUEST_ENABLED() { return true; }
-bool NODE_HTTP_SERVER_RESPONSE_ENABLED() { return true; }
-bool NODE_HTTP_CLIENT_REQUEST_ENABLED() { return true; }
-bool NODE_HTTP_CLIENT_RESPONSE_ENABLED() { return true; }
-bool NODE_NET_SERVER_CONNECTION_ENABLED() { return true; }
-bool NODE_NET_STREAM_END_ENABLED() { return true; }
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_NODE_LTTNG_PROVIDER_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/node_lttng_tp.h
+++ /dev/null
@@ -1,116 +0,0 @@
-#ifndef SRC_NODE_LTTNG_TP_H_
-#define SRC_NODE_LTTNG_TP_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#undef TRACEPOINT_PROVIDER
-#define TRACEPOINT_PROVIDER node
-
-#undef TRACEPOINT_INCLUDE
-#define TRACEPOINT_INCLUDE "./node_lttng_tp.h"
-
-#if !defined(__NODE_LTTNG_TP_H) || defined(TRACEPOINT_HEADER_MULTI_READ)
-#define __NODE_LTTNG_TP_H
-
-#include <lttng/tracepoint.h>
-
-TRACEPOINT_EVENT(
-  node,
-  http_server_request,
-  TP_ARGS(
-    const char*, url,
-    const char*, method,
-    const char*, forwardedFor),
-  TP_FIELDS(
-    ctf_string(url, url)
-    ctf_string(method, method)
-    ctf_string(forwardedFor, forwardedFor))
-
-TRACEPOINT_EVENT(
-  node,
-  http_server_response,
-  TP_ARGS(
-    int, port,
-    const char*, remote,
-    int, fd),
-  TP_FIELDS(
-    ctf_integer(int, port, port)
-    ctf_string(remote, remote)
-    ctf_integer(int, fd, fd))
-
-TRACEPOINT_EVENT(
-  node,
-  http_client_request,
-  TP_ARGS(
-    const char*, url,
-    const char*, method),
-  TP_FIELDS(
-    ctf_string(url, url)
-    ctf_string(method, method))
-
-TRACEPOINT_EVENT(
-  node,
-  http_client_response,
-  TP_ARGS(
-    int, port,
-    const char*, remote,
-    int, fd),
-  TP_FIELDS(
-    ctf_integer(int, port, port)
-    ctf_string(remote, remote)
-    ctf_integer(int, fd, fd))
-
-TRACEPOINT_EVENT(
-  node,
-  net_server_connection,
-  TP_ARGS(
-    const char*, remote,
-    int, port,
-    int, fd,
-    int, buffered),
-  TP_FIELDS(
-    ctf_string(remote, remote)
-    ctf_integer(int, port, port)
-    ctf_integer(int, fd, fd)
-    ctf_integer(int, buffered, buffered))
-
-TRACEPOINT_EVENT(
-  node,
-  net_stream_end,
-  TP_ARGS(
-    const char*, remote,
-    int, port,
-    int, fd),
-  TP_FIELDS(
-    ctf_string(remote, remote)
-    ctf_integer(int, port, port)
-    ctf_integer(int, fd, fd))
-
-TRACEPOINT_EVENT(
-  node,
-  gc_start,
-  TP_ARGS(
-    const char*, gctype,
-    const char*, gcflags),
-  TP_FIELDS(
-    ctf_string(gctype, gctype)
-    ctf_string(gcflags, gcflags))
-)
-
-TRACEPOINT_EVENT(
-  node,
-  gc_done,
-  TP_ARGS(
-    const char*, gctype,
-    const char*, gcflags),
-  TP_FIELDS(
-    ctf_string(gctype, gctype)
-    ctf_string(gcflags, gcflags))
-
-#endif /* __NODE_LTTNG_TP_H */
-
-#include <lttng/tracepoint-event.h>
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_NODE_LTTNG_TP_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/node_mutex.h
+++ /dev/null
@@ -1,187 +0,0 @@
-#ifndef SRC_NODE_MUTEX_H_
-#define SRC_NODE_MUTEX_H_
-
-#include "util.h"
-#include "uv.h"
-
-namespace node {
-
-template <typename Traits> class ConditionVariableBase;
-template <typename Traits> class MutexBase;
-struct LibuvMutexTraits;
-
-using ConditionVariable = ConditionVariableBase<LibuvMutexTraits>;
-using Mutex = MutexBase<LibuvMutexTraits>;
-
-template <typename Traits>
-class MutexBase {
- public:
-  inline MutexBase();
-  inline ~MutexBase();
-  inline void Lock();
-  inline void Unlock();
-
-  class ScopedLock;
-  class ScopedUnlock;
-
-  class ScopedLock {
-   public:
-    inline explicit ScopedLock(const MutexBase& mutex);
-    inline explicit ScopedLock(const ScopedUnlock& scoped_unlock);
-    inline ~ScopedLock();
-
-   private:
-    template <typename> friend class ConditionVariableBase;
-    friend class ScopedUnlock;
-    const MutexBase& mutex_;
-    DISALLOW_COPY_AND_ASSIGN(ScopedLock);
-  };
-
-  class ScopedUnlock {
-   public:
-    inline explicit ScopedUnlock(const ScopedLock& scoped_lock);
-    inline ~ScopedUnlock();
-
-   private:
-    friend class ScopedLock;
-    const MutexBase& mutex_;
-    DISALLOW_COPY_AND_ASSIGN(ScopedUnlock);
-  };
-
- private:
-  template <typename> friend class ConditionVariableBase;
-  mutable typename Traits::MutexT mutex_;
-  DISALLOW_COPY_AND_ASSIGN(MutexBase);
-};
-
-template <typename Traits>
-class ConditionVariableBase {
- public:
-  using ScopedLock = typename MutexBase<Traits>::ScopedLock;
-
-  inline ConditionVariableBase();
-  inline ~ConditionVariableBase();
-  inline void Broadcast(const ScopedLock&);
-  inline void Signal(const ScopedLock&);
-  inline void Wait(const ScopedLock& scoped_lock);
-
- private:
-  typename Traits::CondT cond_;
-  DISALLOW_COPY_AND_ASSIGN(ConditionVariableBase);
-};
-
-struct LibuvMutexTraits {
-  using CondT = uv_cond_t;
-  using MutexT = uv_mutex_t;
-
-  static inline int cond_init(CondT* cond) {
-    return uv_cond_init(cond);
-  }
-
-  static inline int mutex_init(MutexT* mutex) {
-    return uv_mutex_init(mutex);
-  }
-
-  static inline void cond_broadcast(CondT* cond) {
-    uv_cond_broadcast(cond);
-  }
-
-  static inline void cond_destroy(CondT* cond) {
-    uv_cond_destroy(cond);
-  }
-
-  static inline void cond_signal(CondT* cond) {
-    uv_cond_signal(cond);
-  }
-
-  static inline void cond_wait(CondT* cond, MutexT* mutex) {
-    uv_cond_wait(cond, mutex);
-  }
-
-  static inline void mutex_destroy(MutexT* mutex) {
-    uv_mutex_destroy(mutex);
-  }
-
-  static inline void mutex_lock(MutexT* mutex) {
-    uv_mutex_lock(mutex);
-  }
-
-  static inline void mutex_unlock(MutexT* mutex) {
-    uv_mutex_unlock(mutex);
-  }
-};
-
-template <typename Traits>
-ConditionVariableBase<Traits>::ConditionVariableBase() {
-  CHECK_EQ(0, Traits::cond_init(&cond_));
-}
-
-template <typename Traits>
-ConditionVariableBase<Traits>::~ConditionVariableBase() {
-  Traits::cond_destroy(&cond_);
-}
-
-template <typename Traits>
-void ConditionVariableBase<Traits>::Broadcast(const ScopedLock&) {
-  Traits::cond_broadcast(&cond_);
-}
-
-template <typename Traits>
-void ConditionVariableBase<Traits>::Signal(const ScopedLock&) {
-  Traits::cond_signal(&cond_);
-}
-
-template <typename Traits>
-void ConditionVariableBase<Traits>::Wait(const ScopedLock& scoped_lock) {
-  Traits::cond_wait(&cond_, &scoped_lock.mutex_.mutex_);
-}
-
-template <typename Traits>
-MutexBase<Traits>::MutexBase() {
-  CHECK_EQ(0, Traits::mutex_init(&mutex_));
-}
-
-template <typename Traits>
-MutexBase<Traits>::~MutexBase() {
-  Traits::mutex_destroy(&mutex_);
-}
-
-template <typename Traits>
-void MutexBase<Traits>::Lock() {
-  Traits::mutex_lock(&mutex_);
-}
-
-template <typename Traits>
-void MutexBase<Traits>::Unlock() {
-  Traits::mutex_unlock(&mutex_);
-}
-
-template <typename Traits>
-MutexBase<Traits>::ScopedLock::ScopedLock(const MutexBase& mutex)
-    : mutex_(mutex) {
-  Traits::mutex_lock(&mutex_.mutex_);
-}
-
-template <typename Traits>
-MutexBase<Traits>::ScopedLock::ScopedLock(const ScopedUnlock& scoped_unlock)
-    : MutexBase(scoped_unlock.mutex_) {}
-
-template <typename Traits>
-MutexBase<Traits>::ScopedLock::~ScopedLock() {
-  Traits::mutex_unlock(&mutex_.mutex_);
-}
-
-template <typename Traits>
-MutexBase<Traits>::ScopedUnlock::ScopedUnlock(const ScopedLock& scoped_lock)
-    : mutex_(scoped_lock.mutex_) {
-  Traits::mutex_unlock(&mutex_.mutex_);
-}
-
-template <typename Traits>
-MutexBase<Traits>::ScopedUnlock::~ScopedUnlock() {
-  Traits::mutex_lock(&mutex_.mutex_);
-}
-
-}  // namespace node
-
-#endif  // SRC_NODE_MUTEX_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/node_object_wrap.h
+++ /dev/null
@@ -1,111 +0,0 @@
-#ifndef SRC_NODE_OBJECT_WRAP_H_
-#define SRC_NODE_OBJECT_WRAP_H_
-
-#include "v8.h"
-#include <assert.h>
-
-
-namespace node {
-
-class ObjectWrap {
- public:
-  ObjectWrap() {
-    refs_ = 0;
-  }
-
-
-  virtual ~ObjectWrap() {
-    if (persistent().IsEmpty())
-      return;
-    assert(persistent().IsNearDeath());
-    persistent().ClearWeak();
-    persistent().Reset();
-  }
-
-
-  template <class T>
-  static inline T* Unwrap(v8::Local<v8::Object> handle) {
-    assert(!handle.IsEmpty());
-    assert(handle->InternalFieldCount() > 0);
-    // Cast to ObjectWrap before casting to T.  A direct cast from void
-    // to T won't work right when T has more than one base class.
-    void* ptr = handle->GetAlignedPointerFromInternalField(0);
-    ObjectWrap* wrap = static_cast<ObjectWrap*>(ptr);
-    return static_cast<T*>(wrap);
-  }
-
-
-  inline v8::Local<v8::Object> handle() {
-    return handle(v8::Isolate::GetCurrent());
-  }
-
-
-  inline v8::Local<v8::Object> handle(v8::Isolate* isolate) {
-    return v8::Local<v8::Object>::New(isolate, persistent());
-  }
-
-
-  inline v8::Persistent<v8::Object>& persistent() {
-    return handle_;
-  }
-
-
- protected:
-  inline void Wrap(v8::Local<v8::Object> handle) {
-    assert(persistent().IsEmpty());
-    assert(handle->InternalFieldCount() > 0);
-    handle->SetAlignedPointerInInternalField(0, this);
-    persistent().Reset(v8::Isolate::GetCurrent(), handle);
-    MakeWeak();
-  }
-
-
-  inline void MakeWeak(void) {
-    persistent().SetWeak(this, WeakCallback, v8::WeakCallbackType::kParameter);
-    persistent().MarkIndependent();
-  }
-
-  /* Ref() marks the object as being attached to an event loop.
-   * Refed objects will not be garbage collected, even if
-   * all references are lost.
-   */
-  virtual void Ref() {
-    assert(!persistent().IsEmpty());
-    persistent().ClearWeak();
-    refs_++;
-  }
-
-  /* Unref() marks an object as detached from the event loop.  This is its
-   * default state.  When an object with a "weak" reference changes from
-   * attached to detached state it will be freed. Be careful not to access
-   * the object after making this call as it might be gone!
-   * (A "weak reference" means an object that only has a
-   * persistent handle.)
-   *
-   * DO NOT CALL THIS FROM DESTRUCTOR
-   */
-  virtual void Unref() {
-    assert(!persistent().IsEmpty());
-    assert(!persistent().IsWeak());
-    assert(refs_ > 0);
-    if (--refs_ == 0)
-      MakeWeak();
-  }
-
-  int refs_;  // ro
-
- private:
-  static void WeakCallback(
-      const v8::WeakCallbackInfo<ObjectWrap>& data) {
-    ObjectWrap* wrap = data.GetParameter();
-    assert(wrap->refs_ == 0);
-    wrap->handle_.Reset();
-    delete wrap;
-  }
-
-  v8::Persistent<v8::Object> handle_;
-};
-
-}  // namespace node
-
-#endif  // SRC_NODE_OBJECT_WRAP_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/node_revert.h
+++ /dev/null
@@ -1,48 +0,0 @@
-#ifndef SRC_NODE_REVERT_H_
-#define SRC_NODE_REVERT_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "node.h"
-
-/**
- * Note that it is expected for this list to vary across specific LTS and 
- * Stable versions! Only CVE's whose fixes require *breaking* changes within 
- * a given LTS or Stable may be added to this list, and only with CTC 
- * consensus. 
- *
- * For *master* this list should always be empty!
- *
- **/
-#define REVERSIONS(XX)
-//  XX(CVE_2016_PEND, "CVE-2016-PEND", "Vulnerability Title")
-
-namespace node {
-
-typedef enum {
-#define V(code, _, __) REVERT_ ## code,
-  REVERSIONS(V)
-#undef V
-} reversions_t;
-
-
-/* A bit field for tracking the active reverts */
-extern unsigned int reverted;
-
-/* Revert the given CVE (see reversions_t enum) */
-void Revert(const unsigned int cve);
-
-/* Revert the given CVE by label */
-void Revert(const char* cve);
-
-/* true if the CVE has been reverted **/
-bool IsReverted(const unsigned int cve);
-
-/* true if the CVE has been reverted **/
-bool IsReverted(const char * cve);
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_NODE_REVERT_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/node_root_certs.h
+++ /dev/null
@@ -1,3857 +0,0 @@
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-/* GlobalSign Root CA */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkGA1UEBhMC\n"
-"QkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jvb3QgQ0ExGzAZBgNV\n"
-"BAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAwMDBaFw0yODAxMjgxMjAwMDBa\n"
-"MFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9iYWxTaWduIG52LXNhMRAwDgYDVQQLEwdS\n"
-"b290IENBMRswGQYDVQQDExJHbG9iYWxTaWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUA\n"
-"A4IBDwAwggEKAoIBAQDaDuaZjc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtI\n"
-"K+6NiY6arymAZavpxy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCO\n"
-"XkNz8kHp1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\n"
-"snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJU26Qzns3\n"
-"dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N89iFo7+ryUp9/k5DP\n"
-"AgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBRg\n"
-"e2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0BAQUFAAOCAQEA1nPnfE920I2/7LqivjTF\n"
-"KDK1fPxsnCwrvQmeU79rXqoRSLblCKOzyj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY7\n"
-"76BQVvnGCv04zcQLcFGUl5gE38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9\n"
-"LhJIZJrglfCm7ymPAbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr\n"
-"+WymXUadDKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\n"
-"HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\n"
-"-----END CERTIFICATE-----\n",
-
-/* GlobalSign Root CA - R2 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDujCCAqKgAwIBAgILBAAAAAABD4Ym5g0wDQYJKoZIhvcNAQEFBQAwTDEgMB4GA1UECxMX\n"
-"R2xvYmFsU2lnbiBSb290IENBIC0gUjIxEzARBgNVBAoTCkdsb2JhbFNpZ24xEzARBgNVBAMT\n"
-"Ckdsb2JhbFNpZ24wHhcNMDYxMjE1MDgwMDAwWhcNMjExMjE1MDgwMDAwWjBMMSAwHgYDVQQL\n"
-"ExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMjETMBEGA1UEChMKR2xvYmFsU2lnbjETMBEGA1UE\n"
-"AxMKR2xvYmFsU2lnbjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAKbPJA6+Lm8o\n"
-"mUVCxKs+IVSbC9N/hHD6ErPLv4dfxn+G07IwXNb9rfF73OX4YJYJkhD10FPe+3t+c4isUoh7\n"
-"SqbKSaZeqKeMWhG8eoLrvozps6yWJQeXSpkqBy+0Hne/ig+1AnwblrjFuTosvNYSuetZfeLQ\n"
-"BoZfXklqtTleiDTsvHgMCJiEbKjNS7SgfQx5TfC4LcshytVsW33hoCmEofnTlEnLJGKRILzd\n"
-"C9XZzPnqJworc5HGnRusyMvo4KD0L5CLTfuwNhv2GXqF4G3yYROIXJ/gkwpRl4pazq+r1feq\n"
-"CapgvdzZX99yqWATXgAByUr6P6TqBwMhAo6CygPCm48CAwEAAaOBnDCBmTAOBgNVHQ8BAf8E\n"
-"BAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUm+IHV2ccHsBqBt5ZtJot39wZhi4w\n"
-"NgYDVR0fBC8wLTAroCmgJ4YlaHR0cDovL2NybC5nbG9iYWxzaWduLm5ldC9yb290LXIyLmNy\n"
-"bDAfBgNVHSMEGDAWgBSb4gdXZxwewGoG3lm0mi3f3BmGLjANBgkqhkiG9w0BAQUFAAOCAQEA\n"
-"mYFThxxol4aR7OBKuEQLq4GsJ0/WwbgcQ3izDJr86iw8bmEbTUsp9Z8FHSbBuOmDAGJFtqkI\n"
-"k7mpM0sYmsL4h4hO291xNBrBVNpGP+DTKqttVCL1OmLNIG+6KYnX3ZHu01yiPqFbQfXf5WRD\n"
-"LenVOavSot+3i9DAgBkcRcAtjOj4LaR0VknFBbVPFd5uRHg5h6h+u/N5GJG79G+dwfCMNYxd\n"
-"AfvDbbnvRG15RjF+Cv6pgsH/76tuIMRQyV+dTZsXjAzlAcmgQWpzU/qlULRuJQ/7TBj0/VLZ\n"
-"jmmx6BEP3ojY+x1J96relc8geMJgEtslQIxq/H5COEBkEveegeGTLg==\n"
-"-----END CERTIFICATE-----\n",
-
-/* Verisign Class 3 Public Primary Certification Authority - G3 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIEGjCCAwICEQCbfgZJoz5iudXukEhxKe9XMA0GCSqGSIb3DQEBBQUAMIHKMQswCQYDVQQG\n"
-"EwJVUzEXMBUGA1UEChMOVmVyaVNpZ24sIEluYy4xHzAdBgNVBAsTFlZlcmlTaWduIFRydXN0\n"
-"IE5ldHdvcmsxOjA4BgNVBAsTMShjKSAxOTk5IFZlcmlTaWduLCBJbmMuIC0gRm9yIGF1dGhv\n"
-"cml6ZWQgdXNlIG9ubHkxRTBDBgNVBAMTPFZlcmlTaWduIENsYXNzIDMgUHVibGljIFByaW1h\n"
-"cnkgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkgLSBHMzAeFw05OTEwMDEwMDAwMDBaFw0zNjA3\n"
-"MTYyMzU5NTlaMIHKMQswCQYDVQQGEwJVUzEXMBUGA1UEChMOVmVyaVNpZ24sIEluYy4xHzAd\n"
-"BgNVBAsTFlZlcmlTaWduIFRydXN0IE5ldHdvcmsxOjA4BgNVBAsTMShjKSAxOTk5IFZlcmlT\n"
-"aWduLCBJbmMuIC0gRm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxRTBDBgNVBAMTPFZlcmlTaWdu\n"
-"IENsYXNzIDMgUHVibGljIFByaW1hcnkgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkgLSBHMzCC\n"
-"ASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMu6nFL8eB8aHm8bN3O9+MlrlBIwT/A2\n"
-"R/XQkQr1F8ilYcEWQE37imGQ5XYgwREGfassbqb1EUGO+i2tKmFZpGcmTNDovFJbcCAEWNF6\n"
-"yaRpvIMXZK0Fi7zQWM6NjPXr8EJJC52XJ2cybuGukxUccLwgTS8Y3pKI6GyFVxEa6X7jJhFU\n"
-"okWWVYPKMIno3Nij7SqAP395ZVc+FSBmCC+Vk7+qRy+oRpfwEuL+wgorUeZ25rdGt+INpsyo\n"
-"w0xZVYnm6FNcHOqd8GIWC6fJXwzw3sJ2zq/3avL6QaaiMxTJ5Xpj055iN9WFZZ4O5lMkdBte\n"
-"HRJTW8cs54NJOxWuimi5V5cCAwEAATANBgkqhkiG9w0BAQUFAAOCAQEAERSWwauSCPc/L8my\n"
-"/uRan2Te2yFPhpk0djZX3dAVL8WtfxUfN2JzPtTnX84XA9s1+ivbrmAJXx5fj267Cz3qWhMe\n"
-"DGBvtcC1IyIuBwvLqXTLR7sdwdela8wv0kL9Sd2nic9TutoAWii/gt/4uhMdUIaC/Y4wjylG\n"
-"sB49Ndo4YhYYSq3mtlFs3q9i6wHQHiT+eo8SGhJouPtmmRQURVyu565pF4ErWjfJXir0xuKh\n"
-"XFSbplQAz/DxwceYMBo7Nhbbo27q/a2ywtrvAkcTisDxszGtTxzhT5yvDwyd93gN2PQ1VoDa\n"
-"t20Xj50egWTh/sVFuq1ruQp6Tk9LhO5L8X3dEQ==\n"
-"-----END CERTIFICATE-----\n",
-
-/* Entrust.net Premium 2048 Secure Server CA */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIEKjCCAxKgAwIBAgIEOGPe+DANBgkqhkiG9w0BAQUFADCBtDEUMBIGA1UEChMLRW50cnVz\n"
-"dC5uZXQxQDA+BgNVBAsUN3d3dy5lbnRydXN0Lm5ldC9DUFNfMjA0OCBpbmNvcnAuIGJ5IHJl\n"
-"Zi4gKGxpbWl0cyBsaWFiLikxJTAjBgNVBAsTHChjKSAxOTk5IEVudHJ1c3QubmV0IExpbWl0\n"
-"ZWQxMzAxBgNVBAMTKkVudHJ1c3QubmV0IENlcnRpZmljYXRpb24gQXV0aG9yaXR5ICgyMDQ4\n"
-"KTAeFw05OTEyMjQxNzUwNTFaFw0yOTA3MjQxNDE1MTJaMIG0MRQwEgYDVQQKEwtFbnRydXN0\n"
-"Lm5ldDFAMD4GA1UECxQ3d3d3LmVudHJ1c3QubmV0L0NQU18yMDQ4IGluY29ycC4gYnkgcmVm\n"
-"LiAobGltaXRzIGxpYWIuKTElMCMGA1UECxMcKGMpIDE5OTkgRW50cnVzdC5uZXQgTGltaXRl\n"
-"ZDEzMDEGA1UEAxMqRW50cnVzdC5uZXQgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkgKDIwNDgp\n"
-"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArU1LqRKGsuqjIAcVFmQqK0vRvwtK\n"
-"TY7tgHalZ7d4QMBzQshowNtTK91euHaYNZOLGp18EzoOH1u3Hs/lJBQesYGpjX24zGtLA/EC\n"
-"DNyrpUAkAH90lKGdCCmziAv1h3edVc3kw37XamSrhRSGlVuXMlBvPci6Zgzj/L24ScF2iUkZ\n"
-"/cCovYmjZy/Gn7xxGWC4LeksyZB2ZnuU4q941mVTXTzWnLLPKQP5L6RQstRIzgUyVYr9smRM\n"
-"DuSYB3Xbf9+5CFVghTAp+XtIpGmG4zU/HoZdenoVve8AjhUiVBcAkCaTvA5JaJG/+EfTnZVC\n"
-"wQ5N328mz8MYIWJmQ3DW1cAH4QIDAQABo0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/\n"
-"BAUwAwEB/zAdBgNVHQ4EFgQUVeSB0RGAvtiJuQijMfmhJAkWuXAwDQYJKoZIhvcNAQEFBQAD\n"
-"ggEBADubj1abMOdTmXx6eadNl9cZlZD7Bh/KM3xGY4+WZiT6QBshJ8rmcnPyT/4xmf3IDExo\n"
-"U8aAghOY+rat2l098c5u9hURlIIM7j+VrxGrD9cv3h8Dj1csHsm7mhpElesYT6YfzX1XEC+b\n"
-"BAlahLVu2B064dae0Wx5XnkcFMXj0EyTO2U87d89vqbllRrDtRnDvV5bu/8j72gZyxKTJ1wD\n"
-"LW8w0B62GqzeWvfRqqgnpv55gcR5mTNXuhKwqeBCbJPKVt7+bYQLCIt+jerXmCHG8+c8eS9e\n"
-"nNFMFY3h7CI3zJpDC5fcgJCNs2ebb0gIFVbPv/ErfF6adulZkMV8gzURZVE=\n"
-"-----END CERTIFICATE-----\n",
-
-/* Baltimore CyberTrust Root */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDdzCCAl+gAwIBAgIEAgAAuTANBgkqhkiG9w0BAQUFADBaMQswCQYDVQQGEwJJRTESMBAG\n"
-"A1UEChMJQmFsdGltb3JlMRMwEQYDVQQLEwpDeWJlclRydXN0MSIwIAYDVQQDExlCYWx0aW1v\n"
-"cmUgQ3liZXJUcnVzdCBSb290MB4XDTAwMDUxMjE4NDYwMFoXDTI1MDUxMjIzNTkwMFowWjEL\n"
-"MAkGA1UEBhMCSUUxEjAQBgNVBAoTCUJhbHRpbW9yZTETMBEGA1UECxMKQ3liZXJUcnVzdDEi\n"
-"MCAGA1UEAxMZQmFsdGltb3JlIEN5YmVyVHJ1c3QgUm9vdDCCASIwDQYJKoZIhvcNAQEBBQAD\n"
-"ggEPADCCAQoCggEBAKMEuyKrmD1X6CZymrV51Cni4eiVgLGw41uOKymaZN+hXe2wCQVt2ygu\n"
-"zmKiYv60iNoS6zjrIZ3AQSsBUnuId9Mcj8e6uYi1agnnc+gRQKfRzMpijS3ljwumUNKoUMMo\n"
-"6vWrJYeKmpYcqWe4PwzV9/lSEy/CG9VwcPCPwBLKBsua4dnKM3p31vjsufFoREJIE9LAwqSu\n"
-"XmD+tqYF/LTdB1kC1FkYmGP1pWPgkAx9XbIGevOF6uvUA65ehD5f/xXtabz5OTZydc93Uk3z\n"
-"yZAsuT3lySNTPx8kmCFcB5kpvcY67Oduhjprl3RjM71oGDHweI12v/yejl0qhqdNkNwnGjkC\n"
-"AwEAAaNFMEMwHQYDVR0OBBYEFOWdWTCCR1jMrPoIVDaGezq1BE3wMBIGA1UdEwEB/wQIMAYB\n"
-"Af8CAQMwDgYDVR0PAQH/BAQDAgEGMA0GCSqGSIb3DQEBBQUAA4IBAQCFDF2O5G9RaEIFoN27\n"
-"TyclhAO992T9Ldcw46QQF+vaKSm2eT929hkTI7gQCvlYpNRhcL0EYWoSihfVCr3FvDB81ukM\n"
-"JY2GQE/szKN+OMY3EU/t3WgxjkzSswF07r51XgdIGn9w/xZchMB5hbgF/X++ZRGjD8ACtPhS\n"
-"NzkE1akxehi/oCr0Epn3o0WC4zxe9Z2etciefC7IpJ5OCBRLbf1wbWsaY71k5h+3zvDyny67\n"
-"G7fyUIhzksLi4xaNmjICq44Y3ekQEe5+NauQrz4wlHrQMz2nZQ/1/I6eYs9HRCwBXbsdtTLS\n"
-"R9I4LtD+gdwyah617jzV/OeBHRnDJELqYzmp\n"
-"-----END CERTIFICATE-----\n",
-
-/* AddTrust Low-Value Services Root */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIEGDCCAwCgAwIBAgIBATANBgkqhkiG9w0BAQUFADBlMQswCQYDVQQGEwJTRTEUMBIGA1UE\n"
-"ChMLQWRkVHJ1c3QgQUIxHTAbBgNVBAsTFEFkZFRydXN0IFRUUCBOZXR3b3JrMSEwHwYDVQQD\n"
-"ExhBZGRUcnVzdCBDbGFzcyAxIENBIFJvb3QwHhcNMDAwNTMwMTAzODMxWhcNMjAwNTMwMTAz\n"
-"ODMxWjBlMQswCQYDVQQGEwJTRTEUMBIGA1UEChMLQWRkVHJ1c3QgQUIxHTAbBgNVBAsTFEFk\n"
-"ZFRydXN0IFRUUCBOZXR3b3JrMSEwHwYDVQQDExhBZGRUcnVzdCBDbGFzcyAxIENBIFJvb3Qw\n"
-"ggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCWltQhSWDia+hBBwzexODcEyPNwTXH\n"
-"+9ZOEQpnXvUGW2ulCDtbKRY654eyNAbFvAWlA3yCyykQruGIgb3WntP+LVbBFc7jJp0VLhD7\n"
-"Bo8wBN6ntGO0/7Gcrjyvd7ZWxbWroulpOj0OM3kyP3CCkplhbY0wCI9xP6ZIVxn4JdxLZlyl\n"
-"dI+Yrsj5wAYi56xz36Uu+1LcsRVlIPo1Zmne3yzxbrww2ywkEtvrNTVokMsAsJchPXQhI2U0\n"
-"K7t4WaPW4XY5mqRJjox0r26kmqPZm9I4XJuiGMx1I4S+6+JNM3GOGvDC+Mcdoq0Dlyz4zyXG\n"
-"9rgkMbFjXZJ/Y/AlyVMuH79NAgMBAAGjgdIwgc8wHQYDVR0OBBYEFJWxtPCUtr3H2tERCSG+\n"
-"wa9J/RB7MAsGA1UdDwQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MIGPBgNVHSMEgYcwgYSAFJWx\n"
-"tPCUtr3H2tERCSG+wa9J/RB7oWmkZzBlMQswCQYDVQQGEwJTRTEUMBIGA1UEChMLQWRkVHJ1\n"
-"c3QgQUIxHTAbBgNVBAsTFEFkZFRydXN0IFRUUCBOZXR3b3JrMSEwHwYDVQQDExhBZGRUcnVz\n"
-"dCBDbGFzcyAxIENBIFJvb3SCAQEwDQYJKoZIhvcNAQEFBQADggEBACxtZBsfzQ3duQH6lmM0\n"
-"MkhHma6X7f1yFqZzR1r0693p9db7RcwpiURdv0Y5PejuvE1Uhh4dbOMXJ0PhiVYrqW9yTkkz\n"
-"43J8KiOavD7/KCrto/8cI7pDVwlnTUtiBi34/2ydYB7YHEt9tTEv2dB8Xfjea4MYeDdXL+gz\n"
-"B2ffHsdrKpV2ro9Xo/D0UrSpUwjP4E/TelOL/bscVjby/rK25Xa71SJlpz/+0WatC7xrmYbv\n"
-"P33zGDLKe8bjq2RGlfgmadlVg3sslgf/WSxEo8bl6ancoWOAWiFeIc9TVPC6b4nbqKqVz4vj\n"
-"ccweGyBECMB6tkD9xOQ14R0WHNC8K47Wcdk=\n"
-"-----END CERTIFICATE-----\n",
-
-/* AddTrust External Root */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIENjCCAx6gAwIBAgIBATANBgkqhkiG9w0BAQUFADBvMQswCQYDVQQGEwJTRTEUMBIGA1UE\n"
-"ChMLQWRkVHJ1c3QgQUIxJjAkBgNVBAsTHUFkZFRydXN0IEV4dGVybmFsIFRUUCBOZXR3b3Jr\n"
-"MSIwIAYDVQQDExlBZGRUcnVzdCBFeHRlcm5hbCBDQSBSb290MB4XDTAwMDUzMDEwNDgzOFoX\n"
-"DTIwMDUzMDEwNDgzOFowbzELMAkGA1UEBhMCU0UxFDASBgNVBAoTC0FkZFRydXN0IEFCMSYw\n"
-"JAYDVQQLEx1BZGRUcnVzdCBFeHRlcm5hbCBUVFAgTmV0d29yazEiMCAGA1UEAxMZQWRkVHJ1\n"
-"c3QgRXh0ZXJuYWwgQ0EgUm9vdDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALf3\n"
-"GjPm8gAELTngTlvtH7xsD821+iO2zt6bETOXpClMfZOfvUq8k+0DGuOPz+VtUFrWlymUWoCw\n"
-"SXrbLpX9uMq/NzgtHj6RQa1wVsfwTz/oMp50ysiQVOnGXw94nZpAPA6sYapeFI+eh6FqUNzX\n"
-"mk6vBbOmcZSccbNQYArHE504B4YCqOmoaSYYkKtMsE8jqzpPhNjfzp/haW+710LXa0Tkx63u\n"
-"bUFfclpxCDezeWWkWaCUN/cALw3CknLa0Dhy2xSoRcRdKn23tNbE7qzNE0S3ySvdQwAl+mG5\n"
-"aWpYIxG3pzOPVnVZ9c0p10a3CitlttNCbxWyuHv77+ldU9U0WicCAwEAAaOB3DCB2TAdBgNV\n"
-"HQ4EFgQUrb2YejS0Jvf6xCZU7wO94CTLVBowCwYDVR0PBAQDAgEGMA8GA1UdEwEB/wQFMAMB\n"
-"Af8wgZkGA1UdIwSBkTCBjoAUrb2YejS0Jvf6xCZU7wO94CTLVBqhc6RxMG8xCzAJBgNVBAYT\n"
-"AlNFMRQwEgYDVQQKEwtBZGRUcnVzdCBBQjEmMCQGA1UECxMdQWRkVHJ1c3QgRXh0ZXJuYWwg\n"
-"VFRQIE5ldHdvcmsxIjAgBgNVBAMTGUFkZFRydXN0IEV4dGVybmFsIENBIFJvb3SCAQEwDQYJ\n"
-"KoZIhvcNAQEFBQADggEBALCb4IUlwtYj4g+WBpKdQZic2YR5gdkeWxQHIzZlj7DYd7usQWxH\n"
-"YINRsPkyPef89iYTx4AWpb9a/IfPeHmJIZriTAcKhjW88t5RxNKWt9x+Tu5w/Rw56wwCURQt\n"
-"jr0W4MHfRnXnJK3s9EK0hZNwEGe6nQY1ShjTK3rMUUKhemPR5ruhxSvCNr4TDea9Y355e6cJ\n"
-"DUCrat2PisP29owaQgVR1EX1n6diIWgVIEM8med8vSTYqZEXc4g/VhsxOBi0cQ+azcgOno4u\n"
-"G+GMmIPLHzHxREzGBHNJdmAPx/i9F4BrLunMTA5amnkPIAou1Z5jJh5VkpTYghdae9C8x49O\n"
-"hgQ=\n"
-"-----END CERTIFICATE-----\n",
-
-/* AddTrust Public Services Root */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIEFTCCAv2gAwIBAgIBATANBgkqhkiG9w0BAQUFADBkMQswCQYDVQQGEwJTRTEUMBIGA1UE\n"
-"ChMLQWRkVHJ1c3QgQUIxHTAbBgNVBAsTFEFkZFRydXN0IFRUUCBOZXR3b3JrMSAwHgYDVQQD\n"
-"ExdBZGRUcnVzdCBQdWJsaWMgQ0EgUm9vdDAeFw0wMDA1MzAxMDQxNTBaFw0yMDA1MzAxMDQx\n"
-"NTBaMGQxCzAJBgNVBAYTAlNFMRQwEgYDVQQKEwtBZGRUcnVzdCBBQjEdMBsGA1UECxMUQWRk\n"
-"VHJ1c3QgVFRQIE5ldHdvcmsxIDAeBgNVBAMTF0FkZFRydXN0IFB1YmxpYyBDQSBSb290MIIB\n"
-"IjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA6Rowj4OIFMEg2Dybjxt+A3S72mnTRqX4\n"
-"jsIMEZBRpS9mVEBV6tsfSlbunyNu9DnLoblv8n75XYcmYZ4c+OLspoH4IcUkzBEMP9smcnrH\n"
-"AZcHF/nXGCwwfQ56HmIexkvA/X1id9NEHif2P0tEs7c42TkfYNVRknMDtABp4/MUTu7R3AnP\n"
-"dzRGULD4EfL+OHn3Bzn+UZKXC1sIXzSGAa2Il+tmzV7R/9x98oTaunet3IAIx6eH1lWfl2ro\n"
-"yBFkuucZKT8Rs3iQhCBSWxHveNCD9tVIkNAwHM+A+WD+eeSI8t0A65RF62WUaUC6wNW0uLp9\n"
-"BBGo6zEFlpROWCGOn9Bg/QIDAQABo4HRMIHOMB0GA1UdDgQWBBSBPjfYkrAfd59ctKtzquf2\n"
-"NGAv+jALBgNVHQ8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zCBjgYDVR0jBIGGMIGDgBSBPjfY\n"
-"krAfd59ctKtzquf2NGAv+qFopGYwZDELMAkGA1UEBhMCU0UxFDASBgNVBAoTC0FkZFRydXN0\n"
-"IEFCMR0wGwYDVQQLExRBZGRUcnVzdCBUVFAgTmV0d29yazEgMB4GA1UEAxMXQWRkVHJ1c3Qg\n"
-"UHVibGljIENBIFJvb3SCAQEwDQYJKoZIhvcNAQEFBQADggEBAAP3FUr4JNojVhaTdt02KLmu\n"
-"G7jD8WS6IBh4lSknVwW8fCr0uVFV2ocC3g8WFzH4qnkuCRO7r7IgGRLlk/lL+YPoRNWyQSW/\n"
-"iHVv/xD8SlTQX/D67zZzfRs2RcYhbbQVuE7PnFylPVoAjgbjPGsye/Kf8Lb93/AoGEjwxrzQ\n"
-"vzSAlsJKsW2Ox5BF3i9nrEUEo3rcVZLJR2bYGozH7ZxOmuASu7VqTITh4SINhwBk/ox9Yjll\n"
-"pu9CtoAlEmEBqCQTcAARJl/6NVDFSMwGR+gn2HCNX2TmoUQmXiLsks3/QppEIW1cxeMiHV9H\n"
-"EufOX1362KqxMy3ZdvJOOjMMK7MtkAY=\n"
-"-----END CERTIFICATE-----\n",
-
-/* AddTrust Qualified Certificates Root */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIEHjCCAwagAwIBAgIBATANBgkqhkiG9w0BAQUFADBnMQswCQYDVQQGEwJTRTEUMBIGA1UE\n"
-"ChMLQWRkVHJ1c3QgQUIxHTAbBgNVBAsTFEFkZFRydXN0IFRUUCBOZXR3b3JrMSMwIQYDVQQD\n"
-"ExpBZGRUcnVzdCBRdWFsaWZpZWQgQ0EgUm9vdDAeFw0wMDA1MzAxMDQ0NTBaFw0yMDA1MzAx\n"
-"MDQ0NTBaMGcxCzAJBgNVBAYTAlNFMRQwEgYDVQQKEwtBZGRUcnVzdCBBQjEdMBsGA1UECxMU\n"
-"QWRkVHJ1c3QgVFRQIE5ldHdvcmsxIzAhBgNVBAMTGkFkZFRydXN0IFF1YWxpZmllZCBDQSBS\n"
-"b290MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5B6a/twJWoekn0e+EV+vhDTb\n"
-"Yjx5eLfpMLXsDBwqxBb/4Oxx64r1EW7tTw2R0hIYLUkVAcKkIhPHEWT/IhKauY5cLwjPcWqz\n"
-"ZwFZ8V1G87B4pfYOQnrjfxvM0PC3KP0q6p6zsLkEqv32x7SxuCqg+1jxGaBvcCV+PmlKfw8i\n"
-"2O+tCBGaKZnhqkRFmhJePp1tUvznoD1oL/BLcHwTOK28FSXx1s6rosAx1i+f4P8UWfyEk9mH\n"
-"fExUE+uf0S0R+Bg6Ot4l2ffTQO2kBhLEO+GRwVY18BTcZTYJbqukB8c10cIDMzZbdSZtQvES\n"
-"a0NvS3GU+jQd7RNuyoB/mC9suWXY6QIDAQABo4HUMIHRMB0GA1UdDgQWBBQ5lYtii1zJ1IC6\n"
-"WA+XPxUIQ8yYpzALBgNVHQ8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zCBkQYDVR0jBIGJMIGG\n"
-"gBQ5lYtii1zJ1IC6WA+XPxUIQ8yYp6FrpGkwZzELMAkGA1UEBhMCU0UxFDASBgNVBAoTC0Fk\n"
-"ZFRydXN0IEFCMR0wGwYDVQQLExRBZGRUcnVzdCBUVFAgTmV0d29yazEjMCEGA1UEAxMaQWRk\n"
-"VHJ1c3QgUXVhbGlmaWVkIENBIFJvb3SCAQEwDQYJKoZIhvcNAQEFBQADggEBABmrder4i2Vh\n"
-"lRO6aQTvhsoToMeqT2QbPxj2qC0sVY8FtzDqQmodwCVRLae/DLPt7wh/bDxGGuoYQ992zPlm\n"
-"hpwsaPXpF/gxsxjE1kh9I0xowX67ARRvxdlu3rsEQmr49lx95dr6h+sNNVJn0J6XdgWTP5XH\n"
-"AeZpVTh/EGGZyeNfpso+gmNIquIISD6q8rKFYqa0p9m9N5xotS1WfbC3P6CxB9bpT9zeRXEw\n"
-"Mn8bLgn5v1Kh7sKAPgZcLlVAwRv1cEWw3F369nJad9Jjzc9YiQBCYz95OdBEsIJuQRno3eDB\n"
-"iFrRHnGTHyQwdOUeqN48Jzd/g66ed8/wMLH/S5noxqE=\n"
-"-----END CERTIFICATE-----\n",
-
-/* Entrust Root Certification Authority */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIEkTCCA3mgAwIBAgIERWtQVDANBgkqhkiG9w0BAQUFADCBsDELMAkGA1UEBhMCVVMxFjAU\n"
-"BgNVBAoTDUVudHJ1c3QsIEluYy4xOTA3BgNVBAsTMHd3dy5lbnRydXN0Lm5ldC9DUFMgaXMg\n"
-"aW5jb3Jwb3JhdGVkIGJ5IHJlZmVyZW5jZTEfMB0GA1UECxMWKGMpIDIwMDYgRW50cnVzdCwg\n"
-"SW5jLjEtMCsGA1UEAxMkRW50cnVzdCBSb290IENlcnRpZmljYXRpb24gQXV0aG9yaXR5MB4X\n"
-"DTA2MTEyNzIwMjM0MloXDTI2MTEyNzIwNTM0MlowgbAxCzAJBgNVBAYTAlVTMRYwFAYDVQQK\n"
-"Ew1FbnRydXN0LCBJbmMuMTkwNwYDVQQLEzB3d3cuZW50cnVzdC5uZXQvQ1BTIGlzIGluY29y\n"
-"cG9yYXRlZCBieSByZWZlcmVuY2UxHzAdBgNVBAsTFihjKSAyMDA2IEVudHJ1c3QsIEluYy4x\n"
-"LTArBgNVBAMTJEVudHJ1c3QgUm9vdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTCCASIwDQYJ\n"
-"KoZIhvcNAQEBBQADggEPADCCAQoCggEBALaVtkNC+sZtKm9I35RMOVcF7sN5EUFoNu3s/poB\n"
-"j6E4KPz3EEZmLk0eGrEaTsbRwJWIsMn/MYszA9u3g3s+IIRe7bJWKKf44LlAcTfFy0cOlypo\n"
-"wCKVYhXbR9n10Cv/gkvJrT7eTNuQgFA/CYqEAOwwCj0Yzfv9KlmaI5UXLEWeH25DeW0MXJj+\n"
-"SKfFI0dcXv1u5x609mhF0YaDW6KKjbHjKYD+JXGIrb68j6xSlkuqUY3kEzEZ6E5Nn9uss2rV\n"
-"vDlUccp6en+Q3X0dgNmBu1kmwhH+5pPi94DkZfs0Nw4pgHBNrziGLp5/V6+eF67rHMsoIV+2\n"
-"HNjnogQi+dPa2MsCAwEAAaOBsDCBrTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB\n"
-"/zArBgNVHRAEJDAigA8yMDA2MTEyNzIwMjM0MlqBDzIwMjYxMTI3MjA1MzQyWjAfBgNVHSME\n"
-"GDAWgBRokORnpKZTgMeGZqTx90tD+4S9bTAdBgNVHQ4EFgQUaJDkZ6SmU4DHhmak8fdLQ/uE\n"
-"vW0wHQYJKoZIhvZ9B0EABBAwDhsIVjcuMTo0LjADAgSQMA0GCSqGSIb3DQEBBQUAA4IBAQCT\n"
-"1DCw1wMgKtD5Y+iRDAUgqV8ZyntyTtSx29CW+1RaGSwMCPeyvIWonX9tO1KzKtvn1ISMY/YP\n"
-"yyYBkVBs9F8U4pN0wBOeMDpQ47RgxRzwIkSNcUesyBrJ6ZuaAGAT/3B+XxFNSRuzFVJ7yVTa\n"
-"v52Vr2ua2J7p8eRDjeIRRDq/r72DQnNSi6q7pynP9WQcCk3RvKqsnyrQ/39/2n3qse0wJcGE\n"
-"2jTSW3iDVuycNsMm4hH2Z0kdkquM++v/eu6FSqdQgPCnXEqULl8FmTxSQeDNtGPPAUO6nIPc\n"
-"j2A781q0tHuu2guQOHXvgR1m0vdXcDazv/wor3ElhVsT/h5/WrQ8\n"
-"-----END CERTIFICATE-----\n",
-
-/* RSA Security 2048 v3 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDYTCCAkmgAwIBAgIQCgEBAQAAAnwAAAAKAAAAAjANBgkqhkiG9w0BAQUFADA6MRkwFwYD\n"
-"VQQKExBSU0EgU2VjdXJpdHkgSW5jMR0wGwYDVQQLExRSU0EgU2VjdXJpdHkgMjA0OCBWMzAe\n"
-"Fw0wMTAyMjIyMDM5MjNaFw0yNjAyMjIyMDM5MjNaMDoxGTAXBgNVBAoTEFJTQSBTZWN1cml0\n"
-"eSBJbmMxHTAbBgNVBAsTFFJTQSBTZWN1cml0eSAyMDQ4IFYzMIIBIjANBgkqhkiG9w0BAQEF\n"
-"AAOCAQ8AMIIBCgKCAQEAt49VcdKA3XtpeafwGFAyPGJn9gqVB93mG/Oe2dJBVGutn3y+Gc37\n"
-"RqtBaB4Y6lXIL5F4iSj7Jylg/9+PjDvJSZu1pJTOAeo+tWN7fyb9Gd3AIb2E0S1PRsNO3Ng3\n"
-"OTsor8udGuorryGlwSMiuLgbWhOHV4PR8CDn6E8jQrAApX2J6elhc5SYcSa8LWrg903w8bYq\n"
-"ODGBDSnhAMFRD0xS+ARaqn1y07iHKrtjEAMqs6FPDVpeRrc9DvV07Jmf+T0kgYim3WBU6JU2\n"
-"PcYJk5qjEoAAVZkZR73QpXzDuvsf9/UP+Ky5tfQ3mBMY3oVbtwyCO4dvlTlYMNpuAWgXIszA\n"
-"CwIDAQABo2MwYTAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIBBjAfBgNVHSMEGDAW\n"
-"gBQHw1EwpKrpRa41JPr/JCwz0LGdjDAdBgNVHQ4EFgQUB8NRMKSq6UWuNST6/yQsM9CxnYww\n"
-"DQYJKoZIhvcNAQEFBQADggEBAF8+hnZuuDU8TjYcHnmYv/3VEhF5Ug7uMYm83X/50cYVIeiK\n"
-"AVQNOvtUudZj1LGqlk2iQk3UUx+LEN5/Zb5gEydxiKRz44Rj0aRV4VCT5hsOedBnvEbIvz8X\n"
-"DZXmxpBp3ue0L96VfdASPz0+f00/FGj1EVDVwfSQpQgdMWD/YIwjVAqv/qFuxdF6Kmh4zx6C\n"
-"CiC0H63lhbJqaHVOrSU3lIW+vaHU6rcMSzyd6BIA8F+sDeGscGNz9395nzIlQnQFgCi/vcEk\n"
-"llgVsRch6YlL2weIZ/QVrXA+L02FO8K32/6YaCOJ4XQP3vTFhGMpG8zLB8kApKnXwiJPZ9d3\n"
-"7CAFYd4=\n"
-"-----END CERTIFICATE-----\n",
-
-/* GeoTrust Global CA */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDVDCCAjygAwIBAgIDAjRWMA0GCSqGSIb3DQEBBQUAMEIxCzAJBgNVBAYTAlVTMRYwFAYD\n"
-"VQQKEw1HZW9UcnVzdCBJbmMuMRswGQYDVQQDExJHZW9UcnVzdCBHbG9iYWwgQ0EwHhcNMDIw\n"
-"NTIxMDQwMDAwWhcNMjIwNTIxMDQwMDAwWjBCMQswCQYDVQQGEwJVUzEWMBQGA1UEChMNR2Vv\n"
-"VHJ1c3QgSW5jLjEbMBkGA1UEAxMSR2VvVHJ1c3QgR2xvYmFsIENBMIIBIjANBgkqhkiG9w0B\n"
-"AQEFAAOCAQ8AMIIBCgKCAQEA2swYYzD99BcjGlZ+W988bDjkcbd4kdS8odhM+KhDtgPpTSEH\n"
-"CIjaWC9mOSm9BXiLnTjoBbdqfnGk5sRgprDvgOSJKA+eJdbtg/OtppHHmMlCGDUUna2YRpIu\n"
-"T8rxh0PBFpVXLVDviS2Aelet8u5fa9IAjbkU+BQVNdnARqN7csiRv8lVK83Qlz6cJmTM386D\n"
-"GXHKTubU1XupGc1V3sjs0l44U+VcT4wt/lAjNvxm5suOpDkZALeVAjmRCw7+OC7RHQWa9k0+\n"
-"bw8HHa8sHo9gOeL6NlMTOdReJivbPagUvTLrGAMoUgRx5aszPeE4uwc2hGKceeoWMPRfwCvo\n"
-"cWvk+QIDAQABo1MwUTAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBTAephojYn7qwVkDBF9\n"
-"qn1luMrMTjAfBgNVHSMEGDAWgBTAephojYn7qwVkDBF9qn1luMrMTjANBgkqhkiG9w0BAQUF\n"
-"AAOCAQEANeMpauUvXVSOKVCUn5kaFOSPeCpilKInZ57QzxpeR+nBsqTP3UEaBU6bS+5Kb1VS\n"
-"syShNwrrZHYqLizz/Tt1kL/6cdjHPTfStQWVYrmm3ok9Nns4d0iXrKYgjy6myQzCsplFAMfO\n"
-"EVEiIuCl6rYVSAlk6l5PdPcFPseKUgzbFbS9bZvlxrFUaKnjaZC2mqUPuLk/IH2uSrW4nOQd\n"
-"tqvmlKXBx4Ot2/Unhw4EbNX/3aBd7YdStysVAq45pmp06drE57xNNB6pXE0zX5IJL4hmXXeX\n"
-"xx12E6nV5fEWCRE11azbJHFwLJhWC9kXtNHjUStedejV0NxPNO3CBWaAocvmMw==\n"
-"-----END CERTIFICATE-----\n",
-
-/* GeoTrust Global CA 2 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDZjCCAk6gAwIBAgIBATANBgkqhkiG9w0BAQUFADBEMQswCQYDVQQGEwJVUzEWMBQGA1UE\n"
-"ChMNR2VvVHJ1c3QgSW5jLjEdMBsGA1UEAxMUR2VvVHJ1c3QgR2xvYmFsIENBIDIwHhcNMDQw\n"
-"MzA0MDUwMDAwWhcNMTkwMzA0MDUwMDAwWjBEMQswCQYDVQQGEwJVUzEWMBQGA1UEChMNR2Vv\n"
-"VHJ1c3QgSW5jLjEdMBsGA1UEAxMUR2VvVHJ1c3QgR2xvYmFsIENBIDIwggEiMA0GCSqGSIb3\n"
-"DQEBAQUAA4IBDwAwggEKAoIBAQDvPE1APRDfO1MA4Wf+lGAVPoWI8YkNkMgoI5kF6Csgncbz\n"
-"YEbYwbLVjDHZ3CB5JIG/NTL8Y2nbsSpr7iFY8gjpeMtvy/wWUsiRxP89c96xPqfCfWbB9X5S\n"
-"JBri1WeR0IIQ13hLTytCOb1kLUCgsBDTOEhGiKEMuzozKmKY+wCdE1l/bztyqu6mD4b5BWHq\n"
-"Z38MN5aL5mkWRxHCJ1kDs6ZgwiFAVvqgx306E+PsV8ez1q6diYD3Aecs9pYrEw15LNnA5IZ7\n"
-"S4wMcoKK+xfNAGw6EzywhIdLFnopsk/bHdQL82Y3vdj2V7teJHq4PIu5+pIaGoSe2HSPqht/\n"
-"XvT+RSIhAgMBAAGjYzBhMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFHE4NvICMVNHK266\n"
-"ZUapEBVYIAUJMB8GA1UdIwQYMBaAFHE4NvICMVNHK266ZUapEBVYIAUJMA4GA1UdDwEB/wQE\n"
-"AwIBhjANBgkqhkiG9w0BAQUFAAOCAQEAA/e1K6tdEPx7srJerJsOflN4WT5CBP51o62sgU7X\n"
-"AotexC3IUnbHLB/8gTKY0UvGkpMzNTEv/NgdRN3ggX+d6YvhZJFiCzkIjKx0nVnZellSlxG5\n"
-"FntvRdOW2TF9AjYPnDtuzywNA0ZF66D0f0hExghAzN4bcLUprbqLOzRldRtxIR0sFAqwlpW4\n"
-"1uryZfspuk/qkZN0abby/+Ea0AzRdoXLiiW9l14sbxWZJue2Kf8i7MkCx1YAzUm5s2x7UwQa\n"
-"4qjJqhIFI8LO57sEAszAR6LkxCkvW0VXiVHuPOtSCP8HNR6fNWpHSlaY0VqFH4z1Ir+rzoPz\n"
-"4iIprn2DQKi6bA==\n"
-"-----END CERTIFICATE-----\n",
-
-/* GeoTrust Universal CA */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIFaDCCA1CgAwIBAgIBATANBgkqhkiG9w0BAQUFADBFMQswCQYDVQQGEwJVUzEWMBQGA1UE\n"
-"ChMNR2VvVHJ1c3QgSW5jLjEeMBwGA1UEAxMVR2VvVHJ1c3QgVW5pdmVyc2FsIENBMB4XDTA0\n"
-"MDMwNDA1MDAwMFoXDTI5MDMwNDA1MDAwMFowRTELMAkGA1UEBhMCVVMxFjAUBgNVBAoTDUdl\n"
-"b1RydXN0IEluYy4xHjAcBgNVBAMTFUdlb1RydXN0IFVuaXZlcnNhbCBDQTCCAiIwDQYJKoZI\n"
-"hvcNAQEBBQADggIPADCCAgoCggIBAKYVVaCjxuAfjJ0hUNfBvitbtaSeodlyWL0AG0y/YckU\n"
-"HUWCq8YdgNY96xCcOq9tJPi8cQGeBvV8Xx7BDlXKg5pZMK4ZyzBIle0iN430SppyZj6tlcDg\n"
-"FgDgEB8rMQ7XlFTTQjOgNB0eRXbdT8oYN+yFFXoZCPzVx5zw8qkuEKmS5j1YPakWaDwvdSEY\n"
-"fyh3peFhF7em6fgemdtzbvQKoiFs7tqqhZJmr/Z6a4LauiIINQ/PQvE1+mrufislzDoR5G2v\n"
-"c7J2Ha3QsnhnGqQ5HFELZ1aD/ThdDc7d8Lsrlh/eezJS/R27tQahsiFepdaVaH/wmZ7cRQg+\n"
-"59IJDTWU3YBOU5fXtQlEIGQWFwMCTFMNaN7VqnJNk22CDtucvc+081xdVHppCZbW2xHBjXWo\n"
-"tM85yM48vCR85mLK4b19p71XZQvk/iXttmkQ3CgaRr0BHdCXteGYO8A3ZNY9lO4L4fUorgtW\n"
-"v3GLIylBjobFS1J72HGrH4oVpjuDWtdYAVHGTEHZf9hBZ3KiKN9gg6meyHv8U3NyWfWTehd2\n"
-"Ds735VzZC1U0oqpbtWpU5xPKV+yXbfReBi9Fi1jUIxaS5BZuKGNZMN9QAZxjiRqf2xeUgnA3\n"
-"wySemkfWWspOqGmJch+RbNt+nhutxx9z3SxPGWX9f5NAEC7S8O08ni4oPmkmM8V7AgMBAAGj\n"
-"YzBhMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFNq7LqqwDLiIJlF0XG0D08DYj3rWMB8G\n"
-"A1UdIwQYMBaAFNq7LqqwDLiIJlF0XG0D08DYj3rWMA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG\n"
-"9w0BAQUFAAOCAgEAMXjmx7XfuJRAyXHEqDXsRh3ChfMoWIawC/yOsjmPRFWrZIRcaanQmjg8\n"
-"+uUfNeVE44B5lGiku8SfPeE0zTBGi1QrlaXv9z+ZhP015s8xxtxqv6fXIwjhmF7DWgh2qaav\n"
-"dy+3YL1ERmrvl/9zlcGO6JP7/TG37FcREUWbMPEaiDnBTzynANXH/KttgCJwpQzgXQQpAvvL\n"
-"oJHRfNbDflDVnVi+QTjruXU8FdmbyUqDWcDaU/0zuzYYm4UPFd3uLax2k7nZAY1IEKj79TiG\n"
-"8dsKxr2EoyNB3tZ3b4XUhRxQ4K5RirqNPnbiucon8l+f725ZDQbYKxek0nxru18UGkiPGkzn\n"
-"s0ccjkxFKyDuSN/n3QmOGKjaQI2SJhFTYXNd673nxE0pN2HrrDktZy4W1vUAg4WhzH92xH3k\n"
-"t0tm7wNFYGm2DFKWkoRepqO1pD4r2czYG0eq8kTaT/kD6PAUyz/zg97QwVTjt+gKN02LIFkD\n"
-"MBmhLMi9ER/frslKxfMnZmaGrGiR/9nmUxwPi1xpZQomyB40w11Re9epnAahNt3ViZS82eQt\n"
-"DF4JbAiXfKM9fJP/P6EUp8+1Xevb2xzEdt+Iub1FBZUbrvxGakyvSOPOrg/SfuvmbJxPgWp6\n"
-"ZKy7PtXny3YuxadIwVyQD8vIP/rmMuGNG2+k5o7Y+SlIis5z/iw=\n"
-"-----END CERTIFICATE-----\n",
-
-/* GeoTrust Universal CA 2 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIFbDCCA1SgAwIBAgIBATANBgkqhkiG9w0BAQUFADBHMQswCQYDVQQGEwJVUzEWMBQGA1UE\n"
-"ChMNR2VvVHJ1c3QgSW5jLjEgMB4GA1UEAxMXR2VvVHJ1c3QgVW5pdmVyc2FsIENBIDIwHhcN\n"
-"MDQwMzA0MDUwMDAwWhcNMjkwMzA0MDUwMDAwWjBHMQswCQYDVQQGEwJVUzEWMBQGA1UEChMN\n"
-"R2VvVHJ1c3QgSW5jLjEgMB4GA1UEAxMXR2VvVHJ1c3QgVW5pdmVyc2FsIENBIDIwggIiMA0G\n"
-"CSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCzVFLByT7y2dyxUxpZKeexw0Uo5dfR7cXFS6Gq\n"
-"dHtXr0om/Nj1XqduGdt0DE81WzILAePb63p3NeqqWuDW6KFXlPCQo3RWlEQwAx5cTiuFJnSC\n"
-"egx2oG9NzkEtoBUGFF+3Qs17j1hhNNwqCPkuwwGmIkQcTAeC5lvO0Ep8BNMZcyfwqph/Lq9O\n"
-"64ceJHdqXbboW0W63MOhBW9Wjo8QJqVJwy7XQYci4E+GymC16qFjwAGXEHm9ADwSbSsVsaxL\n"
-"se4YuU6W3Nx2/zu+z18DwPw76L5GG//aQMJS9/7jOvdqdzXQ2o3rXhhqMcceujwbKNZrVMaq\n"
-"W9eiLBsZzKIC9ptZvTdrhrVtgrrY6slWvKk2WP0+GfPtDCapkzj4T8FdIgbQl+rhrcZV4IEr\n"
-"KIM6+vR7IVEAvlI4zs1meaj0gVbi0IMJR1FbUGrP20gaXT73y/Zl92zxlfgCOzJWgjl6W70v\n"
-"iRu/obTo/3+NjN8D8WBOWBFM66M/ECuDmgFz2ZRthAAnZqzwcEAJQpKtT5MNYQlRJNiS1QuU\n"
-"YbKHsu3/mjX/hVTK7URDrBs8FmtISgocQIgfksILAAX/8sgCSqSqqcyZlpwvWOB94b67B9xf\n"
-"BHJcMTTD7F8t4D1kkCLm0ey4Lt1ZrtmhN79UNdxzMk+MBB4zsslG8dhcyFVQyWi9qLo2CQID\n"
-"AQABo2MwYTAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBR281Xh+qQ2+/CfXGJx7Tz0RzgQ\n"
-"KzAfBgNVHSMEGDAWgBR281Xh+qQ2+/CfXGJx7Tz0RzgQKzAOBgNVHQ8BAf8EBAMCAYYwDQYJ\n"
-"KoZIhvcNAQEFBQADggIBAGbBxiPz2eAubl/oz66wsCVNK/g7WJtAJDday6sWSf+zdXkzoS9t\n"
-"cBc0kf5nfo/sm+VegqlVHy/c1FEHEv6sFj4sNcZj/NwQ6w2jqtB8zNHQL1EuxBRa3ugZ4T7G\n"
-"zKQp5y6EqgYweHZUcyiYWTjgAA1i00J9IZ+uPTqM1fp3DRgrFg5fNuH8KrUwJM/gYwx7WBr+\n"
-"mbpCErGR9Hxo4sjoryzqyX6uuyo9DRXcNJW2GHSoag/HtPQTxORb7QrSpJdMKu0vbBKJPfEn\n"
-"cKpqA1Ihn0CoZ1Dy81of398j9tx4TuaYT1U6U+Pv8vSfx3zYWK8pIpe44L2RLrB27FcRz+8p\n"
-"RPPphXpgY+RdM4kX2TGq2tbzGDVyz4crL2MjhF2EjD9XoIj8mZEoJmmZ1I+XRL6O1UixpCgp\n"
-"8RW04eWe3fiPpm8m1wk8OhwRDqZsN/etRIcsKMfYdIKz0G9KV7s1KSegi+ghp4dkNl3M2Bas\n"
-"x7InQJJVOCiNUW7dFGdTbHFcJoRNdVq2fmBWqU2t+5sel/MN2dKXVHfaPRK34B7vCAas+YWH\n"
-"6aLcr34YEoP9VhdBLtUpgn2Z9DH2canPLAEnpQW5qrJITirvn5NSUZU8UnOOVkwXQMAJKOSL\n"
-"akhT2+zNVVXxxvjpoixMptEmX36vWkzaH6byHCx+rgIW0lbQL1dTR+iS\n"
-"-----END CERTIFICATE-----\n",
-
-/* Visa eCommerce Root */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDojCCAoqgAwIBAgIQE4Y1TR0/BvLB+WUF1ZAcYjANBgkqhkiG9w0BAQUFADBrMQswCQYD\n"
-"VQQGEwJVUzENMAsGA1UEChMEVklTQTEvMC0GA1UECxMmVmlzYSBJbnRlcm5hdGlvbmFsIFNl\n"
-"cnZpY2UgQXNzb2NpYXRpb24xHDAaBgNVBAMTE1Zpc2EgZUNvbW1lcmNlIFJvb3QwHhcNMDIw\n"
-"NjI2MDIxODM2WhcNMjIwNjI0MDAxNjEyWjBrMQswCQYDVQQGEwJVUzENMAsGA1UEChMEVklT\n"
-"QTEvMC0GA1UECxMmVmlzYSBJbnRlcm5hdGlvbmFsIFNlcnZpY2UgQXNzb2NpYXRpb24xHDAa\n"
-"BgNVBAMTE1Zpc2EgZUNvbW1lcmNlIFJvb3QwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEK\n"
-"AoIBAQCvV95WHm6h2mCxlCfLF9sHP4CFT8icttD0b0/Pmdjh28JIXDqsOTPHH2qLJj0rNfVI\n"
-"sZHBAk4ElpF7sDPwsRROEW+1QK8bRaVK7362rPKgH1g/EkZgPI2h4H3PVz4zHvtH8aoVlwdV\n"
-"ZqW1LS7YgFmypw23RuwhY/81q6UCzyr0TP579ZRdhE2o8mCP2w4lPJ9zcc+U30rq299yOIzz\n"
-"lr3xF7zSujtFWsan9sYXiwGd/BmoKoMWuDpI/k4+oKsGGelT84ATB+0tvz8KPFUgOSwsAGl0\n"
-"lUq8ILKpeeUYiZGo3BxN77t+Nwtd/jmliFKMAGzsGHxBvfaLdXe6YJ2E5/4tAgMBAAGjQjBA\n"
-"MA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgEGMB0GA1UdDgQWBBQVOIMPPyw/cDMe\n"
-"zUb+B4wg4NfDtzANBgkqhkiG9w0BAQUFAAOCAQEAX/FBfXxcCLkr4NWSR/pnXKUTwwMhmytM\n"
-"iUbPWU3J/qVAtmPN3XEolWcRzCSs00Rsca4BIGsDoo8Ytyk6feUWYFN4PMCvFYP3j1IzJL1k\n"
-"k5fui/fbGKhtcbP3LBfQdCVp9/5rPJS+TUtBjE7ic9DjkCJzQ83z7+pzzkWKsKZJ/0x9nXGI\n"
-"xHYdkFsd7v3M9+79YKWxehZx0RbQfBI8bGmX265fOZpwLwU8GUYEmSA20GBuYQa7FkKMcPcw\n"
-"++DbZqMAAb3mLNqRX6BGi01qnD093QVG/na/oAo85ADmJ7f/hC3euiInlhBx6yLt398znM/j\n"
-"ra6O1I7mT1GvFpLgXPYHDw==\n"
-"-----END CERTIFICATE-----\n",
-
-/* Certum Root CA */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDDDCCAfSgAwIBAgIDAQAgMA0GCSqGSIb3DQEBBQUAMD4xCzAJBgNVBAYTAlBMMRswGQYD\n"
-"VQQKExJVbml6ZXRvIFNwLiB6IG8uby4xEjAQBgNVBAMTCUNlcnR1bSBDQTAeFw0wMjA2MTEx\n"
-"MDQ2MzlaFw0yNzA2MTExMDQ2MzlaMD4xCzAJBgNVBAYTAlBMMRswGQYDVQQKExJVbml6ZXRv\n"
-"IFNwLiB6IG8uby4xEjAQBgNVBAMTCUNlcnR1bSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\n"
-"ADCCAQoCggEBAM6xwS7TT3zNJc4YPk/EjG+AanPIW1H4m9LcuwBcsaD8dQPugfCI7iNS6eYV\n"
-"M42sLQnFdvkrOYCJ5JdLkKWoePhzQ3ukYbDYWMzhbGZ+nPMJXlVjhNWo7/OxLjBos8Q82Kxu\n"
-"jZlakE403Daaj4GIULdtlkIJ89eVgw1BS7Bqa/j8D35in2fE7SZfECYPCE/wpFcozo+47UX2\n"
-"bu4lXapuOb7kky/ZR6By6/qmW6/KUz/iDsaWVhFu9+lmqSbYf5VT7QqFiLpPKaVCjF62/IUg\n"
-"AKpoC6EahQGcxEZjgoi2IrHu/qpGWX7PNSzVttpd90gzFFS269lvzs2I1qsb2pY7HVkCAwEA\n"
-"AaMTMBEwDwYDVR0TAQH/BAUwAwEB/zANBgkqhkiG9w0BAQUFAAOCAQEAuI3O7+cUus/usESS\n"
-"bLQ5PqKEbq24IXfS1HeCh+YgQYHu4vgRt2PRFze+GXYkHAQaTOs9qmdvLdTN/mUxcMUbpgIK\n"
-"umB7bVjCmkn+YzILa+M6wKyrO7Do0wlRjBCDxjTgxSvgGrZgFCdsMneMvLJymM/NzD+5yCRC\n"
-"FNZX/OYmQ6kd5YCQzgNUKD73P9P4Te1qCjqTE5s7FCMTY5w/0YcneeVMUeMBrYVdGjux1XMQ\n"
-"pNPyvG5k9VpWkKjHDkx0Dy5xO/fIR/RpbxXyEV6DHpx8Uq79AtoSqFlnGNu8cN2bsWntgM6J\n"
-"QEhqDjXKKWYVIZQs6GAqm4VKQPNriiTsBhYscw==\n"
-"-----END CERTIFICATE-----\n",
-
-/* Comodo AAA Services root */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIEMjCCAxqgAwIBAgIBATANBgkqhkiG9w0BAQUFADB7MQswCQYDVQQGEwJHQjEbMBkGA1UE\n"
-"CAwSR3JlYXRlciBNYW5jaGVzdGVyMRAwDgYDVQQHDAdTYWxmb3JkMRowGAYDVQQKDBFDb21v\n"
-"ZG8gQ0EgTGltaXRlZDEhMB8GA1UEAwwYQUFBIENlcnRpZmljYXRlIFNlcnZpY2VzMB4XDTA0\n"
-"MDEwMTAwMDAwMFoXDTI4MTIzMTIzNTk1OVowezELMAkGA1UEBhMCR0IxGzAZBgNVBAgMEkdy\n"
-"ZWF0ZXIgTWFuY2hlc3RlcjEQMA4GA1UEBwwHU2FsZm9yZDEaMBgGA1UECgwRQ29tb2RvIENB\n"
-"IExpbWl0ZWQxITAfBgNVBAMMGEFBQSBDZXJ0aWZpY2F0ZSBTZXJ2aWNlczCCASIwDQYJKoZI\n"
-"hvcNAQEBBQADggEPADCCAQoCggEBAL5AnfRu4ep2hxxNRUSOvkbIgwadwSr+GB+O5AL686td\n"
-"UIoWMQuaBtDFcCLNSS1UY8y2bmhGC1Pqy0wkwLxyTurxFa70VJoSCsN6sjNg4tqJVfMiWPPe\n"
-"3M/vg4aijJRPn2jymJBGhCfHdr/jzDUsi14HZGWCwEiwqJH5YZ92IFCokcdmtet4YgNW8Ioa\n"
-"E+oxox6gmf049vYnMlhvB/VruPsUK6+3qszWY19zjNoFmag4qMsXeDZRrOme9Hg6jc8P2ULi\n"
-"mAyrL58OAd7vn5lJ8S3frHRNG5i1R8XlKdH5kBjHYpy+g8cmez6KJcfA3Z3mNWgQIJ2P2N7S\n"
-"w4ScDV7oL8kCAwEAAaOBwDCBvTAdBgNVHQ4EFgQUoBEKIz6W8Qfs4q8p74Klf9AwpLQwDgYD\n"
-"VR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wewYDVR0fBHQwcjA4oDagNIYyaHR0cDov\n"
-"L2NybC5jb21vZG9jYS5jb20vQUFBQ2VydGlmaWNhdGVTZXJ2aWNlcy5jcmwwNqA0oDKGMGh0\n"
-"dHA6Ly9jcmwuY29tb2RvLm5ldC9BQUFDZXJ0aWZpY2F0ZVNlcnZpY2VzLmNybDANBgkqhkiG\n"
-"9w0BAQUFAAOCAQEACFb8AvCb6P+k+tZ7xkSAzk/ExfYAWMymtrwUSWgEdujm7l3sAg9g1o1Q\n"
-"GE8mTgHj5rCl7r+8dFRBv/38ErjHT1r0iWAFf2C3BUrz9vHCv8S5dIa2LX1rzNLzRt0vxuBq\n"
-"w8M0Ayx9lt1awg6nCpnBBYurDC/zXDrPbDdVCYfeU0BsWO/8tqtlbgT2G9w84FoVxp7Z8VlI\n"
-"MCFlA2zs6SFz7JsDoeA3raAVGI/6ugLOpyypEBMs1OUIJqsil2D4kF501KKaU73yqWjgom7C\n"
-"12yxow+ev+to51byrvLjKzg6CYG1a4XXvi3tPxq3smPi9WIsgtRqAEFQ8TmDn5XpNpaYbg==\n"
-"-----END CERTIFICATE-----\n",
-
-/* Comodo Secure Services root */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIEPzCCAyegAwIBAgIBATANBgkqhkiG9w0BAQUFADB+MQswCQYDVQQGEwJHQjEbMBkGA1UE\n"
-"CAwSR3JlYXRlciBNYW5jaGVzdGVyMRAwDgYDVQQHDAdTYWxmb3JkMRowGAYDVQQKDBFDb21v\n"
-"ZG8gQ0EgTGltaXRlZDEkMCIGA1UEAwwbU2VjdXJlIENlcnRpZmljYXRlIFNlcnZpY2VzMB4X\n"
-"DTA0MDEwMTAwMDAwMFoXDTI4MTIzMTIzNTk1OVowfjELMAkGA1UEBhMCR0IxGzAZBgNVBAgM\n"
-"EkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4GA1UEBwwHU2FsZm9yZDEaMBgGA1UECgwRQ29tb2Rv\n"
-"IENBIExpbWl0ZWQxJDAiBgNVBAMMG1NlY3VyZSBDZXJ0aWZpY2F0ZSBTZXJ2aWNlczCCASIw\n"
-"DQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMBxM4KK0HDrc4eCQNUd5MvJDkKQ+d40uaG6\n"
-"EfQlhfPMcm3ye5drswfxdySRXyWP9nQ95IDC+DwN879A6vfIUtFyb+/Iq0G4bi4XKpVpDM3S\n"
-"HpR7LZQdqnXXs5jLrLxkU0C8j6ysNstcrbvd4JQX7NFc0L/vpZXJkMWwrPsbQ996CF23uPJA\n"
-"GysnnlDOXmWCiIxe004MeuoIkbY2qitC++rCoznl2yY4rYsK7hljxxwk3wN42ubqwUcaCwtG\n"
-"Cd0C/N7Lh1/XMGNooa7cMqG6vv5Eq2i2pRcV/b3Vp6ea5EQz6YiO/O1R65NxTq0B50SOqy3L\n"
-"qP4BSUjwwN3HaNiS/j0CAwEAAaOBxzCBxDAdBgNVHQ4EFgQUPNiTiMLAggnMAZkGkyDpnnAJ\n"
-"Y08wDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wgYEGA1UdHwR6MHgwO6A5oDeG\n"
-"NWh0dHA6Ly9jcmwuY29tb2RvY2EuY29tL1NlY3VyZUNlcnRpZmljYXRlU2VydmljZXMuY3Js\n"
-"MDmgN6A1hjNodHRwOi8vY3JsLmNvbW9kby5uZXQvU2VjdXJlQ2VydGlmaWNhdGVTZXJ2aWNl\n"
-"cy5jcmwwDQYJKoZIhvcNAQEFBQADggEBAIcBbSMdflsXfcFhMs+P5/OKlFlm4J4oqF7Tt/Q0\n"
-"5qo5spcWxYJvMqTpjOev/e/C6LlLqqP05tqNZSH7uoDrJiiFGv45jN5bBAS0VPmjZ55B+glS\n"
-"zAVIqMk/IQQezkhr/IXownuvf7fM+F86/TXGDe+X3EyrEeFryzHRbPtIgKvcnDe4IRRLDXE9\n"
-"7IMzbtFuMhbsmMcWi1mmNKsFVy2T96oTy9IT4rcuO81rUBcJaD61JlfutuC23bkpgHl9j6Pw\n"
-"pCikFcSF9CfUa7/lXORlAnZUtOM3ZiTTGWHIUhDlizeauan5Hb/qmZJhlv8BzaFfDbxxvA6s\n"
-"Cx1HRR3B7Hzs/Sk=\n"
-"-----END CERTIFICATE-----\n",
-
-/* Comodo Trusted Services root */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIEQzCCAyugAwIBAgIBATANBgkqhkiG9w0BAQUFADB/MQswCQYDVQQGEwJHQjEbMBkGA1UE\n"
-"CAwSR3JlYXRlciBNYW5jaGVzdGVyMRAwDgYDVQQHDAdTYWxmb3JkMRowGAYDVQQKDBFDb21v\n"
-"ZG8gQ0EgTGltaXRlZDElMCMGA1UEAwwcVHJ1c3RlZCBDZXJ0aWZpY2F0ZSBTZXJ2aWNlczAe\n"
-"Fw0wNDAxMDEwMDAwMDBaFw0yODEyMzEyMzU5NTlaMH8xCzAJBgNVBAYTAkdCMRswGQYDVQQI\n"
-"DBJHcmVhdGVyIE1hbmNoZXN0ZXIxEDAOBgNVBAcMB1NhbGZvcmQxGjAYBgNVBAoMEUNvbW9k\n"
-"byBDQSBMaW1pdGVkMSUwIwYDVQQDDBxUcnVzdGVkIENlcnRpZmljYXRlIFNlcnZpY2VzMIIB\n"
-"IjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA33FvNlhTWvI2VFeAxHQIIO0Yfyod5jWa\n"
-"HiWsnOWWfnJSoBVC21ndZHoa0Lh73TkVvFVIxO06AOoxEbrycXQaZ7jPM8yoMa+j49d/vzMt\n"
-"TGo87IvDktJTdyR0nAducPy9C1t2ul/y/9c3S0pgePfw+spwtOpZqqPOSC+pw7ILfhdyFgym\n"
-"BwwbOM/JYrc/oJOlh0Hyt3BAd9i+FHzjqMB6juljatEPmsbS9Is6FARW1O24zG71++IsWL1/\n"
-"T2sr92AkWCTOJu80kTrV44HQsvAEAtdbtz6SrGsSivnkBbA7kUlcsutT6vifR4buv5XAwAaf\n"
-"0lteERv0xwQ1KdJVXOTt6wIDAQABo4HJMIHGMB0GA1UdDgQWBBTFe1i97doladL3WRaoszLA\n"
-"eydb9DAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zCBgwYDVR0fBHwwejA8oDqg\n"
-"OIY2aHR0cDovL2NybC5jb21vZG9jYS5jb20vVHJ1c3RlZENlcnRpZmljYXRlU2VydmljZXMu\n"
-"Y3JsMDqgOKA2hjRodHRwOi8vY3JsLmNvbW9kby5uZXQvVHJ1c3RlZENlcnRpZmljYXRlU2Vy\n"
-"dmljZXMuY3JsMA0GCSqGSIb3DQEBBQUAA4IBAQDIk4E7ibSvuIQSTI3S8NtwuleGFTQQuS9/\n"
-"HrCoiWChisJ3DFBKmwCL2Iv0QeLQg4pKHBQGsKNoBXAxMKdTmw7pSqBYaWcOrp32pSxBvzwG\n"
-"a+RZzG0Q8ZZvH9/0BAKkn0U+yNj6NkZEUD+Cl5EfKNsYEYwq5GWDVxISjBc/lDb+XbDABHcT\n"
-"uPQV1T84zJQ6VdCsmPW6AF/ghhmBeC8owH7TzEIK9a5QoNE+xqFx7D+gIIxmOom0jtTYsU0l\n"
-"R+4viMi14QVFwL4Ucd56/Y57fU0IlqUSc/AtyjcndBInTMu2l+nZrghtWjlA3QVHdWpaIbOj\n"
-"GM9O9y5Xt5hwXsjEeLBi\n"
-"-----END CERTIFICATE-----\n",
-
-/* QuoVadis Root CA */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIF0DCCBLigAwIBAgIEOrZQizANBgkqhkiG9w0BAQUFADB/MQswCQYDVQQGEwJCTTEZMBcG\n"
-"A1UEChMQUXVvVmFkaXMgTGltaXRlZDElMCMGA1UECxMcUm9vdCBDZXJ0aWZpY2F0aW9uIEF1\n"
-"dGhvcml0eTEuMCwGA1UEAxMlUXVvVmFkaXMgUm9vdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0\n"
-"eTAeFw0wMTAzMTkxODMzMzNaFw0yMTAzMTcxODMzMzNaMH8xCzAJBgNVBAYTAkJNMRkwFwYD\n"
-"VQQKExBRdW9WYWRpcyBMaW1pdGVkMSUwIwYDVQQLExxSb290IENlcnRpZmljYXRpb24gQXV0\n"
-"aG9yaXR5MS4wLAYDVQQDEyVRdW9WYWRpcyBSb290IENlcnRpZmljYXRpb24gQXV0aG9yaXR5\n"
-"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAv2G1lVO6V/z68mcLOhrfEYBklbTR\n"
-"vM16z/Ypli4kVEAkOPcahdxYTMukJ0KX0J+DisPkBgNbAKVRHnAEdOLB1Dqr1607BxgFjv2D\n"
-"rOpm2RgbaIr1VxqYuvXtdj182d6UajtLF8HVj71lODqV0D1VNk7feVcxKh7YWWVJWCCYfqtf\n"
-"fp/p1k3sg3Spx2zY7ilKhSoGFPlU5tPaZQeLYzcS19Dsw3sgQUSj7cugF+FxZc4dZjH3dgEZ\n"
-"yH0DWLaVSR2mEiboxgx24ONmy+pdpibu5cxfvWenAScOospUxbF6lR1xHkopigPcakXBpBle\n"
-"bzbNw6Kwt/5cOOJSvPhEQ+aQuwIDAQABo4ICUjCCAk4wPQYIKwYBBQUHAQEEMTAvMC0GCCsG\n"
-"AQUFBzABhiFodHRwczovL29jc3AucXVvdmFkaXNvZmZzaG9yZS5jb20wDwYDVR0TAQH/BAUw\n"
-"AwEB/zCCARoGA1UdIASCAREwggENMIIBCQYJKwYBBAG+WAABMIH7MIHUBggrBgEFBQcCAjCB\n"
-"xxqBxFJlbGlhbmNlIG9uIHRoZSBRdW9WYWRpcyBSb290IENlcnRpZmljYXRlIGJ5IGFueSBw\n"
-"YXJ0eSBhc3N1bWVzIGFjY2VwdGFuY2Ugb2YgdGhlIHRoZW4gYXBwbGljYWJsZSBzdGFuZGFy\n"
-"ZCB0ZXJtcyBhbmQgY29uZGl0aW9ucyBvZiB1c2UsIGNlcnRpZmljYXRpb24gcHJhY3RpY2Vz\n"
-"LCBhbmQgdGhlIFF1b1ZhZGlzIENlcnRpZmljYXRlIFBvbGljeS4wIgYIKwYBBQUHAgEWFmh0\n"
-"dHA6Ly93d3cucXVvdmFkaXMuYm0wHQYDVR0OBBYEFItLbe3TKbkGGew5Oanwl4Rqy+/fMIGu\n"
-"BgNVHSMEgaYwgaOAFItLbe3TKbkGGew5Oanwl4Rqy+/foYGEpIGBMH8xCzAJBgNVBAYTAkJN\n"
-"MRkwFwYDVQQKExBRdW9WYWRpcyBMaW1pdGVkMSUwIwYDVQQLExxSb290IENlcnRpZmljYXRp\n"
-"b24gQXV0aG9yaXR5MS4wLAYDVQQDEyVRdW9WYWRpcyBSb290IENlcnRpZmljYXRpb24gQXV0\n"
-"aG9yaXR5ggQ6tlCLMA4GA1UdDwEB/wQEAwIBBjANBgkqhkiG9w0BAQUFAAOCAQEAitQUtf70\n"
-"mpKnGdSkfnIYj9lofFIk3WdvOXrEql494liwTXCYhGHoG+NpGA7O+0dQoE7/8CQfvbLO9Sf8\n"
-"7C9TqnN7Az10buYWnuulLsS/VidQK2K6vkscPFVcQR0kvoIgR13VRH56FmjffU1RcHhXHTMe\n"
-"/QKZnAzNCgVPx7uOpHX6Sm2xgI4JVrmcGmD+XcHXetwReNDWXcG31a0ymQM6isxUJTkxgXsT\n"
-"IlG6Rmyhu576BGxJJnSP0nPrzDCi5upZIof4l/UO/erMkqQWxFIY6iHOsfHmhIHluqmGKPJD\n"
-"Wl0Snawe2ajlCmqnf6CHKc/yiU3U7MXi5nrQNiOKSnQ2+Q==\n"
-"-----END CERTIFICATE-----\n",
-
-/* QuoVadis Root CA 2 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIFtzCCA5+gAwIBAgICBQkwDQYJKoZIhvcNAQEFBQAwRTELMAkGA1UEBhMCQk0xGTAXBgNV\n"
-"BAoTEFF1b1ZhZGlzIExpbWl0ZWQxGzAZBgNVBAMTElF1b1ZhZGlzIFJvb3QgQ0EgMjAeFw0w\n"
-"NjExMjQxODI3MDBaFw0zMTExMjQxODIzMzNaMEUxCzAJBgNVBAYTAkJNMRkwFwYDVQQKExBR\n"
-"dW9WYWRpcyBMaW1pdGVkMRswGQYDVQQDExJRdW9WYWRpcyBSb290IENBIDIwggIiMA0GCSqG\n"
-"SIb3DQEBAQUAA4ICDwAwggIKAoICAQCaGMpLlA0ALa8DKYrwD4HIrkwZhR0In6spRIXzL4Gt\n"
-"Mh6QRr+jhiYaHv5+HBg6XJxgFyo6dIMzMH1hVBHL7avg5tKifvVrbxi3Cgst/ek+7wrGsxDp\n"
-"3MJGF/hd/aTa/55JWpzmM+Yklvc/ulsrHHo1wtZn/qtmUIttKGAr79dgw8eTvI02kfN/+NsR\n"
-"E8Scd3bBrrcCaoF6qUWD4gXmuVbBlDePSHFjIuwXZQeVikvfj8ZaCuWw419eaxGrDPmF60Tp\n"
-"+ARz8un+XJiM9XOva7R+zdRcAitMOeGylZUtQofX1bOQQ7dsE/He3fbE+Ik/0XX1ksOR1YqI\n"
-"0JDs3G3eicJlcZaLDQP9nL9bFqyS2+r+eXyt66/3FsvbzSUr5R/7mp/iUcw6UwxI5g69ybR2\n"
-"BlLmEROFcmMDBOAENisgGQLodKcftslWZvB1JdxnwQ5hYIizPtGo/KPaHbDRsSNU30R2be1B\n"
-"2MGyIrZTHN81Hdyhdyox5C315eXbyOD/5YDXC2Og/zOhD7osFRXql7PSorW+8oyWHhqPHWyk\n"
-"YTe5hnMz15eWniN9gqRMgeKh0bpnX5UHoycR7hYQe7xFSkyyBNKr79X9DFHOUGoIMfmR2gyP\n"
-"ZFwDwzqLID9ujWc9Otb+fVuIyV77zGHcizN300QyNQliBJIWENieJ0f7OyHj+OsdWwIDAQAB\n"
-"o4GwMIGtMA8GA1UdEwEB/wQFMAMBAf8wCwYDVR0PBAQDAgEGMB0GA1UdDgQWBBQahGK8SEwz\n"
-"JQTU7tD2A8QZRtGUazBuBgNVHSMEZzBlgBQahGK8SEwzJQTU7tD2A8QZRtGUa6FJpEcwRTEL\n"
-"MAkGA1UEBhMCQk0xGTAXBgNVBAoTEFF1b1ZhZGlzIExpbWl0ZWQxGzAZBgNVBAMTElF1b1Zh\n"
-"ZGlzIFJvb3QgQ0EgMoICBQkwDQYJKoZIhvcNAQEFBQADggIBAD4KFk2fBluornFdLwUvZ+YT\n"
-"RYPENvbzwCYMDbVHZF34tHLJRqUDGCdViXh9duqWNIAXINzng/iN/Ae42l9NLmeyhP3ZRPx3\n"
-"UIHmfLTJDQtyU/h2BwdBR5YM++CCJpNVjP4iH2BlfF/nJrP3MpCYUNQ3cVX2kiF495V5+vgt\n"
-"JodmVjB3pjd4M1IQWK4/YY7yarHvGH5KWWPKjaJW1acvvFYfzznB4vsKqBUsfU16Y8Zsl0Q8\n"
-"0m/DShcK+JDSV6IZUaUtl0HaB0+pUNqQjZRG4T7wlP0QADj1O+hA4bRuVhogzG9Yje0uRY/W\n"
-"6ZM/57Es3zrWIozchLsib9D45MY56QSIPMO661V6bYCZJPVsAfv4l7CUW+v90m/xd2gNNWQj\n"
-"rLhVoQPRTUIZ3Ph1WVaj+ahJefivDrkRoHy3au000LYmYjgahwz46P0u05B/B5EqHdZ+XIWD\n"
-"mbA4CD/pXvk1B+TJYm5Xf6dQlfe6yJvmjqIBxdZmv3lh8zwc4bmCXF2gw+nYSL0ZohEUGW6y\n"
-"hhtoPkg3Goi3XZZenMfvJ2II4pEZXNLxId26F0KCl3GBUzGpn/Z9Yr9y4aOTHcyKJloJONDO\n"
-"1w2AFrR4pTqHTI2KpdVGl/IsELm8VCLAAVBpQ570su9t+Oza8eOx79+Rj1QqCyXBJhnEUhAF\n"
-"ZdWCEOrCMc0u\n"
-"-----END CERTIFICATE-----\n",
-
-/* QuoVadis Root CA 3 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIGnTCCBIWgAwIBAgICBcYwDQYJKoZIhvcNAQEFBQAwRTELMAkGA1UEBhMCQk0xGTAXBgNV\n"
-"BAoTEFF1b1ZhZGlzIExpbWl0ZWQxGzAZBgNVBAMTElF1b1ZhZGlzIFJvb3QgQ0EgMzAeFw0w\n"
-"NjExMjQxOTExMjNaFw0zMTExMjQxOTA2NDRaMEUxCzAJBgNVBAYTAkJNMRkwFwYDVQQKExBR\n"
-"dW9WYWRpcyBMaW1pdGVkMRswGQYDVQQDExJRdW9WYWRpcyBSb290IENBIDMwggIiMA0GCSqG\n"
-"SIb3DQEBAQUAA4ICDwAwggIKAoICAQDMV0IWVJzmmNPTTe7+7cefQzlKZbPoFog02w1ZkXTP\n"
-"krgEQK0CSzGrvI2RaNggDhoB4hp7Thdd4oq3P5kazethq8Jlph+3t723j/z9cI8LoGe+AaJZ\n"
-"z3HmDyl2/7FWeUUrH556VOijKTVopAFPD6QuN+8bv+OPEKhyq1hX51SGyMnzW9os2l2Objyj\n"
-"Ptr7guXd8lyyBTNvijbO0BNO/79KDDRMpsMhvVAEVeuxu537RR5kFd5VAYwCdrXLoT9Cabwv\n"
-"vWhDFlaJKjdhkf2mrk7AyxRllDdLkgbvBNDInIjbC3uBr7E9KsRlOni27tyAsdLTmZw67mta\n"
-"a7ONt9XOnMK+pUsvFrGeaDsGb659n/je7Mwpp5ijJUMv7/FfJuGITfhebtfZFG4ZM2mnO4SJ\n"
-"k8RTVROhUXhA+LjJou57ulJCg54U7QVSWllWp5f8nT8KKdjcT5EOE7zelaTfi5m+rJsziO+1\n"
-"ga8bxiJTyPbH7pcUsMV8eFLI8M5ud2CEpukqdiDtWAEXMJPpGovgc2PZapKUSU60rUqFxKMi\n"
-"MPwJ7Wgic6aIDFUhWMXhOp8q3crhkODZc6tsgLjoC2SToJyMGf+z0gzskSaHirOi4XCPLArl\n"
-"zW1oUevaPwV/izLmE1xr/l9A4iLItLRkT9a6fUg+qGkM17uGcclzuD87nSVL2v9A6wIDAQAB\n"
-"o4IBlTCCAZEwDwYDVR0TAQH/BAUwAwEB/zCB4QYDVR0gBIHZMIHWMIHTBgkrBgEEAb5YAAMw\n"
-"gcUwgZMGCCsGAQUFBwICMIGGGoGDQW55IHVzZSBvZiB0aGlzIENlcnRpZmljYXRlIGNvbnN0\n"
-"aXR1dGVzIGFjY2VwdGFuY2Ugb2YgdGhlIFF1b1ZhZGlzIFJvb3QgQ0EgMyBDZXJ0aWZpY2F0\n"
-"ZSBQb2xpY3kgLyBDZXJ0aWZpY2F0aW9uIFByYWN0aWNlIFN0YXRlbWVudC4wLQYIKwYBBQUH\n"
-"AgEWIWh0dHA6Ly93d3cucXVvdmFkaXNnbG9iYWwuY29tL2NwczALBgNVHQ8EBAMCAQYwHQYD\n"
-"VR0OBBYEFPLAE+CCQz777i9nMpY1XNu4ywLQMG4GA1UdIwRnMGWAFPLAE+CCQz777i9nMpY1\n"
-"XNu4ywLQoUmkRzBFMQswCQYDVQQGEwJCTTEZMBcGA1UEChMQUXVvVmFkaXMgTGltaXRlZDEb\n"
-"MBkGA1UEAxMSUXVvVmFkaXMgUm9vdCBDQSAzggIFxjANBgkqhkiG9w0BAQUFAAOCAgEAT62g\n"
-"LEz6wPJv92ZVqyM07ucp2sNbtrCD2dDQ4iH782CnO11gUyeim/YIIirnv6By5ZwkajGxkHon\n"
-"24QRiSemd1o417+shvzuXYO8BsbRd2sPbSQvS3pspweWyuOEn62Iix2rFo1bZhfZFvSLgNLd\n"
-"+LJ2w/w4E6oM3kJpK27zPOuAJ9v1pkQNn1pVWQvVDVJIxa6f8i+AxeoyUDUSly7B4f/xI4hR\n"
-"OJ/yZlZ25w9Rl6VSDE1JUZU2Pb+iSwwQHYaZTKrzchGT5Or2m9qoXadNt54CrnMAyNojA+j5\n"
-"6hl0YgCUyyIgvpSnWbWCar6ZeXqp8kokUvd0/bpO5qgdAm6xDYBEwa7TIzdfu4V8K5Iu6H6l\n"
-"i92Z4b8nby1dqnuH/grdS/yO9SbkbnBCbjPsMZ57k8HkyWkaPcBrTiJt7qtYTcbQQcEr6k8S\n"
-"h17rRdhs9ZgC06DYVYoGmRmioHfRMJ6szHXug/WwYjnPbFfiTNKRCw51KBuav/0aQ/HKd/s7\n"
-"j2G4aSgWQgRecCocIdiP4b0jWy10QJLZYxkNc91pvGJHvOB0K7Lrfb5BG7XARsWhIstfTsEo\n"
-"kt4YutUqKLsRixeTmJlglFwjz1onl14LBQaTNx47aTbrqZ5hHY8y2o4M1nQ+ewkk2gF3R8Q7\n"
-"zTSMmfXK4SVhM7JZG+Ju1zdXtg2pEto=\n"
-"-----END CERTIFICATE-----\n",
-
-/* Security Communication Root CA */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDWjCCAkKgAwIBAgIBADANBgkqhkiG9w0BAQUFADBQMQswCQYDVQQGEwJKUDEYMBYGA1UE\n"
-"ChMPU0VDT00gVHJ1c3QubmV0MScwJQYDVQQLEx5TZWN1cml0eSBDb21tdW5pY2F0aW9uIFJv\n"
-"b3RDQTEwHhcNMDMwOTMwMDQyMDQ5WhcNMjMwOTMwMDQyMDQ5WjBQMQswCQYDVQQGEwJKUDEY\n"
-"MBYGA1UEChMPU0VDT00gVHJ1c3QubmV0MScwJQYDVQQLEx5TZWN1cml0eSBDb21tdW5pY2F0\n"
-"aW9uIFJvb3RDQTEwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCzs/5/022x7xZ8\n"
-"V6UMbXaKL0u/ZPtM7orw8yl89f/uKuDp6bpbZCKamm8sOiZpUQWZJtzVHGpxxpp9Hp3dfGzG\n"
-"jGdnSj74cbAZJ6kJDKaVv0uMDPpVmDvY6CKhS3E4eayXkmmziX7qIWgGmBSWh9JhNrxtJ1ae\n"
-"V+7AwFb9Ms+k2Y7CI9eNqPPYJayX5HA49LY6tJ07lyZDo6G8SVlyTCMwhwFY9k6+HGhWZq/N\n"
-"QV3Is00qVUarH9oe4kA92819uZKAnDfdDJZkndwi92SL32HeFZRSFaB9UslLqCHJxrHty8OV\n"
-"YNEP8Ktw+N/LTX7s1vqr2b1/VPKl6Xn62dZ2JChzAgMBAAGjPzA9MB0GA1UdDgQWBBSgc0mZ\n"
-"aNyFW2XjmygvV5+9M7wHSDALBgNVHQ8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zANBgkqhkiG\n"
-"9w0BAQUFAAOCAQEAaECpqLvkT115swW1F7NgE+vGkl3g0dNq/vu+m22/xwVtWSDEHPC32oRY\n"
-"AmP6SBbvT6UL90qY8j+eG61Ha2POCEfrUj94nK9NrvjVT8+amCoQQTlSxN3Zmw7vkwGusi7K\n"
-"aEIkQmywszo+zenaSMQVy+n5Bw+SUEmK3TGXX8npN6o7WWWXlDLJs58+OmJYxUmtYg5xpTKq\n"
-"L8aJdkNAExNnPaJUJRDL8Try2frbSVa7pv6nQTXD4IhhyYjH3zYQIphZ6rBK+1YWc26sTfci\n"
-"oU+tHXotRSflMMFe8toTyyVCUZVHA4xsIcx0Qu1T/zOLjw9XARYvz6buyXAiFL39vmwLAw==\n"
-"-----END CERTIFICATE-----\n",
-
-/* Sonera Class 2 Root CA */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDIDCCAgigAwIBAgIBHTANBgkqhkiG9w0BAQUFADA5MQswCQYDVQQGEwJGSTEPMA0GA1UE\n"
-"ChMGU29uZXJhMRkwFwYDVQQDExBTb25lcmEgQ2xhc3MyIENBMB4XDTAxMDQwNjA3Mjk0MFoX\n"
-"DTIxMDQwNjA3Mjk0MFowOTELMAkGA1UEBhMCRkkxDzANBgNVBAoTBlNvbmVyYTEZMBcGA1UE\n"
-"AxMQU29uZXJhIENsYXNzMiBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAJAX\n"
-"SjWdyvANlsdE+hY3/Ei9vX+ALTU74W+oZ6m/AxxNjG8yR9VBaKQTBME1DJqEQ/xcHf+Js+gX\n"
-"GM2RX/uJ4+q/Tl18GybTdXnt5oTjV+WtKcT0OijnpXuENmmz/V52vaMtmdOQTiMofRhj8VQ7\n"
-"Jp12W5dCsv+u8E7s3TmVToMGf+dJQMjFAbJUWmYdPfz56TwKnoG4cPABi+QjVHzIrviQHgCW\n"
-"ctRUz2EjvOr7nQKV0ba5cTppCD8PtOFCx4j1P5iop7oc4HFx71hXgVB6XGt0Rg6DA5jDjqhu\n"
-"8nYybieDwnPz3BjotJPqdURrBGAgcVeHnfO+oJAjPYok4doh28MCAwEAAaMzMDEwDwYDVR0T\n"
-"AQH/BAUwAwEB/zARBgNVHQ4ECgQISqCqWITTXjwwCwYDVR0PBAQDAgEGMA0GCSqGSIb3DQEB\n"
-"BQUAA4IBAQBazof5FnIVV0sd2ZvnoiYw7JNn39Yt0jSv9zilzqsWuasvfDXLrNAPtEwr/IDv\n"
-"a4yRXzZ299uzGxnq9LIR/WFxRL8oszodv7ND6J+/3DEIcbCdjdY0RzKQxmUk96BKfARzjzlv\n"
-"F4xytb1LyHr4e4PDKE6cCepnP7JnBBvDFNr450kkkdAdavphOe9r5yF1BgfYErQhIHBCcYHa\n"
-"PJo2vqZbDWpsmh+Re/n570K6Tk6ezAyNlNzZRZxe7EJQY670XcSxEtzKO6gunRRaBXW37Ndj\n"
-"4ro1tgQIkejanZz2ZrUYrAqmVCY0M9IbwdR/GjqOC6oybtv8TyWf2TLHllpwrN9M\n"
-"-----END CERTIFICATE-----\n",
-
-/* UTN USERFirst Hardware Root CA */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIEdDCCA1ygAwIBAgIQRL4Mi1AAJLQR0zYq/mUK/TANBgkqhkiG9w0BAQUFADCBlzELMAkG\n"
-"A1UEBhMCVVMxCzAJBgNVBAgTAlVUMRcwFQYDVQQHEw5TYWx0IExha2UgQ2l0eTEeMBwGA1UE\n"
-"ChMVVGhlIFVTRVJUUlVTVCBOZXR3b3JrMSEwHwYDVQQLExhodHRwOi8vd3d3LnVzZXJ0cnVz\n"
-"dC5jb20xHzAdBgNVBAMTFlVUTi1VU0VSRmlyc3QtSGFyZHdhcmUwHhcNOTkwNzA5MTgxMDQy\n"
-"WhcNMTkwNzA5MTgxOTIyWjCBlzELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAlVUMRcwFQYDVQQH\n"
-"Ew5TYWx0IExha2UgQ2l0eTEeMBwGA1UEChMVVGhlIFVTRVJUUlVTVCBOZXR3b3JrMSEwHwYD\n"
-"VQQLExhodHRwOi8vd3d3LnVzZXJ0cnVzdC5jb20xHzAdBgNVBAMTFlVUTi1VU0VSRmlyc3Qt\n"
-"SGFyZHdhcmUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCx98M4P7Sof885glFn\n"
-"0G2f0v9Y8+efK+wNiVSZuTiZFvfgIXlIwrthdBKWHTxqctU8EGc6Oe0rE81m65UJM6Rsl7Ho\n"
-"xuzBdXmcRl6Nq9Bq/bkqVRcQVLMZ8Jr28bFdtqdt++BxF2uiiPsA3/4aMXcMmgF6sTLjKwEH\n"
-"OG7DpV4jvEWbe1DByTCP2+UretNb+zNAHqDVmBe8i4fDidNdoI6yqqr2jmmIBsX6iSHzCJ1p\n"
-"LgkzmykNRg+MzEk0sGlRvfkGzWitZky8PqxhvQqIDsjfPe58BEydCl5rkdbux+0ojatNh4lz\n"
-"0G6k0B4WixThdkQDf2Os5M1JnMWS9KsyoUhbAgMBAAGjgbkwgbYwCwYDVR0PBAQDAgHGMA8G\n"
-"A1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFKFyXyYbKJhDlV0HN9WFlp1L0sNFMEQGA1UdHwQ9\n"
-"MDswOaA3oDWGM2h0dHA6Ly9jcmwudXNlcnRydXN0LmNvbS9VVE4tVVNFUkZpcnN0LUhhcmR3\n"
-"YXJlLmNybDAxBgNVHSUEKjAoBggrBgEFBQcDAQYIKwYBBQUHAwUGCCsGAQUFBwMGBggrBgEF\n"
-"BQcDBzANBgkqhkiG9w0BAQUFAAOCAQEARxkP3nTGmZev/K0oXnWO6y1n7k57K9cM//bey1Wi\n"
-"CuFMVGWTYGufEpytXoMs61quwOQt9ABjHbjAbPLPSbtNk28GpgoiskliCE7/yMgUsogWXecB\n"
-"5BKV5UU0s4tpvc+0hY91UZ59Ojg6FEgSxvunOxqNDYJAB+gECJChicsZUN/KHAG8HQQZexB2\n"
-"lzvukJDKxA4fFm517zP4029bHpbj4HR3dHuKom4t3XbWOTCC8KucUvIqx69JXn7HaOWCgchq\n"
-"J/kniCrVWFCVH/A7HFe7fRQ5YiuayZSSKqMiDP+JJn1fIytH1xUdqWqeUQ0qUZ6B+dQ7XnAS\n"
-"fxAynB67nfhmqA==\n"
-"-----END CERTIFICATE-----\n",
-
-/* Camerfirma Chambers of Commerce Root */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIEvTCCA6WgAwIBAgIBADANBgkqhkiG9w0BAQUFADB/MQswCQYDVQQGEwJFVTEnMCUGA1UE\n"
-"ChMeQUMgQ2FtZXJmaXJtYSBTQSBDSUYgQTgyNzQzMjg3MSMwIQYDVQQLExpodHRwOi8vd3d3\n"
-"LmNoYW1iZXJzaWduLm9yZzEiMCAGA1UEAxMZQ2hhbWJlcnMgb2YgQ29tbWVyY2UgUm9vdDAe\n"
-"Fw0wMzA5MzAxNjEzNDNaFw0zNzA5MzAxNjEzNDRaMH8xCzAJBgNVBAYTAkVVMScwJQYDVQQK\n"
-"Ex5BQyBDYW1lcmZpcm1hIFNBIENJRiBBODI3NDMyODcxIzAhBgNVBAsTGmh0dHA6Ly93d3cu\n"
-"Y2hhbWJlcnNpZ24ub3JnMSIwIAYDVQQDExlDaGFtYmVycyBvZiBDb21tZXJjZSBSb290MIIB\n"
-"IDANBgkqhkiG9w0BAQEFAAOCAQ0AMIIBCAKCAQEAtzZV5aVdGDDg2olUkfzIx1L4L1DZ77F1\n"
-"c2VHfRtbunXF/KGIJPov7coISjlUxFF6tdpg6jg8gbLL8bvZkSM/SAFwdakFKq0fcfPJVD0d\n"
-"BmpAPrMMhe5cG3nCYsS4No41XQEMIwRHNaqbYE6gZj3LJgqcQKH0XZi/caulAGgq7YN6D6IU\n"
-"tdQis4CwPAxaUWktWBiP7Zme8a7ileb2R6jWDA+wWFjbw2Y3npuRVDM30pQcakjJyfKl2qUM\n"
-"I/cjDpwyVV5xnIQFUZot/eZOKjRa3spAN2cMVCFVd9oKDMyXroDclDZK9D7ONhMeU+SsTjoF\n"
-"7Nuucpw4i9A5O4kKPnf+dQIBA6OCAUQwggFAMBIGA1UdEwEB/wQIMAYBAf8CAQwwPAYDVR0f\n"
-"BDUwMzAxoC+gLYYraHR0cDovL2NybC5jaGFtYmVyc2lnbi5vcmcvY2hhbWJlcnNyb290LmNy\n"
-"bDAdBgNVHQ4EFgQU45T1sU3p26EpW1eLTXYGduHRooowDgYDVR0PAQH/BAQDAgEGMBEGCWCG\n"
-"SAGG+EIBAQQEAwIABzAnBgNVHREEIDAegRxjaGFtYmVyc3Jvb3RAY2hhbWJlcnNpZ24ub3Jn\n"
-"MCcGA1UdEgQgMB6BHGNoYW1iZXJzcm9vdEBjaGFtYmVyc2lnbi5vcmcwWAYDVR0gBFEwTzBN\n"
-"BgsrBgEEAYGHLgoDATA+MDwGCCsGAQUFBwIBFjBodHRwOi8vY3BzLmNoYW1iZXJzaWduLm9y\n"
-"Zy9jcHMvY2hhbWJlcnNyb290Lmh0bWwwDQYJKoZIhvcNAQEFBQADggEBAAxBl8IahsAifJ/7\n"
-"kPMa0QOx7xP5IV8EnNrJpY0nbJaHkb5BkAFyk+cefV/2icZdp0AJPaxJRUXcLo0waLIJuvvD\n"
-"L8y6C98/d3tGfToSJI6WjzwFCm/SlCgdbQzALogi1djPHRPH8EjX1wWnz8dHnjs8NMiAT9QU\n"
-"u/wNUPf6s+xCX6ndbcj0dc97wXImsQEcXCz9ek60AcUFV7nnPKoF2YjpB0ZBzu9Bga5Y34Oi\n"
-"rsrXdx/nADydb47kMgkdTXg0eDQ8lJsm7U9xxhl6vSAiSFr+S30Dt+dYvsYyTnQeaN2oaFuz\n"
-"Pu5ifdmA6Ap1erfutGWaIZDgqtCYvDi1czyL+Nw=\n"
-"-----END CERTIFICATE-----\n",
-
-/* Camerfirma Global Chambersign Root */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIExTCCA62gAwIBAgIBADANBgkqhkiG9w0BAQUFADB9MQswCQYDVQQGEwJFVTEnMCUGA1UE\n"
-"ChMeQUMgQ2FtZXJmaXJtYSBTQSBDSUYgQTgyNzQzMjg3MSMwIQYDVQQLExpodHRwOi8vd3d3\n"
-"LmNoYW1iZXJzaWduLm9yZzEgMB4GA1UEAxMXR2xvYmFsIENoYW1iZXJzaWduIFJvb3QwHhcN\n"
-"MDMwOTMwMTYxNDE4WhcNMzcwOTMwMTYxNDE4WjB9MQswCQYDVQQGEwJFVTEnMCUGA1UEChMe\n"
-"QUMgQ2FtZXJmaXJtYSBTQSBDSUYgQTgyNzQzMjg3MSMwIQYDVQQLExpodHRwOi8vd3d3LmNo\n"
-"YW1iZXJzaWduLm9yZzEgMB4GA1UEAxMXR2xvYmFsIENoYW1iZXJzaWduIFJvb3QwggEgMA0G\n"
-"CSqGSIb3DQEBAQUAA4IBDQAwggEIAoIBAQCicKLQn0KuWxfH2H3PFIP8T8mhtxOviteePgQK\n"
-"kotgVvq0Mi+ITaFgCPS3CU6gSS9J1tPfnZdan5QEcOw/Wdm3zGaLmFIoCQLfxS+EjXqXd7/s\n"
-"QJ0lcqu1PzKY+7e3/HKE5TWH+VX6ox8Oby4o3Wmg2UIQxvi1RMLQQ3/bvOSiPGpVeAp3qdjq\n"
-"GTK3L/5cPxvusZjsyq16aUXjlg9V9ubtdepl6DJWk0aJqCWKZQbua795B9Dxt6/tLE2Su8Co\n"
-"X6dnfQTyFQhwrJLWfQTSM/tMtgsL+xrJxI0DqX5c8lCrEqWhz0hQpe/SyBoT+rB/sYIcd2oP\n"
-"X9wLlY/vQ37mRQklAgEDo4IBUDCCAUwwEgYDVR0TAQH/BAgwBgEB/wIBDDA/BgNVHR8EODA2\n"
-"MDSgMqAwhi5odHRwOi8vY3JsLmNoYW1iZXJzaWduLm9yZy9jaGFtYmVyc2lnbnJvb3QuY3Js\n"
-"MB0GA1UdDgQWBBRDnDafsJ4wTcbOX60Qq+UDpfqpFDAOBgNVHQ8BAf8EBAMCAQYwEQYJYIZI\n"
-"AYb4QgEBBAQDAgAHMCoGA1UdEQQjMCGBH2NoYW1iZXJzaWducm9vdEBjaGFtYmVyc2lnbi5v\n"
-"cmcwKgYDVR0SBCMwIYEfY2hhbWJlcnNpZ25yb290QGNoYW1iZXJzaWduLm9yZzBbBgNVHSAE\n"
-"VDBSMFAGCysGAQQBgYcuCgEBMEEwPwYIKwYBBQUHAgEWM2h0dHA6Ly9jcHMuY2hhbWJlcnNp\n"
-"Z24ub3JnL2Nwcy9jaGFtYmVyc2lnbnJvb3QuaHRtbDANBgkqhkiG9w0BAQUFAAOCAQEAPDtw\n"
-"kfkEVCeR4e3t/mh/YV3lQWVPMvEYBZRqHN4fcNs+ezICNLUMbKGKfKX0j//U2K0X1S0E0T9Y\n"
-"gOKBWYi+wONGkyT+kL0mojAt6JcmVzWJdJYY9hXiryQZVgICsroPFOrGimbBhkVVi76Svpyk\n"
-"BMdJPJ7oKXqJ1/6v/2j1pReQvayZzKWGVwlnRtvWFsJG8eSpUPWP0ZIV018+xgBJOm5YstHR\n"
-"Jw0lyDL4IBHNfTIzSJRUTN3cecQwn+uOuFW114hcxWokPbLTBQNRxgfvzBRydD1ucs4YKIxK\n"
-"oHflCStFREest2d/AYoFWpO+ocH/+OcOZ6RHSXZddZAa9SaP8A==\n"
-"-----END CERTIFICATE-----\n",
-
-/* XRamp Global CA Root */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIEMDCCAxigAwIBAgIQUJRs7Bjq1ZxN1ZfvdY+grTANBgkqhkiG9w0BAQUFADCBgjELMAkG\n"
-"A1UEBhMCVVMxHjAcBgNVBAsTFXd3dy54cmFtcHNlY3VyaXR5LmNvbTEkMCIGA1UEChMbWFJh\n"
-"bXAgU2VjdXJpdHkgU2VydmljZXMgSW5jMS0wKwYDVQQDEyRYUmFtcCBHbG9iYWwgQ2VydGlm\n"
-"aWNhdGlvbiBBdXRob3JpdHkwHhcNMDQxMTAxMTcxNDA0WhcNMzUwMTAxMDUzNzE5WjCBgjEL\n"
-"MAkGA1UEBhMCVVMxHjAcBgNVBAsTFXd3dy54cmFtcHNlY3VyaXR5LmNvbTEkMCIGA1UEChMb\n"
-"WFJhbXAgU2VjdXJpdHkgU2VydmljZXMgSW5jMS0wKwYDVQQDEyRYUmFtcCBHbG9iYWwgQ2Vy\n"
-"dGlmaWNhdGlvbiBBdXRob3JpdHkwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCY\n"
-"JB69FbS638eMpSe2OAtp87ZOqCwuIR1cRN8hXX4jdP5efrRKt6atH67gBhbim1vZZ3RrXYCP\n"
-"KZ2GG9mcDZhtdhAoWORlsH9KmHmf4MMxfoArtYzAQDsRhtDLooY2YKTVMIJt2W7QDxIEM5df\n"
-"T2Fa8OT5kavnHTu86M/0ay00fOJIYRyO82FEzG+gSqmUsE3a56k0enI4qEHMPJQRfevIpoy3\n"
-"hsvKMzvZPTeL+3o+hiznc9cKV6xkmxnr9A8ECIqsAxcZZPRaJSKNNCyy9mgdEm3Tih4U2sSP\n"
-"puIjhdV6Db1q4Ons7Be7QhtnqiXtRYMh/MHJfNViPvryxS3T/dRlAgMBAAGjgZ8wgZwwEwYJ\n"
-"KwYBBAGCNxQCBAYeBABDAEEwCwYDVR0PBAQDAgGGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0O\n"
-"BBYEFMZPoj0GY4QJnM5i5ASsjVy16bYbMDYGA1UdHwQvMC0wK6ApoCeGJWh0dHA6Ly9jcmwu\n"
-"eHJhbXBzZWN1cml0eS5jb20vWEdDQS5jcmwwEAYJKwYBBAGCNxUBBAMCAQEwDQYJKoZIhvcN\n"
-"AQEFBQADggEBAJEVOQMBG2f7Shz5CmBbodpNl2L5JFMn14JkTpAuw0kbK5rc/Kh4ZzXxHfAR\n"
-"vbdI4xD2Dd8/0sm2qlWkSLoC295ZLhVbO50WfUfXN+pfTXYSNrsf16GBBEYgoyxtqZ4Bfj8p\n"
-"zgCT3/3JknOJiWSe5yvkHJEs0rnOfc5vMZnT5r7SHpDwCRR5XCOrTdLaIR9NmXmd4c8nnxCb\n"
-"HIgNsIpkQTG4DmyQJKSbXHGPurt+HBvbaoAPIbzp26a3QPSyi6mx5O+aGtA9aZnuqCij4Tyz\n"
-"8LIRnM98QObd50N9otg6tamN8jSZxNQQ4Qb9CYQQO+7ETPTsJ3xCwnR8gooJybQDJbw=\n"
-"-----END CERTIFICATE-----\n",
-
-/* Go Daddy Class 2 CA */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIEADCCAuigAwIBAgIBADANBgkqhkiG9w0BAQUFADBjMQswCQYDVQQGEwJVUzEhMB8GA1UE\n"
-"ChMYVGhlIEdvIERhZGR5IEdyb3VwLCBJbmMuMTEwLwYDVQQLEyhHbyBEYWRkeSBDbGFzcyAy\n"
-"IENlcnRpZmljYXRpb24gQXV0aG9yaXR5MB4XDTA0MDYyOTE3MDYyMFoXDTM0MDYyOTE3MDYy\n"
-"MFowYzELMAkGA1UEBhMCVVMxITAfBgNVBAoTGFRoZSBHbyBEYWRkeSBHcm91cCwgSW5jLjEx\n"
-"MC8GA1UECxMoR28gRGFkZHkgQ2xhc3MgMiBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTCCASAw\n"
-"DQYJKoZIhvcNAQEBBQADggENADCCAQgCggEBAN6d1+pXGEmhW+vXX0iG6r7d/+TvZxz0ZWiz\n"
-"V3GgXne77ZtJ6XCAPVYYYwhv2vLM0D9/AlQiVBDYsoHUwHU9S3/Hd8M+eKsaA7Ugay9qK7HF\n"
-"iH7Eux6wwdhFJ2+qN1j3hybX2C32qRe3H3I2TqYXP2WYktsqbl2i/ojgC95/5Y0V4evLOtXi\n"
-"EqITLdiOr18SPaAIBQi2XKVlOARFmR6jYGB0xUGlcmIbYsUfb18aQr4CUWWoriMYavx4A6lN\n"
-"f4DD+qta/KFApMoZFv6yyO9ecw3ud72a9nmYvLEHZ6IVDd2gWMZEewo+YihfukEHU1jPEX44\n"
-"dMX4/7VpkI+EdOqXG68CAQOjgcAwgb0wHQYDVR0OBBYEFNLEsNKR1EwRcbNhyz2h/t2oatTj\n"
-"MIGNBgNVHSMEgYUwgYKAFNLEsNKR1EwRcbNhyz2h/t2oatTjoWekZTBjMQswCQYDVQQGEwJV\n"
-"UzEhMB8GA1UEChMYVGhlIEdvIERhZGR5IEdyb3VwLCBJbmMuMTEwLwYDVQQLEyhHbyBEYWRk\n"
-"eSBDbGFzcyAyIENlcnRpZmljYXRpb24gQXV0aG9yaXR5ggEAMAwGA1UdEwQFMAMBAf8wDQYJ\n"
-"KoZIhvcNAQEFBQADggEBADJL87LKPpH8EsahB4yOd6AzBhRckB4Y9wimPQoZ+YeAEW5p5JYX\n"
-"MP80kWNyOO7MHAGjHZQopDH2esRU1/blMVgDoszOYtuURXO1v0XJJLXVggKtI3lpjbi2Tc7P\n"
-"TMozI+gciKqdi0FuFskg5YmezTvacPd+mSYgFFQlq25zheabIZ0KbIIOqPjCDPoQHmyW74cN\n"
-"xA9hi63ugyuV+I6ShHI56yDqg+2DzZduCLzrTia2cyvk0/ZM/iZx4mERdEr/VxqHD3VILs9R\n"
-"aRegAhJhldXRQLIQTO7ErBBDpqWeCtWVYpoNz4iCxTIM5CufReYNnyicsbkqWletNw+vHX/b\n"
-"vZ8=\n"
-"-----END CERTIFICATE-----\n",
-
-/* Starfield Class 2 CA */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIEDzCCAvegAwIBAgIBADANBgkqhkiG9w0BAQUFADBoMQswCQYDVQQGEwJVUzElMCMGA1UE\n"
-"ChMcU3RhcmZpZWxkIFRlY2hub2xvZ2llcywgSW5jLjEyMDAGA1UECxMpU3RhcmZpZWxkIENs\n"
-"YXNzIDIgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMDQwNjI5MTczOTE2WhcNMzQwNjI5\n"
-"MTczOTE2WjBoMQswCQYDVQQGEwJVUzElMCMGA1UEChMcU3RhcmZpZWxkIFRlY2hub2xvZ2ll\n"
-"cywgSW5jLjEyMDAGA1UECxMpU3RhcmZpZWxkIENsYXNzIDIgQ2VydGlmaWNhdGlvbiBBdXRo\n"
-"b3JpdHkwggEgMA0GCSqGSIb3DQEBAQUAA4IBDQAwggEIAoIBAQC3Msj+6XGmBIWtDBFk385N\n"
-"78gDGIc/oav7PKaf8MOh2tTYbitTkPskpD6E8J7oX+zlJ0T1KKY/e97gKvDIr1MvnsoFAZMe\n"
-"j2YcOadN+lq2cwQlZut3f+dZxkqZJRRU6ybH838Z1TBwj6+wRir/resp7defqgSHo9T5iaU0\n"
-"X9tDkYI22WY8sbi5gv2cOj4QyDvvBmVmepsZGD3/cVE8MC5fvj13c7JdBmzDI1aaK4Umkhyn\n"
-"ArPkPw2vCHmCuDY96pzTNbO8acr1zJ3o/WSNF4Azbl5KXZnJHoe0nRrA1W4TNSNe35tfPe/W\n"
-"93bC6j67eA0cQmdrBNj41tpvi/JEoAGrAgEDo4HFMIHCMB0GA1UdDgQWBBS/X7fRzt0fhvRb\n"
-"Vazc1xDCDqmI5zCBkgYDVR0jBIGKMIGHgBS/X7fRzt0fhvRbVazc1xDCDqmI56FspGowaDEL\n"
-"MAkGA1UEBhMCVVMxJTAjBgNVBAoTHFN0YXJmaWVsZCBUZWNobm9sb2dpZXMsIEluYy4xMjAw\n"
-"BgNVBAsTKVN0YXJmaWVsZCBDbGFzcyAyIENlcnRpZmljYXRpb24gQXV0aG9yaXR5ggEAMAwG\n"
-"A1UdEwQFMAMBAf8wDQYJKoZIhvcNAQEFBQADggEBAAWdP4id0ckaVaGsafPzWdqbAYcaT1ep\n"
-"oXkJKtv3L7IezMdeatiDh6GX70k1PncGQVhiv45YuApnP+yz3SFmH8lU+nLMPUxA2IGvd56D\n"
-"eruix/U0F47ZEUD0/CwqTRV/p2JdLiXTAAsgGh1o+Re49L2L7ShZ3U0WixeDyLJlxy16paq8\n"
-"U4Zt3VekyvggQQto8PT7dL5WXXp59fkdheMtlb71cZBDzI0fmgAKhynpVSJYACPq4xJDKVtH\n"
-"CN2MQWplBqjlIapBtJUhlbl90TSrE9atvNziPTnNvT51cKEYWQPJIrSPnNVeKtelttQKbfi3\n"
-"QBFGmh95DmK/D5fs4C8fF5Q=\n"
-"-----END CERTIFICATE-----\n",
-
-/* StartCom Certification Authority */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIHyTCCBbGgAwIBAgIBATANBgkqhkiG9w0BAQUFADB9MQswCQYDVQQGEwJJTDEWMBQGA1UE\n"
-"ChMNU3RhcnRDb20gTHRkLjErMCkGA1UECxMiU2VjdXJlIERpZ2l0YWwgQ2VydGlmaWNhdGUg\n"
-"U2lnbmluZzEpMCcGA1UEAxMgU3RhcnRDb20gQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcN\n"
-"MDYwOTE3MTk0NjM2WhcNMzYwOTE3MTk0NjM2WjB9MQswCQYDVQQGEwJJTDEWMBQGA1UEChMN\n"
-"U3RhcnRDb20gTHRkLjErMCkGA1UECxMiU2VjdXJlIERpZ2l0YWwgQ2VydGlmaWNhdGUgU2ln\n"
-"bmluZzEpMCcGA1UEAxMgU3RhcnRDb20gQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwggIiMA0G\n"
-"CSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDBiNsJvGxGfHiflXu1M5DycmLWwTYgIiRezul3\n"
-"8kMKogZkpMyONvg45iPwbm2xPN1yo4UcodM9tDMr0y+v/uqwQVlntsQGfQqedIXWeUyAN3rf\n"
-"OQVSWff0G0ZDpNKFhdLDcfN1YjS6LIp/Ho/u7TTQEceWzVI9ujPW3U3eCztKS5/CJi/6tRYc\n"
-"cjV3yjxd5srhJosaNnZcAdt0FCX+7bWgiA/deMotHweXMAEtcnn6RtYTKqi5pquDSR3l8u/d\n"
-"5AGOGAqPY1MWhWKpDhk6zLVmpsJrdAfkK+F2PrRt2PZE4XNiHzvEvqBTViVsUQn3qqvKv3b9\n"
-"bZvzndu/PWa8DFaqr5hIlTpL36dYUNk4dalb6kMMAv+Z6+hsTXBbKWWc3apdzK8BMewM69KN\n"
-"6Oqce+Zu9ydmDBpI125C4z/eIT574Q1w+2OqqGwaVLRcJXrJosmLFqa7LH4XXgVNWG4SHQHu\n"
-"EhANxjJ/GP/89PrNbpHoNkm+Gkhpi8KWTRoSsmkXwQqQ1vp5Iki/untp+HDH+no32NgN0nZP\n"
-"V/+Qt+OR0t3vwmC3Zzrd/qqc8NSLf3Iizsafl7b4r4qgEKjZ+xjGtrVcUjyJthkqcwEKDwOz\n"
-"EmDyei+B26Nu/yYwl/WL3YlXtq09s68rxbd2AvCl1iuahhQqcvbjM4xdCUsT37uMdBNSSwID\n"
-"AQABo4ICUjCCAk4wDAYDVR0TBAUwAwEB/zALBgNVHQ8EBAMCAa4wHQYDVR0OBBYEFE4L7xqk\n"
-"QFulF2mHMMo0aEPQQa7yMGQGA1UdHwRdMFswLKAqoCiGJmh0dHA6Ly9jZXJ0LnN0YXJ0Y29t\n"
-"Lm9yZy9zZnNjYS1jcmwuY3JsMCugKaAnhiVodHRwOi8vY3JsLnN0YXJ0Y29tLm9yZy9zZnNj\n"
-"YS1jcmwuY3JsMIIBXQYDVR0gBIIBVDCCAVAwggFMBgsrBgEEAYG1NwEBATCCATswLwYIKwYB\n"
-"BQUHAgEWI2h0dHA6Ly9jZXJ0LnN0YXJ0Y29tLm9yZy9wb2xpY3kucGRmMDUGCCsGAQUFBwIB\n"
-"FilodHRwOi8vY2VydC5zdGFydGNvbS5vcmcvaW50ZXJtZWRpYXRlLnBkZjCB0AYIKwYBBQUH\n"
-"AgIwgcMwJxYgU3RhcnQgQ29tbWVyY2lhbCAoU3RhcnRDb20pIEx0ZC4wAwIBARqBl0xpbWl0\n"
-"ZWQgTGlhYmlsaXR5LCByZWFkIHRoZSBzZWN0aW9uICpMZWdhbCBMaW1pdGF0aW9ucyogb2Yg\n"
-"dGhlIFN0YXJ0Q29tIENlcnRpZmljYXRpb24gQXV0aG9yaXR5IFBvbGljeSBhdmFpbGFibGUg\n"
-"YXQgaHR0cDovL2NlcnQuc3RhcnRjb20ub3JnL3BvbGljeS5wZGYwEQYJYIZIAYb4QgEBBAQD\n"
-"AgAHMDgGCWCGSAGG+EIBDQQrFilTdGFydENvbSBGcmVlIFNTTCBDZXJ0aWZpY2F0aW9uIEF1\n"
-"dGhvcml0eTANBgkqhkiG9w0BAQUFAAOCAgEAFmyZ9GYMNPXQhV59CuzaEE44HF7fpiUFS5Ey\n"
-"weg78T3dRAlbB0mKKctmArexmvclmAk8jhvh3TaHK0u7aNM5Zj2gJsfyOZEdUauCe37Vzlrk\n"
-"4gNXcGmXCPleWKYK34wGmkUWFjgKXlf2Ysd6AgXmvB618p70qSmD+LIU424oh0TDkBreOKk8\n"
-"rENNZEXO3SipXPJzewT4F+irsfMuXGRuczE6Eri8sxHkfY+BUZo7jYn0TZNmezwD7dOaHZrz\n"
-"ZVD1oNB1ny+v8OqCQ5j4aZyJecRDjkZy42Q2Eq/3JR44iZB3fsNrarnDy0RLrHiQi+fHLB5L\n"
-"EUTINFInzQpdn4XBidUaePKVEFMy3YCEZnXZtWgo+2EuvoSoOMCZEoalHmdkrQYuL6lwhceW\n"
-"D3yJZfWOQ1QOq92lgDmUYMA0yZZwLKMS9R9Ie70cfmu3nZD0Ijuu+PwqyvqCUqDvr0tVk+vB\n"
-"tfAii6w0TiYiBKGHLHVKt+V9E9e4DGTANtLJL4YSjCMJwRuCO3NJo2pXh5Tl1njFmUNj403g\n"
-"dy3hZZlyaQQaRwnmDwFWJPsfvw55qVguucQJAX6Vum0ABj6y6koQOdjQK/W/7HW/lwLFCRsI\n"
-"3FU34oH7N4RDYiDK51ZLZer+bMEkkyShNOsF/5oirpt9P/FlUQqmMGqz9IgcgA38corog14=\n"
-"-----END CERTIFICATE-----\n",
-
-/* Taiwan GRCA */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIFcjCCA1qgAwIBAgIQH51ZWtcvwgZEpYAIaeNe9jANBgkqhkiG9w0BAQUFADA/MQswCQYD\n"
-"VQQGEwJUVzEwMC4GA1UECgwnR292ZXJubWVudCBSb290IENlcnRpZmljYXRpb24gQXV0aG9y\n"
-"aXR5MB4XDTAyMTIwNTEzMjMzM1oXDTMyMTIwNTEzMjMzM1owPzELMAkGA1UEBhMCVFcxMDAu\n"
-"BgNVBAoMJ0dvdmVybm1lbnQgUm9vdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTCCAiIwDQYJ\n"
-"KoZIhvcNAQEBBQADggIPADCCAgoCggIBAJoluOzMonWoe/fOW1mKydGGEghU7Jzy50b2iPN8\n"
-"6aXfTEc2pBsBHH8eV4qNw8XRIePaJD9IK/ufLqGU5ywck9G/GwGHU5nOp/UKIXZ3/6m3xnOU\n"
-"T0b3EEk3+qhZSV1qgQdW8or5BtD3cCJNtLdBuTK4sfCxw5w/cP1T3YGq2GN49thTbqGsaoQk\n"
-"clSGxtKyyhwOeYHWtXBiCAEuTk8O1RGvqa/lmr/czIdtJuTJV6L7lvnM4T9TjGxMfptTCAts\n"
-"F/tnyMKtsc2AtJfcdgEWFelq16TheEfOhtX7MfP6Mb40qij7cEwdScevLJ1tZqa2jWR+tSBq\n"
-"nTuBto9AAGdLiYa4zGX+FVPpBMHWXx1E1wovJ5pGfaENda1UhhXcSTvxls4Pm6Dso3pdvtUq\n"
-"dULle96ltqqvKKyskKw4t9VoNSZ63Pc78/1Fm9G7Q3hub/FCVGqY8A2tl+lSXunVanLeavcb\n"
-"YBT0peS2cWeqH+riTcFCQP5nRhc4L0c/cZyu5SHKYS1tB6iEfC3uUSXxY5Ce/eFXiGvviiNt\n"
-"sea9P63RPZYLhY3Naye7twWb7LuRqQoHEgKXTiCQ8P8NHuJBO9NAOueNXdpm5AKwB1KYXA6O\n"
-"M5zCppX7VRluTI6uSw+9wThNXo+EHWbNxWCWtFJaBYmOlXqYwZE8lSOyDvR5tMl8wUohAgMB\n"
-"AAGjajBoMB0GA1UdDgQWBBTMzO/MKWCkO7GStjz6MmKPrCUVOzAMBgNVHRMEBTADAQH/MDkG\n"
-"BGcqBwAEMTAvMC0CAQAwCQYFKw4DAhoFADAHBgVnKgMAAAQUA5vwIhP/lSg209yewDL7MTqK\n"
-"UWUwDQYJKoZIhvcNAQEFBQADggIBAECASvomyc5eMN1PhnR2WPWus4MzeKR6dBcZTulStbng\n"
-"CnRiqmjKeKBMmo4sIy7VahIkv9Ro04rQ2JyftB8M3jh+Vzj8jeJPXgyfqzvS/3WXy6TjZwj/\n"
-"5cAWtUgBfen5Cv8b5Wppv3ghqMKnI6mGq3ZW6A4M9hPdKmaKZEk9GhiHkASfQlK3T8v+R0F2\n"
-"Ne//AHY2RTKbxkaFXeIksB7jSJaYV0eUVXoPQbFEJPPB/hprv4j9wabak2BegUqZIJxIZhm1\n"
-"AHlUD7gsL0u8qV1bYH+Mh6XgUmMqvtg7hUAV/h62ZT/FS9p+tXo1KaMuephgIqP0fSdOLeq0\n"
-"dDzpD6QzDxARvBMB1uUO07+1EqLhRSPAzAhuYbeJq4PjJB7mXQfnHyA+z2fI56wwbSdLaG5L\n"
-"KlwCCDTb+HbkZ6MmnD+iMsJKxYEYMRBWqoTvLQr/uB930r+lWKBi5NdLkXWNiYCYfm3LU05e\n"
-"r/ayl4WXudpVBrkk7tfGOB5jGxI7leFYrPLfhNVfmS8NVVvmONsuP3LpSIXLuykTjx44Vbnz\n"
-"ssQwmSNOXfJIoRIM3BKQCZBUkQM8R+XVyWXgt0t97EfTsws+rZ7QdAAO671RrcDeLMDDav7v\n"
-"3Aun+kbfYNucpllQdSNpc5Oy+fwC00fmcc4QAu4njIT/rEUNE1yDMuAlpYYsfPQS\n"
-"-----END CERTIFICATE-----\n",
-
-/* Swisscom Root CA 1 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIF2TCCA8GgAwIBAgIQXAuFXAvnWUHfV8w/f52oNjANBgkqhkiG9w0BAQUFADBkMQswCQYD\n"
-"VQQGEwJjaDERMA8GA1UEChMIU3dpc3Njb20xJTAjBgNVBAsTHERpZ2l0YWwgQ2VydGlmaWNh\n"
-"dGUgU2VydmljZXMxGzAZBgNVBAMTElN3aXNzY29tIFJvb3QgQ0EgMTAeFw0wNTA4MTgxMjA2\n"
-"MjBaFw0yNTA4MTgyMjA2MjBaMGQxCzAJBgNVBAYTAmNoMREwDwYDVQQKEwhTd2lzc2NvbTEl\n"
-"MCMGA1UECxMcRGlnaXRhbCBDZXJ0aWZpY2F0ZSBTZXJ2aWNlczEbMBkGA1UEAxMSU3dpc3Nj\n"
-"b20gUm9vdCBDQSAxMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA0LmwqAzZuz8h\n"
-"+BvVM5OAFmUgdbI9m2BtRsiMMW8Xw/qabFbtPMWRV8PNq5ZJkCoZSx6jbVfd8StiKHVFXqrW\n"
-"W/oLJdihFvkcxC7mlSpnzNApbjyFNDhhSbEAn9Y6cV9Nbc5fuankiX9qUvrKm/LcqfmdmUc/\n"
-"TilftKaNXXsLmREDA/7n29uj/x2lzZAeAR81sH8A25Bvxn570e56eqeqDFdvpG3FEzuwpdnt\n"
-"Mhy0XmeLVNxzh+XTF3xmUHJd1BpYwdnP2IkCb6dJtDZd0KTeByy2dbcokdaXvij1mB7qWybJ\n"
-"vbCXc9qukSbraMH5ORXWZ0sKbU/Lz7DkQnGMU3nn7uHbHaBuHYwadzVcFh4rUx80i9Fs/PJn\n"
-"B3r1re3WmquhsUvhzDdf/X/NTa64H5xD+SpYVUNFvJbNcA78yeNmuk6NO4HLFWR7uZToXTNS\n"
-"hXEuT46iBhFRyePLoW4xCGQMwtI89Tbo19AOeCMgkckkKmUpWyL3Ic6DXqTz3kvTaI9GdVyD\n"
-"CW4pa8RwjPWd1yAv/0bSKzjCL3UcPX7ape8eYIVpQtPM+GP+HkM5haa2Y0EQs3MevNP6yn0W\n"
-"R+Kn1dCjigoIlmJWbjTb2QK5MHXjBNLnj8KwEUAKrNVxAmKLMb7dxiNYMUJDLXT5xp6mig/p\n"
-"/r+D5kNXJLrvRjSq1xIBOO0CAwEAAaOBhjCBgzAOBgNVHQ8BAf8EBAMCAYYwHQYDVR0hBBYw\n"
-"FDASBgdghXQBUwABBgdghXQBUwABMBIGA1UdEwEB/wQIMAYBAf8CAQcwHwYDVR0jBBgwFoAU\n"
-"AyUv3m+CATpcLNwroWm1Z9SM0/0wHQYDVR0OBBYEFAMlL95vggE6XCzcK6FptWfUjNP9MA0G\n"
-"CSqGSIb3DQEBBQUAA4ICAQA1EMvspgQNDQ/NwNurqPKIlwzfky9NfEBWMXrrpA9gzXrzvsMn\n"
-"jgM+pN0S734edAY8PzHyHHuRMSG08NBsl9Tpl7IkVh5WwzW9iAUPWxAaZOHHgjD5Mq2eUCzn\n"
-"eAXQMbFamIp1TpBcahQq4FJHgmDmHtqBsfsUC1rxn9KVuj7QG9YVHaO+htXbD8BJZLsuUBlL\n"
-"0iT43R4HVtA4oJVwIHaM190e3p9xxCPvgxNcoyQVTSlAPGrEqdi3pkSlDfTgnXceQHAm/NrZ\n"
-"NuR55LU/vJtlvrsRls/bxig5OgjOR1tTWsWZ/l2p3e9M1MalrQLmjAcSHm8D0W+go/MpvRLH\n"
-"UKKwf4ipmXeascClOS5cfGniLLDqN2qk4Vrh9VDlg++luyqI54zb/W1elxmofmZ1a3Hqv7HH\n"
-"b6D0jqTsNFFbjCYDcKF31QESVwA12yPeDooomf2xEG9L/zgtYE4snOtnta1J7ksfrK/7DZBa\n"
-"ZmBwXarNeNQk7shBoJMBkpxqnvy5JMWzFYJ+vq6VK+uxwNrjAWALXmmshFZhvnEX/h0TD/7G\n"
-"h0Xp/jKgGg0TpJRVcaUWi7rKibCyx/yP2FS1k2Kdzs9Z+z0YzirLNRWCXf9UIltxUvu3yf5g\n"
-"mwBBZPCqKuy2QkPOiWaByIufOVQDJdMWNY6E0F/6MBr1mmz0DlP5OlvRHA==\n"
-"-----END CERTIFICATE-----\n",
-
-/* DigiCert Assured ID Root CA */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDtzCCAp+gAwIBAgIQDOfg5RfYRv6P5WD8G/AwOTANBgkqhkiG9w0BAQUFADBlMQswCQYD\n"
-"VQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNlcnQu\n"
-"Y29tMSQwIgYDVQQDExtEaWdpQ2VydCBBc3N1cmVkIElEIFJvb3QgQ0EwHhcNMDYxMTEwMDAw\n"
-"MDAwWhcNMzExMTEwMDAwMDAwWjBlMQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQg\n"
-"SW5jMRkwFwYDVQQLExB3d3cuZGlnaWNlcnQuY29tMSQwIgYDVQQDExtEaWdpQ2VydCBBc3N1\n"
-"cmVkIElEIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCtDhXO5EOA\n"
-"XLGH87dg+XESpa7cJpSIqvTO9SA5KFhgDPiA2qkVlTJhPLWxKISKityfCgyDF3qPkKyK53lT\n"
-"XDGEKvYPmDI2dsze3Tyoou9q+yHyUmHfnyDXH+Kx2f4YZNISW1/5WBg1vEfNoTb5a3/UsDg+\n"
-"wRvDjDPZ2C8Y/igPs6eD1sNuRMBhNZYW/lmci3Zt1/GiSw0r/wty2p5g0I6QNcZ4VYcgoc/l\n"
-"bQrISXwxmDNsIumH0DJaoroTghHtORedmTpyoeb6pNnVFzF1roV9Iq4/AUaG9ih5yLHa5FcX\n"
-"xH4cDrC0kqZWs72yl+2qp/C3xag/lRbQ/6GW6whfGHdPAgMBAAGjYzBhMA4GA1UdDwEB/wQE\n"
-"AwIBhjAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBRF66Kv9JLLgjEtUYunpyGd823IDzAf\n"
-"BgNVHSMEGDAWgBRF66Kv9JLLgjEtUYunpyGd823IDzANBgkqhkiG9w0BAQUFAAOCAQEAog68\n"
-"3+Lt8ONyc3pklL/3cmbYMuRCdWKuh+vy1dneVrOfzM4UKLkNl2BcEkxY5NM9g0lFWJc1aRqo\n"
-"R+pWxnmrEthngYTffwk8lOa4JiwgvT2zKIn3X/8i4peEH+ll74fg38FnSbNd67IJKusm7Xi+\n"
-"fT8r87cmNW1fiQG2SVufAQWbqz0lwcy2f8Lxb4bG+mRo64EtlOtCt/qMHt1i8b5QZ7dsvfPx\n"
-"H2sMNgcWfzd8qVttevESRmCD1ycEvkvOl77DZypoEd+A5wwzZr8TDRRu838fYxAe+o0bJW1s\n"
-"j6W3YQGx0qMmoRBxna3iw/nDmVG3KwcIzi7mULKn+gpFL6Lw8g==\n"
-"-----END CERTIFICATE-----\n",
-
-/* DigiCert Global Root CA */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDrzCCApegAwIBAgIQCDvgVpBCRrGhdWrJWZHHSjANBgkqhkiG9w0BAQUFADBhMQswCQYD\n"
-"VQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNlcnQu\n"
-"Y29tMSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBDQTAeFw0wNjExMTAwMDAwMDBa\n"
-"Fw0zMTExMTAwMDAwMDBaMGExCzAJBgNVBAYTAlVTMRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMx\n"
-"GTAXBgNVBAsTEHd3dy5kaWdpY2VydC5jb20xIDAeBgNVBAMTF0RpZ2lDZXJ0IEdsb2JhbCBS\n"
-"b290IENBMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4jvhEXLeqKTTo1eqUKKP\n"
-"C3eQyaKl7hLOllsBCSDMAZOnTjC3U/dDxGkAV53ijSLdhwZAAIEJzs4bg7/fzTtxRuLWZscF\n"
-"s3YnFo97nh6Vfe63SKMI2tavegw5BmV/Sl0fvBf4q77uKNd0f3p4mVmFaG5cIzJLv07A6Fpt\n"
-"43C/dxC//AH2hdmoRBBYMql1GNXRor5H4idq9Joz+EkIYIvUX7Q6hL+hqkpMfT7PT19sdl6g\n"
-"SzeRntwi5m3OFBqOasv+zbMUZBfHWymeMr/y7vrTC0LUq7dBMtoM1O/4gdW7jVg/tRvoSSii\n"
-"cNoxBN33shbyTApOB6jtSj1etX+jkMOvJwIDAQABo2MwYTAOBgNVHQ8BAf8EBAMCAYYwDwYD\n"
-"VR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUA95QNVbRTLtm8KPiGxvDl7I90VUwHwYDVR0jBBgw\n"
-"FoAUA95QNVbRTLtm8KPiGxvDl7I90VUwDQYJKoZIhvcNAQEFBQADggEBAMucN6pIExIK+t1E\n"
-"nE9SsPTfrgT1eXkIoyQY/EsrhMAtudXH/vTBH1jLuG2cenTnmCmrEbXjcKChzUyImZOMkXDi\n"
-"qw8cvpOp/2PV5Adg06O/nVsJ8dWO41P0jmP6P6fbtGbfYmbW0W5BjfIttep3Sp+dWOIrWcBA\n"
-"I+0tKIJFPnlUkiaY4IBIqDfv8NZ5YBberOgOzW6sRBc4L0na4UU+Krk2U886UAb3LujEV0ls\n"
-"YSEY1QSteDwsOoBrp+uvFRTp2InBuThs4pFsiv9kuXclVzDAGySj4dzp30d8tbQkCAUw7C29\n"
-"C79Fv1C5qfPrmAESrciIxpg0X40KPMbp1ZWVbd4=\n"
-"-----END CERTIFICATE-----\n",
-
-/* DigiCert High Assurance EV Root CA */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDxTCCAq2gAwIBAgIQAqxcJmoLQJuPC3nyrkYldzANBgkqhkiG9w0BAQUFADBsMQswCQYD\n"
-"VQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNlcnQu\n"
-"Y29tMSswKQYDVQQDEyJEaWdpQ2VydCBIaWdoIEFzc3VyYW5jZSBFViBSb290IENBMB4XDTA2\n"
-"MTExMDAwMDAwMFoXDTMxMTExMDAwMDAwMFowbDELMAkGA1UEBhMCVVMxFTATBgNVBAoTDERp\n"
-"Z2lDZXJ0IEluYzEZMBcGA1UECxMQd3d3LmRpZ2ljZXJ0LmNvbTErMCkGA1UEAxMiRGlnaUNl\n"
-"cnQgSGlnaCBBc3N1cmFuY2UgRVYgUm9vdCBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCC\n"
-"AQoCggEBAMbM5XPm+9S75S0tMqbf5YE/yc0lSbZxKsPVlDRnogocsF9ppkCxxLeyj9CYpKlB\n"
-"WTrT3JTWPNt0OKRKzE0lgvdKpVMSOO7zSW1xkX5jtqumX8OkhPhPYlG++MXs2ziS4wblCJEM\n"
-"xChBVfvLWokVfnHoNb9Ncgk9vjo4UFt3MRuNs8ckRZqnrG0AFFoEt7oT61EKmEFBIk5lYYeB\n"
-"QVCmeVyJ3hlKV9Uu5l0cUyx+mM0aBhakaHPQNAQTXKFx01p8VdteZOE3hzBWBOURtCmAEvF5\n"
-"OYiiAhF8J2a3iLd48soKqDirCmTCv2ZdlYTBoSUeh10aUAsgEsxBu24LUTi4S8sCAwEAAaNj\n"
-"MGEwDgYDVR0PAQH/BAQDAgGGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFLE+w2kD+L9H\n"
-"AdSYJhoIAu9jZCvDMB8GA1UdIwQYMBaAFLE+w2kD+L9HAdSYJhoIAu9jZCvDMA0GCSqGSIb3\n"
-"DQEBBQUAA4IBAQAcGgaX3NecnzyIZgYIVyHbIUf4KmeqvxgydkAQV8GK83rZEWWONfqe/EW1\n"
-"ntlMMUu4kehDLI6zeM7b41N5cdblIZQB2lWHmiRk9opmzN6cN82oNLFpmyPInngiK3BD41VH\n"
-"MWEZ71jFhS9OMPagMRYjyOfiZRYzy78aG6A9+MpeizGLYAiJLQwGXFK3xPkKmNEVX58Svnw2\n"
-"Yzi9RKR/5CYrCsSXaQ3pjOLAEFe4yHYSkVXySGnYvCoCWw9E1CAx2/S6cCZdkGCevEsXCS+0\n"
-"yx5DaMkHJ8HSXPfqIbloEpw8nL+e/IBcm2PN7EeqJSdnoDfzAIJ9VNep+OkuE6N36B9K\n"
-"-----END CERTIFICATE-----\n",
-
-/* Certplus Class 2 Primary CA */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDkjCCAnqgAwIBAgIRAIW9S/PY2uNp9pTXX8OlRCMwDQYJKoZIhvcNAQEFBQAwPTELMAkG\n"
-"A1UEBhMCRlIxETAPBgNVBAoTCENlcnRwbHVzMRswGQYDVQQDExJDbGFzcyAyIFByaW1hcnkg\n"
-"Q0EwHhcNOTkwNzA3MTcwNTAwWhcNMTkwNzA2MjM1OTU5WjA9MQswCQYDVQQGEwJGUjERMA8G\n"
-"A1UEChMIQ2VydHBsdXMxGzAZBgNVBAMTEkNsYXNzIDIgUHJpbWFyeSBDQTCCASIwDQYJKoZI\n"
-"hvcNAQEBBQADggEPADCCAQoCggEBANxQltAS+DXSCHh6tlJw/W/uz7kRy1134ezpfgSN1sxv\n"
-"c0NXYKwzCkTsA18cgCSR5aiRVhKC9+Ar9NuuYS6JEI1rbLqzAr3VNsVINyPi8Fo3UjMXEuLR\n"
-"YE2+L0ER4/YXJQyLkcAbmXuZVg2v7tK8R1fjeUl7NIknJITesezpWE7+Tt9avkGtrAjFGA7v\n"
-"0lPubNCdEgETjdyAYveVqUSISnFOYFWe2yMZeVYHDD9jC1yw4r5+FfyUM1hBOHTE4Y+L3yas\n"
-"H7WLO7dDWWuwJKZtkIvEcupdM5i3y95ee++U8Rs+yskhwcWYAqqi9lt3m/V+llU0HGdpwPFC\n"
-"40es/CgcZlUCAwEAAaOBjDCBiTAPBgNVHRMECDAGAQH/AgEKMAsGA1UdDwQEAwIBBjAdBgNV\n"
-"HQ4EFgQU43Mt38sOKAze3bOkynm4jrvoMIkwEQYJYIZIAYb4QgEBBAQDAgEGMDcGA1UdHwQw\n"
-"MC4wLKAqoCiGJmh0dHA6Ly93d3cuY2VydHBsdXMuY29tL0NSTC9jbGFzczIuY3JsMA0GCSqG\n"
-"SIb3DQEBBQUAA4IBAQCnVM+IRBnL39R/AN9WM2K191EBkOvDP9GIROkkXe/nFL0gt5o8AP5t\n"
-"n9uQ3Nf0YtaLcF3n5QRIqWh8yfFC82x/xXp8HVGIutIKPidd3i1RTtMTZGnkLuPT55sJmabg\n"
-"lZvOGtd/vjzOUrMRFcEPF80Du5wlFbqidon8BvEY0JNLDnyCt6X09l/+7UCmnYR0ObncHoUW\n"
-"2ikbhiMAybuJfm6AiB4vFLQDJKgybwOaRywwvlbGp0ICcBvqQNi6BQNwB6SW//1IMwrh3KWB\n"
-"kJtN3X3n57LNXMhqlfil9o3EXXgIvnsG1knPGTZQIy4I5p4FTUcY1Rbpsda2ENW7l7+ijrRU\n"
-"-----END CERTIFICATE-----\n",
-
-/* DST Root CA X3 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDSjCCAjKgAwIBAgIQRK+wgNajJ7qJMDmGLvhAazANBgkqhkiG9w0BAQUFADA/MSQwIgYD\n"
-"VQQKExtEaWdpdGFsIFNpZ25hdHVyZSBUcnVzdCBDby4xFzAVBgNVBAMTDkRTVCBSb290IENB\n"
-"IFgzMB4XDTAwMDkzMDIxMTIxOVoXDTIxMDkzMDE0MDExNVowPzEkMCIGA1UEChMbRGlnaXRh\n"
-"bCBTaWduYXR1cmUgVHJ1c3QgQ28uMRcwFQYDVQQDEw5EU1QgUm9vdCBDQSBYMzCCASIwDQYJ\n"
-"KoZIhvcNAQEBBQADggEPADCCAQoCggEBAN+v6ZdQCINXtMxiZfaQguzH0yxrMMpb7NnDfcdA\n"
-"wRgUi+DoM3ZJKuM/IUmTrE4Orz5Iy2Xu/NMhD2XSKtkyj4zl93ewEnu1lcCJo6m67XMuegwG\n"
-"MoOifooUMM0RoOEqOLl5CjH9UL2AZd+3UWODyOKIYepLYYHsUmu5ouJLGiifSKOeDNoJjj4X\n"
-"Lh7dIN9bxiqKqy69cK3FCxolkHRyxXtqqzTWMIn/5WgTe1QLyNau7Fqckh49ZLOMxt+/yUFw\n"
-"7BZy1SbsOFU5Q9D8/RhcQPGX69Wam40dutolucbY38EVAjqr2m7xPi71XAicPNaDaeQQmxkq\n"
-"tilX4+U9m5/wAl0CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYw\n"
-"HQYDVR0OBBYEFMSnsaR7LHH62+FLkHX/xBVghYkQMA0GCSqGSIb3DQEBBQUAA4IBAQCjGiyb\n"
-"FwBcqR7uKGY3Or+Dxz9LwwmglSBd49lZRNI+DT69ikugdB/OEIKcdBodfpga3csTS7MgROSR\n"
-"6cz8faXbauX+5v3gTt23ADq1cEmv8uXrAvHRAosZy5Q6XkjEGB5YGV8eAlrwDPGxrancWYaL\n"
-"bumR9YbK+rlmM6pZW87ipxZzR8srzJmwN0jP41ZL9c8PDHIyh8bwRLtTcm1D9SZImlJnt1ir\n"
-"/md2cXjbDaJWFBM5JDGFoqgCWjBH4d1QB7wCCZAA62RjYJsWvIjJEubSfZGL+T0yjWW06Xyx\n"
-"V3bqxbYoOb8VZRzI9neWagqNdwvYkQsEjgfbKbYK7p2CNTUQ\n"
-"-----END CERTIFICATE-----\n",
-
-/* DST ACES CA X6 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIECTCCAvGgAwIBAgIQDV6ZCtadt3js2AdWO4YV2TANBgkqhkiG9w0BAQUFADBbMQswCQYD\n"
-"VQQGEwJVUzEgMB4GA1UEChMXRGlnaXRhbCBTaWduYXR1cmUgVHJ1c3QxETAPBgNVBAsTCERT\n"
-"VCBBQ0VTMRcwFQYDVQQDEw5EU1QgQUNFUyBDQSBYNjAeFw0wMzExMjAyMTE5NThaFw0xNzEx\n"
-"MjAyMTE5NThaMFsxCzAJBgNVBAYTAlVTMSAwHgYDVQQKExdEaWdpdGFsIFNpZ25hdHVyZSBU\n"
-"cnVzdDERMA8GA1UECxMIRFNUIEFDRVMxFzAVBgNVBAMTDkRTVCBBQ0VTIENBIFg2MIIBIjAN\n"
-"BgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAuT31LMmU3HWKlV1j6IR3dma5WZFcRt2SPp/5\n"
-"DgO0PWGSvSMmtWPuktKe1jzIDZBfZIGxqAgNTNj50wUoUrQBJcWVHAx+PhCEdc/BGZFjz+io\n"
-"kYi5Q1K7gLFViYsx+tC3dr5BPTCapCIlF3PoHuLTrCq9Wzgh1SpL11V94zpVvddtawJXa+ZH\n"
-"fAjIgrrep4c9oW24MFbCswKBXy314powGCi4ZtPLAZZv6opFVdbgnf9nKxcCpk4aahELfrd7\n"
-"55jWjHZvwTvbUJN+5dCOHze4vbrGn2zpfDPyMjwmR/onJALJfh1biEITajV8fTXpLmaRcpPV\n"
-"MibEdPVTo7NdmvYJywIDAQABo4HIMIHFMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQD\n"
-"AgHGMB8GA1UdEQQYMBaBFHBraS1vcHNAdHJ1c3Rkc3QuY29tMGIGA1UdIARbMFkwVwYKYIZI\n"
-"AWUDAgEBATBJMEcGCCsGAQUFBwIBFjtodHRwOi8vd3d3LnRydXN0ZHN0LmNvbS9jZXJ0aWZp\n"
-"Y2F0ZXMvcG9saWN5L0FDRVMtaW5kZXguaHRtbDAdBgNVHQ4EFgQUCXIGThhDD+XWzMNqizF7\n"
-"eI+og7gwDQYJKoZIhvcNAQEFBQADggEBAKPYjtay284F5zLNAdMEA+V25FYrnJmQ6AgwbN99\n"
-"Pe7lv7UkQIRJ4dEorsTCOlMwiPH1d25Ryvr/ma8kXxug/fKshMrfqfBfBC6tFr8hlxCBPeP/\n"
-"h40y3JTlR4peahPJlJU90u7INJXQgNStMgiAVDzgvVJT11J8smk/f3rPanTK+gQqnExaBqXp\n"
-"IK1FZg9p8d2/6eMyi/rgwYZNcjwu2JN4Cir42NInPRmJX1p7ijvMDNpRrscL9yuwNwXsvFcj\n"
-"4jjSm2jzVhKIT0J8uDHEtdvkyCE06UgRNe76x5JXxZ805Mf29w4LTJxoeHtxMcfrHuBnQfO3\n"
-"oKfN5XozNmr6mis=\n"
-"-----END CERTIFICATE-----\n",
-
-/* SwissSign Gold CA - G2 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIFujCCA6KgAwIBAgIJALtAHEP1Xk+wMA0GCSqGSIb3DQEBBQUAMEUxCzAJBgNVBAYTAkNI\n"
-"MRUwEwYDVQQKEwxTd2lzc1NpZ24gQUcxHzAdBgNVBAMTFlN3aXNzU2lnbiBHb2xkIENBIC0g\n"
-"RzIwHhcNMDYxMDI1MDgzMDM1WhcNMzYxMDI1MDgzMDM1WjBFMQswCQYDVQQGEwJDSDEVMBMG\n"
-"A1UEChMMU3dpc3NTaWduIEFHMR8wHQYDVQQDExZTd2lzc1NpZ24gR29sZCBDQSAtIEcyMIIC\n"
-"IjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAr+TufoskDhJuqVAtFkQ7kpJcyrhdhJJC\n"
-"Eyq8ZVeCQD5XJM1QiyUqt2/876LQwB8CJEoTlo8jE+YoWACjR8cGp4QjK7u9lit/VcyLwVcf\n"
-"DmJlD909Vopz2q5+bbqBHH5CjCA12UNNhPqE21Is8w4ndwtrvxEvcnifLtg+5hg3Wipy+dpi\n"
-"kJKVyh+c6bM8K8vzARO/Ws/BtQpgvd21mWRTuKCWs2/iJneRjOBiEAKfNA+k1ZIzUd6+jbqE\n"
-"emA8atufK+ze3gE/bk3lUIbLtK/tREDFylqM2tIrfKjuvqblCqoOpd8FUrdVxyJdMmqXl2MT\n"
-"28nbeTZ7hTpKxVKJ+STnnXepgv9VHKVxaSvRAiTysybUa9oEVeXBCsdtMDeQKuSeFDNeFhdV\n"
-"xVu1yzSJkvGdJo+hB9TGsnhQ2wwMC3wLjEHXuendjIj3o02yMszYF9rNt85mndT9Xv+9lz4p\n"
-"ded+p2JYryU0pUHHPbwNUMoDAw8IWh+Vc3hiv69yFGkOpeUDDniOJihC8AcLYiAQZzlG+qkD\n"
-"zAQ4embvIIO1jEpWjpEA/I5cgt6IoMPiaG59je883WX0XaxR7ySArqpWl2/5rX3aYT+Ydzyl\n"
-"kbYcjCbaZaIJbcHiVOO5ykxMgI93e2CaHt+28kgeDrpOVG2Y4OGiGqJ3UM/EY5LsRxmd6+Zr\n"
-"zsECAwEAAaOBrDCBqTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4E\n"
-"FgQUWyV7lqRlUX64OfPAeGZe6Drn8O4wHwYDVR0jBBgwFoAUWyV7lqRlUX64OfPAeGZe6Drn\n"
-"8O4wRgYDVR0gBD8wPTA7BglghXQBWQECAQEwLjAsBggrBgEFBQcCARYgaHR0cDovL3JlcG9z\n"
-"aXRvcnkuc3dpc3NzaWduLmNvbS8wDQYJKoZIhvcNAQEFBQADggIBACe645R88a7A3hfm5djV\n"
-"9VSwg/S7zV4Fe0+fdWavPOhWfvxyeDgD2StiGwC5+OlgzczOUYrHUDFu4Up+GC9pWbY9ZIEr\n"
-"44OE5iKHjn3g7gKZYbge9LgriBIWhMIxkziWMaa5O1M/wySTVltpkuzFwbs4AOPsF6m43Md8\n"
-"AYOfMke6UiI0HTJ6CVanfCU2qT1L2sCCbwq7EsiHSycR+R4tx5M/nttfJmtS2S6K8RTGRI0V\n"
-"qbe/vd6mGu6uLftIdxf+u+yvGPUqUfA5hJeVbG4bwyvEdGB5JbAKJ9/fXtI5z0V9Qkvfsywe\n"
-"xcZdylU6oJxpmo/a77KwPJ+HbBIrZXAVUjEaJM9vMSNQH4xPjyPDdEFjHFWoFN0+4FFQz/Eb\n"
-"MFYOkrCChdiDyyJkvC24JdVUorgG6q2SpCSgwYa1ShNqR88uC1aVVMvOmttqtKay20EIhid3\n"
-"92qgQmwLOM7XdVAyksLfKzAiSNDVQTglXaTpXZ/GlHXQRf0wl0OPkKsKx4ZzYEppLd6leNcG\n"
-"2mqeSz53OiATIgHQv2ieY2BrNU0LbbqhPcCT4H8js1WtciVORvnSFu+wZMEBnunKoGqYDs/Y\n"
-"YPIvSbjkQuE4NRb0yG5P94FW6LqjviOvrv1vA+ACOzB2+httQc8Bsem4yWb02ybzOqR08kkk\n"
-"W8mw0FfB+j564ZfJ\n"
-"-----END CERTIFICATE-----\n",
-
-/* SwissSign Silver CA - G2 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIFvTCCA6WgAwIBAgIITxvUL1S7L0swDQYJKoZIhvcNAQEFBQAwRzELMAkGA1UEBhMCQ0gx\n"
-"FTATBgNVBAoTDFN3aXNzU2lnbiBBRzEhMB8GA1UEAxMYU3dpc3NTaWduIFNpbHZlciBDQSAt\n"
-"IEcyMB4XDTA2MTAyNTA4MzI0NloXDTM2MTAyNTA4MzI0NlowRzELMAkGA1UEBhMCQ0gxFTAT\n"
-"BgNVBAoTDFN3aXNzU2lnbiBBRzEhMB8GA1UEAxMYU3dpc3NTaWduIFNpbHZlciBDQSAtIEcy\n"
-"MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAxPGHf9N4Mfc4yfjDmUO8x/e8N+dO\n"
-"cbpLj6VzHVxumK4DV644N0MvFz0fyM5oEMF4rhkDKxD6LHmD9ui5aLlV8gREpzn5/ASLHvGi\n"
-"TSf5YXu6t+WiE7brYT7QbNHm+/pe7R20nqA1W6GSy/BJkv6FCgU+5tkL4k+73JU3/JHpMjUi\n"
-"0R86TieFnbAVlDLaYQ1HTWBCrpJH6INaUFjpiou5XaHc3ZlKHzZnu0jkg7Y360g6rw9njxcH\n"
-"6ATK72oxh9TAtvmUcXtnZLi2kUpCe2UuMGoM9ZDulebyzYLs2aFK7PayS+VFheZteJMELpyC\n"
-"bTapxDFkH4aDCyr0NQp4yVXPQbBH6TCfmb5hqAaEuSh6XzjZG6k4sIN/c8HDO0gqgg8hm7jM\n"
-"qDXDhBuDsz6+pJVpATqJAHgE2cn0mRmrVn5bi4Y5FZGkECwJMoBgs5PAKrYYC51+jUnyEEp/\n"
-"+dVGLxmSo5mnJqy7jDzmDrxHB9xzUfFwZC8I+bRHHTBsROopN4WSaGa8gzj+ezku01DwH/te\n"
-"YLappvonQfGbGHLy9YR0SslnxFSuSGTfjNFusB3hB48IHpmccelM2KX3RxIfdNFRnobzwqIj\n"
-"QAtz20um53MGjMGg6cFZrEb65i/4z3GcRm25xBWNOHkDRUjvxF3XCO6HOSKGsg0PWEP3calI\n"
-"Lv3q1h8CAwEAAaOBrDCBqTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNV\n"
-"HQ4EFgQUF6DNweRBtjpbO8tFnb0cwpj6hlgwHwYDVR0jBBgwFoAUF6DNweRBtjpbO8tFnb0c\n"
-"wpj6hlgwRgYDVR0gBD8wPTA7BglghXQBWQEDAQEwLjAsBggrBgEFBQcCARYgaHR0cDovL3Jl\n"
-"cG9zaXRvcnkuc3dpc3NzaWduLmNvbS8wDQYJKoZIhvcNAQEFBQADggIBAHPGgeAn0i0P4JUw\n"
-"4ppBf1AsX19iYamGamkYDHRJ1l2E6kFSGG9YrVBWIGrGvShpWJHckRE1qTodvBqlYJ7YH39F\n"
-"kWnZfrt4csEGDyrOj4VwYaygzQu4OSlWhDJOhrs9xCrZ1x9y7v5RoSJBsXECYxqCsGKrXlcS\n"
-"H9/L3XWgwF15kIwb4FDm3jH+mHtwX6WQ2K34ArZv02DdQEsixT2tOnqfGhpHkXkzuoLcMmkD\n"
-"lm4fS/Bx/uNncqCxv1yL5PqZIseEuRuNI5c/7SXgz2W79WEE790eslpBIlqhn10s6FvJbakM\n"
-"DHiqYMZWjwFaDGi8aRl5xB9+lwW/xekkUV7U1UtT7dkjWjYDZaPBA61BMPNGG4WQr2W11bHk\n"
-"Flt4dR2Xem1ZqSqPe97Dh4kQmUlzeMg9vVE1dCrV8X5pGyq7O70luJpaPXJhkGaH7gzWTdQR\n"
-"dAtq/gsD/KNVV4n+SsuuWxcFyPKNIzFTONItaj+CuY0IavdeQXRuwxF+B6wpYJE/OMpXEA29\n"
-"MC/HpeZBoNquBYeaoKRlbEwJDIm6uNO5wJOKMPqN5ZprFQFOZ6raYlY+hAhm0sQ2fac+EPyI\n"
-"4NSA5QC9qvNOBqN6avlicuMJT+ubDgEj8Z+7fNzcbBGXJbLytGMU0gYqZ4yD9c7qB9iaah7s\n"
-"5Aq7KkzrCWA5zspi2C5u\n"
-"-----END CERTIFICATE-----\n",
-
-/* GeoTrust Primary Certification Authority */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDfDCCAmSgAwIBAgIQGKy1av1pthU6Y2yv2vrEoTANBgkqhkiG9w0BAQUFADBYMQswCQYD\n"
-"VQQGEwJVUzEWMBQGA1UEChMNR2VvVHJ1c3QgSW5jLjExMC8GA1UEAxMoR2VvVHJ1c3QgUHJp\n"
-"bWFyeSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTAeFw0wNjExMjcwMDAwMDBaFw0zNjA3MTYy\n"
-"MzU5NTlaMFgxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1HZW9UcnVzdCBJbmMuMTEwLwYDVQQD\n"
-"EyhHZW9UcnVzdCBQcmltYXJ5IENlcnRpZmljYXRpb24gQXV0aG9yaXR5MIIBIjANBgkqhkiG\n"
-"9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvrgVe//UfH1nrYNke8hCUy3f9oQIIGHWAVlqnEQRr+92\n"
-"/ZV+zmEwu3qDXwK9AWbK7hWNb6EwnL2hhZ6UOvNWiAAxz9juapYC2e0DjPt1befquFUWBRaa\n"
-"9OBesYjAZIVcFU2Ix7e64HXprQU9nceJSOC7KMgD4TCTZF5SwFlwIjVXiIrxlQqD17wxcwE0\n"
-"7e9GceBrAqg1cmuXm2bgyxx5X9gaBGgeRwLmnWDiNpcB3841kt++Z8dtd1k7j53WkBWUvEI0\n"
-"EME5+bEnPn7WinXFsq+W06Lem+SYvn3h6YGttm/81w7a4DSwDRp35+MImO9Y+pyEtzavwt+s\n"
-"0vQQBnBxNQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIBBjAdBgNV\n"
-"HQ4EFgQULNVQQZcVi/CPNmFbSvtr2ZnJM5IwDQYJKoZIhvcNAQEFBQADggEBAFpwfyzdtzRP\n"
-"9YZRqSa+S7iq8XEN3GHHoOo0Hnp3DwQ16CePbJC/kRYkRj5KTs4rFtULUh38H2eiAkUxT87z\n"
-"+gOneZ1TatnaYzr4gNfTmeGl4b7UVXGYNTq+k+qurUKykG/g/CFNNWMziUnWm07Kx+dOCQD3\n"
-"2sfvmWKZd7aVIl6KoKv0uHiYyjgZmclynnjNS6yvGaBzEi38wkG6gZHaFloxt/m0cYASSJly\n"
-"c1pZU8FjUjPtp8nSOQJw+uCxQmYpqptR7TBUIhRf2asdweSU8Pj1K/fqynhG1riR/aYNKxoU\n"
-"AT6A8EKglQdebc3MS6RFjasS6LPeWuWgfOgPIh1a6Vk=\n"
-"-----END CERTIFICATE-----\n",
-
-/* thawte Primary Root CA */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIEIDCCAwigAwIBAgIQNE7VVyDV7exJ9C/ON9srbTANBgkqhkiG9w0BAQUFADCBqTELMAkG\n"
-"A1UEBhMCVVMxFTATBgNVBAoTDHRoYXd0ZSwgSW5jLjEoMCYGA1UECxMfQ2VydGlmaWNhdGlv\n"
-"biBTZXJ2aWNlcyBEaXZpc2lvbjE4MDYGA1UECxMvKGMpIDIwMDYgdGhhd3RlLCBJbmMuIC0g\n"
-"Rm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxHzAdBgNVBAMTFnRoYXd0ZSBQcmltYXJ5IFJvb3Qg\n"
-"Q0EwHhcNMDYxMTE3MDAwMDAwWhcNMzYwNzE2MjM1OTU5WjCBqTELMAkGA1UEBhMCVVMxFTAT\n"
-"BgNVBAoTDHRoYXd0ZSwgSW5jLjEoMCYGA1UECxMfQ2VydGlmaWNhdGlvbiBTZXJ2aWNlcyBE\n"
-"aXZpc2lvbjE4MDYGA1UECxMvKGMpIDIwMDYgdGhhd3RlLCBJbmMuIC0gRm9yIGF1dGhvcml6\n"
-"ZWQgdXNlIG9ubHkxHzAdBgNVBAMTFnRoYXd0ZSBQcmltYXJ5IFJvb3QgQ0EwggEiMA0GCSqG\n"
-"SIb3DQEBAQUAA4IBDwAwggEKAoIBAQCsoPD7gFnUnMekz52hWXMJEEUMDSxuaPFsW0hoSVk3\n"
-"/AszGcJ3f8wQLZU0HObrTQmnHNK4yZc2AreJ1CRfBsDMRJSUjQJib+ta3RGNKJpchJAQeg29\n"
-"dGYvajig4tVUROsdB58Hum/u6f1OCyn1PoSgAfGcq/gcfomk6KHYcWUNo1F77rzSImANuVud\n"
-"37r8UVsLr5iy6S7pBOhih94ryNdOwUxkHt3Ph1i6Sk/KaAcdHJ1KxtUvkcx8cXIcxcBn6zL9\n"
-"yZJclNqFwJu/U30rCfSMnZEfl2pSy94JNqR32HuHUETVPm4pafs5SSYeCaWAe0At6+gnhcn+\n"
-"Yf1+5nyXHdWdAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgEGMB0G\n"
-"A1UdDgQWBBR7W0XPr87Lev0xkhpqtvNG61dIUDANBgkqhkiG9w0BAQUFAAOCAQEAeRHAS7OR\n"
-"tvzw6WfUDW5FvlXok9LOAz/t2iWwHVfLHjp2oEzsUHboZHIMpKnxuIvW1oeEuzLlQRHAd9mz\n"
-"YJ3rG9XRbkREqaYB7FViHXe4XI5ISXycO1cRrK1zN44veFyQaEfZYGDm/Ac9IiAXxPcW6cTY\n"
-"cvnIc3zfFi8VqT79aie2oetaupgf1eNNZAqdE8hhuvU5HIe6uL17In/2/qxAeeWsEG89jxt5\n"
-"dovEN7MhGITlNgDrYyCZuen+MwS7QcjBAvlEYyCegc5C09Y/LHbTY5xZ3Y+m4Q6gLkH3LpVH\n"
-"z7z9M/P2C2F+fpErgUfCJzDupxBdN49cOSvkBPB7jVaMaA==\n"
-"-----END CERTIFICATE-----\n",
-
-/* VeriSign Class 3 Public Primary Certification Authority - G5 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIE0zCCA7ugAwIBAgIQGNrRniZ96LtKIVjNzGs7SjANBgkqhkiG9w0BAQUFADCByjELMAkG\n"
-"A1UEBhMCVVMxFzAVBgNVBAoTDlZlcmlTaWduLCBJbmMuMR8wHQYDVQQLExZWZXJpU2lnbiBU\n"
-"cnVzdCBOZXR3b3JrMTowOAYDVQQLEzEoYykgMjAwNiBWZXJpU2lnbiwgSW5jLiAtIEZvciBh\n"
-"dXRob3JpemVkIHVzZSBvbmx5MUUwQwYDVQQDEzxWZXJpU2lnbiBDbGFzcyAzIFB1YmxpYyBQ\n"
-"cmltYXJ5IENlcnRpZmljYXRpb24gQXV0aG9yaXR5IC0gRzUwHhcNMDYxMTA4MDAwMDAwWhcN\n"
-"MzYwNzE2MjM1OTU5WjCByjELMAkGA1UEBhMCVVMxFzAVBgNVBAoTDlZlcmlTaWduLCBJbmMu\n"
-"MR8wHQYDVQQLExZWZXJpU2lnbiBUcnVzdCBOZXR3b3JrMTowOAYDVQQLEzEoYykgMjAwNiBW\n"
-"ZXJpU2lnbiwgSW5jLiAtIEZvciBhdXRob3JpemVkIHVzZSBvbmx5MUUwQwYDVQQDEzxWZXJp\n"
-"U2lnbiBDbGFzcyAzIFB1YmxpYyBQcmltYXJ5IENlcnRpZmljYXRpb24gQXV0aG9yaXR5IC0g\n"
-"RzUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCvJAgIKXo1nmAMqudLO07cfLw8\n"
-"RRy7K+D+KQL5VwijZIUVJ/XxrcgxiV0i6CqqpkKzj/i5Vbext0uz/o9+B1fs70PbZmIVYc9g\n"
-"DaTY3vjgw2IIPVQT60nKWVSFJuUrjxuf6/WhkcIzSdhDY2pSS9KP6HBRTdGJaXvHcPaz3BJ0\n"
-"23tdS1bTlr8Vd6Gw9KIl8q8ckmcY5fQGBO+QueQA5N06tRn/Arr0PO7gi+s3i+z016zy9vA9\n"
-"r911kTMZHRxAy3QkGSGT2RT+rCpSx4/VBEnkjWNHiDxpg8v+R70rfk/Fla4OndTRQ8Bnc+MU\n"
-"CH7lP59zuDMKz10/NIeWiu5T6CUVAgMBAAGjgbIwga8wDwYDVR0TAQH/BAUwAwEB/zAOBgNV\n"
-"HQ8BAf8EBAMCAQYwbQYIKwYBBQUHAQwEYTBfoV2gWzBZMFcwVRYJaW1hZ2UvZ2lmMCEwHzAH\n"
-"BgUrDgMCGgQUj+XTGoasjY5rw8+AatRIGCx7GS4wJRYjaHR0cDovL2xvZ28udmVyaXNpZ24u\n"
-"Y29tL3ZzbG9nby5naWYwHQYDVR0OBBYEFH/TZafC3ey78DAJ80M5+gKvMzEzMA0GCSqGSIb3\n"
-"DQEBBQUAA4IBAQCTJEowX2LP2BqYLz3q3JktvXf2pXkiOOzEp6B4Eq1iDkVwZMXnl2YtmAl+\n"
-"X6/WzChl8gGqCBpH3vn5fJJaCGkgDdk+bW48DW7Y5gaRQBi5+MHt39tBquCWIMnNZBU4gcmU\n"
-"7qKEKQsTb47bDN0lAtukixlE0kF6BWlKWE9gyn6CagsCqiUXObXbf+eEZSqVir2G3l6BFoMt\n"
-"EMze/aiCKm0oHw0LxOXnGiYZ4fQRbxC1lfznQgUy286dUV4otp6F01vvpX1FQHKOtw5rDgb7\n"
-"MzVIcbidJ4vEZV8NhnacRHr2lVz2XTIIM6RUthg/aFzyQkqFOFSDX9HoLPKsEdao7WNq\n"
-"-----END CERTIFICATE-----\n",
-
-/* SecureTrust CA */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDuDCCAqCgAwIBAgIQDPCOXAgWpa1Cf/DrJxhZ0DANBgkqhkiG9w0BAQUFADBIMQswCQYD\n"
-"VQQGEwJVUzEgMB4GA1UEChMXU2VjdXJlVHJ1c3QgQ29ycG9yYXRpb24xFzAVBgNVBAMTDlNl\n"
-"Y3VyZVRydXN0IENBMB4XDTA2MTEwNzE5MzExOFoXDTI5MTIzMTE5NDA1NVowSDELMAkGA1UE\n"
-"BhMCVVMxIDAeBgNVBAoTF1NlY3VyZVRydXN0IENvcnBvcmF0aW9uMRcwFQYDVQQDEw5TZWN1\n"
-"cmVUcnVzdCBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAKukgeWVzfX2FI7C\n"
-"T8rU4niVWJxB4Q2ZQCQXOZEzZum+4YOvYlyJ0fwkW2Gz4BERQRwdbvC4u/jep4G6pkjGnx29\n"
-"vo6pQT64lO0pGtSO0gMdA+9tDWccV9cGrcrI9f4Or2YlSASWC12juhbDCE/RRvgUXPLIXgGZ\n"
-"bf2IzIaowW8xQmxSPmjL8xk037uHGFaAJsTQ3MBv396gwpEWoGQRS0S8Hvbn+mPeZqx2pHGj\n"
-"7DaUaHp3pLHnDi+BeuK1cobvomuL8A/b01k/unK8RCSc43Oz969XL0Imnal0ugBS8kvNU3xH\n"
-"CzaFDmapCJcWNFfBZveA4+1wVMeT4C4oFVmHursCAwEAAaOBnTCBmjATBgkrBgEEAYI3FAIE\n"
-"Bh4EAEMAQTALBgNVHQ8EBAMCAYYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUQjK2FvoE\n"
-"/f5dS3rD/fdMQB1aQ68wNAYDVR0fBC0wKzApoCegJYYjaHR0cDovL2NybC5zZWN1cmV0cnVz\n"
-"dC5jb20vU1RDQS5jcmwwEAYJKwYBBAGCNxUBBAMCAQAwDQYJKoZIhvcNAQEFBQADggEBADDt\n"
-"T0rhWDpSclu1pqNlGKa7UTt36Z3q059c4EVlew3KW+JwULKUBRSuSceNQQcSc5R+DCMh/bwQ\n"
-"f2AQWnL1mA6s7Ll/3XpvXdMc9P+IBWlCqQVxyLesJugutIxq/3HcuLHfmbx8IVQr5Fiiu1cp\n"
-"rp6poxkmD5kuCLDv/WnPmRoJjeOnnyvJNjR7JLN4TJUXpAYmHrZkUjZfYGfZnMUFdAvnZyPS\n"
-"CPyI6a6Lf+Ew9Dd+/cYy2i2eRDAwbO4H3tI0/NL/QPZL9GZGBlSm8jIKYyYwa5vR3ItHuuG5\n"
-"1WLQoqD0ZwV4KWMabwTW+MZMo5qxN7SN5ShLHZ4swrhovO0C7jE=\n"
-"-----END CERTIFICATE-----\n",
-
-/* Secure Global CA */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDvDCCAqSgAwIBAgIQB1YipOjUiolN9BPI8PjqpTANBgkqhkiG9w0BAQUFADBKMQswCQYD\n"
-"VQQGEwJVUzEgMB4GA1UEChMXU2VjdXJlVHJ1c3QgQ29ycG9yYXRpb24xGTAXBgNVBAMTEFNl\n"
-"Y3VyZSBHbG9iYWwgQ0EwHhcNMDYxMTA3MTk0MjI4WhcNMjkxMjMxMTk1MjA2WjBKMQswCQYD\n"
-"VQQGEwJVUzEgMB4GA1UEChMXU2VjdXJlVHJ1c3QgQ29ycG9yYXRpb24xGTAXBgNVBAMTEFNl\n"
-"Y3VyZSBHbG9iYWwgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCvNS7YrGxV\n"
-"aQZx5RNoJLNP2MwhR/jxYDiJiQPpvepeRlMJ3Fz1Wuj3RSoC6zFh1ykzTM7HfAo3fg+6Mpjh\n"
-"HZevj8fcyTiW89sa/FHtaMbQbqR8JNGuQsiWUGMu4P51/pinX0kuleM5M2SOHqRfkNJnPLLZ\n"
-"/kG5VacJjnIFHovdRIWCQtBJwB1g8NEXLJXr9qXBkqPFwqcIYA1gBBCWeZ4WNOaptvolRTnI\n"
-"HmX5k/Wq8VLcmZg9pYYaDDUz+kulBAYVHDGA76oYa8J719rO+TMg1fW9ajMtgQT7sFzUnKPi\n"
-"XB3jqUJ1XnvUd+85VLrJChgbEplJL4hL/VBi0XPnj3pDAgMBAAGjgZ0wgZowEwYJKwYBBAGC\n"
-"NxQCBAYeBABDAEEwCwYDVR0PBAQDAgGGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFK9E\n"
-"BMJBfkiD2045AuzshHrmzsmkMDQGA1UdHwQtMCswKaAnoCWGI2h0dHA6Ly9jcmwuc2VjdXJl\n"
-"dHJ1c3QuY29tL1NHQ0EuY3JsMBAGCSsGAQQBgjcVAQQDAgEAMA0GCSqGSIb3DQEBBQUAA4IB\n"
-"AQBjGghAfaReUw132HquHw0LURYD7xh8yOOvaliTFGCRsoTciE6+OYo68+aCiV0BN7OrJKQV\n"
-"DpI1WkpEXk5X+nXOH0jOZvQ8QCaSmGwb7iRGDBezUqXbpZGRzzfTb+cnCDpOGR86p1hcF895\n"
-"P4vkp9MmI50mD1hp/Ed+stCNi5O/KU9DaXR2Z0vPB4zmAve14bRDtUstFJ/53CYNv6ZHdAbY\n"
-"iNE6KTCEztI5gGIbqMdXSbxqVVFnFUq+NQfk1XWYN3kwFNspnWzFacxHVaIw98xcf8LDmBxr\n"
-"ThaA63p4ZUWiABqvDA1VZDRIuJK58bRQKfJPIx/abKwfROHdI3hRW8cW\n"
-"-----END CERTIFICATE-----\n",
-
-/* COMODO Certification Authority */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIEHTCCAwWgAwIBAgIQToEtioJl4AsC7j41AkblPTANBgkqhkiG9w0BAQUFADCBgTELMAkG\n"
-"A1UEBhMCR0IxGzAZBgNVBAgTEkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4GA1UEBxMHU2FsZm9y\n"
-"ZDEaMBgGA1UEChMRQ09NT0RPIENBIExpbWl0ZWQxJzAlBgNVBAMTHkNPTU9ETyBDZXJ0aWZp\n"
-"Y2F0aW9uIEF1dGhvcml0eTAeFw0wNjEyMDEwMDAwMDBaFw0yOTEyMzEyMzU5NTlaMIGBMQsw\n"
-"CQYDVQQGEwJHQjEbMBkGA1UECBMSR3JlYXRlciBNYW5jaGVzdGVyMRAwDgYDVQQHEwdTYWxm\n"
-"b3JkMRowGAYDVQQKExFDT01PRE8gQ0EgTGltaXRlZDEnMCUGA1UEAxMeQ09NT0RPIENlcnRp\n"
-"ZmljYXRpb24gQXV0aG9yaXR5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA0ECL\n"
-"i3LjkRv3UcEbVASY06m/weaKXTuH+7uIzg3jLz8GlvCiKVCZrts7oVewdFFxze1CkU1B/qnI\n"
-"2GqGd0S7WWaXUF601CxwRM/aN5VCaTwwxHGzUvAhTaHYujl8HJ6jJJ3ygxaYqhZ8Q5sVW7eu\n"
-"NJH+1GImGEaaP+vB+fGQV+useg2L23IwambV4EajcNxo2f8ESIl33rXp+2dtQem8Ob0y2WIC\n"
-"8bGoPW43nOIv4tOiJovGuFVDiOEjPqXSJDlqR6sA1KGzqSX+DT+nHbrTUcELpNqsOO9VUCQF\n"
-"ZUaTNE8tja3G1CEZ0o7KBWFxB3NH5YoZEr0ETc5OnKVIrLsm9wIDAQABo4GOMIGLMB0GA1Ud\n"
-"DgQWBBQLWOWLxkwVN6RAqTCpIb5HNlpW/zAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUw\n"
-"AwEB/zBJBgNVHR8EQjBAMD6gPKA6hjhodHRwOi8vY3JsLmNvbW9kb2NhLmNvbS9DT01PRE9D\n"
-"ZXJ0aWZpY2F0aW9uQXV0aG9yaXR5LmNybDANBgkqhkiG9w0BAQUFAAOCAQEAPpiem/Yb6dc5\n"
-"t3iuHXIYSdOH5EOC6z/JqvWote9VfCFSZfnVDeFs9D6Mk3ORLgLETgdxb8CPOGEIqB6BCsAv\n"
-"IC9Bi5HcSEW88cbeunZrM8gALTFGTO3nnc+IlP8zwFboJIYmuNg4ON8qa90SzMc/RxdMosIG\n"
-"lgnW2/4/PEZB31jiVg88O8EckzXZOFKs7sjsLjBOlDW0JB9LeGna8gI4zJVSk/BwJVmcIGfE\n"
-"7vmLV2H0knZ9P4SNVbfo5azV8fUZVqZa+5Acr5Pr5RzUZ5ddBA6+C4OmF4O5MBKgxTMVBbkN\n"
-"+8cFduPYSo38NBejxiEovjBFMR7HeL5YYTisO+IBZQ==\n"
-"-----END CERTIFICATE-----\n",
-
-/* Network Solutions Certificate Authority */
-"-----BEGIN CERTIFICATE-----\n"
-"MIID5jCCAs6gAwIBAgIQV8szb8JcFuZHFhfjkDFo4DANBgkqhkiG9w0BAQUFADBiMQswCQYD\n"
-"VQQGEwJVUzEhMB8GA1UEChMYTmV0d29yayBTb2x1dGlvbnMgTC5MLkMuMTAwLgYDVQQDEydO\n"
-"ZXR3b3JrIFNvbHV0aW9ucyBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkwHhcNMDYxMjAxMDAwMDAw\n"
-"WhcNMjkxMjMxMjM1OTU5WjBiMQswCQYDVQQGEwJVUzEhMB8GA1UEChMYTmV0d29yayBTb2x1\n"
-"dGlvbnMgTC5MLkMuMTAwLgYDVQQDEydOZXR3b3JrIFNvbHV0aW9ucyBDZXJ0aWZpY2F0ZSBB\n"
-"dXRob3JpdHkwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDkvH6SMG3G2I4rC7xG\n"
-"zuAnlt7e+foS0zwzc7MEL7xxjOWftiJgPl9dzgn/ggwbmlFQGiaJ3dVhXRncEg8tCqJDXRfQ\n"
-"NJIg6nPPOCwGJgl6cvf6UDL4wpPTaaIjzkGxzOTVHzbRijr4jGPiFFlp7Q3Tf2vouAPlT2rl\n"
-"mGNpSAW+Lv8ztumXWWn4Zxmuk2GWRBXTcrA/vGp97Eh/jcOrqnErU2lBUzS1sLnFBgrEsEX1\n"
-"QV1uiUV7PTsmjHTC5dLRfbIR1PtYMiKagMnc/Qzpf14Dl847ABSHJ3A4qY5usyd2mFHgBeMh\n"
-"qxrVhSI8KbWaFsWAqPS7azCPL0YCorEMIuDTAgMBAAGjgZcwgZQwHQYDVR0OBBYEFCEwyfsA\n"
-"106Y2oeqKtCnLrFAMadMMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MFIGA1Ud\n"
-"HwRLMEkwR6BFoEOGQWh0dHA6Ly9jcmwubmV0c29sc3NsLmNvbS9OZXR3b3JrU29sdXRpb25z\n"
-"Q2VydGlmaWNhdGVBdXRob3JpdHkuY3JsMA0GCSqGSIb3DQEBBQUAA4IBAQC7rkvnt1frf6ot\n"
-"t3NHhWrB5KUd5Oc86fRZZXe1eltajSU24HqXLjjAV2CDmAaDn7l2em5Q4LqILPxFzBiwmZVR\n"
-"DuwduIj/h1AcgsLj4DKAv6ALR8jDMe+ZZzKATxcheQxpXN5eNK4CtSbqUN9/GGUsyfJj4akH\n"
-"/nxxH2szJGoeBfcFaMBqEssuXmHLrijTfsK0ZpEmXzwuJF/LWA/rKOyvEZbz3HtvwKeI8lN3\n"
-"s2Berq4o2jUsbzRF0ybh3uxbTydrFny9RAQYgrOJeRcQcT16ohZO9QHNpGxlaKFJdlxDydi8\n"
-"NmdspZS11My5vWo1ViHe2MPr+8ukYEywVaCge1ey\n"
-"-----END CERTIFICATE-----\n",
-
-/* WellsSecure Public Root Certificate Authority */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIEvTCCA6WgAwIBAgIBATANBgkqhkiG9w0BAQUFADCBhTELMAkGA1UEBhMCVVMxIDAeBgNV\n"
-"BAoMF1dlbGxzIEZhcmdvIFdlbGxzU2VjdXJlMRwwGgYDVQQLDBNXZWxscyBGYXJnbyBCYW5r\n"
-"IE5BMTYwNAYDVQQDDC1XZWxsc1NlY3VyZSBQdWJsaWMgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRo\n"
-"b3JpdHkwHhcNMDcxMjEzMTcwNzU0WhcNMjIxMjE0MDAwNzU0WjCBhTELMAkGA1UEBhMCVVMx\n"
-"IDAeBgNVBAoMF1dlbGxzIEZhcmdvIFdlbGxzU2VjdXJlMRwwGgYDVQQLDBNXZWxscyBGYXJn\n"
-"byBCYW5rIE5BMTYwNAYDVQQDDC1XZWxsc1NlY3VyZSBQdWJsaWMgUm9vdCBDZXJ0aWZpY2F0\n"
-"ZSBBdXRob3JpdHkwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDub7S9eeKPCCGe\n"
-"OARBJe+rWxxTkqxtnt3CxC5FlAM1iGd0V+PfjLindo8796jE2yljDpFoNoqXjopxaAkH5OjU\n"
-"Dk/41itMpBb570OYj7OeUt9tkTmPOL13i0Nj67eT/DBMHAGTthP796EfvyXhdDcsHqRePGj4\n"
-"S78NuR4uNuip5Kf4D8uCdXw1LSLWwr8L87T8bJVhHlfXBIEyg1J55oNjz7fLY4sR4r1e6/aN\n"
-"7ZVyKLSsEmLpSjPmgzKuBXWVvYSV2ypcm44uDLiBK0HmOFafSZtsdvqKXfcBeYF8wYNABf5x\n"
-"/Qw/zE5gCQ5lRxAvAcAFP4/4s0HvWkJ+We/SlwxlAgMBAAGjggE0MIIBMDAPBgNVHRMBAf8E\n"
-"BTADAQH/MDkGA1UdHwQyMDAwLqAsoCqGKGh0dHA6Ly9jcmwucGtpLndlbGxzZmFyZ28uY29t\n"
-"L3dzcHJjYS5jcmwwDgYDVR0PAQH/BAQDAgHGMB0GA1UdDgQWBBQmlRkQ2eihl5H/3BnZtQQ+\n"
-"0nMKajCBsgYDVR0jBIGqMIGngBQmlRkQ2eihl5H/3BnZtQQ+0nMKaqGBi6SBiDCBhTELMAkG\n"
-"A1UEBhMCVVMxIDAeBgNVBAoMF1dlbGxzIEZhcmdvIFdlbGxzU2VjdXJlMRwwGgYDVQQLDBNX\n"
-"ZWxscyBGYXJnbyBCYW5rIE5BMTYwNAYDVQQDDC1XZWxsc1NlY3VyZSBQdWJsaWMgUm9vdCBD\n"
-"ZXJ0aWZpY2F0ZSBBdXRob3JpdHmCAQEwDQYJKoZIhvcNAQEFBQADggEBALkVsUSRzCPIK013\n"
-"4/iaeycNzXK7mQDKfGYZUMbVmO2rvwNa5U3lHshPcZeG1eMd/ZDJPHV3V3p9+N701NX3leZ0\n"
-"bh08rnyd2wIDBSxxSyU+B+NemvVmFymIGjifz6pBA4SXa5M4esowRBskRDPQ5NHcKDj0E0M1\n"
-"NSljqHyita04pO2t/caaH/+Xc/77szWnk4bGdpEA5qxRFsQnMlzbc9qlk1eOPm01JghZ1edE\n"
-"13YgY+esE2fDbbFwRnzVlhE9iW9dqKHrjQrawx0zbKPqZxmamX9LPYNRKh3KL4YMon4QLSvU\n"
-"FpULB6ouFJJJtylv2G0xffX8oRAHh84vWdw+WNs=\n"
-"-----END CERTIFICATE-----\n",
-
-/* COMODO ECC Certification Authority */
-"-----BEGIN CERTIFICATE-----\n"
-"MIICiTCCAg+gAwIBAgIQH0evqmIAcFBUTAGem2OZKjAKBggqhkjOPQQDAzCBhTELMAkGA1UE\n"
-"BhMCR0IxGzAZBgNVBAgTEkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4GA1UEBxMHU2FsZm9yZDEa\n"
-"MBgGA1UEChMRQ09NT0RPIENBIExpbWl0ZWQxKzApBgNVBAMTIkNPTU9ETyBFQ0MgQ2VydGlm\n"
-"aWNhdGlvbiBBdXRob3JpdHkwHhcNMDgwMzA2MDAwMDAwWhcNMzgwMTE4MjM1OTU5WjCBhTEL\n"
-"MAkGA1UEBhMCR0IxGzAZBgNVBAgTEkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4GA1UEBxMHU2Fs\n"
-"Zm9yZDEaMBgGA1UEChMRQ09NT0RPIENBIExpbWl0ZWQxKzApBgNVBAMTIkNPTU9ETyBFQ0Mg\n"
-"Q2VydGlmaWNhdGlvbiBBdXRob3JpdHkwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAAQDR3svdcmC\n"
-"FYX7deSRFtSrYpn1PlILBs5BAH+X4QokPB0BBO490o0JlwzgdeT6+3eKKvUDYEs2ixYjFq0J\n"
-"cfRK9ChQtP6IHG4/bC8vCVlbpVsLM5niwz2J+Wos77LTBumjQjBAMB0GA1UdDgQWBBR1cacZ\n"
-"SBm8nZ3qQUfflMRId5nTeTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAKBggq\n"
-"hkjOPQQDAwNoADBlAjEA7wNbeqy3eApyt4jf/7VGFAkK+qDmfQjGGoe9GKhzvSbKYAydzpmf\n"
-"z1wPMOG+FDHqAjAU9JM8SaczepBGR7NjfRObTrdvGDeAU/7dIOA1mjbRxwG55tzd8/8dLDoW\n"
-"V9mSOdY=\n"
-"-----END CERTIFICATE-----\n",
-
-/* IGC/A */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIEAjCCAuqgAwIBAgIFORFFEJQwDQYJKoZIhvcNAQEFBQAwgYUxCzAJBgNVBAYTAkZSMQ8w\n"
-"DQYDVQQIEwZGcmFuY2UxDjAMBgNVBAcTBVBhcmlzMRAwDgYDVQQKEwdQTS9TR0ROMQ4wDAYD\n"
-"VQQLEwVEQ1NTSTEOMAwGA1UEAxMFSUdDL0ExIzAhBgkqhkiG9w0BCQEWFGlnY2FAc2dkbi5w\n"
-"bS5nb3V2LmZyMB4XDTAyMTIxMzE0MjkyM1oXDTIwMTAxNzE0MjkyMlowgYUxCzAJBgNVBAYT\n"
-"AkZSMQ8wDQYDVQQIEwZGcmFuY2UxDjAMBgNVBAcTBVBhcmlzMRAwDgYDVQQKEwdQTS9TR0RO\n"
-"MQ4wDAYDVQQLEwVEQ1NTSTEOMAwGA1UEAxMFSUdDL0ExIzAhBgkqhkiG9w0BCQEWFGlnY2FA\n"
-"c2dkbi5wbS5nb3V2LmZyMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsh/R0GLF\n"
-"MzvABIaIs9z4iPf930Pfeo2aSVz2TqrMHLmh6yeJ8kbpO0px1R2OLc/mratjUMdUC24SyZA2\n"
-"xtgv2pGqaMVy/hcKshd+ebUyiHDKcMCWSo7kVc0dJ5S/znIq7Fz5cyD+vfcuiWe4u0dzEvfR\n"
-"NWk68gq5rv9GQkaiv6GFGvm/5P9JhfejcIYyHF2fYPepraX/z9E0+X1bF8bc1g4oa8Ld8fUz\n"
-"aJ1O/Id8NhLWo4DoQw1VYZTqZDdH6nfK0LJYBcNdfrGoRpAxVs5wKpayMLh35nnAvSk7/ZR3\n"
-"TL0gzUEl4C7HG7vupARB0l2tEmqKm0f7yd1GQOGdPDPQtQIDAQABo3cwdTAPBgNVHRMBAf8E\n"
-"BTADAQH/MAsGA1UdDwQEAwIBRjAVBgNVHSAEDjAMMAoGCCqBegF5AQEBMB0GA1UdDgQWBBSj\n"
-"BS8YYFDCiQrdKyFP/45OqDAxNjAfBgNVHSMEGDAWgBSjBS8YYFDCiQrdKyFP/45OqDAxNjAN\n"
-"BgkqhkiG9w0BAQUFAAOCAQEABdwm2Pp3FURo/C9mOnTgXeQp/wYHE4RKq89toB9RlPhJy3Q2\n"
-"FLwV3duJL92PoF189RLrn544pEfMs5bZvpwlqwN+Mw+VgQ39FuCIvjfwbF3QMZsyK10XZZOY\n"
-"YLxuj7GoPB7ZHPOpJkL5ZB3C55L29B5aqhlSXa/oovdgoPaN8In1buAKBQGVyYsgCrpa/Jos\n"
-"PL3Dt8ldeCUFP1YUmwza+zpI/pdpXsoQhvdOlgQITeywvl3cO45Pwf2aNjSaTFR+FwNIlQgR\n"
-"HAdvhQh+XU3Endv7rs6y0bO4g2wdsrN58dhwmX7wEwLOXt1R0982gaEbeC9xs/FZTEYYKKuF\n"
-"0mBWWg==\n"
-"-----END CERTIFICATE-----\n",
-
-/* Security Communication EV RootCA1 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDfTCCAmWgAwIBAgIBADANBgkqhkiG9w0BAQUFADBgMQswCQYDVQQGEwJKUDElMCMGA1UE\n"
-"ChMcU0VDT00gVHJ1c3QgU3lzdGVtcyBDTy4sTFRELjEqMCgGA1UECxMhU2VjdXJpdHkgQ29t\n"
-"bXVuaWNhdGlvbiBFViBSb290Q0ExMB4XDTA3MDYwNjAyMTIzMloXDTM3MDYwNjAyMTIzMlow\n"
-"YDELMAkGA1UEBhMCSlAxJTAjBgNVBAoTHFNFQ09NIFRydXN0IFN5c3RlbXMgQ08uLExURC4x\n"
-"KjAoBgNVBAsTIVNlY3VyaXR5IENvbW11bmljYXRpb24gRVYgUm9vdENBMTCCASIwDQYJKoZI\n"
-"hvcNAQEBBQADggEPADCCAQoCggEBALx/7FebJOD+nLpCeamIivqA4PUHKUPqjgo0No0c+qe1\n"
-"OXj/l3X3L+SqawSERMqm4miO/VVQYg+kcQ7OBzgtQoVQrTyWb4vVog7P3kmJPdZkLjjlHmy1\n"
-"V4qe70gOzXppFodEtZDkBp2uoQSXWHnvIEqCa4wiv+wfD+mEce3xDuS4GBPMVjZd0ZoeUWs5\n"
-"bmB2iDQL87PRsJ3KYeJkHcFGB7hj3R4zZbOOCVVSPbW9/wfrrWFVGCypaZhKqkDFMxRldAD5\n"
-"kd6vA0jFQFTcD4SQaCDFkpbcLuUCRarAX1T4bepJz11sS6/vmsJWXMY1VkJqMF/Cq/biPT+z\n"
-"yRGPMUzXn0kCAwEAAaNCMEAwHQYDVR0OBBYEFDVK9U2vP9eCOKyrcWUXdYydVZPmMA4GA1Ud\n"
-"DwEB/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3DQEBBQUAA4IBAQCoh+ns+EBn\n"
-"XcPBZsdAS5f8hxOQWsTvoMpfi7ent/HWtWS3irO4G8za+6xmiEHO6Pzk2x6Ipu0nUBsCMCRG\n"
-"ef4Eh3CXQHPRwMFXGZpppSeZq51ihPZRwSzJIxXYKLerJRO1RuGGAv8mjMSIkh1W/hln8lXk\n"
-"gKNrnKt34VFxDSDbEJrbvXZ5B3eZKK2aXtqxT0QsNY6llsf9g/BYxnnWmHyojf6GPgcWkuF7\n"
-"5x3sM3Z+Qi5KhfmRiWiEA4Glm5q+4zfFVKtWOxgtQaQM+ELbmaDgcm+7XeEWT1MKZPlO9L9O\n"
-"VL14bIjqv5wTJMJwaaJ/D8g8rQjJsJhAoyrniIPtd490\n"
-"-----END CERTIFICATE-----\n",
-
-/* OISTE WISeKey Global Root GA CA */
-"-----BEGIN CERTIFICATE-----\n"
-"MIID8TCCAtmgAwIBAgIQQT1yx/RrH4FDffHSKFTfmjANBgkqhkiG9w0BAQUFADCBijELMAkG\n"
-"A1UEBhMCQ0gxEDAOBgNVBAoTB1dJU2VLZXkxGzAZBgNVBAsTEkNvcHlyaWdodCAoYykgMjAw\n"
-"NTEiMCAGA1UECxMZT0lTVEUgRm91bmRhdGlvbiBFbmRvcnNlZDEoMCYGA1UEAxMfT0lTVEUg\n"
-"V0lTZUtleSBHbG9iYWwgUm9vdCBHQSBDQTAeFw0wNTEyMTExNjAzNDRaFw0zNzEyMTExNjA5\n"
-"NTFaMIGKMQswCQYDVQQGEwJDSDEQMA4GA1UEChMHV0lTZUtleTEbMBkGA1UECxMSQ29weXJp\n"
-"Z2h0IChjKSAyMDA1MSIwIAYDVQQLExlPSVNURSBGb3VuZGF0aW9uIEVuZG9yc2VkMSgwJgYD\n"
-"VQQDEx9PSVNURSBXSVNlS2V5IEdsb2JhbCBSb290IEdBIENBMIIBIjANBgkqhkiG9w0BAQEF\n"
-"AAOCAQ8AMIIBCgKCAQEAy0+zAJs9Nt350UlqaxBJH+zYK7LG+DKBKUOVTJoZIyEVRd7jyBxR\n"
-"VVuuk+g3/ytr6dTqvirdqFEr12bDYVxgAsj1znJ7O7jyTmUIms2kahnBAbtzptf2w93NvKSL\n"
-"tZlhuAGio9RN1AU9ka34tAhxZK9w8RxrfvbDd50kc3vkDIzh2TbhmYsFmQvtRTEJysIA2/dy\n"
-"oJaqlYfQjse2YXMNdmaM3Bu0Y6Kff5MTMPGhJ9vZ/yxViJGg4E8HsChWjBgbl0SOid3gF27n\n"
-"Ku+POQoxhILYQBRJLnpB5Kf+42TMwVlxSywhp1t94B3RLoGbw9ho972WG6xwsRYUC9tguSYB\n"
-"BQIDAQABo1EwTzALBgNVHQ8EBAMCAYYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUswN+\n"
-"rja8sHnR3JQmthG+IbJphpQwEAYJKwYBBAGCNxUBBAMCAQAwDQYJKoZIhvcNAQEFBQADggEB\n"
-"AEuh/wuHbrP5wUOxSPMowB0uyQlB+pQAHKSkq0lPjz0e701vvbyk9vImMMkQyh2I+3QZH4VF\n"
-"vbBsUfk2ftv1TDI6QU9bR8/oCy22xBmddMVHxjtqD6wU2zz0c5ypBd8A3HR4+vg1YFkCExh8\n"
-"vPtNsCBtQ7tgMHpnM1zFmdH4LTlSc/uMqpclXHLZCB6rTjzjgTGfA6b7wP4piFXahNVQA7bi\n"
-"hKOmNqoROgHhGEvWRGizPflTdISzRpFGlgC3gCy24eMQ4tui5yiPAZZiFj4A4xylNoEYokxS\n"
-"dsARo27mHbrjWr42U8U+dY+GaSlYU7Wcu2+fXMUY7N0v4ZjJ/L7fCg0=\n"
-"-----END CERTIFICATE-----\n",
-
-/* Microsec e-Szigno Root CA */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIHqDCCBpCgAwIBAgIRAMy4579OKRr9otxmpRwsDxEwDQYJKoZIhvcNAQEFBQAwcjELMAkG\n"
-"A1UEBhMCSFUxETAPBgNVBAcTCEJ1ZGFwZXN0MRYwFAYDVQQKEw1NaWNyb3NlYyBMdGQuMRQw\n"
-"EgYDVQQLEwtlLVN6aWdubyBDQTEiMCAGA1UEAxMZTWljcm9zZWMgZS1Temlnbm8gUm9vdCBD\n"
-"QTAeFw0wNTA0MDYxMjI4NDRaFw0xNzA0MDYxMjI4NDRaMHIxCzAJBgNVBAYTAkhVMREwDwYD\n"
-"VQQHEwhCdWRhcGVzdDEWMBQGA1UEChMNTWljcm9zZWMgTHRkLjEUMBIGA1UECxMLZS1Temln\n"
-"bm8gQ0ExIjAgBgNVBAMTGU1pY3Jvc2VjIGUtU3ppZ25vIFJvb3QgQ0EwggEiMA0GCSqGSIb3\n"
-"DQEBAQUAA4IBDwAwggEKAoIBAQDtyADVgXvNOABHzNuEwSFpLHSQDCHZU4ftPkNEU6+r+ICb\n"
-"PHiN1I2uuO/TEdyB5s87lozWbxXGd36hL+BfkrYn13aaHUM86tnsL+4582pnS4uCzyL4ZVX+\n"
-"LMsvfUh6PXX5qqAnu3jCBspRwn5mS6/NoqdNAoI/gqyFxuEPkEeZlApxcpMqyabAvjxWTHOS\n"
-"J/FrtfX9/DAFYJLG65Z+AZHCabEeHXtTRbjcQR/Ji3HWVBTji1R4P770Yjtb9aPs1ZJ04nQw\n"
-"7wHb4dSrmZsqa/i9phyGI0Jf7Enemotb9HI6QMVJPqW+jqpx62z69Rrkav17fVVA71hu5tnV\n"
-"vCSrwe+3AgMBAAGjggQ3MIIEMzBnBggrBgEFBQcBAQRbMFkwKAYIKwYBBQUHMAGGHGh0dHBz\n"
-"Oi8vcmNhLmUtc3ppZ25vLmh1L29jc3AwLQYIKwYBBQUHMAKGIWh0dHA6Ly93d3cuZS1zemln\n"
-"bm8uaHUvUm9vdENBLmNydDAPBgNVHRMBAf8EBTADAQH/MIIBcwYDVR0gBIIBajCCAWYwggFi\n"
-"BgwrBgEEAYGoGAIBAQEwggFQMCgGCCsGAQUFBwIBFhxodHRwOi8vd3d3LmUtc3ppZ25vLmh1\n"
-"L1NaU1ovMIIBIgYIKwYBBQUHAgIwggEUHoIBEABBACAAdABhAG4A+gBzAO0AdAB2AOEAbgB5\n"
-"ACAA6QByAHQAZQBsAG0AZQB6AOkAcwDpAGgAZQB6ACAA6QBzACAAZQBsAGYAbwBnAGEAZADh\n"
-"AHMA4QBoAG8AegAgAGEAIABTAHoAbwBsAGcA4QBsAHQAYQB0APMAIABTAHoAbwBsAGcA4QBs\n"
-"AHQAYQB0AOEAcwBpACAAUwB6AGEAYgDhAGwAeQB6AGEAdABhACAAcwB6AGUAcgBpAG4AdAAg\n"
-"AGsAZQBsAGwAIABlAGwAagDhAHIAbgBpADoAIABoAHQAdABwADoALwAvAHcAdwB3AC4AZQAt\n"
-"AHMAegBpAGcAbgBvAC4AaAB1AC8AUwBaAFMAWgAvMIHIBgNVHR8EgcAwgb0wgbqggbeggbSG\n"
-"IWh0dHA6Ly93d3cuZS1zemlnbm8uaHUvUm9vdENBLmNybIaBjmxkYXA6Ly9sZGFwLmUtc3pp\n"
-"Z25vLmh1L0NOPU1pY3Jvc2VjJTIwZS1Temlnbm8lMjBSb290JTIwQ0EsT1U9ZS1Temlnbm8l\n"
-"MjBDQSxPPU1pY3Jvc2VjJTIwTHRkLixMPUJ1ZGFwZXN0LEM9SFU/Y2VydGlmaWNhdGVSZXZv\n"
-"Y2F0aW9uTGlzdDtiaW5hcnkwDgYDVR0PAQH/BAQDAgEGMIGWBgNVHREEgY4wgYuBEGluZm9A\n"
-"ZS1zemlnbm8uaHWkdzB1MSMwIQYDVQQDDBpNaWNyb3NlYyBlLVN6aWduw7MgUm9vdCBDQTEW\n"
-"MBQGA1UECwwNZS1TemlnbsOzIEhTWjEWMBQGA1UEChMNTWljcm9zZWMgS2Z0LjERMA8GA1UE\n"
-"BxMIQnVkYXBlc3QxCzAJBgNVBAYTAkhVMIGsBgNVHSMEgaQwgaGAFMegSXUWYYTbMUuE0vE3\n"
-"QJDvTtz3oXakdDByMQswCQYDVQQGEwJIVTERMA8GA1UEBxMIQnVkYXBlc3QxFjAUBgNVBAoT\n"
-"DU1pY3Jvc2VjIEx0ZC4xFDASBgNVBAsTC2UtU3ppZ25vIENBMSIwIAYDVQQDExlNaWNyb3Nl\n"
-"YyBlLVN6aWdubyBSb290IENBghEAzLjnv04pGv2i3GalHCwPETAdBgNVHQ4EFgQUx6BJdRZh\n"
-"hNsxS4TS8TdAkO9O3PcwDQYJKoZIhvcNAQEFBQADggEBANMTnGZjWS7KXHAM/IO8VbH0jgds\n"
-"ZifOwTsgqRy7RlRw7lrMoHfqaEQn6/Ip3Xep1fvj1KcExJW4C+FEaGAHQzAxQmHl7tnlJNUb\n"
-"3+FKG6qfx1/4ehHqE5MAyopYse7tDk2016g2JnzgOsHVV4Lxdbb9iV/a86g4nzUGCM4ilb7N\n"
-"1fy+W955a9x6qWVmvrElWl/tftOsRm1M9DKHtCAE4Gx4sHfRhUZLphK3dehKyVZs15KrnfVJ\n"
-"ONJPU+NVkBHbmJbGSfI+9J8b4PeI3CVimUTYc78/MPMMNz7UwiiAc7EBt51alhQBS6kRnSlq\n"
-"LtBdgcDPsiBDxwPgN05dCtxZICU=\n"
-"-----END CERTIFICATE-----\n",
-
-/* Certigna */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDqDCCApCgAwIBAgIJAP7c4wEPyUj/MA0GCSqGSIb3DQEBBQUAMDQxCzAJBgNVBAYTAkZS\n"
-"MRIwEAYDVQQKDAlEaGlteW90aXMxETAPBgNVBAMMCENlcnRpZ25hMB4XDTA3MDYyOTE1MTMw\n"
-"NVoXDTI3MDYyOTE1MTMwNVowNDELMAkGA1UEBhMCRlIxEjAQBgNVBAoMCURoaW15b3RpczER\n"
-"MA8GA1UEAwwIQ2VydGlnbmEwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDIaPHJ\n"
-"1tazNHUmgh7stL7qXOEm7RFHYeGifBZ4QCHkYJ5ayGPhxLGWkv8YbWkj4Sti993iNi+RB7lI\n"
-"zw7sebYs5zRLcAglozyHGxnygQcPOJAZ0xH+hrTy0V4eHpbNgGzOOzGTtvKg0KmVEn2lmsxr\n"
-"yIRWijOp5yIVUxbwzBfsV1/pogqYCd7jX5xv3EjjhQsVWqa6n6xI4wmy9/Qy3l40vhx4XUJb\n"
-"zg4ij02Q130yGLMLLGq/jj8UEYkgDncUtT2UCIf3JR7VsmAA7G8qKCVuKj4YYxclPz5EIBb2\n"
-"JsglrgVKtOdjLPOMFlN+XPsRGgjBRmKfIrjxwo1p3Po6WAbfAgMBAAGjgbwwgbkwDwYDVR0T\n"
-"AQH/BAUwAwEB/zAdBgNVHQ4EFgQUGu3+QTmQtCRZvgHyUtVF9lo53BEwZAYDVR0jBF0wW4AU\n"
-"Gu3+QTmQtCRZvgHyUtVF9lo53BGhOKQ2MDQxCzAJBgNVBAYTAkZSMRIwEAYDVQQKDAlEaGlt\n"
-"eW90aXMxETAPBgNVBAMMCENlcnRpZ25hggkA/tzjAQ/JSP8wDgYDVR0PAQH/BAQDAgEGMBEG\n"
-"CWCGSAGG+EIBAQQEAwIABzANBgkqhkiG9w0BAQUFAAOCAQEAhQMeknH2Qq/ho2Ge6/PAD/Kl\n"
-"1NqV5ta+aDY9fm4fTIrv0Q8hbV6lUmPOEvjvKtpv6zf+EwLHyzs+ImvaYS5/1HI93TDhHkxA\n"
-"GYwP15zRgzB7mFncfca5DClMoTOi62c6ZYTTluLtdkVwj7Ur3vkj1kluPBS1xp81HlDQwY9q\n"
-"cEQCYsuuHWhBp6pX6FOqB9IG9tUUBguRA3UsbHK1YZWaDYu5Def131TN3ubY1gkIl2PlwS6w\n"
-"t0QmwCbAr1UwnjvVNioZBPRcHv/PLLf/0P2HQBHVESO7SMAhqaQoLf0V+LBOK/QwWyH8EZE0\n"
-"vkHve52Xdf+XlcCWWC/qu0bXu+TZLg==\n"
-"-----END CERTIFICATE-----\n",
-
-/* Deutsche Telekom Root CA 2 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDnzCCAoegAwIBAgIBJjANBgkqhkiG9w0BAQUFADBxMQswCQYDVQQGEwJERTEcMBoGA1UE\n"
-"ChMTRGV1dHNjaGUgVGVsZWtvbSBBRzEfMB0GA1UECxMWVC1UZWxlU2VjIFRydXN0IENlbnRl\n"
-"cjEjMCEGA1UEAxMaRGV1dHNjaGUgVGVsZWtvbSBSb290IENBIDIwHhcNOTkwNzA5MTIxMTAw\n"
-"WhcNMTkwNzA5MjM1OTAwWjBxMQswCQYDVQQGEwJERTEcMBoGA1UEChMTRGV1dHNjaGUgVGVs\n"
-"ZWtvbSBBRzEfMB0GA1UECxMWVC1UZWxlU2VjIFRydXN0IENlbnRlcjEjMCEGA1UEAxMaRGV1\n"
-"dHNjaGUgVGVsZWtvbSBSb290IENBIDIwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIB\n"
-"AQCrC6M14IspFLEUha88EOQ5bzVdSq7d6mGNlUn0b2SjGmBmpKlAIoTZ1KXleJMOaAGtuU1c\n"
-"Os7TuKhCQN/Po7qCWWqSG6wcmtoIKyUn+WkjR/Hg6yx6m/UTAtB+NHzCnjwAWav12gz1Mjwr\n"
-"rFDa1sPeg5TKqAyZMg4ISFZbavva4VhYAUlfckE8FQYBjl2tqriTtM2e66foai1SNNs671x1\n"
-"Udrb8zH57nGYMsRUFUQM+ZtV7a3fGAigo4aKSe5TBY8ZTNXeWHmb0mocQqvF1afPaA+W5OFh\n"
-"mHZhyJF81j4A4pFQh+GdCuatl9Idxjp9y7zaAzTVjlsB9WoHtxa2bkp/AgMBAAGjQjBAMB0G\n"
-"A1UdDgQWBBQxw3kbuvVT1xfgiXotF2wKsyudMzAPBgNVHRMECDAGAQH/AgEFMA4GA1UdDwEB\n"
-"/wQEAwIBBjANBgkqhkiG9w0BAQUFAAOCAQEAlGRZrTlk5ynrE/5aw4sTV8gEJPB0d8Bg42f7\n"
-"6Ymmg7+Wgnxu1MM9756AbrsptJh6sTtU6zkXR34ajgv8HzFZMQSyzhfzLMdiNlXiItiJVbSY\n"
-"SKpk+tYcNthEeFpaIzpXl/V6ME+un2pMSyuOoAPjPuCp1NJ70rOo4nI8rZ7/gFnkm0W09juw\n"
-"zTkZmDLl6iFhkOQxIY40sfcvNUqFENrnijchvllj4PKFiDFT1FQUhXB59C4Gdyd1Lx+4ivn+\n"
-"xbrYNuSD7Odlt79jWvNGr4GUN9RBjNYj1h7P9WgbRGOiWrqnNVmh5XAFmw4jV5mUCm26OWMo\n"
-"hpLzGITY+9HPBVZkVw==\n"
-"-----END CERTIFICATE-----\n",
-
-/* Cybertrust Global Root */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDoTCCAomgAwIBAgILBAAAAAABD4WqLUgwDQYJKoZIhvcNAQEFBQAwOzEYMBYGA1UEChMP\n"
-"Q3liZXJ0cnVzdCwgSW5jMR8wHQYDVQQDExZDeWJlcnRydXN0IEdsb2JhbCBSb290MB4XDTA2\n"
-"MTIxNTA4MDAwMFoXDTIxMTIxNTA4MDAwMFowOzEYMBYGA1UEChMPQ3liZXJ0cnVzdCwgSW5j\n"
-"MR8wHQYDVQQDExZDeWJlcnRydXN0IEdsb2JhbCBSb290MIIBIjANBgkqhkiG9w0BAQEFAAOC\n"
-"AQ8AMIIBCgKCAQEA+Mi8vRRQZhP/8NN57CPytxrHjoXxEnOmGaoQ25yiZXRadz5RfVb23CO2\n"
-"1O1fWLE3TdVJDm71aofW0ozSJ8bi/zafmGWgE07GKmSb1ZASzxQG9Dvj1Ci+6A74q05IlG2O\n"
-"lTEQXO2iLb3VOm2yHLtgwEZLAfVJrn5GitB0jaEMAs7u/OePuGtm839EAL9mJRQr3RAwHQeW\n"
-"P032a7iPt3sMpTjr3kfb1V05/Iin89cqdPHoWqI7n1C6poxFNcJQZZXcY4Lv3b93TZxiyWNz\n"
-"FtApD0mpSPCzqrdsxacwOUBdrsTiXSZT8M4cIwhhqJQZugRiQOwfOHB3EgZxpzAYXSUnpQID\n"
-"AQABo4GlMIGiMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBS2\n"
-"CHsNesysIEyGVjJez6tuhS1wVzA/BgNVHR8EODA2MDSgMqAwhi5odHRwOi8vd3d3Mi5wdWJs\n"
-"aWMtdHJ1c3QuY29tL2NybC9jdC9jdHJvb3QuY3JsMB8GA1UdIwQYMBaAFLYIew16zKwgTIZW\n"
-"Ml7Pq26FLXBXMA0GCSqGSIb3DQEBBQUAA4IBAQBW7wojoFROlZfJ+InaRcHUowAl9B8Tq7ej\n"
-"hVhpwjCt2BWKLePJzYFa+HMjWqd8BfP9IjsO0QbE2zZMcwSO5bAi5MXzLqXZI+O4Tkogp24C\n"
-"JJ8iYGd7ix1yCcUxXOl5n4BHPa2hCwcUPUf/A2kaDAtE52Mlp3+yybh2hO0j9n0Hq0V+09+z\n"
-"v+mKts2oomcrUtW3ZfA5TGOgkXmTUg9U3YO7n9GPp1Nzw8v/MOx8BLjYRB+TX3EJIrduPuoc\n"
-"A06dGiBh+4E37F78CkWr1+cXVdCg6mCbpvbjjFspwgZgFJ0tl0ypkxWdYcQBX0jWWL1WMRJO\n"
-"Ecgh4LMRkWXbtKaIOM5V\n"
-"-----END CERTIFICATE-----\n",
-
-/* ePKI Root Certification Authority */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIFsDCCA5igAwIBAgIQFci9ZUdcr7iXAF7kBtK8nTANBgkqhkiG9w0BAQUFADBeMQswCQYD\n"
-"VQQGEwJUVzEjMCEGA1UECgwaQ2h1bmdod2EgVGVsZWNvbSBDby4sIEx0ZC4xKjAoBgNVBAsM\n"
-"IWVQS0kgUm9vdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTAeFw0wNDEyMjAwMjMxMjdaFw0z\n"
-"NDEyMjAwMjMxMjdaMF4xCzAJBgNVBAYTAlRXMSMwIQYDVQQKDBpDaHVuZ2h3YSBUZWxlY29t\n"
-"IENvLiwgTHRkLjEqMCgGA1UECwwhZVBLSSBSb290IENlcnRpZmljYXRpb24gQXV0aG9yaXR5\n"
-"MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA4SUP7o3biDN1Z82tH306Tm2d0y8U\n"
-"82N0ywEhajfqhFAHSyZbCUNsIZ5qyNUD9WBpj8zwIuQf5/dqIjG3LBXy4P4AakP/h2XGtRrB\n"
-"p0xtInAhijHyl3SJCRImHJ7K2RKilTza6We/CKBk49ZCt0Xvl/T29de1ShUCWH2YWEtgvM3X\n"
-"DZoTM1PRYfl61dd4s5oz9wCGzh1NlDivqOx4UXCKXBCDUSH3ET00hl7lSM2XgYI1TBnsZfZr\n"
-"xQWh7kcT1rMhJ5QQCtkkO7q+RBNGMD+XPNjX12ruOzjjK9SXDrkb5wdJfzcq+Xd4z1TtW0ad\n"
-"o4AOkUPB1ltfFLqfpo0kR0BZv3I4sjZsN/+Z0V0OWQqraffAsgRFelQArr5T9rXn4fg8ozHS\n"
-"qf4hUmTFpmfwdQcGlBSBVcYn5AGPF8Fqcde+S/uUWH1+ETOxQvdibBjWzwloPn9s9h6PYq2l\n"
-"Y9sJpx8iQkEeb5mKPtf5P0B6ebClAZLSnT0IFaUQAS2zMnaolQ2zepr7BxB4EW/hj8e6DyUa\n"
-"dCrlHJhBmd8hh+iVBmoKs2pHdmX2Os+PYhcZewoozRrSgx4hxyy/vv9haLdnG7t4TY3OZ+Xk\n"
-"wY63I2binZB1NJipNiuKmpS5nezMirH4JYlcWrYvjB9teSSnUmjDhDXiZo1jDiVN1Rmy5nk3\n"
-"pyKdVDECAwEAAaNqMGgwHQYDVR0OBBYEFB4M97Zn8uGSJglFwFU5Lnc/QkqiMAwGA1UdEwQF\n"
-"MAMBAf8wOQYEZyoHAAQxMC8wLQIBADAJBgUrDgMCGgUAMAcGBWcqAwAABBRFsMLHClZ87lt4\n"
-"DJX5GFPBphzYEDANBgkqhkiG9w0BAQUFAAOCAgEACbODU1kBPpVJufGBuvl2ICO1J2B01GqZ\n"
-"NF5sAFPZn/KmsSQHRGoqxqWOeBLoR9lYGxMqXnmbnwoqZ6YlPwZpVnPDimZI+ymBV3QGypzq\n"
-"KOg4ZyYr8dW1P2WT+DZdjo2NQCCHGervJ8A9tDkPJXtoUHRVnAxZfVo9QZQlUgjgRywVMRnV\n"
-"vwdVxrsStZf0X4OFunHB2WyBEXYKCrC/gpf36j36+uwtqSiUO1bd0lEursC9CBWMd1I0ltab\n"
-"rNMdjmEPNXubrjlpC2JgQCA2j6/7Nu4tCEoduL+bXPjqpRugc6bY+G7gMwRfaKonh+3ZwZCc\n"
-"7b3jajWvY9+rGNm65ulK6lCKD2GTHuItGeIwlDWSXQ62B68ZgI9HkFFLLk3dheLSClIKF5r8\n"
-"GrBQAuUBo2M3IUxExJtRmREOc5wGj1QupyheRDmHVi03vYVElOEMSyycw5KFNGHLD7ibSkNS\n"
-"/jQ6fbjpKdx2qcgw+BRxgMYeNkh0IkFch4LoGHGLQYlE535YW6i4jRPpp2zDR+2zGp1iro2C\n"
-"6pSe3VkQw63d4k3jMdXH7OjysP6SHhYKGvzZ8/gntsm+HbRsZJB/9OTEW9c3rkIO3aQab3yI\n"
-"VMUWbuF6aC74Or8NpDyJO3inTmODBCEIZ43ygknQW/2xzQ+DhNQ+IIX3Sj0rnP0qCglN6oH4\n"
-"EZw=\n"
-"-----END CERTIFICATE-----\n",
-
-/* T\xc3\x9c\x42\xC4\xB0TAK UEKAE K\xC3\xB6k Sertifika Hizmet Sa\xC4\x9Flay\xc4\xb1\x63\xc4\xb1s\xc4\xb1 - S\xC3\xBCr\xC3\xBCm 3 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIFFzCCA/+gAwIBAgIBETANBgkqhkiG9w0BAQUFADCCASsxCzAJBgNVBAYTAlRSMRgwFgYD\n"
-"VQQHDA9HZWJ6ZSAtIEtvY2FlbGkxRzBFBgNVBAoMPlTDvHJraXllIEJpbGltc2VsIHZlIFRl\n"
-"a25vbG9qaWsgQXJhxZ90xLFybWEgS3VydW11IC0gVMOcQsSwVEFLMUgwRgYDVQQLDD9VbHVz\n"
-"YWwgRWxla3Ryb25payB2ZSBLcmlwdG9sb2ppIEFyYcWfdMSxcm1hIEVuc3RpdMO8c8O8IC0g\n"
-"VUVLQUUxIzAhBgNVBAsMGkthbXUgU2VydGlmaWthc3lvbiBNZXJrZXppMUowSAYDVQQDDEFU\n"
-"w5xCxLBUQUsgVUVLQUUgS8O2ayBTZXJ0aWZpa2EgSGl6bWV0IFNhxJ9sYXnEsWPEsXPEsSAt\n"
-"IFPDvHLDvG0gMzAeFw0wNzA4MjQxMTM3MDdaFw0xNzA4MjExMTM3MDdaMIIBKzELMAkGA1UE\n"
-"BhMCVFIxGDAWBgNVBAcMD0dlYnplIC0gS29jYWVsaTFHMEUGA1UECgw+VMO8cmtpeWUgQmls\n"
-"aW1zZWwgdmUgVGVrbm9sb2ppayBBcmHFn3TEsXJtYSBLdXJ1bXUgLSBUw5xCxLBUQUsxSDBG\n"
-"BgNVBAsMP1VsdXNhbCBFbGVrdHJvbmlrIHZlIEtyaXB0b2xvamkgQXJhxZ90xLFybWEgRW5z\n"
-"dGl0w7xzw7wgLSBVRUtBRTEjMCEGA1UECwwaS2FtdSBTZXJ0aWZpa2FzeW9uIE1lcmtlemkx\n"
-"SjBIBgNVBAMMQVTDnELEsFRBSyBVRUtBRSBLw7ZrIFNlcnRpZmlrYSBIaXptZXQgU2HEn2xh\n"
-"ecSxY8Sxc8SxIC0gU8O8csO8bSAzMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA\n"
-"im1L/xCIOsP2fpTo6iBkcK4hgb46ezzb8R1Sf1n68yJMlaCQvEhOEav7t7WNeoMojCZG2E6V\n"
-"QIdhn8WebYGHV2yKO7Rm6sxA/OOqbLLLAdsyv9Lrhc+hDVXDWzhXcLh1xnnRFDDtG1hba+81\n"
-"8qEhTsXOfJlfbLm4IpNQp81McGq+agV/E5wrHur+R84EpW+sky58K5+eeROR6Oqeyjh1jmKw\n"
-"lZMq5d/pXpduIF9fhHpEORlAHLpVK/swsoHvhOPc7Jg4OQOFCKlUAwUp8MmPi+oLhmUZEdPp\n"
-"CSPeaJMDyTYcIW7OjGbxmTDY17PDHfiBLqi9ggtm/oLL4eAagsNAgQIDAQABo0IwQDAdBgNV\n"
-"HQ4EFgQUvYiHyY/2pAoLquvF/pEjnatKijIwDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQF\n"
-"MAMBAf8wDQYJKoZIhvcNAQEFBQADggEBAB18+kmPNOm3JpIWmgV050vQbTlswyb2zrgxvMTf\n"
-"vCr4N5EY3ATIZJkrGG2AA1nJrvhY0D7twyOfaTyGOBye79oneNGEN3GKPEs5z35FBtYt2IpN\n"
-"eBLWrcLTy9LQQfMmNkqblWwM7uXRQydmwYj3erMgbOqwaSvHIOgMA8RBBZniP+Rr+KCGgceE\n"
-"xh/VS4ESshYhLBOhgLJeDEoTniDYYkCrkOpkSi+sDQESeUWoL4cZaMjihccwsnX5OD+ywJO0\n"
-"a+IDRM5noN+J1q2MdqMTw5RhK2vZbMEHCiIHhWyFJEapvj+LeISCfiQMnf2BN+MlqO02TpUs\n"
-"yZyQ2uypQjyttgI=\n"
-"-----END CERTIFICATE-----\n",
-
-/* Buypass Class 2 CA 1 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDUzCCAjugAwIBAgIBATANBgkqhkiG9w0BAQUFADBLMQswCQYDVQQGEwJOTzEdMBsGA1UE\n"
-"CgwUQnV5cGFzcyBBUy05ODMxNjMzMjcxHTAbBgNVBAMMFEJ1eXBhc3MgQ2xhc3MgMiBDQSAx\n"
-"MB4XDTA2MTAxMzEwMjUwOVoXDTE2MTAxMzEwMjUwOVowSzELMAkGA1UEBhMCTk8xHTAbBgNV\n"
-"BAoMFEJ1eXBhc3MgQVMtOTgzMTYzMzI3MR0wGwYDVQQDDBRCdXlwYXNzIENsYXNzIDIgQ0Eg\n"
-"MTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAIs8B0XY9t/mx8q6jUPFR42wWsE4\n"
-"25KEHK8T1A9vNkYgxC7McXA0ojTTNy7Y3Tp3L8DrKehc0rWpkTSHIln+zNvnma+WwajHQN2l\n"
-"FYxuyHyXA8vmIPLXl18xoS830r7uvqmtqEyeIWZDO6i88wmjONVZJMHCR3axiFyCO7srpgTX\n"
-"jAePzdVBHfCuuCkslFJgNJQ72uA40Z0zPhX0kzLFANq1KWYOOngPIVJfAuWSeyXTkh4vFZ2B\n"
-"5J2O6O+JzhRMVB0cgRJNcKi+EAUXfh/RuFdV7c27UsKwHnjCTTZoy1YmwVLBvXb3WNVyfh9E\n"
-"drsAiR0WnVE1703CVu9r4Iw7DekCAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4E\n"
-"FgQUP42aWYv8e3uco684sDntkHGA1sgwDgYDVR0PAQH/BAQDAgEGMA0GCSqGSIb3DQEBBQUA\n"
-"A4IBAQAVGn4TirnoB6NLJzKyQJHyIdFkhb5jatLPgcIV1Xp+DCmsNx4cfHZSldq1fyOhKXdl\n"
-"yTKdqC5Wq2B2zha0jX94wNWZUYN/Xtm+DKhQ7SLHrQVMdvvt7h5HZPb3J31cKA9FxVxiXqaa\n"
-"kZG3Uxcu3K1gnZZkOb1naLKuBctN518fV4bVIJwo+28TOPX2EZL2fZleHwzoq0QkKXJAPTZS\n"
-"r4xYkHPB7GEseaHsh7U/2k3ZIQAw3pDaDtMaSKk+hQsUi4y8QZ5q9w5wwDX3OaJdZtB7WZ+o\n"
-"RxKaJyOkLY4ng5IgodcVf/EuGO70SH8vf/GhGLWhC5SgYiAynB321O+/TIho\n"
-"-----END CERTIFICATE-----\n",
-
-/* EBG Elektronik Sertifika Hizmet Sa\xC4\x9Flay\xc4\xb1\x63\xc4\xb1s\xc4\xb1 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIF5zCCA8+gAwIBAgIITK9zQhyOdAIwDQYJKoZIhvcNAQEFBQAwgYAxODA2BgNVBAMML0VC\n"
-"RyBFbGVrdHJvbmlrIFNlcnRpZmlrYSBIaXptZXQgU2HEn2xhecSxY8Sxc8SxMTcwNQYDVQQK\n"
-"DC5FQkcgQmlsacWfaW0gVGVrbm9sb2ppbGVyaSB2ZSBIaXptZXRsZXJpIEEuxZ4uMQswCQYD\n"
-"VQQGEwJUUjAeFw0wNjA4MTcwMDIxMDlaFw0xNjA4MTQwMDMxMDlaMIGAMTgwNgYDVQQDDC9F\n"
-"QkcgRWxla3Ryb25payBTZXJ0aWZpa2EgSGl6bWV0IFNhxJ9sYXnEsWPEsXPEsTE3MDUGA1UE\n"
-"CgwuRUJHIEJpbGnFn2ltIFRla25vbG9qaWxlcmkgdmUgSGl6bWV0bGVyaSBBLsWeLjELMAkG\n"
-"A1UEBhMCVFIwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDuoIRh0DpqZhAy2DE4\n"
-"f6en5f2h4fuXd7hxlugTlkaDT7byX3JWbhNgpQGR4lvFzVcfd2NR/y8927k/qqk153nQ9dAk\n"
-"tiHq6yOU/im/+4mRDGSaBUorzAzu8T2bgmmkTPiab+ci2hC6X5L8GCcKqKpE+i4stPtGmggD\n"
-"g3KriORqcsnlZR9uKg+ds+g75AxuetpX/dfreYteIAbTdgtsApWjluTLdlHRKJ2hGvxEok3M\n"
-"enaoDT2/F08iiFD9rrbskFBKW5+VQarKD7JK/oCZTqNGFav4c0JqwmZ2sQomFd2TkuzbqV9U\n"
-"IlKRcF0T6kjsbgNs2d1s/OsNA/+mgxKb8amTD8UmTDGyY5lhcucqZJnSuOl14nypqZoaqsNW\n"
-"2xCaPINStnuWt6yHd6i58mcLlEOzrz5z+kI2sSXFCjEmN1ZnuqMLfdb3ic1nobc6HmZP9qBV\n"
-"FCVMLDMNpkGMvQQxahByCp0OLna9XvNRiYuoP1Vzv9s6xiQFlpJIqkuNKgPlV5EQ9GooFW5H\n"
-"d4RcUXSfGenmHmMWOeMRFeNYGkS9y8RsZteEBt8w9DeiQyJ50hBs37vmExH8nYQKE3vwO9D8\n"
-"owrXieqWfo1IhR5kX9tUoqzVegJ5a9KK8GfaZXINFHDk6Y54jzJ0fFfy1tb0Nokb+Clsi7n2\n"
-"l9GkLqq+CxnCRelwXQIDAJ3Zo2MwYTAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIB\n"
-"BjAdBgNVHQ4EFgQU587GT/wWZ5b6SqMHwQSny2re2kcwHwYDVR0jBBgwFoAU587GT/wWZ5b6\n"
-"SqMHwQSny2re2kcwDQYJKoZIhvcNAQEFBQADggIBAJuYml2+8ygjdsZs93/mQJ7ANtyVDR2t\n"
-"FcU22NU57/IeIl6zgrRdu0waypIN30ckHrMk2pGI6YNw3ZPX6bqz3xZaPt7gyPvT/Wwp+BVG\n"
-"oGgmzJNSroIBk5DKd8pNSe/iWtkqvTDOTLKBtjDOWU/aWR1qeqRFsIImgYZ29fUQALjuswno\n"
-"T4cCB64kXPBfrAowzIpAoHMEwfuJJPaaHFy3PApnNgUIMbOv2AFoKuB4j3TeuFGkjGwgPaL7\n"
-"s9QJ/XvCgKqTbCmYIai7FvOpEl90tYeY8pUm3zTvilORiF0alKM/fCL414i6poyWqD1SNGKf\n"
-"AB5UVUJnxk1Gj7sURT0KlhaOEKGXmdXTMIXM3rRyt7yKPBgpaP3ccQfuJDlq+u2lrDgv+R4Q\n"
-"DgZxGhBM/nV+/x5XOULK1+EVoVZVWRvRo68R2E7DpSvvkL/A7IITW43WciyTTo9qKd+FPNMN\n"
-"4KIYEsxVL0e3p5sC/kH2iExt2qkBR4NkJ2IQgtYSe14DHzSpyZH+r11thie3I6p1GMog57AP\n"
-"14kOpmciY/SDQSsGS7tY1dHXt7kQY9iJSrSq3RZj9W6+YKH47ejWkE8axsWgKdOnIaj1Wjz3\n"
-"x0miIZpKlVIglnKaZsv30oZDfCK+lvm9AahH3eU7QPl1K5srRmSGjR70j/sHd9DqSaIcjVIU\n"
-"pgqT\n"
-"-----END CERTIFICATE-----\n",
-
-/* certSIGN ROOT CA */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDODCCAiCgAwIBAgIGIAYFFnACMA0GCSqGSIb3DQEBBQUAMDsxCzAJBgNVBAYTAlJPMREw\n"
-"DwYDVQQKEwhjZXJ0U0lHTjEZMBcGA1UECxMQY2VydFNJR04gUk9PVCBDQTAeFw0wNjA3MDQx\n"
-"NzIwMDRaFw0zMTA3MDQxNzIwMDRaMDsxCzAJBgNVBAYTAlJPMREwDwYDVQQKEwhjZXJ0U0lH\n"
-"TjEZMBcGA1UECxMQY2VydFNJR04gUk9PVCBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCC\n"
-"AQoCggEBALczuX7IJUqOtdu0KBuqV5Do0SLTZLrTk+jUrIZhQGpgV2hUhE28alQCBf/fm5oq\n"
-"rl0Hj0rDKH/v+yv6efHHrfAQUySQi2bJqIirr1qjAOm+ukbuW3N7LBeCgV5iLKECZbO9xSsA\n"
-"fsT8AzNXDe3i+s5dRdY4zTW2ssHQnIFKquSyAVwdj1+ZxLGt24gh65AIgoDzMKND5pCCrlUo\n"
-"Se1b16kQOA7+j0xbm0bqQfWwCHTD0IgztnzXdN/chNFDDnU5oSVAKOp4yw4sLjmdjItuFhwv\n"
-"JoIQ4uNllAoEwF73XVv4EOLQunpL+943AAAaWyjj0pxzPjKHmKHJUS/X3qwzs08CAwEAAaNC\n"
-"MEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAcYwHQYDVR0OBBYEFOCMm9slSbPx\n"
-"fIbWskKHC9BroNnkMA0GCSqGSIb3DQEBBQUAA4IBAQA+0hyJLjX8+HXd5n9liPRyTMks1zJO\n"
-"890ZeUe9jjtbkw9QSSQTaxQGcu8J06Gh40CEyecYMnQ8SG4Pn0vU9x7Tk4ZkVJdjclDVVc/6\n"
-"IJMCopvDI5NOFlV2oHB5bc0hH88vLbwZ44gx+FkagQnIl6Z0x2DEW8xXjrJ1/RsCCdtZb3KT\n"
-"afcxQdaIOL+Hsr0Wefmq5L6IJd1hJyMctTEHBDa0GpC9oHRxUIltvBTjD4au8as+x6AJzKNI\n"
-"0eDbZOeStc+vckNwi/nDhDwTqn6Sm1dTk/pwwpEOMfmbZ13pljheX7NzTogVZ96edhBiIL5V\n"
-"aZVDADlN9u6wWk5JRFRYX0KD\n"
-"-----END CERTIFICATE-----\n",
-
-/* CNNIC ROOT */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDVTCCAj2gAwIBAgIESTMAATANBgkqhkiG9w0BAQUFADAyMQswCQYDVQQGEwJDTjEOMAwG\n"
-"A1UEChMFQ05OSUMxEzARBgNVBAMTCkNOTklDIFJPT1QwHhcNMDcwNDE2MDcwOTE0WhcNMjcw\n"
-"NDE2MDcwOTE0WjAyMQswCQYDVQQGEwJDTjEOMAwGA1UEChMFQ05OSUMxEzARBgNVBAMTCkNO\n"
-"TklDIFJPT1QwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDTNfc/c3et6FtzF8LR\n"
-"b+1VvG7q6KR5smzDo+/hn7E7SIX1mlwhIhAsxYLO2uOabjfhhyzcuQxauohV3/2q2x8x6gHx\n"
-"3zkBwRP9SFIhxFXf2tizVHa6dLG3fdfA6PZZxU3Iva0fFNrfWEQlMhkqx35+jq44sDB7R3IJ\n"
-"MfAw28Mbdim7aXZOV/kbZKKTVrdvmW7bCgScEeOAH8tjlBAKqeFkgjH5jCftppkA9nCTGPih\n"
-"NIaj3XrCGHn2emU1z5DrvTOTn1OrczvmmzQgLx3vqR1jGqCA2wMv+SYahtKNu6m+UjqHZ0gN\n"
-"v7Sg2Ca+I19zN38m5pIEo3/PIKe38zrKy5nLAgMBAAGjczBxMBEGCWCGSAGG+EIBAQQEAwIA\n"
-"BzAfBgNVHSMEGDAWgBRl8jGtKvf33VKWCscCwQ7vptU7ETAPBgNVHRMBAf8EBTADAQH/MAsG\n"
-"A1UdDwQEAwIB/jAdBgNVHQ4EFgQUZfIxrSr3991SlgrHAsEO76bVOxEwDQYJKoZIhvcNAQEF\n"
-"BQADggEBAEs17szkrr/Dbq2flTtLP1se31cpolnKOOK5Gv+e5m4y3R6u6jW39ZORTtpC4cMX\n"
-"YFDy0VwmuYK36m3knITnA3kXr5g9lNvHugDnuL8BV8F3RTIMO/G0HAiw/VGgod2aHRM2mm23\n"
-"xzy54cXZF/qD1T0VoDy7HgviyJA/qIYM/PmLXoXLT1tLYhFHxUV8BS9BsZ4QaRuZluBVeftO\n"
-"hpm4lNqGOGqTo+fLbuXf6iFViZx9fX+Y9QCJ7uOEwFyWtcVG6kbghVW2G8kS1sHNzYDzAgE8\n"
-"yGnLRUhj2JTQ7IUOO04RZfSCjKY9ri4ilAnIXOo8gV0WKgOXFlUJ24pBgp5mmxE=\n"
-"-----END CERTIFICATE-----\n",
-
-/* ApplicationCA - Japanese Government */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDoDCCAoigAwIBAgIBMTANBgkqhkiG9w0BAQUFADBDMQswCQYDVQQGEwJKUDEcMBoGA1UE\n"
-"ChMTSmFwYW5lc2UgR292ZXJubWVudDEWMBQGA1UECxMNQXBwbGljYXRpb25DQTAeFw0wNzEy\n"
-"MTIxNTAwMDBaFw0xNzEyMTIxNTAwMDBaMEMxCzAJBgNVBAYTAkpQMRwwGgYDVQQKExNKYXBh\n"
-"bmVzZSBHb3Zlcm5tZW50MRYwFAYDVQQLEw1BcHBsaWNhdGlvbkNBMIIBIjANBgkqhkiG9w0B\n"
-"AQEFAAOCAQ8AMIIBCgKCAQEAp23gdE6Hj6UG3mii24aZS2QNcfAKBZuOquHMLtJqO8F6tJdh\n"
-"jYq+xpqcBrSGUeQ3DnR4fl+Kf5Sk10cI/VBaVuRorChzoHvpfxiSQE8tnfWuREhzNgaeZCw7\n"
-"NCPbXCbkcXmP1G55IrmTwcrNwVbtiGrXoDkhBFcsovW8R0FPXjQilbUfKW1eSvNNcr5BViCH\n"
-"/OlQR9cwFO5cjFW6WY2H/CPek9AEjP3vbb3QesmlOmpyM8ZKDQUXKi17safY1vC+9D/qDiht\n"
-"QWEjdnjDuGWk81quzMKq2edY3rZ+nYVunyoKb58DKTCXKB28t89UKU5RMfkntigm/qJj5kEW\n"
-"8DOYRwIDAQABo4GeMIGbMB0GA1UdDgQWBBRUWssmP3HMlEYNllPqa0jQk/5CdTAOBgNVHQ8B\n"
-"Af8EBAMCAQYwWQYDVR0RBFIwUKROMEwxCzAJBgNVBAYTAkpQMRgwFgYDVQQKDA/ml6XmnKzl\n"
-"m73mlL/lupwxIzAhBgNVBAsMGuOCouODl+ODquOCseODvOOCt+ODp+ODs0NBMA8GA1UdEwEB\n"
-"/wQFMAMBAf8wDQYJKoZIhvcNAQEFBQADggEBADlqRHZ3ODrso2dGD/mLBqj7apAxzn7s2tGJ\n"
-"fHrrLgy9mTLnsCTWw//1sogJhyzjVOGjprIIC8CFqMjSnHH2HZ9g/DgzE+Ge3Atf2hZQKXsv\n"
-"cJEPmbo0NI2VdMV+eKlmXb3KIXdCEKxmJj3ekav9FfBv7WxfEPjzFvYDio+nEhEMy/0/ecGc\n"
-"/WLuo89UDNErXxc+4z6/wCs+CZv+iKZ+tJIX/COUgb1up8WMwusRRdv4QcmWdupwX3kSa+Sj\n"
-"B1oF7ydJzyGfikwJcGapJsErEU4z0g781mzSDjJkaP+tBXhfAx2o45CsJOAPQKdLrosot4LK\n"
-"GAfmt1t06SAZf7IbiVQ=\n"
-"-----END CERTIFICATE-----\n",
-
-/* GeoTrust Primary Certification Authority - G3 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIID/jCCAuagAwIBAgIQFaxulBmyeUtB9iepwxgPHzANBgkqhkiG9w0BAQsFADCBmDELMAkG\n"
-"A1UEBhMCVVMxFjAUBgNVBAoTDUdlb1RydXN0IEluYy4xOTA3BgNVBAsTMChjKSAyMDA4IEdl\n"
-"b1RydXN0IEluYy4gLSBGb3IgYXV0aG9yaXplZCB1c2Ugb25seTE2MDQGA1UEAxMtR2VvVHJ1\n"
-"c3QgUHJpbWFyeSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSAtIEczMB4XDTA4MDQwMjAwMDAw\n"
-"MFoXDTM3MTIwMTIzNTk1OVowgZgxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1HZW9UcnVzdCBJ\n"
-"bmMuMTkwNwYDVQQLEzAoYykgMjAwOCBHZW9UcnVzdCBJbmMuIC0gRm9yIGF1dGhvcml6ZWQg\n"
-"dXNlIG9ubHkxNjA0BgNVBAMTLUdlb1RydXN0IFByaW1hcnkgQ2VydGlmaWNhdGlvbiBBdXRo\n"
-"b3JpdHkgLSBHMzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBANziXmJYHTNXOTIz\n"
-"+uvLh4yn1ErdBojqZI4xmKU4kB6Yzy5jK/BGvESyiaHAKAxJcCGVn2TAppMSAmUmhsalifD6\n"
-"14SgcK9PGpc/BkTVyetyEH3kMSj7HGHmKAdEc5IiaacDiGydY8hS2pgn5whMcD60yRLBxWeD\n"
-"XTPzAxHsatBT4tG6NmCUgLthY2xbF37fQJQeqw3CIShwiP/WJmxsYAQlTlV+fe+/lEjetx3d\n"
-"cI0FX4ilm/LC7urRQEFtYjgdVgbFA0dRIBn8exALDmKudlW/X3e+PkkBUz2YJQN2JFodtNuJ\n"
-"6nnltrM7P7pMKEF/BqxqjsHQ9gUdfeZChuOl1UcCAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB\n"
-"/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFMR5yo6hTgMdHNxr2zFblD4/MH8tMA0GCSqG\n"
-"SIb3DQEBCwUAA4IBAQAtxRPPVoB7eni9n64smefv2t+UXglpp+duaIy9cr5HqQ6XErhK8WTT\n"
-"Od8lNNTBzU6B8A8ExCSzNJbGpqow32hhc9f5joWJ7w5elShKKiePEI4ufIbEAp7aDHdlDkQN\n"
-"kv39sxY2+hENHYwOB4lqKVb3cvTdFZx3NWZXqxNT2I7BQMXXExZacse3aQHEerGDAWh9jUGh\n"
-"lBjBJVz88P6DAod8DQ3PLghcSkANPuyBYeYk28rgDi0Hsj5W3I31QYUHSJsMC8tJP33st/3L\n"
-"jWeJGqvtux6jAAgIFyqCXDFdRootD4abdNlF+9RAsXqqaC2Gspki4cErx5z481+oghLrGREt\n"
-"-----END CERTIFICATE-----\n",
-
-/* thawte Primary Root CA - G2 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIICiDCCAg2gAwIBAgIQNfwmXNmET8k9Jj1Xm67XVjAKBggqhkjOPQQDAzCBhDELMAkGA1UE\n"
-"BhMCVVMxFTATBgNVBAoTDHRoYXd0ZSwgSW5jLjE4MDYGA1UECxMvKGMpIDIwMDcgdGhhd3Rl\n"
-"LCBJbmMuIC0gRm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxJDAiBgNVBAMTG3RoYXd0ZSBQcmlt\n"
-"YXJ5IFJvb3QgQ0EgLSBHMjAeFw0wNzExMDUwMDAwMDBaFw0zODAxMTgyMzU5NTlaMIGEMQsw\n"
-"CQYDVQQGEwJVUzEVMBMGA1UEChMMdGhhd3RlLCBJbmMuMTgwNgYDVQQLEy8oYykgMjAwNyB0\n"
-"aGF3dGUsIEluYy4gLSBGb3IgYXV0aG9yaXplZCB1c2Ugb25seTEkMCIGA1UEAxMbdGhhd3Rl\n"
-"IFByaW1hcnkgUm9vdCBDQSAtIEcyMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEotWcgnuVnfFS\n"
-"eIf+iha/BebfowJPDQfGAFG6DAJSLSKkQjnE/o/qycG+1E3/n3qe4rF8mq2nhglzh9HnmuN6\n"
-"papu+7qzcMBniKI11KOasf2twu8x+qi58/sIxpHR+ymVo0IwQDAPBgNVHRMBAf8EBTADAQH/\n"
-"MA4GA1UdDwEB/wQEAwIBBjAdBgNVHQ4EFgQUmtgAMADna3+FGO6Lts6KDPgR4bswCgYIKoZI\n"
-"zj0EAwMDaQAwZgIxAN344FdHW6fmCsO99YCKlzUNG4k8VIZ3KMqh9HneteY4sPBlcIx/AlTC\n"
-"v//YoT7ZzwIxAMSNlPzcU9LcnXgWHxUzI1NS41oxXZ3Krr0TKUQNJ1uo52icEvdYPy5yAlej\n"
-"j6EULg==\n"
-"-----END CERTIFICATE-----\n",
-
-/* thawte Primary Root CA - G3 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIEKjCCAxKgAwIBAgIQYAGXt0an6rS0mtZLL/eQ+zANBgkqhkiG9w0BAQsFADCBrjELMAkG\n"
-"A1UEBhMCVVMxFTATBgNVBAoTDHRoYXd0ZSwgSW5jLjEoMCYGA1UECxMfQ2VydGlmaWNhdGlv\n"
-"biBTZXJ2aWNlcyBEaXZpc2lvbjE4MDYGA1UECxMvKGMpIDIwMDggdGhhd3RlLCBJbmMuIC0g\n"
-"Rm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxJDAiBgNVBAMTG3RoYXd0ZSBQcmltYXJ5IFJvb3Qg\n"
-"Q0EgLSBHMzAeFw0wODA0MDIwMDAwMDBaFw0zNzEyMDEyMzU5NTlaMIGuMQswCQYDVQQGEwJV\n"
-"UzEVMBMGA1UEChMMdGhhd3RlLCBJbmMuMSgwJgYDVQQLEx9DZXJ0aWZpY2F0aW9uIFNlcnZp\n"
-"Y2VzIERpdmlzaW9uMTgwNgYDVQQLEy8oYykgMjAwOCB0aGF3dGUsIEluYy4gLSBGb3IgYXV0\n"
-"aG9yaXplZCB1c2Ugb25seTEkMCIGA1UEAxMbdGhhd3RlIFByaW1hcnkgUm9vdCBDQSAtIEcz\n"
-"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsr8nLPvb2FvdeHsbnndmgcs+vHyu\n"
-"86YnmjSjaDFxODNi5PNxZnmxqWWjpYvVj2AtP0LMqmsywCPLLEHd5N/8YZzic7IilRFDGF/E\n"
-"th9XbAoFWCLINkw6fKXRz4aviKdEAhN0cXMKQlkC+BsUa0Lfb1+6a4KinVvnSr0eAXLbS3To\n"
-"O39/fR8EtCab4LRarEc9VbjXsCZSKAExQGbY2SS99irY7CFJXJv2eul/VTV+lmuNk5Mny5K7\n"
-"6qxAwJ/C+IDPXfRa3M50hqY+bAtTyr2SzhkGcuYMXDhpxwTWvGzOW/b3aJzcJRVIiKHpqfiY\n"
-"nODz1TEoYRFsZ5aNOZnLwkUkOQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB\n"
-"/wQEAwIBBjAdBgNVHQ4EFgQUrWyqlGCc7eT/+j4KdCtjA/e2Wb8wDQYJKoZIhvcNAQELBQAD\n"
-"ggEBABpA2JVlrAmSicY59BDlqQ5mU1143vokkbvnRFHfxhY0Cu9qRFHqKweKA3rD6z8KLFIW\n"
-"oCtDuSWQP3CpMyVtRRooOyfPqsMpQhvfO0zAMzRbQYi/aytlryjvsvXDqmbOe1but8jLZ8HJ\n"
-"nBoYuMTDSQPxYA5QzUbF83d597YV4Djbxy8ooAw/dyZ02SUS2jHaGh7cKUGRIjxpp7sC8rZc\n"
-"JwOJ9Abqm+RyguOhCcHpABnTPtRwa7pxpqpYrvS76Wy274fMm7v/OeZWYdMKp8RcTGB7BXcm\n"
-"er/YB1IsYvdwY9k5vG8cwnncdimvzsUsZAReiDZuMdRAGmI0Nj81Aa6sY6A=\n"
-"-----END CERTIFICATE-----\n",
-
-/* GeoTrust Primary Certification Authority - G2 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIICrjCCAjWgAwIBAgIQPLL0SAoA4v7rJDteYD7DazAKBggqhkjOPQQDAzCBmDELMAkGA1UE\n"
-"BhMCVVMxFjAUBgNVBAoTDUdlb1RydXN0IEluYy4xOTA3BgNVBAsTMChjKSAyMDA3IEdlb1Ry\n"
-"dXN0IEluYy4gLSBGb3IgYXV0aG9yaXplZCB1c2Ugb25seTE2MDQGA1UEAxMtR2VvVHJ1c3Qg\n"
-"UHJpbWFyeSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSAtIEcyMB4XDTA3MTEwNTAwMDAwMFoX\n"
-"DTM4MDExODIzNTk1OVowgZgxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1HZW9UcnVzdCBJbmMu\n"
-"MTkwNwYDVQQLEzAoYykgMjAwNyBHZW9UcnVzdCBJbmMuIC0gRm9yIGF1dGhvcml6ZWQgdXNl\n"
-"IG9ubHkxNjA0BgNVBAMTLUdlb1RydXN0IFByaW1hcnkgQ2VydGlmaWNhdGlvbiBBdXRob3Jp\n"
-"dHkgLSBHMjB2MBAGByqGSM49AgEGBSuBBAAiA2IABBWx6P0DFUPlrOuHNxFi79KDNlJ9RVcL\n"
-"So17VDs6bl8VAsBQps8lL33KSLjHUGMcKiEIfJo22Av+0SbFWDEwKCXzXV2juLaltJLtbCyf\n"
-"691DiaI8S0iRHVDsJt/WYC69IaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMC\n"
-"AQYwHQYDVR0OBBYEFBVfNVdRVfslsq0DafwBo/q+EVXVMAoGCCqGSM49BAMDA2cAMGQCMGSW\n"
-"WaboCd6LuvpaiIjwH5HTRqjySkwCY/tsXzjbLkGTqQ7mndwxHLKgpxgceeHHNgIwOlavmnRs\n"
-"9vuD4DPTCF+hnMJbn0bWtsuRBmOiBuczrD6ogRLQy7rQkgu2npaqBA+K\n"
-"-----END CERTIFICATE-----\n",
-
-/* VeriSign Universal Root Certification Authority */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIEuTCCA6GgAwIBAgIQQBrEZCGzEyEDDrvkEhrFHTANBgkqhkiG9w0BAQsFADCBvTELMAkG\n"
-"A1UEBhMCVVMxFzAVBgNVBAoTDlZlcmlTaWduLCBJbmMuMR8wHQYDVQQLExZWZXJpU2lnbiBU\n"
-"cnVzdCBOZXR3b3JrMTowOAYDVQQLEzEoYykgMjAwOCBWZXJpU2lnbiwgSW5jLiAtIEZvciBh\n"
-"dXRob3JpemVkIHVzZSBvbmx5MTgwNgYDVQQDEy9WZXJpU2lnbiBVbml2ZXJzYWwgUm9vdCBD\n"
-"ZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTAeFw0wODA0MDIwMDAwMDBaFw0zNzEyMDEyMzU5NTla\n"
-"MIG9MQswCQYDVQQGEwJVUzEXMBUGA1UEChMOVmVyaVNpZ24sIEluYy4xHzAdBgNVBAsTFlZl\n"
-"cmlTaWduIFRydXN0IE5ldHdvcmsxOjA4BgNVBAsTMShjKSAyMDA4IFZlcmlTaWduLCBJbmMu\n"
-"IC0gRm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxODA2BgNVBAMTL1ZlcmlTaWduIFVuaXZlcnNh\n"
-"bCBSb290IENlcnRpZmljYXRpb24gQXV0aG9yaXR5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A\n"
-"MIIBCgKCAQEAx2E3XrEBNNti1xWb/1hajCMj1mCOkdeQmIN65lgZOIzF9uVkhbSicfvtvbna\n"
-"zU0AtMgtc6XHaXGVHzk8skQHnOgO+k1KxCHfKWGPMiJhgsWHH26MfF8WIFFE0XBPV+rjHOPM\n"
-"ee5Y2A7Cs0WTwCznmhcrewA3ekEzeOEz4vMQGn+HLL729fdC4uW/h2KJXwBL38Xd5HVEMkE6\n"
-"HnFuacsLdUYI0crSK5XQz/u5QGtkjFdN/BMReYTtXlT2NJ8IAfMQJQYXStrxHXpma5hgZqTZ\n"
-"79IugvHw7wnqRMkVauIDbjPTrJ9VAMf2CGqUuV/c4DPxhGD5WycRtPwW8rtWaoAljQIDAQAB\n"
-"o4GyMIGvMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgEGMG0GCCsGAQUFBwEMBGEw\n"
-"X6FdoFswWTBXMFUWCWltYWdlL2dpZjAhMB8wBwYFKw4DAhoEFI/l0xqGrI2Oa8PPgGrUSBgs\n"
-"exkuMCUWI2h0dHA6Ly9sb2dvLnZlcmlzaWduLmNvbS92c2xvZ28uZ2lmMB0GA1UdDgQWBBS2\n"
-"d/ppSEefUxLVwuoHMnYH0ZcHGTANBgkqhkiG9w0BAQsFAAOCAQEASvj4sAPmLGd75JR3Y8xu\n"
-"TPl9Dg3cyLk1uXBPY/ok+myDjEedO2Pzmvl2MpWRsXe8rJq+seQxIcaBlVZaDrHC1LGmWazx\n"
-"Y8u4TB1ZkErvkBYoH1quEPuBUDgMbMzxPcP1Y+Oz4yHJJDnp/RVmRvQbEdBNc6N9Rvk97ahf\n"
-"YtTxP/jgdFcrGJ2BtMQo2pSXpXDrrB2+BxHw1dvd5Yzw1TKwg+ZX4o+/vqGqvz0dtdQ46tew\n"
-"XDpPaj+PwGZsY6rp2aQW9IHRlRQOfc2VNNnSj3BzgXucfr2YYdhFh5iQxeuGMMY1v/D/w1WI\n"
-"g0vvBZIGcfK4mJO37M2CYfE45k+XmCpajQ==\n"
-"-----END CERTIFICATE-----\n",
-
-/* VeriSign Class 3 Public Primary Certification Authority - G4 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDhDCCAwqgAwIBAgIQL4D+I4wOIg9IZxIokYesszAKBggqhkjOPQQDAzCByjELMAkGA1UE\n"
-"BhMCVVMxFzAVBgNVBAoTDlZlcmlTaWduLCBJbmMuMR8wHQYDVQQLExZWZXJpU2lnbiBUcnVz\n"
-"dCBOZXR3b3JrMTowOAYDVQQLEzEoYykgMjAwNyBWZXJpU2lnbiwgSW5jLiAtIEZvciBhdXRo\n"
-"b3JpemVkIHVzZSBvbmx5MUUwQwYDVQQDEzxWZXJpU2lnbiBDbGFzcyAzIFB1YmxpYyBQcmlt\n"
-"YXJ5IENlcnRpZmljYXRpb24gQXV0aG9yaXR5IC0gRzQwHhcNMDcxMTA1MDAwMDAwWhcNMzgw\n"
-"MTE4MjM1OTU5WjCByjELMAkGA1UEBhMCVVMxFzAVBgNVBAoTDlZlcmlTaWduLCBJbmMuMR8w\n"
-"HQYDVQQLExZWZXJpU2lnbiBUcnVzdCBOZXR3b3JrMTowOAYDVQQLEzEoYykgMjAwNyBWZXJp\n"
-"U2lnbiwgSW5jLiAtIEZvciBhdXRob3JpemVkIHVzZSBvbmx5MUUwQwYDVQQDEzxWZXJpU2ln\n"
-"biBDbGFzcyAzIFB1YmxpYyBQcmltYXJ5IENlcnRpZmljYXRpb24gQXV0aG9yaXR5IC0gRzQw\n"
-"djAQBgcqhkjOPQIBBgUrgQQAIgNiAASnVnp8Utpkmw4tXNherJI9/gHmGUo9FANL+mAnINmD\n"
-"iWn6VMaaGF5VKmTeBvaNSjutEDxlPZCIBIngMGGzrl0Bp3vefLK+ymVhAIau2o970ImtTR1Z\n"
-"mkGxvEeA3J5iw/mjgbIwga8wDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwbQYI\n"
-"KwYBBQUHAQwEYTBfoV2gWzBZMFcwVRYJaW1hZ2UvZ2lmMCEwHzAHBgUrDgMCGgQUj+XTGoas\n"
-"jY5rw8+AatRIGCx7GS4wJRYjaHR0cDovL2xvZ28udmVyaXNpZ24uY29tL3ZzbG9nby5naWYw\n"
-"HQYDVR0OBBYEFLMWkf3upm7ktS5Jj4d4gYDs5bG1MAoGCCqGSM49BAMDA2gAMGUCMGYhDBgm\n"
-"YFo4e1ZC4Kf8NoRRkSAsdk1DPcQdhCPQrNZ8NQbOzWm9kA3bbEhCHQ6qQgIxAJw9SDkjOVga\n"
-"FRJZap7v1VmyHVIsmXHNxynfGyphe3HR3vPA5Q06Sqotp9iGKt0uEA==\n"
-"-----END CERTIFICATE-----\n",
-
-/* NetLock Arany (Class Gold) Ftanstvny */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIEFTCCAv2gAwIBAgIGSUEs5AAQMA0GCSqGSIb3DQEBCwUAMIGnMQswCQYDVQQGEwJIVTER\n"
-"MA8GA1UEBwwIQnVkYXBlc3QxFTATBgNVBAoMDE5ldExvY2sgS2Z0LjE3MDUGA1UECwwuVGFu\n"
-"w7pzw610dsOhbnlraWFkw7NrIChDZXJ0aWZpY2F0aW9uIFNlcnZpY2VzKTE1MDMGA1UEAwws\n"
-"TmV0TG9jayBBcmFueSAoQ2xhc3MgR29sZCkgRsWRdGFuw7pzw610dsOhbnkwHhcNMDgxMjEx\n"
-"MTUwODIxWhcNMjgxMjA2MTUwODIxWjCBpzELMAkGA1UEBhMCSFUxETAPBgNVBAcMCEJ1ZGFw\n"
-"ZXN0MRUwEwYDVQQKDAxOZXRMb2NrIEtmdC4xNzA1BgNVBAsMLlRhbsO6c8OtdHbDoW55a2lh\n"
-"ZMOzayAoQ2VydGlmaWNhdGlvbiBTZXJ2aWNlcykxNTAzBgNVBAMMLE5ldExvY2sgQXJhbnkg\n"
-"KENsYXNzIEdvbGQpIEbFkXRhbsO6c8OtdHbDoW55MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A\n"
-"MIIBCgKCAQEAxCRec75LbRTDofTjl5Bu0jBFHjzuZ9lk4BqKf8owyoPjIMHj9DrTlF8afFtt\n"
-"vzBPhCf2nx9JvMaZCpDyD/V/Q4Q3Y1GLeqVw/HpYzY6b7cNGbIRwXdrzAZAj/E4wqX7hJ2Pn\n"
-"7WQ8oLjJM2P+FpD/sLj916jAwJRDC7bVWaaeVtAkH3B5r9s5VA1lddkVQZQBr17s9o3x/61k\n"
-"/iCa11zr/qYfCGSji3ZVrR47KGAuhyXoqq8fxmRGILdwfzzeSNuWU7c5d+Qa4scWhHaXWy+7\n"
-"GRWF+GmF9ZmnqfI0p6m2pgP8b4Y9VHx2BJtr+UBdADTHLpl1neWIA6pN+APSQnbAGwIDAKiL\n"
-"o0UwQzASBgNVHRMBAf8ECDAGAQH/AgEEMA4GA1UdDwEB/wQEAwIBBjAdBgNVHQ4EFgQUzPpn\n"
-"k/C2uNClwB7zU/2MU9+D15YwDQYJKoZIhvcNAQELBQADggEBAKt/7hwWqZw8UQCgwBEIBaeZ\n"
-"5m8BiFRhbvG5GK1Krf6BQCOUL/t1fC8oS2IkgYIL9WHxHG64YTjrgfpioTtaYtOUZcTh5m2C\n"
-"+C8lcLIhJsFyUR+MLMOEkMNaj7rP9KdlpeuY0fsFskZ1FSNqb4VjMIDw1Z4fKRzCbLBQWV2Q\n"
-"WzuoDTDPv31/zvGdg73JRm4gpvlhUbohL3u+pRVjodSVh/GeufOJ8z2FuLjbvrW5KfnaNwUA\n"
-"SZQDhETnv0Mxz3WLJdH0pmT1kvarBes96aULNmLazAZfNou2XjG4Kvte9nHfRCaexOYNkbQu\n"
-"dZWAUWpLMKawYqGT8ZvYzsRjdT9ZR7E=\n"
-"-----END CERTIFICATE-----\n",
-
-/* Staat der Nederlanden Root CA - G2 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIFyjCCA7KgAwIBAgIEAJiWjDANBgkqhkiG9w0BAQsFADBaMQswCQYDVQQGEwJOTDEeMBwG\n"
-"A1UECgwVU3RhYXQgZGVyIE5lZGVybGFuZGVuMSswKQYDVQQDDCJTdGFhdCBkZXIgTmVkZXJs\n"
-"YW5kZW4gUm9vdCBDQSAtIEcyMB4XDTA4MDMyNjExMTgxN1oXDTIwMDMyNTExMDMxMFowWjEL\n"
-"MAkGA1UEBhMCTkwxHjAcBgNVBAoMFVN0YWF0IGRlciBOZWRlcmxhbmRlbjErMCkGA1UEAwwi\n"
-"U3RhYXQgZGVyIE5lZGVybGFuZGVuIFJvb3QgQ0EgLSBHMjCCAiIwDQYJKoZIhvcNAQEBBQAD\n"
-"ggIPADCCAgoCggIBAMVZ5291qj5LnLW4rJ4L5PnZyqtdj7U5EILXr1HgO+EASGrP2uEGQxGZ\n"
-"qhQlEq0i6ABtQ8SpuOUfiUtnvWFI7/3S4GCI5bkYYCjDdyutsDeqN95kWSpGV+RLufg3fNU2\n"
-"54DBtvPUZ5uW6M7XxgpT0GtJlvOjCwV3SPcl5XCsMBQgJeN/dVrlSPhOewMHBPqCYYdu8DvE\n"
-"pMfQ9XQ+pV0aCPKbJdL2rAQmPlU6Yiile7Iwr/g3wtG61jj99O9JMDeZJiFIhQGp5Rbn3JBV\n"
-"3w/oOM2ZNyFPXfUib2rFEhZgF1XyZWampzCROME4HYYEhLoaJXhena/MUGDWE4dS7WMfbWV9\n"
-"whUYdMrhfmQpjHLYFhN9C0lK8SgbIHRrxT3dsKpICT0ugpTNGmXZK4iambwYfp/ufWZ8Pr2U\n"
-"uIHOzZgweMFvZ9C+X+Bo7d7iscksWXiSqt8rYGPy5V6548r6f1CGPqI0GAwJaCgRHOThuVw+\n"
-"R7oyPxjMW4T182t0xHJ04eOLoEq9jWYv6q012iDTiIJh8BIitrzQ1aTsr1SIJSQ8p22xcik/\n"
-"Plemf1WvbibG/ufMQFxRRIEKeN5KzlW/HdXZt1bv8Hb/C3m1r737qWmRRpdogBQ2HbN/uymY\n"
-"NqUg+oJgYjOk7Na6B6duxc8UpufWkjTYgfX8HV2qXB72o007uPc5AgMBAAGjgZcwgZQwDwYD\n"
-"VR0TAQH/BAUwAwEB/zBSBgNVHSAESzBJMEcGBFUdIAAwPzA9BggrBgEFBQcCARYxaHR0cDov\n"
-"L3d3dy5wa2lvdmVyaGVpZC5ubC9wb2xpY2llcy9yb290LXBvbGljeS1HMjAOBgNVHQ8BAf8E\n"
-"BAMCAQYwHQYDVR0OBBYEFJFoMocVHYnitfGsNig0jQt8YojrMA0GCSqGSIb3DQEBCwUAA4IC\n"
-"AQCoQUpnKpKBglBu4dfYszk78wIVCVBR7y29JHuIhjv5tLySCZa59sCrI2AGeYwRTlHSeYAz\n"
-"+51IvuxBQ4EffkdAHOV6CMqqi3WtFMTC6GY8ggen5ieCWxjmD27ZUD6KQhgpxrRW/FYQoAUX\n"
-"vQwjf/ST7ZwaUb7dRUG/kSS0H4zpX897IZmflZ85OkYcbPnNe5yQzSipx6lVu6xiNGI1E0sU\n"
-"OlWDuYaNkqbG9AclVMwWVxJKgnjIFNkXgiYtXSAfea7+1HAWFpWD2DU5/1JddRwWxRNVz0fM\n"
-"dWVSSt7wsKfkCpYL+63C4iWEst3kvX5ZbJvw8NjnyvLplzh+ib7M+zkXYT9y2zqR2GUBGR2t\n"
-"UKRXCnxLvJxxcypFURmFzI79R6d0lR2o0a9OF7FpJsKqeFdbxU2n5Z4FF5TKsl+gSRiNNOkm\n"
-"bEgeqmiSBeGCc1qb3AdbCG19ndeNIdn8FCCqwkXfP+cAslHkwvgFuXkajDTznlvkN1trSt8s\n"
-"V4pAWja63XVECDdCcAz+3F4hoKOKwJCcaNpQ5kUQR3i2TtJlycM33+FCY7BXN0Ute4qcvwXq\n"
-"ZVUz9zkQxSgqIXobisQk+T8VyJoVIPVVYpbtbZNQvOSqeK3Zywplh6ZmwcSBo3c6WB4L7oOL\n"
-"nR7SUqTMHW+wmG2UMbX4cQrcufx9MmDm66+KAQ==\n"
-"-----END CERTIFICATE-----\n",
-
-/* Juur-SK */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIE5jCCA86gAwIBAgIEO45L/DANBgkqhkiG9w0BAQUFADBdMRgwFgYJKoZIhvcNAQkBFglw\n"
-"a2lAc2suZWUxCzAJBgNVBAYTAkVFMSIwIAYDVQQKExlBUyBTZXJ0aWZpdHNlZXJpbWlza2Vz\n"
-"a3VzMRAwDgYDVQQDEwdKdXVyLVNLMB4XDTAxMDgzMDE0MjMwMVoXDTE2MDgyNjE0MjMwMVow\n"
-"XTEYMBYGCSqGSIb3DQEJARYJcGtpQHNrLmVlMQswCQYDVQQGEwJFRTEiMCAGA1UEChMZQVMg\n"
-"U2VydGlmaXRzZWVyaW1pc2tlc2t1czEQMA4GA1UEAxMHSnV1ci1TSzCCASIwDQYJKoZIhvcN\n"
-"AQEBBQADggEPADCCAQoCggEBAIFxNj4zB9bjMI0TfncyRsvPGbJgMUaXhvSYRqTCZUXP00B8\n"
-"41oiqBB4M8yIsdOBSvZiF3tfTQou0M+LI+5PAk676w7KvRhj6IAcjeEcjT3g/1tf6mTll+g/\n"
-"mX8MCgkzABpTpyHhOEvWgxutr2TC+Rx6jGZITWYfGAriPrsfB2WThbkasLnE+w0R9vXW+RvH\n"
-"LCu3GFH+4Hv2qEivbDtPL+/40UceJlfwUR0zlv/vWT3aTdEVNMfqPxZIe5EcgEMPPbgFPtGz\n"
-"lc3Yyg/CQ2fbt5PgIoIuvvVoKIO5wTtpeyDaTpxt4brNj3pssAki14sL2xzVWiZbDcDq5WDQ\n"
-"n/413z8CAwEAAaOCAawwggGoMA8GA1UdEwEB/wQFMAMBAf8wggEWBgNVHSAEggENMIIBCTCC\n"
-"AQUGCisGAQQBzh8BAQEwgfYwgdAGCCsGAQUFBwICMIHDHoHAAFMAZQBlACAAcwBlAHIAdABp\n"
-"AGYAaQBrAGEAYQB0ACAAbwBuACAAdgDkAGwAagBhAHMAdABhAHQAdQBkACAAQQBTAC0AaQBz\n"
-"ACAAUwBlAHIAdABpAGYAaQB0AHMAZQBlAHIAaQBtAGkAcwBrAGUAcwBrAHUAcwAgAGEAbABh\n"
-"AG0ALQBTAEsAIABzAGUAcgB0AGkAZgBpAGsAYQBhAHQAaQBkAGUAIABrAGkAbgBuAGkAdABh\n"
-"AG0AaQBzAGUAawBzMCEGCCsGAQUFBwIBFhVodHRwOi8vd3d3LnNrLmVlL2Nwcy8wKwYDVR0f\n"
-"BCQwIjAgoB6gHIYaaHR0cDovL3d3dy5zay5lZS9qdXVyL2NybC8wHQYDVR0OBBYEFASqekej\n"
-"5ImvGs8KQKcYP2/v6X2+MB8GA1UdIwQYMBaAFASqekej5ImvGs8KQKcYP2/v6X2+MA4GA1Ud\n"
-"DwEB/wQEAwIB5jANBgkqhkiG9w0BAQUFAAOCAQEAe8EYlFOiCfP+JmeaUOTDBS8rNXiRTHyo\n"
-"ERF5TElZrMj3hWVcRrs7EKACr81Ptcw2Kuxd/u+gkcm2k298gFTsxwhwDY77guwqYHhpNjbR\n"
-"xZyLabVAyJRld/JXIWY7zoVAtjNjGr95HvxcHdMdkxuLDF2FvZkwMhgJkVLpfKG6/2SSmuz+\n"
-"Ne6ML678IIbsSt4beDI3poHSna9aEhbKmVv8b20OxaAehsmR0FyYgl9jDIpaq9iVpszLita/\n"
-"ZEuOyoqysOkhMp6qqIWYNIE5ITuoOlIyPfZrN4YGWhWY3PARZv40ILcD9EEQfTmEeZZyY7aW\n"
-"AuVrua0ZTbvGRNs2yyqcjg==\n"
-"-----END CERTIFICATE-----\n",
-
-/* Hongkong Post Root CA 1 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDMDCCAhigAwIBAgICA+gwDQYJKoZIhvcNAQEFBQAwRzELMAkGA1UEBhMCSEsxFjAUBgNV\n"
-"BAoTDUhvbmdrb25nIFBvc3QxIDAeBgNVBAMTF0hvbmdrb25nIFBvc3QgUm9vdCBDQSAxMB4X\n"
-"DTAzMDUxNTA1MTMxNFoXDTIzMDUxNTA0NTIyOVowRzELMAkGA1UEBhMCSEsxFjAUBgNVBAoT\n"
-"DUhvbmdrb25nIFBvc3QxIDAeBgNVBAMTF0hvbmdrb25nIFBvc3QgUm9vdCBDQSAxMIIBIjAN\n"
-"BgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArP84tulmAknjorThkPlAj3n54r15/gK97iSS\n"
-"HSL22oVyaf7XPwnU3ZG1ApzQjVrhVcNQhrkpJsLj2aDxaQMoIIBFIi1WpztUlVYiWR8o3x8g\n"
-"PW2iNr4joLFutbEnPzlTCeqrauh0ssJlXI6/fMN4hM2eFvz1Lk8gKgifd/PFHsSaUmYeSF7j\n"
-"EAaPIpjhZY4bXSNmO7ilMlHIhqqhqZ5/dpTCpmy3QfDVyAY45tQM4vM7TG1QjMSDJ8EThFk9\n"
-"nnV0ttgCXjqQesBCNnLsak3c78QA3xMYV18meMjWCnl3v/evt3a5pQuEF10Q6m/hq5URX208\n"
-"o1xNg1vysxmKgIsLhwIDAQABoyYwJDASBgNVHRMBAf8ECDAGAQH/AgEDMA4GA1UdDwEB/wQE\n"
-"AwIBxjANBgkqhkiG9w0BAQUFAAOCAQEADkbVPK7ih9legYsCmEEIjEy82tvuJxuC52pF7BaL\n"
-"T4Wg87JwvVqWuspube5Gi27nKi6Wsxkz67SfqLI37piol7Yutmcn1KZJ/RyTZXaeQi/cImya\n"
-"T/JaFTmxcdcrUehtHJjA2Sr0oYJ71clBoiMBdDhViw+5LmeiIAQ32pwL0xch4I+XeTRvhEgC\n"
-"IDMb5jREn5Fw9IBehEPCKdJsEhTkYY2sEJCehFC78JZvRZ+K88psT/oROhUVRsPNH4NbLUES\n"
-"7VBnQRM9IauUiqpOfMGx+6fWtScvl6tu4B3i0RwsH0Ti/L6RoZz71ilTc4afU9hDDl3WY4Jx\n"
-"HYB0yvbiAmvZWg==\n"
-"-----END CERTIFICATE-----\n",
-
-/* SecureSign RootCA11 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDbTCCAlWgAwIBAgIBATANBgkqhkiG9w0BAQUFADBYMQswCQYDVQQGEwJKUDErMCkGA1UE\n"
-"ChMiSmFwYW4gQ2VydGlmaWNhdGlvbiBTZXJ2aWNlcywgSW5jLjEcMBoGA1UEAxMTU2VjdXJl\n"
-"U2lnbiBSb290Q0ExMTAeFw0wOTA0MDgwNDU2NDdaFw0yOTA0MDgwNDU2NDdaMFgxCzAJBgNV\n"
-"BAYTAkpQMSswKQYDVQQKEyJKYXBhbiBDZXJ0aWZpY2F0aW9uIFNlcnZpY2VzLCBJbmMuMRww\n"
-"GgYDVQQDExNTZWN1cmVTaWduIFJvb3RDQTExMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB\n"
-"CgKCAQEA/XeqpRyQBTvLTJszi1oURaTnkBbR31fSIRCkF/3frNYfp+TbfPfs37gD2pRY/V1y\n"
-"fIw/XwFndBWW4wI8h9uuywGOwvNmxoVF9ALGOrVisq/6nL+k5tSAMJjzDbaTj6nU2DbysPyK\n"
-"yiyhFTOVMdrAG/LuYpmGYz+/3ZMqg6h2uRMft85OQoWPIucuGvKVCbIFtUROd6EgvanyTgp9\n"
-"UK31BQ1FT0Zx/Sg+U/sE2C3XZR1KG/rPO7AxmjVuyIsG0wCR8pQIZUyxNAYAeoni8McDWc/V\n"
-"1uinMrPmmECGxc0nEovMe863ETxiYAcjPitAbpSACW22s293bzUIUPsCh8U+iQIDAQABo0Iw\n"
-"QDAdBgNVHQ4EFgQUW/hNT7KlhtQ60vFjmqC+CfZXt94wDgYDVR0PAQH/BAQDAgEGMA8GA1Ud\n"
-"EwEB/wQFMAMBAf8wDQYJKoZIhvcNAQEFBQADggEBAKChOBZmLqdWHyGcBvod7bkixTgm2E5P\n"
-"7KN/ed5GIaGHd48HCJqypMWvDzKYC3xmKbabfSVSSUOrTC4rbnpwrxYO4wJs+0LmGJ1F2FXI\n"
-"6Dvd5+H0LgscNFxsWEr7jIhQX5Ucv+2rIrVls4W6ng+4reV6G4pQOh29Dbx7VFALuUKvVaAY\n"
-"ga1lme++5Jy/xIWrQbJUb9wlze144o4MjQlJ3WN7WmmWAiGovVJZ6X01y8hSyn+B/tlr0/cR\n"
-"7SXf+Of5pPpyl4RTDaXQMhhRdlkUbA/r7F+AjHVDg8OFmP9Mni0N5HeDk061lgeLKBObjBmN\n"
-"QSdJQO7e5iNEOdyhIta6A/I=\n"
-"-----END CERTIFICATE-----\n",
-
-/* ACEDICOM Root */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIFtTCCA52gAwIBAgIIYY3HhjsBggUwDQYJKoZIhvcNAQEFBQAwRDEWMBQGA1UEAwwNQUNF\n"
-"RElDT00gUm9vdDEMMAoGA1UECwwDUEtJMQ8wDQYDVQQKDAZFRElDT00xCzAJBgNVBAYTAkVT\n"
-"MB4XDTA4MDQxODE2MjQyMloXDTI4MDQxMzE2MjQyMlowRDEWMBQGA1UEAwwNQUNFRElDT00g\n"
-"Um9vdDEMMAoGA1UECwwDUEtJMQ8wDQYDVQQKDAZFRElDT00xCzAJBgNVBAYTAkVTMIICIjAN\n"
-"BgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA/5KV4WgGdrQsyFhIyv2AVClVYyT/kGWbEHV7\n"
-"w2rbYgIB8hiGtXxaOLHkWLn709gtn70yN78sFW2+tfQh0hOR2QetAQXW8713zl9CgQr5auOD\n"
-"AKgrLlUTY4HKRxx7XBZXehuDYAQ6PmXDzQHe3qTWDLqO3tkE7hdWIpuPY/1NFgu3e3eM+SW1\n"
-"0W2ZEi5PGrjm6gSSrj0RuVFCPYewMYWveVqc/udOXpJPQ/yrOq2lEiZmueIM15jO1FillUAK\n"
-"t0SdE3QrwqXrIhWYENiLxQSfHY9g5QYbm8+5eaA9oiM/Qj9r+hwDezCNzmzAv+YbX79nuIQZ\n"
-"1RXve8uQNjFiybwCq0Zfm/4aaJQ0PZCOrfbkHQl/Sog4P75n/TSW9R28MHTLOO7VbKvU/PQA\n"
-"twBbhTIWdjPp2KOZnQUAqhbm84F9b32qhm2tFXTTxKJxqvQUfecyuB+81fFOvW8XAjnXDpVC\n"
-"OscAPukmYxHqC9FK/xidstd7LzrZlvvoHpKuE1XI2Sf23EgbsCTBheN3nZqk8wwRHQ3ItBTu\n"
-"tYJXCb8gWH8vIiPYcMt5bMlL8qkqyPyHK9caUPgn6C9D4zq92Fdx/c6mUlv53U3t5fZvie27\n"
-"k5x2IXXwkkwp9y+cAS7+UEaeZAwUswdbxcJzbPEHXEUkFDWug/FqTYl6+rPYLWbwNof1K1MC\n"
-"AwEAAaOBqjCBpzAPBgNVHRMBAf8EBTADAQH/MB8GA1UdIwQYMBaAFKaz4SsrSbbXc6GqlPUB\n"
-"53NlTKxQMA4GA1UdDwEB/wQEAwIBhjAdBgNVHQ4EFgQUprPhKytJttdzoaqU9QHnc2VMrFAw\n"
-"RAYDVR0gBD0wOzA5BgRVHSAAMDEwLwYIKwYBBQUHAgEWI2h0dHA6Ly9hY2VkaWNvbS5lZGlj\n"
-"b21ncm91cC5jb20vZG9jMA0GCSqGSIb3DQEBBQUAA4ICAQDOLAtSUWImfQwng4/F9tqgaHtP\n"
-"kl7qpHMyEVNEskTLnewPeUKzEKbHDZ3Ltvo/Onzqv4hTGzz3gvoFNTPhNahXwOf9jU8/kzJP\n"
-"eGYDdwdY6ZXIfj7QeQCM8htRM5u8lOk6e25SLTKeI6RF+7YuE7CLGLHdztUdp0J/Vb77W7tH\n"
-"1PwkzQSulgUV1qzOMPPKC8W64iLgpq0i5ALudBF/TP94HTXa5gI06xgSYXcGCRZj6hitoocf\n"
-"8seACQl1ThCojz2GuHURwCRiipZ7SkXp7FnFvmuD5uHorLUwHv4FB4D54SMNUI8FmP8sX+g7\n"
-"tq3PgbUhh8oIKiMnMCArz+2UW6yyetLHKKGKC5tNSixthT8Jcjxn4tncB7rrZXtaAWPWkFtP\n"
-"F2Y9fwsZo5NjEFIqnxQWWOLcpfShFosOkYuByptZ+thrkQdlVV9SH686+5DdaaVbnG0OLLb6\n"
-"zqylfDJKZ0DcMDQj3dcEI2bw/FWAp/tmGYI1Z2JwOV5vx+qQQEQIHriy1tvuWacNGHk0vFQY\n"
-"XlPKNFHtRQrmjseCNj6nOGOpMCwXEGCSn1WHElkQwg9naRHMTh5+Spqtr0CodaxWkHS4oJyl\n"
-"eW/c6RrIaQXpuvoDs3zk4E7Czp3otkYNbn5XOmeUwssfnHdKZ05phkOTOPu220+DkdRgfks+\n"
-"KzgHVZhepA==\n"
-"-----END CERTIFICATE-----\n",
-
-/* Microsec e-Szigno Root CA 2009 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIECjCCAvKgAwIBAgIJAMJ+QwRORz8ZMA0GCSqGSIb3DQEBCwUAMIGCMQswCQYDVQQGEwJI\n"
-"VTERMA8GA1UEBwwIQnVkYXBlc3QxFjAUBgNVBAoMDU1pY3Jvc2VjIEx0ZC4xJzAlBgNVBAMM\n"
-"Hk1pY3Jvc2VjIGUtU3ppZ25vIFJvb3QgQ0EgMjAwOTEfMB0GCSqGSIb3DQEJARYQaW5mb0Bl\n"
-"LXN6aWduby5odTAeFw0wOTA2MTYxMTMwMThaFw0yOTEyMzAxMTMwMThaMIGCMQswCQYDVQQG\n"
-"EwJIVTERMA8GA1UEBwwIQnVkYXBlc3QxFjAUBgNVBAoMDU1pY3Jvc2VjIEx0ZC4xJzAlBgNV\n"
-"BAMMHk1pY3Jvc2VjIGUtU3ppZ25vIFJvb3QgQ0EgMjAwOTEfMB0GCSqGSIb3DQEJARYQaW5m\n"
-"b0BlLXN6aWduby5odTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAOn4j/NjrdqG\n"
-"2KfgQvvPkd6mJviZpWNwrZuuyjNAfW2WbqEORO7hE52UQlKavXWFdCyoDh2Tthi3jCyoz/tc\n"
-"cbna7P7ofo/kLx2yqHWH2Leh5TvPmUpG0IMZfcChEhyVbUr02MelTTMuhTlAdX4UfIASmFDH\n"
-"QWe4oIBhVKZsTh/gnQ4H6cm6M+f+wFUoLAKApxn1ntxVUwOXewdI/5n7N4okxFnMUBBjjqqp\n"
-"GrCEGob5X7uxUG6k0QrM1XF+H6cbfPVTbiJfyyvm1HxdrtbCxkzlBQHZ7Vf8wSN5/PrIJIOV\n"
-"87VqUQHQd9bpEqH5GoP7ghu5sJf0dgYzQ0mg/wu1+rUCAwEAAaOBgDB+MA8GA1UdEwEB/wQF\n"
-"MAMBAf8wDgYDVR0PAQH/BAQDAgEGMB0GA1UdDgQWBBTLD8bfQkPMPcu1SCOhGnqmKrs0aDAf\n"
-"BgNVHSMEGDAWgBTLD8bfQkPMPcu1SCOhGnqmKrs0aDAbBgNVHREEFDASgRBpbmZvQGUtc3pp\n"
-"Z25vLmh1MA0GCSqGSIb3DQEBCwUAA4IBAQDJ0Q5eLtXMs3w+y/w9/w0olZMEyL/azXm4Q5Dw\n"
-"pL7v8u8hmLzU1F0G9u5C7DBsoKqpyvGvivo/C3NqPuouQH4frlRheesuCDfXI/OMn74dseGk\n"
-"ddug4lQUsbocKaQY9hK6ohQU4zE1yED/t+AFdlfBHFny+L/k7SViXITwfn4fs775tyERzAMB\n"
-"VnCnEJIeGzSBHq2cGsMEPO0CYdYeBvNfOofyK/FFh+U9rNHHV4S9a67c2Pm2G2JwCz02yULy\n"
-"Mtd6YebS2z3PyKnJm9zbWETXbzivf3jTo60adbocwTZ8jx5tHMN1Rq41Bab2XD0h7lbwyYIi\n"
-"LXpUq3DDfSJlgnCW\n"
-"-----END CERTIFICATE-----\n",
-
-/* GlobalSign Root CA - R3 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4GA1UECxMX\n"
-"R2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNpZ24xEzARBgNVBAMT\n"
-"Ckdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4MTAwMDAwWjBMMSAwHgYDVQQL\n"
-"ExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEGA1UEChMKR2xvYmFsU2lnbjETMBEGA1UE\n"
-"AxMKR2xvYmFsU2lnbjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5Bngi\n"
-"FvXAg7aEyiie/QV2EcWtiHL8RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0M\n"
-"K66X17YUhhB5uzsTgHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL\n"
-"0gRgykmmKPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\n"
-"QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZXriX7613\n"
-"t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAwDgYDVR0PAQH/BAQD\n"
-"AgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+oLkUkrk1Q+mOai97i3Ru8MA0G\n"
-"CSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZURUm7lgAJQayzE4aGKAczymvmdLm6AC2u\n"
-"pArT9fHxD4q/c2dKg8dEe3jgr25sbwMpjjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdW\n"
-"PoO4zzUhw8lo/s7awlOqzJCK6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0\n"
-"095MJ6RMG3NzdvQXmcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJr\n"
-"lAGomecsMx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\n"
-"WD9f\n"
-"-----END CERTIFICATE-----\n",
-
-/* Autoridad de Certificacion Firmaprofesional CIF A62634068 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIGFDCCA/ygAwIBAgIIU+w77vuySF8wDQYJKoZIhvcNAQEFBQAwUTELMAkGA1UEBhMCRVMx\n"
-"QjBABgNVBAMMOUF1dG9yaWRhZCBkZSBDZXJ0aWZpY2FjaW9uIEZpcm1hcHJvZmVzaW9uYWwg\n"
-"Q0lGIEE2MjYzNDA2ODAeFw0wOTA1MjAwODM4MTVaFw0zMDEyMzEwODM4MTVaMFExCzAJBgNV\n"
-"BAYTAkVTMUIwQAYDVQQDDDlBdXRvcmlkYWQgZGUgQ2VydGlmaWNhY2lvbiBGaXJtYXByb2Zl\n"
-"c2lvbmFsIENJRiBBNjI2MzQwNjgwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDK\n"
-"lmuO6vj78aI14H9M2uDDUtd9thDIAl6zQyrET2qyyhxdKJp4ERppWVevtSBC5IsP5t9bpgOS\n"
-"L/UR5GLXMnE42QQMcas9UX4PB99jBVzpv5RvwSmCwLTaUbDBPLutN0pcyvFLNg4kq7/DhHf9\n"
-"qFD0sefGL9ItWY16Ck6WaVICqjaY7Pz6FIMMNx/Jkjd/14Et5cS54D40/mf0PmbR0/RAz15i\n"
-"NA9wBj4gGFrO93IbJWyTdBSTo3OxDqqHECNZXyAFGUftaI6SEspd/NYrspI8IM/hX68gvqB2\n"
-"f3bl7BqGYTM+53u0P6APjqK5am+5hyZvQWyIplD9amML9ZMWGxmPsu2bm8mQ9QEM3xk9Dz44\n"
-"I8kvjwzRAv4bVdZO0I08r0+k8/6vKtMFnXkIoctXMbScyJCyZ/QYFpM6/EfY0XiWMR+6Kwxf\n"
-"XZmtY4laJCB22N/9q06mIqqdXuYnin1oKaPnirjaEbsXLZmdEyRG98Xi2J+Of8ePdG1asuhy\n"
-"9azuJBCtLxTa/y2aRnFHvkLfuwHb9H/TKI8xWVvTyQKmtFLKbpf7Q8UIJm+K9Lv9nyiqDdVF\n"
-"8xM6HdjAeI9BZzwelGSuewvF6NkBiDkal4ZkQdU7hwxu+g/GvUgUvzlN1J5Bto+WHWOWk9mV\n"
-"BngxaJ43BjuAiUVhOSPHG0SjFeUc+JIwuwIDAQABo4HvMIHsMBIGA1UdEwEB/wQIMAYBAf8C\n"
-"AQEwDgYDVR0PAQH/BAQDAgEGMB0GA1UdDgQWBBRlzeurNR4APn7VdMActHNHDhpkLzCBpgYD\n"
-"VR0gBIGeMIGbMIGYBgRVHSAAMIGPMC8GCCsGAQUFBwIBFiNodHRwOi8vd3d3LmZpcm1hcHJv\n"
-"ZmVzaW9uYWwuY29tL2NwczBcBggrBgEFBQcCAjBQHk4AUABhAHMAZQBvACAAZABlACAAbABh\n"
-"ACAAQgBvAG4AYQBuAG8AdgBhACAANAA3ACAAQgBhAHIAYwBlAGwAbwBuAGEAIAAwADgAMAAx\n"
-"ADcwDQYJKoZIhvcNAQEFBQADggIBABd9oPm03cXF661LJLWhAqvdpYhKsg9VSytXjDvlMd3+\n"
-"xDLx51tkljYyGOylMnfX40S2wBEqgLk9am58m9Ot/MPWo+ZkKXzR4Tgegiv/J2Wv+xYVxC5x\n"
-"hOW1//qkR71kMrv2JYSiJ0L1ILDCExARzRAVukKQKtJE4ZYm6zFIEv0q2skGz3QeqUvVhyj5\n"
-"eTSSPi5E6PaPT481PyWzOdxjKpBrIF/EUhJOlywqrJ2X3kjyo2bbwtKDlaZmp54lD+kLM5Fl\n"
-"ClrD2VQS3a/DTg4fJl4N3LON7NWBcN7STyQF82xO9UxJZo3R/9ILJUFI/lGExkKvgATP0H5k\n"
-"SeTy36LssUzAKh3ntLFlosS88Zj0qnAHY7S42jtM+kAiMFsRpvAFDsYCA0irhpuF3dvd6qJ2\n"
-"gHN99ZwExEWN57kci57q13XRcrHedUTnQn3iV2t93Jm8PYMo6oCTjcVMZcFwgbg4/EMxsvYD\n"
-"NEeyrPsiBsse3RdHHF9mudMaotoRsaS8I8nkvof/uZS2+F0gStRf571oe2XyFR7SOqkt6dhr\n"
-"JKyXWERHrVkY8SFlcN7ONGCoQPHzPKTDKCOM/iczQ0CgFzzr6juwcqajuUpLXhZI9LK8yIyS\n"
-"xZ2frHI2vDSANGupi5LAuBft7HZT9SQBjLMi6Et8Vcad+qMUu2WFbm5PEn4KPJ2V\n"
-"-----END CERTIFICATE-----\n",
-
-/* Izenpe.com */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIF8TCCA9mgAwIBAgIQALC3WhZIX7/hy/WL1xnmfTANBgkqhkiG9w0BAQsFADA4MQswCQYD\n"
-"VQQGEwJFUzEUMBIGA1UECgwLSVpFTlBFIFMuQS4xEzARBgNVBAMMCkl6ZW5wZS5jb20wHhcN\n"
-"MDcxMjEzMTMwODI4WhcNMzcxMjEzMDgyNzI1WjA4MQswCQYDVQQGEwJFUzEUMBIGA1UECgwL\n"
-"SVpFTlBFIFMuQS4xEzARBgNVBAMMCkl6ZW5wZS5jb20wggIiMA0GCSqGSIb3DQEBAQUAA4IC\n"
-"DwAwggIKAoICAQDJ03rKDx6sp4boFmVqscIbRTJxldn+EFvMr+eleQGPicPK8lVx93e+d5Tz\n"
-"cqQsRNiekpsUOqHnJJAKClaOxdgmlOHZSOEtPtoKct2jmRXagaKH9HtuJneJWK3W6wyyQXpz\n"
-"bm3benhB6QiIEn6HLmYRY2xU+zydcsC8Lv/Ct90NduM61/e0aL6i9eOBbsFGb12N4E3GVFWJ\n"
-"GjMxCrFXuaOKmMPsOzTFlUFpfnXCPCDFYbpRR6AgkJOhkEvzTnyFRVSa0QUmQbC1TR0zvsQD\n"
-"yCV8wXDbO/QJLVQnSKwv4cSsPsjLkkxTOTcj7NMB+eAJRE1NZMDhDVqHIrytG6P+JrUV86f8\n"
-"hBnp7KGItERphIPzidF0BqnMC9bC3ieFUCbKF7jJeodWLBoBHmy+E60QrLUk9TiRodZL2vG7\n"
-"0t5HtfG8gfZZa88ZU+mNFctKy6lvROUbQc/hhqfK0GqfvEyNBjNaooXlkDWgYlwWTvDjovoD\n"
-"GrQscbNYLN57C9saD+veIR8GdwYDsMnvmfzAuU8Lhij+0rnq49qlw0dpEuDb8PYZi+17cNcC\n"
-"1u2HGCgsBCRMd+RIihrGO5rUD8r6ddIBQFqNeb+Lz0vPqhbBleStTIo+F5HUsWLlguWABKQD\n"
-"fo2/2n+iD5dPDNMN+9fR5XJ+HMh3/1uaD7euBUbl8agW7EekFwIDAQABo4H2MIHzMIGwBgNV\n"
-"HREEgagwgaWBD2luZm9AaXplbnBlLmNvbaSBkTCBjjFHMEUGA1UECgw+SVpFTlBFIFMuQS4g\n"
-"LSBDSUYgQTAxMzM3MjYwLVJNZXJjLlZpdG9yaWEtR2FzdGVpeiBUMTA1NSBGNjIgUzgxQzBB\n"
-"BgNVBAkMOkF2ZGEgZGVsIE1lZGl0ZXJyYW5lbyBFdG9yYmlkZWEgMTQgLSAwMTAxMCBWaXRv\n"
-"cmlhLUdhc3RlaXowDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYE\n"
-"FB0cZQ6o8iV7tJHP5LGx5r1VdGwFMA0GCSqGSIb3DQEBCwUAA4ICAQB4pgwWSp9MiDrAyw6l\n"
-"Fn2fuUhfGI8NYjb2zRlrrKvV9pF9rnHzP7MOeIWblaQnIUdCSnxIOvVFfLMMjlF4rJUT3sb9\n"
-"fbgakEyrkgPH7UIBzg/YsfqikuFgba56awmqxinuaElnMIAkejEWOVt+8Rwu3WwJrfIxwYJO\n"
-"ubv5vr8qhT/AQKM6WfxZSzwoJNu0FXWuDYi6LnPAvViH5ULy617uHjAimcs30cQhbIHsvm0m\n"
-"5hzkQiCeR7Csg1lwLDXWrzY0tM07+DKo7+N4ifuNRSzanLh+QBxh5z6ikixL8s36mLYp//Py\n"
-"e6kfLqCTVyvehQP5aTfLnnhqBbTFMXiJ7HqnheG5ezzevh55hM6fcA5ZwjUukCox2eRFekGk\n"
-"LhObNA5me0mrZJfQRsN5nXJQY6aYWwa9SG3YOYNw6DXwBdGqvOPbyALqfP2C2sJbUjWumDqt\n"
-"ujWTI6cfSN01RpiyEGjkpTHCClguGYEQyVB1/OpaFs4R1+7vUIgtYf8/QnMFlEPVjjxOAToZ\n"
-"pR9GTnfQXeWBIiGH/pR9hNiTrdZoQ0iy2+tzJOeRf1SktoA+naM8THLCV8Sg1Mw4J87VBp6i\n"
-"SNnpn86CcDaTmjvfliHjWbcM2pE38P1ZWrOZyGlsQyYBNWNgVYkDOnXYukrZVP/u3oDYLdE4\n"
-"1V4tC5h9Pmzb/CaIxw==\n"
-"-----END CERTIFICATE-----\n",
-
-/* Chambers of Commerce Root - 2008 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIHTzCCBTegAwIBAgIJAKPaQn6ksa7aMA0GCSqGSIb3DQEBBQUAMIGuMQswCQYDVQQGEwJF\n"
-"VTFDMEEGA1UEBxM6TWFkcmlkIChzZWUgY3VycmVudCBhZGRyZXNzIGF0IHd3dy5jYW1lcmZp\n"
-"cm1hLmNvbS9hZGRyZXNzKTESMBAGA1UEBRMJQTgyNzQzMjg3MRswGQYDVQQKExJBQyBDYW1l\n"
-"cmZpcm1hIFMuQS4xKTAnBgNVBAMTIENoYW1iZXJzIG9mIENvbW1lcmNlIFJvb3QgLSAyMDA4\n"
-"MB4XDTA4MDgwMTEyMjk1MFoXDTM4MDczMTEyMjk1MFowga4xCzAJBgNVBAYTAkVVMUMwQQYD\n"
-"VQQHEzpNYWRyaWQgKHNlZSBjdXJyZW50IGFkZHJlc3MgYXQgd3d3LmNhbWVyZmlybWEuY29t\n"
-"L2FkZHJlc3MpMRIwEAYDVQQFEwlBODI3NDMyODcxGzAZBgNVBAoTEkFDIENhbWVyZmlybWEg\n"
-"Uy5BLjEpMCcGA1UEAxMgQ2hhbWJlcnMgb2YgQ29tbWVyY2UgUm9vdCAtIDIwMDgwggIiMA0G\n"
-"CSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCvAMtwNyuAWko6bHiUfaN/Gh/2NdW928sNRHI+\n"
-"JrKQUrpjOyhYb6WzbZSm891kDFX29ufyIiKAXuFixrYp4YFs8r/lfTJqVKAyGVn+H4vXPWCG\n"
-"hSRv4xGzdz4gljUha7MI2XAuZPeEklPWDrCQiorjh40G072QDuKZoRuGDtqaCrsLYVAGUvGe\n"
-"f3bsyw/QHg3PmTA9HMRFEFis1tPo1+XqxQEHd9ZR5gN/ikilTWh1uem8nk4ZcfUyS5xtYBkL\n"
-"+8ydddy/Js2Pk3g5eXNeJQ7KXOt3EgfLZEFHcpOrUMPrCXZkNNI5t3YRCQ12RcSprj1qr7V9\n"
-"ZS+UWBDsXHyvfuK2GNnQm05aSd+pZgvMPMZ4fKecHePOjlO+Bd5gD2vlGts/4+EhySnB8esH\n"
-"nFIbAURRPHsl18TlUlRdJQfKFiC4reRB7noI/plvg6aRArBsNlVq5331lubKgdaX8ZSD6e2w\n"
-"sWsSaR6s+12pxZjptFtYer49okQ6Y1nUCyXeG0+95QGezdIp1Z8XGQpvvwyQ0wlf2eOKNcx5\n"
-"Wk0ZN5K3xMGtr/R5JJqyAQuxr1yW84Ay+1w9mPGgP0revq+ULtlVmhduYJ1jbLhjya6BXBg1\n"
-"4JC7vjxPNyK5fuvPnnchpj04gftI2jE9K+OJ9dC1vX7gUMQSibMjmhAxhduub+84Mxh2EQID\n"
-"AQABo4IBbDCCAWgwEgYDVR0TAQH/BAgwBgEB/wIBDDAdBgNVHQ4EFgQU+SSsD7K1+HnA+mCI\n"
-"G8TZTQKeFxkwgeMGA1UdIwSB2zCB2IAU+SSsD7K1+HnA+mCIG8TZTQKeFxmhgbSkgbEwga4x\n"
-"CzAJBgNVBAYTAkVVMUMwQQYDVQQHEzpNYWRyaWQgKHNlZSBjdXJyZW50IGFkZHJlc3MgYXQg\n"
-"d3d3LmNhbWVyZmlybWEuY29tL2FkZHJlc3MpMRIwEAYDVQQFEwlBODI3NDMyODcxGzAZBgNV\n"
-"BAoTEkFDIENhbWVyZmlybWEgUy5BLjEpMCcGA1UEAxMgQ2hhbWJlcnMgb2YgQ29tbWVyY2Ug\n"
-"Um9vdCAtIDIwMDiCCQCj2kJ+pLGu2jAOBgNVHQ8BAf8EBAMCAQYwPQYDVR0gBDYwNDAyBgRV\n"
-"HSAAMCowKAYIKwYBBQUHAgEWHGh0dHA6Ly9wb2xpY3kuY2FtZXJmaXJtYS5jb20wDQYJKoZI\n"
-"hvcNAQEFBQADggIBAJASryI1wqM58C7e6bXpeHxIvj99RZJe6dqxGfwWPJ+0W2aeaufDuV2I\n"
-"6A+tzyMP3iU6XsxPpcG1Lawk0lgH3qLPaYRgM+gQDROpI9CF5Y57pp49chNyM/WqfcZjHwj0\n"
-"/gF/JM8rLFQJ3uIrbZLGOU8W6jx+ekbURWpGqOt1glanq6B8aBMz9p0w8G8nOSQjKpD9kCk1\n"
-"8pPfNKXG9/jvjA9iSnyu0/VU+I22mlaHFoI6M6taIgj3grrqLuBHmrS1RaMFO9ncLkVAO+rc\n"
-"f+g769HsJtg1pDDFOqxXnrN2pSB7+R5KBWIBpih1YJeSDW4+TTdDDZIVnBgizVGZoCkaPF+K\n"
-"MjNbMMeJL0eYD6MDxvbxrN8y8NmBGuScvfaAFPDRLLmF9dijscilIeUcE5fuDr3fKanvNFNb\n"
-"0+RqE4QGtjICxFKuItLcsiFCGtpA8CnJ7AoMXOLQusxI0zcKzBIKinmwPQN/aUv0NCB9szTq\n"
-"jktk9T79syNnFQ0EuPAtwQlRPLJsFfClI9eDdOTlLsn+mCdCxqvGnrDQWzilm1DefhiYtUU7\n"
-"9nm06PcaewaD+9CL2rvHvRirCG88gGtAPxkZumWK5r7VXNM21+9AUiRgOGcEMeyP84LG3rlV\n"
-"8zsxkVrctQgVrXYlCg17LofiDKYGvCYQbTed7N14jHyAxfDZd0jQ\n"
-"-----END CERTIFICATE-----\n",
-
-/* Global Chambersign Root - 2008 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIHSTCCBTGgAwIBAgIJAMnN0+nVfSPOMA0GCSqGSIb3DQEBBQUAMIGsMQswCQYDVQQGEwJF\n"
-"VTFDMEEGA1UEBxM6TWFkcmlkIChzZWUgY3VycmVudCBhZGRyZXNzIGF0IHd3dy5jYW1lcmZp\n"
-"cm1hLmNvbS9hZGRyZXNzKTESMBAGA1UEBRMJQTgyNzQzMjg3MRswGQYDVQQKExJBQyBDYW1l\n"
-"cmZpcm1hIFMuQS4xJzAlBgNVBAMTHkdsb2JhbCBDaGFtYmVyc2lnbiBSb290IC0gMjAwODAe\n"
-"Fw0wODA4MDExMjMxNDBaFw0zODA3MzExMjMxNDBaMIGsMQswCQYDVQQGEwJFVTFDMEEGA1UE\n"
-"BxM6TWFkcmlkIChzZWUgY3VycmVudCBhZGRyZXNzIGF0IHd3dy5jYW1lcmZpcm1hLmNvbS9h\n"
-"ZGRyZXNzKTESMBAGA1UEBRMJQTgyNzQzMjg3MRswGQYDVQQKExJBQyBDYW1lcmZpcm1hIFMu\n"
-"QS4xJzAlBgNVBAMTHkdsb2JhbCBDaGFtYmVyc2lnbiBSb290IC0gMjAwODCCAiIwDQYJKoZI\n"
-"hvcNAQEBBQADggIPADCCAgoCggIBAMDfVtPkOpt2RbQT2//BthmLN0EYlVJH6xedKYiONWwG\n"
-"Mi5HYvNJBL99RDaxccy9Wglz1dmFRP+RVyXfXjaOcNFccUMd2drvXNL7G706tcuto8xEpw2u\n"
-"IRU/uXpbknXYpBI4iRmKt4DS4jJvVpyR1ogQC7N0ZJJ0YPP2zxhPYLIj0Mc7zmFLmY/CDNBA\n"
-"spjcDahOo7kKrmCgrUVSY7pmvWjg+b4aqIG7HkF4ddPB/gBVsIdU6CeQNR1MM62X/JcumIS/\n"
-"LMmjv9GYERTtY/jKmIhYF5ntRQOXfjyGHoiMvvKRhI9lNNgATH23MRdaKXoKGCQwoze1eqkB\n"
-"fSbW+Q6OWfH9GzO1KTsXO0G2Id3UwD2ln58fQ1DJu7xsepeY7s2MH/ucUa6LcL0nn3HAa6x9\n"
-"kGbo1106DbDVwo3VyJ2dwW3Q0L9R5OP4wzg2rtandeavhENdk5IMagfeOx2YItaswTXbo6Al\n"
-"/3K1dh3ebeksZixShNBFks4c5eUzHdwHU1SjqoI7mjcv3N2gZOnm3b2u/GSFHTynyQbehP9r\n"
-"6GsaPMWis0L7iwk+XwhSx2LE1AVxv8Rk5Pihg+g+EpuoHtQ2TS9x9o0o9oOpE9JhwZG7SMA0\n"
-"j0GMS0zbaRL/UJScIINZc+18ofLx/d33SdNDWKBWY8o9PeU1VlnpDsogzCtLkykPAgMBAAGj\n"
-"ggFqMIIBZjASBgNVHRMBAf8ECDAGAQH/AgEMMB0GA1UdDgQWBBS5CcqcHtvTbDprru1U8VuT\n"
-"BjUuXjCB4QYDVR0jBIHZMIHWgBS5CcqcHtvTbDprru1U8VuTBjUuXqGBsqSBrzCBrDELMAkG\n"
-"A1UEBhMCRVUxQzBBBgNVBAcTOk1hZHJpZCAoc2VlIGN1cnJlbnQgYWRkcmVzcyBhdCB3d3cu\n"
-"Y2FtZXJmaXJtYS5jb20vYWRkcmVzcykxEjAQBgNVBAUTCUE4Mjc0MzI4NzEbMBkGA1UEChMS\n"
-"QUMgQ2FtZXJmaXJtYSBTLkEuMScwJQYDVQQDEx5HbG9iYWwgQ2hhbWJlcnNpZ24gUm9vdCAt\n"
-"IDIwMDiCCQDJzdPp1X0jzjAOBgNVHQ8BAf8EBAMCAQYwPQYDVR0gBDYwNDAyBgRVHSAAMCow\n"
-"KAYIKwYBBQUHAgEWHGh0dHA6Ly9wb2xpY3kuY2FtZXJmaXJtYS5jb20wDQYJKoZIhvcNAQEF\n"
-"BQADggIBAICIf3DekijZBZRG/5BXqfEv3xoNa/p8DhxJJHkn2EaqbylZUohwEurdPfWbU1Rv\n"
-"4WCiqAm57OtZfMY18dwY6fFn5a+6ReAJ3spED8IXDneRRXozX1+WLGiLwUePmJs9wOzL9dWC\n"
-"koQ10b42OFZyMVtHLaoXpGNR6woBrX/sdZ7LoR/xfxKxueRkf2fWIyr0uDldmOghp+G9PUIa\n"
-"dJpwr2hsUF1Jz//7Dl3mLEfXgTpZALVza2Mg9jFFCDkO9HB+QHBaP9BrQql0PSgvAm11cpUJ\n"
-"jUhjxsYjV5KTXjXBjfkK9yydYhz2rXzdpjEetrHHfoUm+qRqtdpjMNHvkzeyZi99Bffnt0uY\n"
-"lDXA2TopwZ2yUDMdSqlapskD7+3056huirRXhOukP9DuqqqHW2Pok+JrqNS4cnhrG+055F3L\n"
-"m6qH1U9OAP7Zap88MQ8oAgF9mOinsKJknnn4SPIVqczmyETrP3iZ8ntxPjzxmKfFGBI/5rso\n"
-"M0LpRQp8bfKGeS/Fghl9CYl8slR2iK7ewfPM4W7bMdaTrpmg7yVqc5iJWzouE4gev8CSlDQb\n"
-"4ye3ix5vQv/n6TebUB0tovkC7stYWDpxvGjjqsGvHCgfotwjZT+B6q6Z09gwzxMNTxXJhLyn\n"
-"SC34MCN32EZLeW32jO06f2ARePTpm67VVMB0gNELQp/B\n"
-"-----END CERTIFICATE-----\n",
-
-/* Go Daddy Root Certificate Authority - G2 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDxTCCAq2gAwIBAgIBADANBgkqhkiG9w0BAQsFADCBgzELMAkGA1UEBhMCVVMxEDAOBgNV\n"
-"BAgTB0FyaXpvbmExEzARBgNVBAcTClNjb3R0c2RhbGUxGjAYBgNVBAoTEUdvRGFkZHkuY29t\n"
-"LCBJbmMuMTEwLwYDVQQDEyhHbyBEYWRkeSBSb290IENlcnRpZmljYXRlIEF1dGhvcml0eSAt\n"
-"IEcyMB4XDTA5MDkwMTAwMDAwMFoXDTM3MTIzMTIzNTk1OVowgYMxCzAJBgNVBAYTAlVTMRAw\n"
-"DgYDVQQIEwdBcml6b25hMRMwEQYDVQQHEwpTY290dHNkYWxlMRowGAYDVQQKExFHb0RhZGR5\n"
-"LmNvbSwgSW5jLjExMC8GA1UEAxMoR28gRGFkZHkgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3Jp\n"
-"dHkgLSBHMjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAL9xYgjx+lk09xvJGKP3\n"
-"gElY6SKDE6bFIEMBO4Tx5oVJnyfq9oQbTqC023CYxzIBsQU+B07u9PpPL1kwIuerGVZr4oAH\n"
-"/PMWdYA5UXvl+TW2dE6pjYIT5LY/qQOD+qK+ihVqf94Lw7YZFAXK6sOoBJQ7RnwyDfMAZiLI\n"
-"jWltNowRGLfTshxgtDj6AozO091GB94KPutdfMh8+7ArU6SSYmlRJQVhGkSBjCypQ5Yj36w6\n"
-"gZoOKcUcqeldHraenjAKOc7xiID7S13MMuyFYkMlNAJWJwGRtDtwKj9useiciAF9n9T521Nt\n"
-"YJ2/LOdYq7hfRvzOxBsDPAnrSTFcaUaz4EcCAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAO\n"
-"BgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFDqahQcQZyi27/a9BUFuIMGU2g/eMA0GCSqGSIb3\n"
-"DQEBCwUAA4IBAQCZ21151fmXWWcDYfF+OwYxdS2hII5PZYe096acvNjpL9DbWu7PdIxztDhC\n"
-"2gV7+AJ1uP2lsdeu9tfeE8tTEH6KRtGX+rcuKxGrkLAngPnon1rpN5+r5N9ss4UXnT3ZJE95\n"
-"kTXWXwTrgIOrmgIttRD02JDHBHNA7XIloKmf7J6raBKZV8aPEjoJpL1E/QYVN8Gb5DKj7Tjo\n"
-"2GTzLH4U/ALqn83/B2gX2yKQOC16jdFU8WnjXzPKej17CuPKf1855eJ1usV2GDPOLPAvTK33\n"
-"sefOT6jEm0pUBsV/fdUID+Ic/n4XuKxe9tQWskMJDE32p2u0mYRlynqI4uJEvlz36hz1\n"
-"-----END CERTIFICATE-----\n",
-
-/* Starfield Root Certificate Authority - G2 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIID3TCCAsWgAwIBAgIBADANBgkqhkiG9w0BAQsFADCBjzELMAkGA1UEBhMCVVMxEDAOBgNV\n"
-"BAgTB0FyaXpvbmExEzARBgNVBAcTClNjb3R0c2RhbGUxJTAjBgNVBAoTHFN0YXJmaWVsZCBU\n"
-"ZWNobm9sb2dpZXMsIEluYy4xMjAwBgNVBAMTKVN0YXJmaWVsZCBSb290IENlcnRpZmljYXRl\n"
-"IEF1dGhvcml0eSAtIEcyMB4XDTA5MDkwMTAwMDAwMFoXDTM3MTIzMTIzNTk1OVowgY8xCzAJ\n"
-"BgNVBAYTAlVTMRAwDgYDVQQIEwdBcml6b25hMRMwEQYDVQQHEwpTY290dHNkYWxlMSUwIwYD\n"
-"VQQKExxTdGFyZmllbGQgVGVjaG5vbG9naWVzLCBJbmMuMTIwMAYDVQQDEylTdGFyZmllbGQg\n"
-"Um9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkgLSBHMjCCASIwDQYJKoZIhvcNAQEBBQADggEP\n"
-"ADCCAQoCggEBAL3twQP89o/8ArFvW59I2Z154qK3A2FWGMNHttfKPTUuiUP3oWmb3ooa/RMg\n"
-"nLRJdzIpVv257IzdIvpy3Cdhl+72WoTsbhm5iSzchFvVdPtrX8WJpRBSiUZV9Lh1HOZ/5FSu\n"
-"S/hVclcCGfgXcVnrHigHdMWdSL5stPSksPNkN3mSwOxGXn/hbVNMYq/NHwtjuzqd+/x5AJhh\n"
-"dM8mgkBj87JyahkNmcrUDnXMN/uLicFZ8WJ/X7NfZTD4p7dNdloedl40wOiWVpmKs/B/pM29\n"
-"3DIxfJHP4F8R+GuqSVzRmZTRouNjWwl2tVZi4Ut0HZbUJtQIBFnQmA4O5t78w+wfkPECAwEA\n"
-"AaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFHwMMh+n\n"
-"2TB/xH1oo2Kooc6rB1snMA0GCSqGSIb3DQEBCwUAA4IBAQARWfolTwNvlJk7mh+ChTnUdgWU\n"
-"XuEok21iXQnCoKjUsHU48TRqneSfioYmUeYs0cYtbpUgSpIB7LiKZ3sx4mcujJUDJi5DnUox\n"
-"9g61DLu34jd/IroAow57UvtruzvE03lRTs2Q9GcHGcg8RnoNAX3FWOdt5oUwF5okxBDgBPfg\n"
-"8n/Uqgr/Qh037ZTlZFkSIHc40zI+OIF1lnP6aI+xy84fxez6nH7PfrHxBy22/L/KpL/QlwVK\n"
-"vOoYKAKQvVR4CSFx09F9HdkWsKlhPdAKACL8x3vLCWRFCztAgfd9fDL1mMpYjn0q7pBZc2T5\n"
-"NnReJaH1ZgUufzkVqSr7UIuOhWn0\n"
-"-----END CERTIFICATE-----\n",
-
-/* Starfield Services Root Certificate Authority - G2 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIID7zCCAtegAwIBAgIBADANBgkqhkiG9w0BAQsFADCBmDELMAkGA1UEBhMCVVMxEDAOBgNV\n"
-"BAgTB0FyaXpvbmExEzARBgNVBAcTClNjb3R0c2RhbGUxJTAjBgNVBAoTHFN0YXJmaWVsZCBU\n"
-"ZWNobm9sb2dpZXMsIEluYy4xOzA5BgNVBAMTMlN0YXJmaWVsZCBTZXJ2aWNlcyBSb290IENl\n"
-"cnRpZmljYXRlIEF1dGhvcml0eSAtIEcyMB4XDTA5MDkwMTAwMDAwMFoXDTM3MTIzMTIzNTk1\n"
-"OVowgZgxCzAJBgNVBAYTAlVTMRAwDgYDVQQIEwdBcml6b25hMRMwEQYDVQQHEwpTY290dHNk\n"
-"YWxlMSUwIwYDVQQKExxTdGFyZmllbGQgVGVjaG5vbG9naWVzLCBJbmMuMTswOQYDVQQDEzJT\n"
-"dGFyZmllbGQgU2VydmljZXMgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkgLSBHMjCCASIw\n"
-"DQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBANUMOsQq+U7i9b4Zl1+OiFOxHz/Lz58gE20p\n"
-"OsgPfTz3a3Y4Y9k2YKibXlwAgLIvWX/2h/klQ4bnaRtSmpDhcePYLQ1Ob/bISdm28xpWriu2\n"
-"dBTrz/sm4xq6HZYuajtYlIlHVv8loJNwU4PahHQUw2eeBGg6345AWh1KTs9DkTvnVtYAcMtS\n"
-"7nt9rjrnvDH5RfbCYM8TWQIrgMw0R9+53pBlbQLPLJGmpufehRhJfGZOozptqbXuNC66DQO4\n"
-"M99H67FrjSXZm86B0UVGMpZwh94CDklDhbZsc7tk6mFBrMnUVN+HL8cisibMn1lUaJ/8viov\n"
-"xFUcdUBgF4UCVTmLfwUCAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMC\n"
-"AQYwHQYDVR0OBBYEFJxfAN+qAdcwKziIorhtSpzyEZGDMA0GCSqGSIb3DQEBCwUAA4IBAQBL\n"
-"NqaEd2ndOxmfZyMIbw5hyf2E3F/YNoHN2BtBLZ9g3ccaaNnRbobhiCPPE95Dz+I0swSdHynV\n"
-"v/heyNXBve6SbzJ08pGCL72CQnqtKrcgfU28elUSwhXqvfdqlS5sdJ/PHLTyxQGjhdByPq1z\n"
-"qwubdQxtRbeOlKyWN7Wg0I8VRw7j6IPdj/3vQQF3zCepYoUz8jcI73HPdwbeyBkdiEDPfUYd\n"
-"/x7H4c7/I9vG+o1VTqkC50cRRj70/b17KSa7qWFiNyi2LSr2EIZkyXCn0q23KXB56jzaYyWf\n"
-"/Wi3MOxw+3WKt21gZ7IeyLnp2KhvAotnDU0mV3HaIPzBSlCNsSi6\n"
-"-----END CERTIFICATE-----\n",
-
-/* AffirmTrust Commercial */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDTDCCAjSgAwIBAgIId3cGJyapsXwwDQYJKoZIhvcNAQELBQAwRDELMAkGA1UEBhMCVVMx\n"
-"FDASBgNVBAoMC0FmZmlybVRydXN0MR8wHQYDVQQDDBZBZmZpcm1UcnVzdCBDb21tZXJjaWFs\n"
-"MB4XDTEwMDEyOTE0MDYwNloXDTMwMTIzMTE0MDYwNlowRDELMAkGA1UEBhMCVVMxFDASBgNV\n"
-"BAoMC0FmZmlybVRydXN0MR8wHQYDVQQDDBZBZmZpcm1UcnVzdCBDb21tZXJjaWFsMIIBIjAN\n"
-"BgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA9htPZwcroRX1BiLLHwGy43NFBkRJLLtJJRTW\n"
-"zsO3qyxPxkEylFf6EqdbDuKPHx6GGaeqtS25Xw2Kwq+FNXkyLbscYjfysVtKPcrNcV/pQr6U\n"
-"6Mje+SJIZMblq8Yrba0F8PrVC8+a5fBQpIs7R6UjW3p6+DM/uO+Zl+MgwdYoic+U+7lF7eNA\n"
-"FxHUdPALMeIrJmqbTFeurCA+ukV6BfO9m2kVrn1OIGPENXY6BwLJN/3HR+7o8XYdcxXyl6S1\n"
-"yHp52UKqK39c/s4mT6NmgTWvRLpUHhwwMmWd5jyTXlBOeuM61G7MGvv50jeuJCqrVwMiKA1J\n"
-"dX+3KNp1v47j3A55MQIDAQABo0IwQDAdBgNVHQ4EFgQUnZPGU4teyq8/nx4P5ZmVvCT2lI8w\n"
-"DwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwDQYJKoZIhvcNAQELBQADggEBAFis\n"
-"9AQOzcAN/wr91LoWXym9e2iZWEnStB03TX8nfUYGXUPGhi4+c7ImfU+TqbbEKpqrIZcUsd6M\n"
-"06uJFdhrJNTxFq7YpFzUf1GO7RgBsZNjvbz4YYCanrHOQnDiqX0GJX0nof5v7LMeJNrjS1Ua\n"
-"ADs1tDvZ110w/YETifLCBivtZ8SOyUOyXGsViQK8YvxO8rUzqrJv0wqiUOP2O+guRMLbZjip\n"
-"M1ZI8W0bM40NjD9gN53Tym1+NH4Nn3J2ixufcv1SNUFFApYvHLKac0khsUlHRUe072o0EclN\n"
-"msxZt9YCnlpOZbWUrhvfKbAW8b8Angc6F2S1BLUjIZkKlTuXfO8=\n"
-"-----END CERTIFICATE-----\n",
-
-/* AffirmTrust Networking */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDTDCCAjSgAwIBAgIIfE8EORzUmS0wDQYJKoZIhvcNAQEFBQAwRDELMAkGA1UEBhMCVVMx\n"
-"FDASBgNVBAoMC0FmZmlybVRydXN0MR8wHQYDVQQDDBZBZmZpcm1UcnVzdCBOZXR3b3JraW5n\n"
-"MB4XDTEwMDEyOTE0MDgyNFoXDTMwMTIzMTE0MDgyNFowRDELMAkGA1UEBhMCVVMxFDASBgNV\n"
-"BAoMC0FmZmlybVRydXN0MR8wHQYDVQQDDBZBZmZpcm1UcnVzdCBOZXR3b3JraW5nMIIBIjAN\n"
-"BgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtITMMxcua5Rsa2FSoOujz3mUTOWUgJnLVWRE\n"
-"ZY9nZOIG41w3SfYvm4SEHi3yYJ0wTsyEheIszx6e/jarM3c1RNg1lho9Nuh6DtjVR6FqaYvZ\n"
-"/Ls6rnla1fTWcbuakCNrmreIdIcMHl+5ni36q1Mr3Lt2PpNMCAiMHqIjHNRqrSK6mQEubWXL\n"
-"viRmVSRLQESxG9fhwoXA3hA/Pe24/PHxI1Pcv2WXb9n5QHGNfb2V1M6+oF4nI979ptAmDgAp\n"
-"6zxG8D1gvz9Q0twmQVGeFDdCBKNwV6gbh+0t+nvujArjqWaJGctB+d1ENmHP4ndGyH329JKB\n"
-"Nv3bNPFyfvMMFr20FQIDAQABo0IwQDAdBgNVHQ4EFgQUBx/S55zawm6iQLSwelAQUHTEyL0w\n"
-"DwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwDQYJKoZIhvcNAQEFBQADggEBAIlX\n"
-"shZ6qML91tmbmzTCnLQyFE2npN/svqe++EPbkTfOtDIuUFUaNU52Q3Eg75N3ThVwLofDwR1t\n"
-"3Mu1J9QsVtFSUzpE0nPIxBsFZVpikpzuQY0x2+c06lkh1QF612S4ZDnNye2v7UsDSKegmQGA\n"
-"3GWjNq5lWUhPgkvIZfFXHeVZLgo/bNjR9eUJtGxUAArgFU2HdW23WJZa3W3SAKD0m0i+wzek\n"
-"ujbgfIeFlxoVot4uolu9rxj5kFDNcFn4J2dHy8egBzp90SxdbBk6ZrV9/ZFvgrG+CJPbFEfx\n"
-"ojfHRZ48x3evZKiT3/Zpg4Jg8klCNO1aAFSFHBY2kgxc+qatv9s=\n"
-"-----END CERTIFICATE-----\n",
-
-/* AffirmTrust Premium */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIFRjCCAy6gAwIBAgIIbYwURrGmCu4wDQYJKoZIhvcNAQEMBQAwQTELMAkGA1UEBhMCVVMx\n"
-"FDASBgNVBAoMC0FmZmlybVRydXN0MRwwGgYDVQQDDBNBZmZpcm1UcnVzdCBQcmVtaXVtMB4X\n"
-"DTEwMDEyOTE0MTAzNloXDTQwMTIzMTE0MTAzNlowQTELMAkGA1UEBhMCVVMxFDASBgNVBAoM\n"
-"C0FmZmlybVRydXN0MRwwGgYDVQQDDBNBZmZpcm1UcnVzdCBQcmVtaXVtMIICIjANBgkqhkiG\n"
-"9w0BAQEFAAOCAg8AMIICCgKCAgEAxBLfqV/+Qd3d9Z+K4/as4Tx4mrzY8H96oDMq3I0gW64t\n"
-"b+eT2TZwamjPjlGjhVtnBKAQJG9dKILBl1fYSCkTtuG+kU3fhQxTGJoeJKJPj/CihQvL9Cl/\n"
-"0qRY7iZNyaqoe5rZ+jjeRFcV5fiMyNlI4g0WJx0eyIOFJbe6qlVBzAMiSy2RjYvmia9mx+n/\n"
-"K+k8rNrSs8PhaJyJ+HoAVt70VZVs+7pk3WKL3wt3MutizCaam7uqYoNMtAZ6MMgpv+0GTZe5\n"
-"HMQxK9VfvFMSF5yZVylmd2EhMQcuJUmdGPLu8ytxjLW6OQdJd/zvLpKQBY0tL3d770O/Nbua\n"
-"2Plzpyzy0FfuKE4mX4+QaAkvuPjcBukumj5Rp9EixAqnOEhss/n/fauGV+O61oV4d7pD6kh/\n"
-"9ti+I20ev9E2bFhc8e6kGVQa9QPSdubhjL08s9NIS+LI+H+SqHZGnEJlPqQewQcDWkYtuJfz\n"
-"t9WyVSHvutxMAJf7FJUnM7/oQ0dG0giZFmA7mn7S5u046uwBHjxIVkkJx0w3AJ6IDsBz4W9m\n"
-"6XJHMD4Q5QsDyZpCAGzFlH5hxIrff4IaC1nEWTJ3s7xgaVY5/bQGeyzWZDbZvUjthB9+pSKP\n"
-"KrhC9IK31FOQeE4tGv2Bb0TXOwF0lkLgAOIua+rF7nKsu7/+6qqo+Nz2snmKtmcCAwEAAaNC\n"
-"MEAwHQYDVR0OBBYEFJ3AZ6YMItkm9UWrpmVSESfYRaxjMA8GA1UdEwEB/wQFMAMBAf8wDgYD\n"
-"VR0PAQH/BAQDAgEGMA0GCSqGSIb3DQEBDAUAA4ICAQCzV00QYk465KzquByvMiPIs0laUZx2\n"
-"KI15qldGF9X1Uva3ROgIRL8YhNILgM3FEv0AVQVhh0HctSSePMTYyPtwni94loMgNt58D2kT\n"
-"iKV1NpgIpsbfrM7jWNa3Pt668+s0QNiigfV4Py/VpfzZotReBA4Xrf5B8OWycvpEgjNC6C1Y\n"
-"91aMYj+6QrCcDFx+LmUmXFNPALJ4fqENmS2NuB2OosSw/WDQMKSOyARiqcTtNd56l+0OOF6S\n"
-"L5Nwpamcb6d9Ex1+xghIsV5n61EIJenmJWtSKZGc0jlzCFfemQa0W50QBuHCAKi4HEoCChTQ\n"
-"wUHK+4w1IX2COPKpVJEZNZOUbWo6xbLQu4mGk+ibyQ86p3q4ofB4Rvr8Ny/lioTz3/4E2aFo\n"
-"oC8k4gmVBtWVyuEklut89pMFu+1z6S3RdTnX5yTb2E5fQ4+e0BQ5v1VwSJlXMbSc7kqYA5Yw\n"
-"H2AG7hsj/oFgIxpHYoWlzBk0gG+zrBrjn/B7SK3VAdlntqlyk+otZrWyuOQ9PLLvTIzq6we/\n"
-"qzWaVYa8GKa1qF60g2xraUDTn9zxw2lrueFtCfTxqlB2Cnp9ehehVZZCmTEJ3WARjQUwfuaO\n"
-"RtGdFNrHF+QFlozEJLUbzxQHskD4o55BhrwE0GuWyCqANP2/7waj3VjFhT0+j/6eKeC2uAlo\n"
-"GRwYQw==\n"
-"-----END CERTIFICATE-----\n",
-
-/* AffirmTrust Premium ECC */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIB/jCCAYWgAwIBAgIIdJclisc/elQwCgYIKoZIzj0EAwMwRTELMAkGA1UEBhMCVVMxFDAS\n"
-"BgNVBAoMC0FmZmlybVRydXN0MSAwHgYDVQQDDBdBZmZpcm1UcnVzdCBQcmVtaXVtIEVDQzAe\n"
-"Fw0xMDAxMjkxNDIwMjRaFw00MDEyMzExNDIwMjRaMEUxCzAJBgNVBAYTAlVTMRQwEgYDVQQK\n"
-"DAtBZmZpcm1UcnVzdDEgMB4GA1UEAwwXQWZmaXJtVHJ1c3QgUHJlbWl1bSBFQ0MwdjAQBgcq\n"
-"hkjOPQIBBgUrgQQAIgNiAAQNMF4bFZ0D0KF5Nbc6PJJ6yhUczWLznCZcBz3lVPqj1swS6vQU\n"
-"X+iOGasvLkjmrBhDeKzQN8O9ss0s5kfiGuZjuD0uL3jET9v0D6RoTFVya5UdThhClXjMNzyR\n"
-"4ptlKymjQjBAMB0GA1UdDgQWBBSaryl6wBE1NSZRMADDav5A1a7WPDAPBgNVHRMBAf8EBTAD\n"
-"AQH/MA4GA1UdDwEB/wQEAwIBBjAKBggqhkjOPQQDAwNnADBkAjAXCfOHiFBar8jAQr9HX/Vs\n"
-"aobgxCd05DhT1wV/GzTjxi+zygk8N53X57hG8f2h4nECMEJZh0PUUd+60wkyWs6Iflc9nF9C\n"
-"a/UHLbXwgpP5WW+uZPpY5Yse42O+tYHNbwKMeQ==\n"
-"-----END CERTIFICATE-----\n",
-
-/* Certum Trusted Network CA */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDuzCCAqOgAwIBAgIDBETAMA0GCSqGSIb3DQEBBQUAMH4xCzAJBgNVBAYTAlBMMSIwIAYD\n"
-"VQQKExlVbml6ZXRvIFRlY2hub2xvZ2llcyBTLkEuMScwJQYDVQQLEx5DZXJ0dW0gQ2VydGlm\n"
-"aWNhdGlvbiBBdXRob3JpdHkxIjAgBgNVBAMTGUNlcnR1bSBUcnVzdGVkIE5ldHdvcmsgQ0Ew\n"
-"HhcNMDgxMDIyMTIwNzM3WhcNMjkxMjMxMTIwNzM3WjB+MQswCQYDVQQGEwJQTDEiMCAGA1UE\n"
-"ChMZVW5pemV0byBUZWNobm9sb2dpZXMgUy5BLjEnMCUGA1UECxMeQ2VydHVtIENlcnRpZmlj\n"
-"YXRpb24gQXV0aG9yaXR5MSIwIAYDVQQDExlDZXJ0dW0gVHJ1c3RlZCBOZXR3b3JrIENBMIIB\n"
-"IjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4/t9o3K6wvDJFIf1awFO4W5AB7ptJ11/\n"
-"91sts1rHUV+rpDKmYYe2bg+G0jACl/jXaVehGDldamR5xgFZrDwxSjh80gTSSyjoIF87B6LM\n"
-"TXPb865Px1bVWqeWifrzq2jUI4ZZJ88JJ7ysbnKDHDBy3+Ci6dLhdHUZvSqeexVUBBvXQzmt\n"
-"VSjF4hq79MDkrjhJM8x2hZ85RdKknvISjFH4fOQtf/WsX+sWn7Et0brMkUJ3TCXJkDhv2/DM\n"
-"+44el1k+1WBO5gUo7Ul5E0u6SNsv+XLTOcr+H9g0cvW0QM8xAcPs3hEtF10fuFDRXhmnad4H\n"
-"MyjKUJX5p1TLVIZQRan5SQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBQI\n"
-"ds3LB/8k9sXN7buQvOKEN0Z19zAOBgNVHQ8BAf8EBAMCAQYwDQYJKoZIhvcNAQEFBQADggEB\n"
-"AKaorSLOAT2mo/9i0Eidi15ysHhE49wcrwn9I0j6vSrEuVUEtRCjjSfeC4Jj0O7eDDd5QVsi\n"
-"srCaQVymcODU0HfLI9MA4GxWL+FpDQ3Zqr8hgVDZBqWo/5U30Kr+4rP1mS1FhIrlQgnXdAIv\n"
-"94nYmem8J9RHjboNRhx3zxSkHLmkMcScKHQDNP8zGSal6Q10tz6XxnboJ5ajZt3hrvJBW8qY\n"
-"VoNzcOSGGtIxQbovvi0TWnZvTuhOgQ4/WwMioBK+ZlgRSssDxLQqKi2WF+A5VLxI03YnnZot\n"
-"BqbJ7DnSq9ufmgsnAjUpsUCV5/nonFWIGUbWtzT1fs45mtk48VH3Tyw=\n"
-"-----END CERTIFICATE-----\n",
-
-/* Certinomis - Autorit Racine */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIFnDCCA4SgAwIBAgIBATANBgkqhkiG9w0BAQUFADBjMQswCQYDVQQGEwJGUjETMBEGA1UE\n"
-"ChMKQ2VydGlub21pczEXMBUGA1UECxMOMDAwMiA0MzM5OTg5MDMxJjAkBgNVBAMMHUNlcnRp\n"
-"bm9taXMgLSBBdXRvcml0w6kgUmFjaW5lMB4XDTA4MDkxNzA4Mjg1OVoXDTI4MDkxNzA4Mjg1\n"
-"OVowYzELMAkGA1UEBhMCRlIxEzARBgNVBAoTCkNlcnRpbm9taXMxFzAVBgNVBAsTDjAwMDIg\n"
-"NDMzOTk4OTAzMSYwJAYDVQQDDB1DZXJ0aW5vbWlzIC0gQXV0b3JpdMOpIFJhY2luZTCCAiIw\n"
-"DQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAJ2Fn4bT46/HsmtuM+Cet0I0VZ35gb5j2CN2\n"
-"DpdUzZlMGvE5x4jYF1AMnmHawE5V3udauHpOd4cN5bjr+p5eex7Ezyh0x5P1FMYiKAT5kcOr\n"
-"J3NqDi5N8y4oH3DfVS9O7cdxbwlyLu3VMpfQ8Vh30WC8Tl7bmoT2R2FFK/ZQpn9qcSdIhDWe\n"
-"rP5pqZ56XjUl+rSnSTV3lqc2W+HN3yNw2F1MpQiD8aYkOBOo7C+ooWfHpi2GR+6K/OybDnT0\n"
-"K0kCe5B1jPyZOQE51kqJ5Z52qz6WKDgmi92NjMD2AR5vpTESOH2VwnHu7XSu5DaiQ3XV8QCb\n"
-"4uTXzEIDS3h65X27uK4uIJPT5GHfceF2Z5c/tt9qc1pkIuVC28+BA5PY9OMQ4HL2AHCs8MF6\n"
-"DwV/zzRpRbWT5BnbUhYjBYkOjUjkJW+zeL9i9Qf6lSTClrLooyPCXQP8w9PlfMl1I9f09bze\n"
-"5N/NgL+RiH2nE7Q5uiy6vdFrzPOlKO1Enn1So2+WLhl+HPNbxxaOu2B9d2ZHVIIAEWBsMsGo\n"
-"OBvrbpgT1u449fCfDu/+MYHB0iSVL1N6aaLwD4ZFjliCK0wi1F6g530mJ0jfJUaNSih8hp75\n"
-"mxpZuWW/Bd22Ql095gBIgl4g9xGC3srYn+Y3RyYe63j3YcNBZFgCQfna4NH4+ej9Uji29Ynf\n"
-"AgMBAAGjWzBZMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgEGMB0GA1UdDgQWBBQN\n"
-"jLZh2kS40RR9w759XkjwzspqsDAXBgNVHSAEEDAOMAwGCiqBegFWAgIAAQEwDQYJKoZIhvcN\n"
-"AQEFBQADggIBACQ+YAZ+He86PtvqrxyaLAEL9MW12Ukx9F1BjYkMTv9sov3/4gbIOZ/xWqnd\n"
-"IlgVqIrTseYyCYIDbNc/CMf4uboAbbnW/FIyXaR/pDGUu7ZMOH8oMDX/nyNTt7buFHAAQCva\n"
-"R6s0fl6nVjBhK4tDrP22iCj1a7Y+YEq6QpA0Z43q619FVDsXrIvkxmUP7tCMXWY5zjKn2BCX\n"
-"wH40nJ+U8/aGH88bc62UeYdocMMzpXDn2NU4lG9jeeu/Cg4I58UvD0KgKxRA/yHgBcUn4YQR\n"
-"E7rWhh1BCxMjidPJC+iKunqjo3M3NYB9Ergzd0A4wPpeMNLytqOx1qKVl4GbUu1pTP+A5FPb\n"
-"VFsDbVRfsbjvJL1vnxHDx2TCDyhihWZeGnuyt++uNckZM6i4J9szVb9o4XVIRFb7zdNIu0eJ\n"
-"Oqxp9YDG5ERQL1TEqkPFMTFYvZbF6nVsmnWxTfj3l/+WFvKXTej28xH5On2KOG4Ey+HTRRWq\n"
-"pdEdnV1j6CTmNhTih60bWfVEm/vXd3wfAXBioSAaosUaKPQhA+4u2cGA6rnZgtZbdsLLO7XS\n"
-"APCjDuGtbkD326C00EauFddEwk01+dIL8hf2rGbVJLJP0RyZwG71fet0BLj5TXcJ17TPBzAJ\n"
-"8bgAVtkXFhYKK4bfjwEZGuW7gmP/vgt2Fl43N+bYdJeimUV5\n"
-"-----END CERTIFICATE-----\n",
-
-/* Root CA Generalitat Valenciana */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIGizCCBXOgAwIBAgIEO0XlaDANBgkqhkiG9w0BAQUFADBoMQswCQYDVQQGEwJFUzEfMB0G\n"
-"A1UEChMWR2VuZXJhbGl0YXQgVmFsZW5jaWFuYTEPMA0GA1UECxMGUEtJR1ZBMScwJQYDVQQD\n"
-"Ex5Sb290IENBIEdlbmVyYWxpdGF0IFZhbGVuY2lhbmEwHhcNMDEwNzA2MTYyMjQ3WhcNMjEw\n"
-"NzAxMTUyMjQ3WjBoMQswCQYDVQQGEwJFUzEfMB0GA1UEChMWR2VuZXJhbGl0YXQgVmFsZW5j\n"
-"aWFuYTEPMA0GA1UECxMGUEtJR1ZBMScwJQYDVQQDEx5Sb290IENBIEdlbmVyYWxpdGF0IFZh\n"
-"bGVuY2lhbmEwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDGKqtXETcvIorKA3Qd\n"
-"yu0togu8M1JAJke+WmmmO3I2F0zo37i7L3bhQEZ0ZQKQUgi0/6iMweDHiVYQOTPvaLRfX9pt\n"
-"I6GJXiKjSgbwJ/BXufjpTjJ3Cj9BZPPrZe52/lSqfR0grvPXdMIKX/UIKFIIzFVd0g/bmoGl\n"
-"u6GzwZTNVOAydTGRGmKy3nXiz0+J2ZGQD0EbtFpKd71ng+CT516nDOeB0/RSrFOyA8dEJvt5\n"
-"5cs0YFAQexvba9dHq198aMpunUEDEO5rmXteJajCq+TA81yc477OMUxkHl6AovWDfgzWyoxV\n"
-"jr7gvkkHD6MkQXpYHYTqWBLI4bft75PelAgxAgMBAAGjggM7MIIDNzAyBggrBgEFBQcBAQQm\n"
-"MCQwIgYIKwYBBQUHMAGGFmh0dHA6Ly9vY3NwLnBraS5ndmEuZXMwEgYDVR0TAQH/BAgwBgEB\n"
-"/wIBAjCCAjQGA1UdIASCAiswggInMIICIwYKKwYBBAG/VQIBADCCAhMwggHoBggrBgEFBQcC\n"
-"AjCCAdoeggHWAEEAdQB0AG8AcgBpAGQAYQBkACAAZABlACAAQwBlAHIAdABpAGYAaQBjAGEA\n"
-"YwBpAPMAbgAgAFIAYQDtAHoAIABkAGUAIABsAGEAIABHAGUAbgBlAHIAYQBsAGkAdABhAHQA\n"
-"IABWAGEAbABlAG4AYwBpAGEAbgBhAC4ADQAKAEwAYQAgAEQAZQBjAGwAYQByAGEAYwBpAPMA\n"
-"bgAgAGQAZQAgAFAAcgDhAGMAdABpAGMAYQBzACAAZABlACAAQwBlAHIAdABpAGYAaQBjAGEA\n"
-"YwBpAPMAbgAgAHEAdQBlACAAcgBpAGcAZQAgAGUAbAAgAGYAdQBuAGMAaQBvAG4AYQBtAGkA\n"
-"ZQBuAHQAbwAgAGQAZQAgAGwAYQAgAHAAcgBlAHMAZQBuAHQAZQAgAEEAdQB0AG8AcgBpAGQA\n"
-"YQBkACAAZABlACAAQwBlAHIAdABpAGYAaQBjAGEAYwBpAPMAbgAgAHMAZQAgAGUAbgBjAHUA\n"
-"ZQBuAHQAcgBhACAAZQBuACAAbABhACAAZABpAHIAZQBjAGMAaQDzAG4AIAB3AGUAYgAgAGgA\n"
-"dAB0AHAAOgAvAC8AdwB3AHcALgBwAGsAaQAuAGcAdgBhAC4AZQBzAC8AYwBwAHMwJQYIKwYB\n"
-"BQUHAgEWGWh0dHA6Ly93d3cucGtpLmd2YS5lcy9jcHMwHQYDVR0OBBYEFHs100DSHHgZZu90\n"
-"ECjcPk+yeAT8MIGVBgNVHSMEgY0wgYqAFHs100DSHHgZZu90ECjcPk+yeAT8oWykajBoMQsw\n"
-"CQYDVQQGEwJFUzEfMB0GA1UEChMWR2VuZXJhbGl0YXQgVmFsZW5jaWFuYTEPMA0GA1UECxMG\n"
-"UEtJR1ZBMScwJQYDVQQDEx5Sb290IENBIEdlbmVyYWxpdGF0IFZhbGVuY2lhbmGCBDtF5Wgw\n"
-"DQYJKoZIhvcNAQEFBQADggEBACRhTvW1yEICKrNcda3FbcrnlD+laJWIwVTAEGmiEi8YPyVQ\n"
-"qHxK6sYJ2fR1xkDar1CdPaUWu20xxsdzCkj+IHLtb8zog2EWRpABlUt9jppSCS/2bxzkoXHP\n"
-"jCpaF3ODR00PNvsETUlR4hTJZGH71BTg9J63NI8KJr2XXPR5OkowGcytT6CYirQxlyric21+\n"
-"eLj4iIlPsSKRZEv1UN4D2+XFducTZnV+ZfsBn5OHiJ35Rld8TWCvmHMTI6QgkYH60GFmuH3R\n"
-"r9ZvHmw96RH9qfmCIoaZM3Fa6hlXPZHNqcCjbgcTpsnt+GijnsNacgmHKNHEc8RzGF9QdRYx\n"
-"n7fofMM=\n"
-"-----END CERTIFICATE-----\n",
-
-/* TWCA Root Certification Authority */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDezCCAmOgAwIBAgIBATANBgkqhkiG9w0BAQUFADBfMQswCQYDVQQGEwJUVzESMBAGA1UE\n"
-"CgwJVEFJV0FOLUNBMRAwDgYDVQQLDAdSb290IENBMSowKAYDVQQDDCFUV0NBIFJvb3QgQ2Vy\n"
-"dGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMDgwODI4MDcyNDMzWhcNMzAxMjMxMTU1OTU5WjBf\n"
-"MQswCQYDVQQGEwJUVzESMBAGA1UECgwJVEFJV0FOLUNBMRAwDgYDVQQLDAdSb290IENBMSow\n"
-"KAYDVQQDDCFUV0NBIFJvb3QgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwggEiMA0GCSqGSIb3\n"
-"DQEBAQUAA4IBDwAwggEKAoIBAQCwfnK4pAOU5qfeCTiRShFAh6d8WWQUe7UREN3+v9XAu1bi\n"
-"hSX0NXIP+FPQQeFEAcK0HMMxQhZHhTMidrIKbw/lJVBPhYa+v5guEGcevhEFhgWQxFnQfHgQ\n"
-"sIBct+HHK3XLfJ+utdGdIzdjp9xCoi2SBBtQwXu4PhvJVgSLL1KbralW6cH/ralYhzC2gfeX\n"
-"RfwZVzsrb+RH9JlF/h3x+JejiB03HFyP4HYlmlD4oFT/RJB2I9IyxsOrBr/8+7/zrX2SYgJb\n"
-"KdM1o5OaQ2RgXbL6Mv87BK9NQGr5x+PvI/1ry+UPizgN7gr8/g+YnzAx3WxSZfmLgb4i4RxY\n"
-"A7qRG4kHAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud\n"
-"DgQWBBRqOFsmjd6LWvJPelSDGRjjCDWmujANBgkqhkiG9w0BAQUFAAOCAQEAPNV3PdrfibqH\n"
-"DAhUaiBQkr6wQT25JmSDCi/oQMCXKCeCMErJk/9q56YAf4lCmtYR5VPOL8zy2gXE/uJQxDqG\n"
-"fczafhAJO5I1KlOy/usrBdlsXebQ79NqZp4VKIV66IIArB6nCWlWQtNoURi+VJq/REG6Sb4g\n"
-"umlc7rh3zc5sH62Dlhh9DrUUOYTxKOkto557HnpyWoOzeW/vtPzQCqVYT0bf+215WfKEIlKu\n"
-"D8z7fDvnaspHYcN6+NOSBB+4IIThNlQWx0DeO4pz3N/GCUzf7Nr/1FNCocnyYh0igzyXxfkZ\n"
-"YiesZSLX0zzG5Y6yU8xJzrww/nsOM5D77dIUkR8Hrw==\n"
-"-----END CERTIFICATE-----\n",
-
-/* Security Communication RootCA2 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDdzCCAl+gAwIBAgIBADANBgkqhkiG9w0BAQsFADBdMQswCQYDVQQGEwJKUDElMCMGA1UE\n"
-"ChMcU0VDT00gVHJ1c3QgU3lzdGVtcyBDTy4sTFRELjEnMCUGA1UECxMeU2VjdXJpdHkgQ29t\n"
-"bXVuaWNhdGlvbiBSb290Q0EyMB4XDTA5MDUyOTA1MDAzOVoXDTI5MDUyOTA1MDAzOVowXTEL\n"
-"MAkGA1UEBhMCSlAxJTAjBgNVBAoTHFNFQ09NIFRydXN0IFN5c3RlbXMgQ08uLExURC4xJzAl\n"
-"BgNVBAsTHlNlY3VyaXR5IENvbW11bmljYXRpb24gUm9vdENBMjCCASIwDQYJKoZIhvcNAQEB\n"
-"BQADggEPADCCAQoCggEBANAVOVKxUrO6xVmCxF1SrjpDZYBLx/KWvNs2l9amZIyoXvDjChz3\n"
-"35c9S672XewhtUGrzbl+dp+++T42NKA7wfYxEUV0kz1XgMX5iZnK5atq1LXaQZAQwdbWQonC\n"
-"v/Q4EpVMVAX3NuRFg3sUZdbcDE3R3n4MqzvEFb46VqZab3ZpUql6ucjrappdUtAtCms1FgkQ\n"
-"hNBqyjoGADdH5H5XTz+L62e4iKrFvlNVspHEfbmwhRkGeC7bYRr6hfVKkaHnFtWOojnflLhw\n"
-"Hyg/i/xAXmODPIMqGplrz95Zajv8bxbXH/1KEOtOghY6rCcMU/Gt1SSwawNQwS08Ft1ENCca\n"
-"dfsCAwEAAaNCMEAwHQYDVR0OBBYEFAqFqXdlBZh8QIH4D5csOPEK7DzPMA4GA1UdDwEB/wQE\n"
-"AwIBBjAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3DQEBCwUAA4IBAQBMOqNErLlFsceTfsgL\n"
-"CkLfZOoc7llsCLqJX2rKSpWeeo8HxdpFcoJxDjrSzG+ntKEju/Ykn8sX/oymzsLS28yN/HH8\n"
-"AynBbF0zX2S2ZTuJbxh2ePXcokgfGT+Ok+vx+hfuzU7jBBJV1uXk3fs+BXziHV7Gp7yXT2g6\n"
-"9ekuCkO2r1dcYmh8t/2jioSgrGK+KwmHNPBqAbubKVY8/gA3zyNs8U6qtnRGEmyR7jTV7JqR\n"
-"50S+kDFy1UkC9gLl9B/rfNmWVan/7Ir5mUf/NVoCqgTLiluHcSmRvaS0eg29mvVXIwAHIRc/\n"
-"SjnRBUkLp7Y3gaVdjKozXoEofKd9J+sAro03\n"
-"-----END CERTIFICATE-----\n",
-
-/* EC-ACC */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIFVjCCBD6gAwIBAgIQ7is969Qh3hSoYqwE893EATANBgkqhkiG9w0BAQUFADCB8zELMAkG\n"
-"A1UEBhMCRVMxOzA5BgNVBAoTMkFnZW5jaWEgQ2F0YWxhbmEgZGUgQ2VydGlmaWNhY2lvIChO\n"
-"SUYgUS0wODAxMTc2LUkpMSgwJgYDVQQLEx9TZXJ2ZWlzIFB1YmxpY3MgZGUgQ2VydGlmaWNh\n"
-"Y2lvMTUwMwYDVQQLEyxWZWdldSBodHRwczovL3d3dy5jYXRjZXJ0Lm5ldC92ZXJhcnJlbCAo\n"
-"YykwMzE1MDMGA1UECxMsSmVyYXJxdWlhIEVudGl0YXRzIGRlIENlcnRpZmljYWNpbyBDYXRh\n"
-"bGFuZXMxDzANBgNVBAMTBkVDLUFDQzAeFw0wMzAxMDcyMzAwMDBaFw0zMTAxMDcyMjU5NTla\n"
-"MIHzMQswCQYDVQQGEwJFUzE7MDkGA1UEChMyQWdlbmNpYSBDYXRhbGFuYSBkZSBDZXJ0aWZp\n"
-"Y2FjaW8gKE5JRiBRLTA4MDExNzYtSSkxKDAmBgNVBAsTH1NlcnZlaXMgUHVibGljcyBkZSBD\n"
-"ZXJ0aWZpY2FjaW8xNTAzBgNVBAsTLFZlZ2V1IGh0dHBzOi8vd3d3LmNhdGNlcnQubmV0L3Zl\n"
-"cmFycmVsIChjKTAzMTUwMwYDVQQLEyxKZXJhcnF1aWEgRW50aXRhdHMgZGUgQ2VydGlmaWNh\n"
-"Y2lvIENhdGFsYW5lczEPMA0GA1UEAxMGRUMtQUNDMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A\n"
-"MIIBCgKCAQEAsyLHT+KXQpWIR4NA9h0X84NzJB5R85iKw5K4/0CQBXCHYMkAqbWUZRkiFRfC\n"
-"Q2xmRJoNBD45b6VLeqpjt4pEndljkYRm4CgPukLjbo73FCeTae6RDqNfDrHrZqJyTxIThmV6\n"
-"PttPB/SnCWDaOkKZx7J/sxaVHMf5NLWUhdWZXqBIoH7nF2W4onW4HvPlQn2v7fOKSGRdghST\n"
-"2MDk/7NQcvJ29rNdQlB50JQ+awwAvthrDk4q7D7SzIKiGGUzE3eeml0aE9jD2z3Il3rucO2n\n"
-"5nzbcc8tlGLfbdb1OL4/pYUKGbio2Al1QnDE6u/LDsg0qBIimAy4E5S2S+zw0JDnJwIDAQAB\n"
-"o4HjMIHgMB0GA1UdEQQWMBSBEmVjX2FjY0BjYXRjZXJ0Lm5ldDAPBgNVHRMBAf8EBTADAQH/\n"
-"MA4GA1UdDwEB/wQEAwIBBjAdBgNVHQ4EFgQUoMOLRKo3pUW/l4Ba0fF4opvpXY0wfwYDVR0g\n"
-"BHgwdjB0BgsrBgEEAfV4AQMBCjBlMCwGCCsGAQUFBwIBFiBodHRwczovL3d3dy5jYXRjZXJ0\n"
-"Lm5ldC92ZXJhcnJlbDA1BggrBgEFBQcCAjApGidWZWdldSBodHRwczovL3d3dy5jYXRjZXJ0\n"
-"Lm5ldC92ZXJhcnJlbCAwDQYJKoZIhvcNAQEFBQADggEBAKBIW4IB9k1IuDlVNZyAelOZ1Vr/\n"
-"sXE7zDkJlF7W2u++AVtd0x7Y/X1PzaBB4DSTv8vihpw3kpBWHNzrKQXlxJ7HNd+KDM3FIUPp\n"
-"qojlNcAZQmNaAl6kSBg6hW/cnbw/nZzBh7h6YQjpdwt/cKt63dmXLGQehb+8dJahw3oS7Awa\n"
-"boMMPOhyRp/7SNVel+axofjk70YllJyJ22k4vuxcDlbHZVHlUIiIv0LVKz3l+bqeLrPK9HOS\n"
-"Agu+TGbrIP65y7WZf+a2E/rKS03Z7lNGBjvGTq2TWoF+bCpLagVFjPIhpDGQh2xlnJ2lYJU6\n"
-"Un/10asIbvPuW/mIPX64b24D5EI=\n"
-"-----END CERTIFICATE-----\n",
-
-/* Hellenic Academic and Research Institutions RootCA 2011 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIEMTCCAxmgAwIBAgIBADANBgkqhkiG9w0BAQUFADCBlTELMAkGA1UEBhMCR1IxRDBCBgNV\n"
-"BAoTO0hlbGxlbmljIEFjYWRlbWljIGFuZCBSZXNlYXJjaCBJbnN0aXR1dGlvbnMgQ2VydC4g\n"
-"QXV0aG9yaXR5MUAwPgYDVQQDEzdIZWxsZW5pYyBBY2FkZW1pYyBhbmQgUmVzZWFyY2ggSW5z\n"
-"dGl0dXRpb25zIFJvb3RDQSAyMDExMB4XDTExMTIwNjEzNDk1MloXDTMxMTIwMTEzNDk1Mlow\n"
-"gZUxCzAJBgNVBAYTAkdSMUQwQgYDVQQKEztIZWxsZW5pYyBBY2FkZW1pYyBhbmQgUmVzZWFy\n"
-"Y2ggSW5zdGl0dXRpb25zIENlcnQuIEF1dGhvcml0eTFAMD4GA1UEAxM3SGVsbGVuaWMgQWNh\n"
-"ZGVtaWMgYW5kIFJlc2VhcmNoIEluc3RpdHV0aW9ucyBSb290Q0EgMjAxMTCCASIwDQYJKoZI\n"
-"hvcNAQEBBQADggEPADCCAQoCggEBAKlTAOMupvaO+mDYLZU++CwqVE7NuYRhlFhPjz2L5EPz\n"
-"dYmNUeTDN9KKiE15HrcS3UN4SoqS5tdI1Q+kOilENbgH9mgdVc04UfCMJDGFr4PJfel3r+0a\n"
-"e50X+bOdOFAPplp5kYCvN66m0zH7tSYJnTxa71HFK9+WXesyHgLacEnsbgzImjeN9/E2YEsm\n"
-"LIKe0HjzDQ9jpFEw4fkrJxIH2Oq9GGKYsFk3fb7u8yBRQlqD75O6aRXxYp2fmTmCobd0LovU\n"
-"xQt7L/DICto9eQqakxylKHJzkUOap9FNhYS5qXSPFEDH3N6sQWRstBmbAmNtJGSPRLIl6s5d\n"
-"dAxjMlyNh+UCAwEAAaOBiTCBhjAPBgNVHRMBAf8EBTADAQH/MAsGA1UdDwQEAwIBBjAdBgNV\n"
-"HQ4EFgQUppFC/RNhSiOeCKQp5dgTBCPuQSUwRwYDVR0eBEAwPqA8MAWCAy5ncjAFggMuZXUw\n"
-"BoIELmVkdTAGggQub3JnMAWBAy5ncjAFgQMuZXUwBoEELmVkdTAGgQQub3JnMA0GCSqGSIb3\n"
-"DQEBBQUAA4IBAQAf73lB4XtuP7KMhjdCSk4cNx6NZrokgclPEg8hwAOXhiVtXdMiKahsog2p\n"
-"6z0GW5k6x8zDmjR/qw7IThzh+uTczQ2+vyT+bOdrwg3IBp5OjWEopmr95fZi6hg8TqBTnbI6\n"
-"nOulnJEWtk2C4AwFSKls9cz4y51JtPACpf1wA+2KIaWuE4ZJwzNzvoc7dIsXRSZMFpGD/md9\n"
-"zU1jZ/rzAxKWeAaNsWftjj++n08C9bMJL/NMh98qy5V8AcysNnq/onN694/BtZqhFLKPM58N\n"
-"7yLcZnuEvUUXBj08yrl3NI/K6s8/MT7jiOOASSXIl7WdmplNsDz4SgCbZN2fOUvRJ9e4\n"
-"-----END CERTIFICATE-----\n",
-
-/* Actalis Authentication Root CA */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIFuzCCA6OgAwIBAgIIVwoRl0LE48wwDQYJKoZIhvcNAQELBQAwazELMAkGA1UEBhMCSVQx\n"
-"DjAMBgNVBAcMBU1pbGFuMSMwIQYDVQQKDBpBY3RhbGlzIFMucC5BLi8wMzM1ODUyMDk2NzEn\n"
-"MCUGA1UEAwweQWN0YWxpcyBBdXRoZW50aWNhdGlvbiBSb290IENBMB4XDTExMDkyMjExMjIw\n"
-"MloXDTMwMDkyMjExMjIwMlowazELMAkGA1UEBhMCSVQxDjAMBgNVBAcMBU1pbGFuMSMwIQYD\n"
-"VQQKDBpBY3RhbGlzIFMucC5BLi8wMzM1ODUyMDk2NzEnMCUGA1UEAwweQWN0YWxpcyBBdXRo\n"
-"ZW50aWNhdGlvbiBSb290IENBMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAp8bE\n"
-"pSmkLO/lGMWwUKNvUTufClrJwkg4CsIcoBh/kbWHuUA/3R1oHwiD1S0eiKD4j1aPbZkCkpAW\n"
-"1V8IbInX4ay8IMKx4INRimlNAJZaby/ARH6jDuSRzVju3PvHHkVH3Se5CAGfpiEd9UEtL0z9\n"
-"KK3giq0itFZljoZUj5NDKd45RnijMCO6zfB9E1fAXdKDa0hMxKufgFpbOr3JpyI/gCczWw63\n"
-"igxdBzcIy2zSekciRDXFzMwujt0q7bd9Zg1fYVEiVRvjRuPjPdA1YprbrxTIW6HMiRvhMCb8\n"
-"oJsfgadHHwTrozmSBp+Z07/T6k9QnBn+locePGX2oxgkg4YQ51Q+qDp2JE+BIcXjDwL4k5RH\n"
-"ILv+1A7TaLndxHqEguNTVHnd25zS8gebLra8Pu2Fbe8lEfKXGkJh90qX6IuxEAf6ZYGyojnP\n"
-"9zz/GPvG8VqLWeICrHuS0E4UT1lF9gxeKF+w6D9Fz8+vm2/7hNN3WpVvrJSEnu68wEqPSpP4\n"
-"RCHiMUVhUE4Q2OM1fEwZtN4Fv6MGn8i1zeQf1xcGDXqVdFUNaBr8EBtiZJ1t4JWgw5QHVw0U\n"
-"5r0F+7if5t+L4sbnfpb2U8WANFAoWPASUHEXMLrmeGO89LKtmyuy/uE5jF66CyCU3nuDuP/j\n"
-"Vo23Eek7jPKxwV2dpAtMK9myGPW1n0sCAwEAAaNjMGEwHQYDVR0OBBYEFFLYiDrIn3hm7Ynz\n"
-"ezhwlMkCAjbQMA8GA1UdEwEB/wQFMAMBAf8wHwYDVR0jBBgwFoAUUtiIOsifeGbtifN7OHCU\n"
-"yQICNtAwDgYDVR0PAQH/BAQDAgEGMA0GCSqGSIb3DQEBCwUAA4ICAQALe3KHwGCmSUyIWOYd\n"
-"iPcUZEim2FgKDk8TNd81HdTtBjHIgT5q1d07GjLukD0R0i70jsNjLiNmsGe+b7bAEzlgqqI0\n"
-"JZN1Ut6nna0Oh4lScWoWPBkdg/iaKWW+9D+a2fDzWochcYBNy+A4mz+7+uAwTc+G02UQGRjR\n"
-"lwKxK3JCaKygvU5a2hi/a5iB0P2avl4VSM0RFbnAKVy06Ij3Pjaut2L9HmLecHgQHEhb2ryk\n"
-"OLpn7VU+Xlff1ANATIGk0k9jpwlCCRT8AKnCgHNPLsBA2RF7SOp6AsDT6ygBJlh0wcBzIm2T\n"
-"lf05fbsq4/aC4yyXX04fkZT6/iyj2HYauE2yOE+b+h1IYHkm4vP9qdCa6HCPSXrW5b0KDtst\n"
-"842/6+OkfcvHlXHo2qN8xcL4dJIEG4aspCJTQLas/kx2z/uUMsA1n3Y/buWQbqCmJqK4LL7R\n"
-"K4X9p2jIugErsWx0Hbhzlefut8cl8ABMALJ+tguLHPPAUJ4lueAI3jZm/zel0btUZCzJJ7VL\n"
-"kn5l/9Mt4blOvH+kQSGQQXemOR/qnuOf0GZvBeyqdn6/axag67XH/JJULysRJyU3eExRarDz\n"
-"zFhdFPFqSBX/wge2sY0PjlxQRrM9vwGYT7JZVEc+NHt4bVaTLnPqZih4zR0Uv6CPLy64Lo7y\n"
-"FIrM6bV8+2ydDKXhlg==\n"
-"-----END CERTIFICATE-----\n",
-
-/* Trustis FPS Root CA */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDZzCCAk+gAwIBAgIQGx+ttiD5JNM2a/fH8YygWTANBgkqhkiG9w0BAQUFADBFMQswCQYD\n"
-"VQQGEwJHQjEYMBYGA1UEChMPVHJ1c3RpcyBMaW1pdGVkMRwwGgYDVQQLExNUcnVzdGlzIEZQ\n"
-"UyBSb290IENBMB4XDTAzMTIyMzEyMTQwNloXDTI0MDEyMTExMzY1NFowRTELMAkGA1UEBhMC\n"
-"R0IxGDAWBgNVBAoTD1RydXN0aXMgTGltaXRlZDEcMBoGA1UECxMTVHJ1c3RpcyBGUFMgUm9v\n"
-"dCBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMVQe547NdDfxIzNjpvto8A2\n"
-"mfRC6qc+gIMPpqdZh8mQRUN+AOqGeSoDvT03mYlmt+WKVoaTnGhLaASMk5MCPjDSNzoiYYkc\n"
-"hU59j9WvezX2fihHiTHcDnlkH5nSW7r+f2C/revnPDgpai/lkQtV/+xvWNUtyd5MZnGPDNcE\n"
-"2gfmHhjjvSkCqPoc4Vu5g6hBSLwacY3nYuUtsuvffM/bq1rKMfFMIvMFE/eC+XN5DL7XSxzA\n"
-"0RU8k0Fk0ea+IxciAIleH2ulrG6nS4zto3Lmr2NNL4XSFDWaLk6M6jKYKIahkQlBOrTh4/L6\n"
-"8MkKokHdqeMDx4gVOxzUGpTXn2RZEm0CAwEAAaNTMFEwDwYDVR0TAQH/BAUwAwEB/zAfBgNV\n"
-"HSMEGDAWgBS6+nEleYtXQSUhhgtx67JkDoshZzAdBgNVHQ4EFgQUuvpxJXmLV0ElIYYLceuy\n"
-"ZA6LIWcwDQYJKoZIhvcNAQEFBQADggEBAH5Y//01GX2cGE+esCu8jowU/yyg2kdbw++BLa8F\n"
-"6nRIW/M+TgfHbcWzk88iNVy2P3UnXwmWzaD+vkAMXBJV+JOCyinpXj9WV4s4NvdFGkwozZ5B\n"
-"uO1WTISkQMi4sKUraXAEasP41BIy+Q7DsdwyhEQsb8tGD+pmQQ9P8Vilpg0ND2HepZ5dfWWh\n"
-"PBfnqFVO76DH7cZEf1T1o+CP8HxVIo8ptoGj4W1OLBuAZ+ytIJ8MYmHVl/9D7S3B2l0pKoU/\n"
-"rGXuhg8FjZBf3+6f9L/uHfuY5H+QK4R4EA5sSVPvFVtlRkpdr7r7OnIdzfYliB6XzCGcKQEN\n"
-"ZetX2fNXlrtIzYE=\n"
-"-----END CERTIFICATE-----\n",
-
-/* StartCom Certification Authority */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIHhzCCBW+gAwIBAgIBLTANBgkqhkiG9w0BAQsFADB9MQswCQYDVQQGEwJJTDEWMBQGA1UE\n"
-"ChMNU3RhcnRDb20gTHRkLjErMCkGA1UECxMiU2VjdXJlIERpZ2l0YWwgQ2VydGlmaWNhdGUg\n"
-"U2lnbmluZzEpMCcGA1UEAxMgU3RhcnRDb20gQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcN\n"
-"MDYwOTE3MTk0NjM3WhcNMzYwOTE3MTk0NjM2WjB9MQswCQYDVQQGEwJJTDEWMBQGA1UEChMN\n"
-"U3RhcnRDb20gTHRkLjErMCkGA1UECxMiU2VjdXJlIERpZ2l0YWwgQ2VydGlmaWNhdGUgU2ln\n"
-"bmluZzEpMCcGA1UEAxMgU3RhcnRDb20gQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwggIiMA0G\n"
-"CSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDBiNsJvGxGfHiflXu1M5DycmLWwTYgIiRezul3\n"
-"8kMKogZkpMyONvg45iPwbm2xPN1yo4UcodM9tDMr0y+v/uqwQVlntsQGfQqedIXWeUyAN3rf\n"
-"OQVSWff0G0ZDpNKFhdLDcfN1YjS6LIp/Ho/u7TTQEceWzVI9ujPW3U3eCztKS5/CJi/6tRYc\n"
-"cjV3yjxd5srhJosaNnZcAdt0FCX+7bWgiA/deMotHweXMAEtcnn6RtYTKqi5pquDSR3l8u/d\n"
-"5AGOGAqPY1MWhWKpDhk6zLVmpsJrdAfkK+F2PrRt2PZE4XNiHzvEvqBTViVsUQn3qqvKv3b9\n"
-"bZvzndu/PWa8DFaqr5hIlTpL36dYUNk4dalb6kMMAv+Z6+hsTXBbKWWc3apdzK8BMewM69KN\n"
-"6Oqce+Zu9ydmDBpI125C4z/eIT574Q1w+2OqqGwaVLRcJXrJosmLFqa7LH4XXgVNWG4SHQHu\n"
-"EhANxjJ/GP/89PrNbpHoNkm+Gkhpi8KWTRoSsmkXwQqQ1vp5Iki/untp+HDH+no32NgN0nZP\n"
-"V/+Qt+OR0t3vwmC3Zzrd/qqc8NSLf3Iizsafl7b4r4qgEKjZ+xjGtrVcUjyJthkqcwEKDwOz\n"
-"EmDyei+B26Nu/yYwl/WL3YlXtq09s68rxbd2AvCl1iuahhQqcvbjM4xdCUsT37uMdBNSSwID\n"
-"AQABo4ICEDCCAgwwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYE\n"
-"FE4L7xqkQFulF2mHMMo0aEPQQa7yMB8GA1UdIwQYMBaAFE4L7xqkQFulF2mHMMo0aEPQQa7y\n"
-"MIIBWgYDVR0gBIIBUTCCAU0wggFJBgsrBgEEAYG1NwEBATCCATgwLgYIKwYBBQUHAgEWImh0\n"
-"dHA6Ly93d3cuc3RhcnRzc2wuY29tL3BvbGljeS5wZGYwNAYIKwYBBQUHAgEWKGh0dHA6Ly93\n"
-"d3cuc3RhcnRzc2wuY29tL2ludGVybWVkaWF0ZS5wZGYwgc8GCCsGAQUFBwICMIHCMCcWIFN0\n"
-"YXJ0IENvbW1lcmNpYWwgKFN0YXJ0Q29tKSBMdGQuMAMCAQEagZZMaW1pdGVkIExpYWJpbGl0\n"
-"eSwgcmVhZCB0aGUgc2VjdGlvbiAqTGVnYWwgTGltaXRhdGlvbnMqIG9mIHRoZSBTdGFydENv\n"
-"bSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSBQb2xpY3kgYXZhaWxhYmxlIGF0IGh0dHA6Ly93\n"
-"d3cuc3RhcnRzc2wuY29tL3BvbGljeS5wZGYwEQYJYIZIAYb4QgEBBAQDAgAHMDgGCWCGSAGG\n"
-"+EIBDQQrFilTdGFydENvbSBGcmVlIFNTTCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTANBgkq\n"
-"hkiG9w0BAQsFAAOCAgEAjo/n3JR5fPGFf59Jb2vKXfuM/gTFwWLRfUKKvFO3lANmMD+x5wqn\n"
-"UCBVJX92ehQN6wQOQOY+2IirByeDqXWmN3PH/UvSTa0XQMhGvjt/UfzDtgUx3M2FIk5xt/Jx\n"
-"XrAaxrqTi3iSSoX4eA+D/i+tLPfkpLst0OcNOrg+zvZ49q5HJMqjNTbOx8aHmNrs++myzieb\n"
-"iMMEofYLWWivydsQD032ZGNcpRJvkrKTlMeIFw6Ttn5ii5B/q06f/ON1FE8qMt9bDeD1e5MN\n"
-"q6HPh+GlBEXoPBKlCcWw0bdT82AUuoVpaiF8H3VhFyAXe2w7QSlc4axa0c2Mm+tgHRns9+Ww\n"
-"2vl5GKVFP0lDV9LdJNUso/2RjSe15esUBppMeyG7Oq0wBhjA2MFrLH9ZXF2RsXAiV+uKa0hK\n"
-"1Q8p7MZAwC+ITGgBF3f0JBlPvfrhsiAhS90a2Cl9qrjeVOwhVYBsHvUwyKMQ5bLmKhQxw4Ut\n"
-"jJixhlpPiVktucf3HMiKf8CdBUrmQk9io20ppB+Fq9vlgcitKj1MXVuEJnHEhV5xJMqlG2zY\n"
-"YdMa4FTbzrqpMrUi9nNBCV24F10OD5mQ1kfabwo6YigUZ4LZ8dCAWZvLMdibD4x3TrVoivJs\n"
-"9iQOLWxwxXPR3hTQcY+203sC9uO41Alua551hDnmfyWl8kgAwKQB2j8=\n"
-"-----END CERTIFICATE-----\n",
-
-/* StartCom Certification Authority G2 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIFYzCCA0ugAwIBAgIBOzANBgkqhkiG9w0BAQsFADBTMQswCQYDVQQGEwJJTDEWMBQGA1UE\n"
-"ChMNU3RhcnRDb20gTHRkLjEsMCoGA1UEAxMjU3RhcnRDb20gQ2VydGlmaWNhdGlvbiBBdXRo\n"
-"b3JpdHkgRzIwHhcNMTAwMTAxMDEwMDAxWhcNMzkxMjMxMjM1OTAxWjBTMQswCQYDVQQGEwJJ\n"
-"TDEWMBQGA1UEChMNU3RhcnRDb20gTHRkLjEsMCoGA1UEAxMjU3RhcnRDb20gQ2VydGlmaWNh\n"
-"dGlvbiBBdXRob3JpdHkgRzIwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC2iTZb\n"
-"B7cgNr2Cu+EWIAOVeq8Oo1XJJZlKxdBWQYeQTSFgpBSHO839sj60ZwNq7eEPS8CRhXBF4EKe\n"
-"3ikj1AENoBB5uNsDvfOpL9HG4A/LnooUCri99lZi8cVytjIl2bLzvWXFDSxu1ZJvGIsAQRSC\n"
-"b0AgJnooD/Uefyf3lLE3PbfHkffiAez9lInhzG7TNtYKGXmu1zSCZf98Qru23QumNK9LYP5/\n"
-"Q0kGi4xDuFby2X8hQxfqp0iVAXV16iulQ5XqFYSdCI0mblWbq9zSOdIxHWDirMxWRST1HFSr\n"
-"7obdljKF+ExP6JV2tgXdNiNnvP8V4so75qbsO+wmETRIjfaAKxojAuuKHDp2KntWFhxyKrOq\n"
-"42ClAJ8Em+JvHhRYW6Vsi1g8w7pOOlz34ZYrPu8HvKTlXcxNnw3h3Kq74W4a7I/htkxNeXJd\n"
-"FzULHdfBR9qWJODQcqhaX2YtENwvKhOuJv4KHBnM0D4LnMgJLvlblnpHnOl68wVQdJVznjAJ\n"
-"85eCXuaPOQgeWeU1FEIT/wCc976qUM/iUUjXuG+v+E5+M5iSFGI6dWPPe/regjupuznixL0s\n"
-"AA7IF6wT700ljtizkC+p2il9Ha90OrInwMEePnWjFqmveiJdnxMaz6eg6+OGCtP95paV1yPI\n"
-"N93EfKo2rJgaErHgTuixO/XWb/Ew1wIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1Ud\n"
-"DwEB/wQEAwIBBjAdBgNVHQ4EFgQUS8W0QGutHLOlHGVuRjaJhwUMDrYwDQYJKoZIhvcNAQEL\n"
-"BQADggIBAHNXPyzVlTJ+N9uWkusZXn5T50HsEbZH77Xe7XRcxfGOSeD8bpkTzZ+K2s06Ctg6\n"
-"Wgk/XzTQLwPSZh0avZyQN8gMjgdalEVGKua+etqhqaRpEpKwfTbURIfXUfEpY9Z1zRbkJ4kd\n"
-"+MIySP3bmdCPX1R0zKxnNBFi2QwKN4fRoxdIjtIXHfbX/dtl6/2o1PXWT6RbdejF0mCy2wl+\n"
-"JYt7ulKSnj7oxXehPOBKc2thz4bcQ///If4jXSRK9dNtD2IEBVeC2m6kMyV5Sy5UGYvMLD0w\n"
-"6dEG/+gyRr61M3Z3qAFdlsHB1b6uJcDJHgoJIIihDsnzb02CVAAgp9KP5DlUFy6NHrgbuxu9\n"
-"mk47EDTcnIhT76IxW1hPkWLIwpqazRVdOKnWvvgTtZ8SafJQYqz7Fzf07rh1Z2AQ+4NQ+US1\n"
-"dZxAF7L+/XldblhYXzD8AK6vM8EOTmy6p6ahfzLbOOCxchcKK5HsamMm7YnUeMx0HgX4a/6M\n"
-"anY5Ka5lIxKVCCIcl85bBu4M4ru8H0ST9tg4RQUh7eStqxK2A6RCLi3ECToDZ2mEmuFZkIoo\n"
-"hdVddLHRDiBYmxOlsGOm7XtH/UVVMKTumtTm4ofvmMkyghEpIrwACjFeLQ/Ajulrso8uBtjR\n"
-"kcfGEvRM/TAXw8HaOFvjqermobp573PYtlNXLfbQ4ddI\n"
-"-----END CERTIFICATE-----\n",
-
-/* Buypass Class 2 Root CA */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIFWTCCA0GgAwIBAgIBAjANBgkqhkiG9w0BAQsFADBOMQswCQYDVQQGEwJOTzEdMBsGA1UE\n"
-"CgwUQnV5cGFzcyBBUy05ODMxNjMzMjcxIDAeBgNVBAMMF0J1eXBhc3MgQ2xhc3MgMiBSb290\n"
-"IENBMB4XDTEwMTAyNjA4MzgwM1oXDTQwMTAyNjA4MzgwM1owTjELMAkGA1UEBhMCTk8xHTAb\n"
-"BgNVBAoMFEJ1eXBhc3MgQVMtOTgzMTYzMzI3MSAwHgYDVQQDDBdCdXlwYXNzIENsYXNzIDIg\n"
-"Um9vdCBDQTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBANfHXvfBB9R3+0Mh9PT1\n"
-"aeTuMgHbo4Yf5FkNuud1g1Lr6hxhFUi7HQfKjK6w3Jad6sNgkoaCKHOcVgb/S2TwDCo3SbXl\n"
-"zwx87vFKu3MwZfPVL4O2fuPn9Z6rYPnT8Z2SdIrkHJasW4DptfQxh6NR/Md+oW+OU3fUl8FV\n"
-"M5I+GC911K2GScuVr1QGbNgGE41b/+EmGVnAJLqBcXmQRFBoJJRfuLMR8SlBYaNByyM21cHx\n"
-"MlAQTn/0hpPshNOOvEu/XAFOBz3cFIqUCqTqc/sLUegTBxj6DvEr0VQVfTzh97QZQmdiXnfg\n"
-"olXsttlpF9U6r0TtSsWe5HonfOV116rLJeffawrbD02TTqigzXsu8lkBarcNuAeBfos4Gzjm\n"
-"CleZPe4h6KP1DBbdi+w0jpwqHAAVF41og9JwnxgIzRFo1clrUs3ERo/ctfPYV3Me6ZQ5BL/T\n"
-"3jjetFPsaRyifsSP5BtwrfKi+fv3FmRmaZ9JUaLiFRhnBkp/1Wy1TbMz4GHrXb7pmA8y1x1L\n"
-"PC5aAVKRCfLf6o3YBkBjqhHk/sM3nhRSP/TizPJhk9H9Z2vXUq6/aKtAQ6BXNVN48FP4YUIH\n"
-"ZMbXb5tMOA1jrGKvNouicwoN9SG9dKpN6nIDSdvHXx1iY8f93ZHsM+71bbRuMGjeyNYmsHVe\n"
-"e7QHIJihdjK4TWxPAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFMmAd+Bi\n"
-"koL1RpzzuvdMw964o605MA4GA1UdDwEB/wQEAwIBBjANBgkqhkiG9w0BAQsFAAOCAgEAU18h\n"
-"9bqwOlI5LJKwbADJ784g7wbylp7ppHR/ehb8t/W2+xUbP6umwHJdELFx7rxP462sA20ucS6v\n"
-"xOOto70MEae0/0qyexAQH6dXQbLArvQsWdZHEIjzIVEpMMpghq9Gqx3tOluwlN5E40EIosHs\n"
-"Hdb9T7bWR9AUC8rmyrV7d35BH16Dx7aMOZawP5aBQW9gkOLo+fsicdl9sz1Gv7SEr5AcD48S\n"
-"aq/v7h56rgJKihcrdv6sVIkkLE8/trKnToyokZf7KcZ7XC25y2a2t6hbElGFtQl+Ynhw/qlq\n"
-"YLYdDnkM/crqJIByw5c/8nerQyIKx+u2DISCLIBrQYoIwOula9+ZEsuK1V6ADJHgJgg2SMX6\n"
-"OBE1/yWDLfJ6v9r9jv6ly0UsH8SIU653DtmadsWOLB2jutXsMq7Aqqz30XpN69QH4kj3Io6w\n"
-"pJ9qzo6ysmD0oyLQI+uUWnpp3Q+/QFesa1lQ2aOZ4W7+jQF5JyMV3pKdewlNWudLSDBaGOYK\n"
-"beaP4NK75t98biGCwWg5TbSYWGZizEqQXsP6JwSxeRV0mcy+rSDeJmAc61ZRpqPq5KM/p/9h\n"
-"3PFaTWwyI0PurKju7koSCTxdccK+efrCh2gdC/1cacwG0Jp9VJkqyTkaGa9LKkPzY11aWOIv\n"
-"4x3kqdbQCtCev9eBCfHJxyYNrJgWVqA=\n"
-"-----END CERTIFICATE-----\n",
-
-/* Buypass Class 3 Root CA */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIFWTCCA0GgAwIBAgIBAjANBgkqhkiG9w0BAQsFADBOMQswCQYDVQQGEwJOTzEdMBsGA1UE\n"
-"CgwUQnV5cGFzcyBBUy05ODMxNjMzMjcxIDAeBgNVBAMMF0J1eXBhc3MgQ2xhc3MgMyBSb290\n"
-"IENBMB4XDTEwMTAyNjA4Mjg1OFoXDTQwMTAyNjA4Mjg1OFowTjELMAkGA1UEBhMCTk8xHTAb\n"
-"BgNVBAoMFEJ1eXBhc3MgQVMtOTgzMTYzMzI3MSAwHgYDVQQDDBdCdXlwYXNzIENsYXNzIDMg\n"
-"Um9vdCBDQTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAKXaCpUWUOOV8l6ddjEG\n"
-"Mnqb8RB2uACatVI2zSRHsJ8YZLya9vrVediQYkwiL944PdbgqOkcLNt4EemOaFEVcsfzM4fk\n"
-"oF0LXOBXByow9c3EN3coTRiR5r/VUv1xLXA+58bEiuPwKAv0dpihi4dVsjoT/Lc+JzeOIuOo\n"
-"TyrvYLs9tznDDgFHmV0ST9tD+leh7fmdvhFHJlsTmKtdFoqwNxxXnUX/iJY2v7vKB3tvh2PX\n"
-"0DJq1l1sDPGzbjniazEuOQAnFN44wOwZZoYS6J1yFhNkUsepNxz9gjDthBgd9K5c/3ATAOux\n"
-"9TN6S9ZV+AWNS2mw9bMoNlwUxFFzTWsL8TQH2xc519woe2v1n/MuwU8XKhDzzMro6/1rqy6a\n"
-"ny2CbgTUUgGTLT2G/H783+9CHaZr77kgxve9oKeV/afmiSTYzIw0bOIjL9kSGiG5VZFvC5F5\n"
-"GQytQIgLcOJ60g7YaEi7ghM5EFjp2CoHxhLbWNvSO1UQRwUVZ2J+GGOmRj8JDlQyXr8NYnon\n"
-"74Do29lLBlo3WiXQCBJ31G8JUJc9yB3D34xFMFbG02SrZvPAXpacw8Tvw3xrizp5f7NJzz3i\n"
-"iZ+gMEuFuZyUJHmPfWupRWgPK9Dx2hzLabjKSWJtyNBjYt1gD1iqj6G8BaVmos8bdrKEZLFM\n"
-"OVLAMLrwjEsCsLa3AgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFEe4zf/l\n"
-"b+74suwvTg75JbCOPGvDMA4GA1UdDwEB/wQEAwIBBjANBgkqhkiG9w0BAQsFAAOCAgEAACAj\n"
-"QTUEkMJAYmDv4jVM1z+s4jSQuKFvdvoWFqRINyzpkMLyPPgKn9iB5btb2iUspKdVcSQy9sgL\n"
-"8rxq+JOssgfCX5/bzMiKqr5qb+FJEMwx14C7u8jYog5kV+qi9cKpMRXSIGrs/CIBKM+GuIAe\n"
-"qcwRpTzyFrNHnfzSgCHEy9BHcEGhyoMZCCxt8l13nIoUE9Q2HJLw5QY33KbmkJs4j1xrG0aG\n"
-"Q0JfPgEHU1RdZX33inOhmlRaHylDFCfChQ+1iHsaO5S3HWCntZznKWlXWpuTekMwGwPXYshA\n"
-"pqr8ZORK15FTAaggiG6cX0S5y2CBNOxv033aSF/rtJC8LakcC6wc1aJoIIAE1vyxjy+7SjEN\n"
-"SoYc6+I2KSb12tjE8nVhz36udmNKekBlk4f4HoCMhuWG1o8O/FMsYOgWYRqiPkN7zTlgVGr1\n"
-"8okmAWiDSKIz6MkEkbIRNBE+6tBDGR8Dk5AM/1E9V/RBbuHLoL7ryWPNbczk+DaqaJ3tvV2X\n"
-"cEQNtg413OEMXbugUZTLfhbrES+jkkXITHHZvMmZUldGL1DPvTVp9D0VzgalLA8+9oG6lLvD\n"
-"u79leNKGef9JOxqDDPDeeOzI8k1MGt6CKfjBWtrt7uYnXuhF0J0cUahoq0Tj0Itq4/g7u9xN\n"
-"12TyUb7mqqta6THuBrxzvxNiCp/HuZc=\n"
-"-----END CERTIFICATE-----\n",
-
-/* T-TeleSec GlobalRoot Class 3 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDwzCCAqugAwIBAgIBATANBgkqhkiG9w0BAQsFADCBgjELMAkGA1UEBhMCREUxKzApBgNV\n"
-"BAoMIlQtU3lzdGVtcyBFbnRlcnByaXNlIFNlcnZpY2VzIEdtYkgxHzAdBgNVBAsMFlQtU3lz\n"
-"dGVtcyBUcnVzdCBDZW50ZXIxJTAjBgNVBAMMHFQtVGVsZVNlYyBHbG9iYWxSb290IENsYXNz\n"
-"IDMwHhcNMDgxMDAxMTAyOTU2WhcNMzMxMDAxMjM1OTU5WjCBgjELMAkGA1UEBhMCREUxKzAp\n"
-"BgNVBAoMIlQtU3lzdGVtcyBFbnRlcnByaXNlIFNlcnZpY2VzIEdtYkgxHzAdBgNVBAsMFlQt\n"
-"U3lzdGVtcyBUcnVzdCBDZW50ZXIxJTAjBgNVBAMMHFQtVGVsZVNlYyBHbG9iYWxSb290IENs\n"
-"YXNzIDMwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC9dZPwYiJvJK7genasfb3Z\n"
-"JNW4t/zN8ELg63iIVl6bmlQdTQyK9tPPcPRStdiTBONGhnFBSivwKixVA9ZIw+A5OO3yXDw/\n"
-"RLyTPWGrTs0NvvAgJ1gORH8EGoel15YUNpDQSXuhdfsaa3Ox+M6pCSzyU9XDFES4hqX2iys5\n"
-"2qMzVNn6chr3IhUciJFrf2blw2qAsCTz34ZFiP0Zf3WHHx+xGwpzJFu5ZeAsVMhg02YXP+HM\n"
-"VDNzkQI6pn97djmiH5a2OK61yJN0HZ65tOVgnS9W0eDrXltMEnAMbEQgqxHY9Bn20pxSN+f6\n"
-"tsIxO0rUFJmtxxr1XV/6B7h8DR/Wgx6zAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wDgYD\n"
-"VR0PAQH/BAQDAgEGMB0GA1UdDgQWBBS1A/d2O2GCahKqGFPrAyGUv/7OyjANBgkqhkiG9w0B\n"
-"AQsFAAOCAQEAVj3vlNW92nOyWL6ukK2YJ5f+AbGwUgC4TeQbIXQbfsDuXmkqJa9c1h3a0nnJ\n"
-"85cp4IaH3gRZD/FZ1GSFS5mvJQQeyUapl96Cshtwn5z2r3Ex3XsFpSzTucpH9sry9uetuUg/\n"
-"vBa3wW306gmv7PO15wWeph6KU1HWk4HMdJP2udqmJQV0eVp+QD6CSyYRMG7hP0HHRwA11fXT\n"
-"91Q+gT3aSWqas+8QPebrb9HIIkfLzM8BMZLZGOMivgkeGj5asuRrDFR6fUNOuImle9eiPZaG\n"
-"zPImNC1qkp2aGtAw4l1OBLBfiyB+d8E9lYLRRpo7PHi4b6HQDWSieB4pTpPDpFQUWw==\n"
-"-----END CERTIFICATE-----\n",
-
-/* EE Certification Centre Root CA */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIEAzCCAuugAwIBAgIQVID5oHPtPwBMyonY43HmSjANBgkqhkiG9w0BAQUFADB1MQswCQYD\n"
-"VQQGEwJFRTEiMCAGA1UECgwZQVMgU2VydGlmaXRzZWVyaW1pc2tlc2t1czEoMCYGA1UEAwwf\n"
-"RUUgQ2VydGlmaWNhdGlvbiBDZW50cmUgUm9vdCBDQTEYMBYGCSqGSIb3DQEJARYJcGtpQHNr\n"
-"LmVlMCIYDzIwMTAxMDMwMTAxMDMwWhgPMjAzMDEyMTcyMzU5NTlaMHUxCzAJBgNVBAYTAkVF\n"
-"MSIwIAYDVQQKDBlBUyBTZXJ0aWZpdHNlZXJpbWlza2Vza3VzMSgwJgYDVQQDDB9FRSBDZXJ0\n"
-"aWZpY2F0aW9uIENlbnRyZSBSb290IENBMRgwFgYJKoZIhvcNAQkBFglwa2lAc2suZWUwggEi\n"
-"MA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDIIMDs4MVLqwd4lfNE7vsLDP90jmG7sWLq\n"
-"I9iroWUyeuuOF0+W2Ap7kaJjbMeMTC55v6kF/GlclY1i+blw7cNRfdCT5mzrMEvhvH2/UpvO\n"
-"bntl8jixwKIy72KyaOBhU8E2lf/slLo2rpwcpzIP5Xy0xm90/XsY6KxX7QYgSzIwWFv9zajm\n"
-"ofxwvI6Sc9uXp3whrj3B9UiHbCe9nyV0gVWw93X2PaRka9ZP585ArQ/dMtO8ihJTmMmJ+xAd\n"
-"TX7Nfh9WDSFwhfYggx/2uh8Ej+p3iDXE/+pOoYtNP2MbRMNE1CV2yreN1x5KZmTNXMWcg+HC\n"
-"CIia7E6j8T4cLNlsHaFLAgMBAAGjgYowgYcwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8E\n"
-"BAMCAQYwHQYDVR0OBBYEFBLyWj7qVhy/zQas8fElyalL1BSZMEUGA1UdJQQ+MDwGCCsGAQUF\n"
-"BwMCBggrBgEFBQcDAQYIKwYBBQUHAwMGCCsGAQUFBwMEBggrBgEFBQcDCAYIKwYBBQUHAwkw\n"
-"DQYJKoZIhvcNAQEFBQADggEBAHv25MANqhlHt01Xo/6tu7Fq1Q+e2+RjxY6hUFaTlrg4wCQi\n"
-"ZrxTFGGVv9DHKpY5P30osxBAIWrEr7BSdxjhlthWXePdNl4dp1BUoMUq5KqMlIpPnTX/dqQG\n"
-"E5Gion0ARD9V04I8GtVbvFZMIi5GQ4okQC3zErg7cBqklrkar4dBGmoYDQZPxz5uuSlNDUmJ\n"
-"EYcyW+ZLBMjkXOZ0c5RdFpgTlf7727FE5TpwrDdr5rMzcijJs1eg9gIWiAYLtqZLICjU3j2L\n"
-"rTcFU3T+bsy8QxdxXvnFzBqpYe73dgzzcvRyrc9yAjYHR8/vGVCJYMzpJJUPwssd8m92kMfM\n"
-"dcGWxZ0=\n"
-"-----END CERTIFICATE-----\n",
-
-/* TURKTRUST Certificate Services Provider Root 2007 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIEPTCCAyWgAwIBAgIBATANBgkqhkiG9w0BAQUFADCBvzE/MD0GA1UEAww2VMOcUktUUlVT\n"
-"VCBFbGVrdHJvbmlrIFNlcnRpZmlrYSBIaXptZXQgU2HEn2xhecSxY8Sxc8SxMQswCQYDVQQG\n"
-"EwJUUjEPMA0GA1UEBwwGQW5rYXJhMV4wXAYDVQQKDFVUw5xSS1RSVVNUIEJpbGdpIMSwbGV0\n"
-"acWfaW0gdmUgQmlsacWfaW0gR8O8dmVubGnEn2kgSGl6bWV0bGVyaSBBLsWeLiAoYykgQXJh\n"
-"bMSxayAyMDA3MB4XDTA3MTIyNTE4MzcxOVoXDTE3MTIyMjE4MzcxOVowgb8xPzA9BgNVBAMM\n"
-"NlTDnFJLVFJVU1QgRWxla3Ryb25payBTZXJ0aWZpa2EgSGl6bWV0IFNhxJ9sYXnEsWPEsXPE\n"
-"sTELMAkGA1UEBhMCVFIxDzANBgNVBAcMBkFua2FyYTFeMFwGA1UECgxVVMOcUktUUlVTVCBC\n"
-"aWxnaSDEsGxldGnFn2ltIHZlIEJpbGnFn2ltIEfDvHZlbmxpxJ9pIEhpem1ldGxlcmkgQS7F\n"
-"ni4gKGMpIEFyYWzEsWsgMjAwNzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAKu3\n"
-"PgqMyKVYFeaK7yc9SrToJdPNM8Ig3BnuiD9NYvDdE3ePYakqtdTyuTFYKTsvP2qcb3N2Je40\n"
-"IIDu6rfwxArNK4aUyeNgsURSsloptJGXg9i3phQvKUmi8wUG+7RP2qFsmmaf8EMJyupyj+sA\n"
-"1zU511YXRxcw9L6/P8JorzZAwan0qafoEGsIiveGHtyaKhUG9qPw9ODHFNRRf8+0222vR5YX\n"
-"m3dx2KdxnSQM9pQ/hTEST7ruToK4uT6PIzdezKKqdfcYbwnTrqdUKDT74eA7YH2gvnmJhsif\n"
-"LfkKS8RQouf9eRbHegsYz85M733WB2+Y8a+xwXrXgTW4qhe04MsCAwEAAaNCMEAwHQYDVR0O\n"
-"BBYEFCnFkKslrxHkYb+j/4hhkeYO/pyBMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8EBTAD\n"
-"AQH/MA0GCSqGSIb3DQEBBQUAA4IBAQAQDdr4Ouwo0RSVgrESLFF6QSU2TJ/sPx+EnWVUXKgW\n"
-"AkD6bho3hO9ynYYKVZ1WKKxmLNA6VpM0ByWtCLCPyA8JWcqdmBzlVPi5RX9ql2+IaE1KBiY3\n"
-"iAIOtsbWcpnOa3faYjGkVh+uX4132l32iPwa2Z61gfAyuOOI0JzzaqC5mxRZNTZPz/OOXl0X\n"
-"rRWV2N2y1RVuAE6zS89mlOTgzbUF2mNXi+WzqtvALhyQRNsaXRik7r4EW5nVcV9VZWRi1aKb\n"
-"BFmGyGJ353yCRWo9F7/snXUMrqNvWtMvmDb08PUZqxFdyKbjKlhqQgnDvZImZjINXQhVdP+M\n"
-"mNAKpoRq0Tl9\n"
-"-----END CERTIFICATE-----\n",
-
-/* D-TRUST Root Class 3 CA 2 2009 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIEMzCCAxugAwIBAgIDCYPzMA0GCSqGSIb3DQEBCwUAME0xCzAJBgNVBAYTAkRFMRUwEwYD\n"
-"VQQKDAxELVRydXN0IEdtYkgxJzAlBgNVBAMMHkQtVFJVU1QgUm9vdCBDbGFzcyAzIENBIDIg\n"
-"MjAwOTAeFw0wOTExMDUwODM1NThaFw0yOTExMDUwODM1NThaME0xCzAJBgNVBAYTAkRFMRUw\n"
-"EwYDVQQKDAxELVRydXN0IEdtYkgxJzAlBgNVBAMMHkQtVFJVU1QgUm9vdCBDbGFzcyAzIENB\n"
-"IDIgMjAwOTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBANOySs96R+91myP6Oi/W\n"
-"UEWJNTrGa9v+2wBoqOADER03UAifTUpolDWzU9GUY6cgVq/eUXjsKj3zSEhQPgrfRlWLJ23D\n"
-"EE0NkVJD2IfgXU42tSHKXzlABF9bfsyjxiupQB7ZNoTWSPOSHjRGICTBpFGOShrvUD9pXRl/\n"
-"RcPHAY9RySPocq60vFYJfxLLHLGvKZAKyVXMD9O0Gu1HNVpK7ZxzBCHQqr0ME7UAyiZsxGsM\n"
-"lFqVlNpQmvH/pStmMaTJOKDfHR+4CS7zp+hnUquVH+BGPtikw8paxTGA6Eian5Rp/hnd2HN8\n"
-"gcqW3o7tszIFZYQ05ub9VxC1X3a/L7AQDcUCAwEAAaOCARowggEWMA8GA1UdEwEB/wQFMAMB\n"
-"Af8wHQYDVR0OBBYEFP3aFMSfMN4hvR5COfyrYyNJ4PGEMA4GA1UdDwEB/wQEAwIBBjCB0wYD\n"
-"VR0fBIHLMIHIMIGAoH6gfIZ6bGRhcDovL2RpcmVjdG9yeS5kLXRydXN0Lm5ldC9DTj1ELVRS\n"
-"VVNUJTIwUm9vdCUyMENsYXNzJTIwMyUyMENBJTIwMiUyMDIwMDksTz1ELVRydXN0JTIwR21i\n"
-"SCxDPURFP2NlcnRpZmljYXRlcmV2b2NhdGlvbmxpc3QwQ6BBoD+GPWh0dHA6Ly93d3cuZC10\n"
-"cnVzdC5uZXQvY3JsL2QtdHJ1c3Rfcm9vdF9jbGFzc18zX2NhXzJfMjAwOS5jcmwwDQYJKoZI\n"
-"hvcNAQELBQADggEBAH+X2zDI36ScfSF6gHDOFBJpiBSVYEQBrLLpME+bUMJm2H6NMLVwMeni\n"
-"acfzcNsgFYbQDfC+rAF1hM5+n02/t2A7nPPKHeJeaNijnZflQGDSNiH+0LS4F9p0o3/U37CY\n"
-"Aqxva2ssJSRyoWXuJVrl5jLn8t+rSfrzkGkj2wTZ51xY/GXUl77M/C4KzCUqNQT4YJEVdT1B\n"
-"/yMfGchs64JTBKbkTCJNjYy6zltz7GRUUG3RnFX7acM2w4y8PIWmawomDeCTmGCufsYkl4ph\n"
-"X5GOZpIJhzbNi5stPvZR1FDUWSi9g/LMKHtThm3YJohw1+qRzT65ysCQblrGXnRl11z+o+I=\n"
-"-----END CERTIFICATE-----\n",
-
-/* D-TRUST Root Class 3 CA 2 EV 2009 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIEQzCCAyugAwIBAgIDCYP0MA0GCSqGSIb3DQEBCwUAMFAxCzAJBgNVBAYTAkRFMRUwEwYD\n"
-"VQQKDAxELVRydXN0IEdtYkgxKjAoBgNVBAMMIUQtVFJVU1QgUm9vdCBDbGFzcyAzIENBIDIg\n"
-"RVYgMjAwOTAeFw0wOTExMDUwODUwNDZaFw0yOTExMDUwODUwNDZaMFAxCzAJBgNVBAYTAkRF\n"
-"MRUwEwYDVQQKDAxELVRydXN0IEdtYkgxKjAoBgNVBAMMIUQtVFJVU1QgUm9vdCBDbGFzcyAz\n"
-"IENBIDIgRVYgMjAwOTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAJnxhDRwui+3\n"
-"MKCOvXwEz75ivJn9gpfSegpnljgJ9hBOlSJzmY3aFS3nBfwZcyK3jpgAvDw9rKFs+9Z5JUut\n"
-"8Mxk2og+KbgPCdM03TP1YtHhzRnp7hhPTFiu4h7WDFsVWtg6uMQYZB7jM7K1iXdODL/ZlGsT\n"
-"l28So/6ZqQTMFexgaDbtCHu39b+T7WYxg4zGcTSHThfqr4uRjRxWQa4iN1438h3Z0S0NL2lR\n"
-"p75mpoo6Kr3HGrHhFPC+Oh25z1uxav60sUYgovseO3Dvk5h9jHOW8sXvhXCtKSb8HgQ+HKDY\n"
-"D8tSg2J87otTlZCpV6LqYQXY+U3EJ/pure3511H3a6UCAwEAAaOCASQwggEgMA8GA1UdEwEB\n"
-"/wQFMAMBAf8wHQYDVR0OBBYEFNOUikxiEyoZLsyvcop9NteaHNxnMA4GA1UdDwEB/wQEAwIB\n"
-"BjCB3QYDVR0fBIHVMIHSMIGHoIGEoIGBhn9sZGFwOi8vZGlyZWN0b3J5LmQtdHJ1c3QubmV0\n"
-"L0NOPUQtVFJVU1QlMjBSb290JTIwQ2xhc3MlMjAzJTIwQ0ElMjAyJTIwRVYlMjAyMDA5LE89\n"
-"RC1UcnVzdCUyMEdtYkgsQz1ERT9jZXJ0aWZpY2F0ZXJldm9jYXRpb25saXN0MEagRKBChkBo\n"
-"dHRwOi8vd3d3LmQtdHJ1c3QubmV0L2NybC9kLXRydXN0X3Jvb3RfY2xhc3NfM19jYV8yX2V2\n"
-"XzIwMDkuY3JsMA0GCSqGSIb3DQEBCwUAA4IBAQA07XtaPKSUiO8aEXUHL7P+PPoeUSbrh/Yp\n"
-"3uDx1MYkCenBz1UbtDDZzhr+BlGmFaQt77JLvyAoJUnRpjZ3NOhk31KxEcdzes05nsKtjHEh\n"
-"8lprr988TlWvsoRlFIm5d8sqMb7Po23Pb0iUMkZv53GMoKaEGTcH8gNFCSuGdXzfX2lXANtu\n"
-"2KZyIktQ1HWYVt+3GP9DQ1CuekR78HlR10M9p9OB0/DJT7naxpeG0ILD5EJt/rDiZE4OJudA\n"
-"NCa1CInXCGNjOCd1HjPqbqjdn5lPdE2BiYBL3ZqXKVwvvoFBuYz/6n1gBp7N1z3TLqMVvKjm\n"
-"JuVvw9y4AyHqnxbxLFS1\n"
-"-----END CERTIFICATE-----\n",
-
-/* PSCProcert */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIJhjCCB26gAwIBAgIBCzANBgkqhkiG9w0BAQsFADCCAR4xPjA8BgNVBAMTNUF1dG9yaWRh\n"
-"ZCBkZSBDZXJ0aWZpY2FjaW9uIFJhaXogZGVsIEVzdGFkbyBWZW5lem9sYW5vMQswCQYDVQQG\n"
-"EwJWRTEQMA4GA1UEBxMHQ2FyYWNhczEZMBcGA1UECBMQRGlzdHJpdG8gQ2FwaXRhbDE2MDQG\n"
-"A1UEChMtU2lzdGVtYSBOYWNpb25hbCBkZSBDZXJ0aWZpY2FjaW9uIEVsZWN0cm9uaWNhMUMw\n"
-"QQYDVQQLEzpTdXBlcmludGVuZGVuY2lhIGRlIFNlcnZpY2lvcyBkZSBDZXJ0aWZpY2FjaW9u\n"
-"IEVsZWN0cm9uaWNhMSUwIwYJKoZIhvcNAQkBFhZhY3JhaXpAc3VzY2VydGUuZ29iLnZlMB4X\n"
-"DTEwMTIyODE2NTEwMFoXDTIwMTIyNTIzNTk1OVowgdExJjAkBgkqhkiG9w0BCQEWF2NvbnRh\n"
-"Y3RvQHByb2NlcnQubmV0LnZlMQ8wDQYDVQQHEwZDaGFjYW8xEDAOBgNVBAgTB01pcmFuZGEx\n"
-"KjAoBgNVBAsTIVByb3ZlZWRvciBkZSBDZXJ0aWZpY2Fkb3MgUFJPQ0VSVDE2MDQGA1UEChMt\n"
-"U2lzdGVtYSBOYWNpb25hbCBkZSBDZXJ0aWZpY2FjaW9uIEVsZWN0cm9uaWNhMQswCQYDVQQG\n"
-"EwJWRTETMBEGA1UEAxMKUFNDUHJvY2VydDCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoC\n"
-"ggIBANW39KOUM6FGqVVhSQ2oh3NekS1wwQYalNo97BVCwfWMrmoX8Yqt/ICV6oNEolt6Vc5P\n"
-"p6XVurgfoCfAUFM+jbnADrgV3NZs+J74BCXfgI8Qhd19L3uA3VcAZCP4bsm+lU/hdezgfl6V\n"
-"zbHvvnpC2Mks0+saGiKLt38GieU89RLAu9MLmV+QfI4tL3czkkohRqipCKzx9hEC2ZUWno0v\n"
-"luYC3XXCFCpa1sl9JcLB/KpnheLsvtF8PPqv1W7/U0HU9TI4seJfxPmOEO8GqQKJ/+MMbpfg\n"
-"353bIdD0PghpbNjU5Db4g7ayNo+c7zo3Fn2/omnXO1ty0K+qP1xmk6wKImG20qCZyFSTXai2\n"
-"0b1dCl53lKItwIKOvMoDKjSuc/HUtQy9vmebVOvh+qBa7Dh+PsHMosdEMXXqP+UH0quhJZb2\n"
-"5uSgXTcYOWEAM11G1ADEtMo88aKjPvM6/2kwLkDd9p+cJsmWN63nOaK/6mnbVSKVUyqUtd+t\n"
-"FjiBdWbjxywbk5yqjKPK2Ww8F22c3HxT4CAnQzb5EuE8XL1mv6JpIzi4mWCZDlZTOpx+FIyw\n"
-"Bm/xhnaQr/2v/pDGj59/i5IjnOcVdo/Vi5QTcmn7K2FjiO/mpF7moxdqWEfLcU8UC17IAggm\n"
-"osvpr2uKGcfLFFb14dq12fy/czja+eevbqQ34gcnAgMBAAGjggMXMIIDEzASBgNVHRMBAf8E\n"
-"CDAGAQH/AgEBMDcGA1UdEgQwMC6CD3N1c2NlcnRlLmdvYi52ZaAbBgVghl4CAqASDBBSSUYt\n"
-"Ry0yMDAwNDAzNi0wMB0GA1UdDgQWBBRBDxk4qpl/Qguk1yeYVKIXTC1RVDCCAVAGA1UdIwSC\n"
-"AUcwggFDgBStuyIdxuDSAaj9dlBSk+2YwU2u06GCASakggEiMIIBHjE+MDwGA1UEAxM1QXV0\n"
-"b3JpZGFkIGRlIENlcnRpZmljYWNpb24gUmFpeiBkZWwgRXN0YWRvIFZlbmV6b2xhbm8xCzAJ\n"
-"BgNVBAYTAlZFMRAwDgYDVQQHEwdDYXJhY2FzMRkwFwYDVQQIExBEaXN0cml0byBDYXBpdGFs\n"
-"MTYwNAYDVQQKEy1TaXN0ZW1hIE5hY2lvbmFsIGRlIENlcnRpZmljYWNpb24gRWxlY3Ryb25p\n"
-"Y2ExQzBBBgNVBAsTOlN1cGVyaW50ZW5kZW5jaWEgZGUgU2VydmljaW9zIGRlIENlcnRpZmlj\n"
-"YWNpb24gRWxlY3Ryb25pY2ExJTAjBgkqhkiG9w0BCQEWFmFjcmFpekBzdXNjZXJ0ZS5nb2Iu\n"
-"dmWCAQowDgYDVR0PAQH/BAQDAgEGME0GA1UdEQRGMESCDnByb2NlcnQubmV0LnZloBUGBWCG\n"
-"XgIBoAwMClBTQy0wMDAwMDKgGwYFYIZeAgKgEgwQUklGLUotMzE2MzUzNzMtNzB2BgNVHR8E\n"
-"bzBtMEagRKBChkBodHRwOi8vd3d3LnN1c2NlcnRlLmdvYi52ZS9sY3IvQ0VSVElGSUNBRE8t\n"
-"UkFJWi1TSEEzODRDUkxERVIuY3JsMCOgIaAfhh1sZGFwOi8vYWNyYWl6LnN1c2NlcnRlLmdv\n"
-"Yi52ZTA3BggrBgEFBQcBAQQrMCkwJwYIKwYBBQUHMAGGG2h0dHA6Ly9vY3NwLnN1c2NlcnRl\n"
-"LmdvYi52ZTBBBgNVHSAEOjA4MDYGBmCGXgMBAjAsMCoGCCsGAQUFBwIBFh5odHRwOi8vd3d3\n"
-"LnN1c2NlcnRlLmdvYi52ZS9kcGMwDQYJKoZIhvcNAQELBQADggIBACtZ6yKZu4SqT96QxtGG\n"
-"cSOeSwORR3C7wJJg7ODU523G0+1ng3dS1fLld6c2suNUvtm7CpsR72H0xpkzmfWvADmNg7+m\n"
-"vTV+LFwxNG9s2/NkAZiqlCxB3RWGymspThbASfzXg0gTB1GEMVKIu4YXx2sviiCtxQuPcD4q\n"
-"uxtxj7mkoP3YldmvWb8lK5jpY5MvYB7Eqvh39YtsL+1+LrVPQA3uvFd359m21D+VJzog1eWu\n"
-"q2w1n8GhHVnchIHuTQfiSLaeS5UtQbHh6N5+LwUeaO6/u5BlOsju6rEYNxxik6SgMexxbJHm\n"
-"pHmJWhSnFFAFTKQAVzAswbVhltw+HoSvOULP5dAssSS830DD7X9jSr3hTxJkhpXzsOfIt+FT\n"
-"vZLm8wyWuevo5pLtp4EJFAv8lXrPj9Y0TzYS3F7RNHXGRoAvlQSMx4bEqCaJqD8Zm4G7UaRK\n"
-"hqsLEQ+xrmNTbSjq3TNWOByyrYDT13K9mmyZY+gAu0F2BbdbmRiKw7gSXFbPVgx96OLP7bx0\n"
-"R/vu0xdOIk9W/1DzLuY5poLWccret9W6aAjtmcz9opLLabid+Qqkpj5PkygqYWwHJgD/ll9o\n"
-"hri4zspV4KuxPX+Y1zMOWj3YeMLEYC/HYvBhkdI4sPaeVdtAgAUSM84dkpvRabP/v/GSCmE1\n"
-"P93+hvS84Bpxs2Km\n"
-"-----END CERTIFICATE-----\n",
-
-/* China Internet Network Information Center EV Certificates Root */
-"-----BEGIN CERTIFICATE-----\n"
-"MIID9zCCAt+gAwIBAgIESJ8AATANBgkqhkiG9w0BAQUFADCBijELMAkGA1UEBhMCQ04xMjAw\n"
-"BgNVBAoMKUNoaW5hIEludGVybmV0IE5ldHdvcmsgSW5mb3JtYXRpb24gQ2VudGVyMUcwRQYD\n"
-"VQQDDD5DaGluYSBJbnRlcm5ldCBOZXR3b3JrIEluZm9ybWF0aW9uIENlbnRlciBFViBDZXJ0\n"
-"aWZpY2F0ZXMgUm9vdDAeFw0xMDA4MzEwNzExMjVaFw0zMDA4MzEwNzExMjVaMIGKMQswCQYD\n"
-"VQQGEwJDTjEyMDAGA1UECgwpQ2hpbmEgSW50ZXJuZXQgTmV0d29yayBJbmZvcm1hdGlvbiBD\n"
-"ZW50ZXIxRzBFBgNVBAMMPkNoaW5hIEludGVybmV0IE5ldHdvcmsgSW5mb3JtYXRpb24gQ2Vu\n"
-"dGVyIEVWIENlcnRpZmljYXRlcyBSb290MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKC\n"
-"AQEAm35z7r07eKpkQ0H1UN+U8i6yjUqORlTSIRLIOTJCBumD1Z9S7eVnAztUwYyZmczpwA//\n"
-"DdmEEbK40ctb3B75aDFk4Zv6dOtouSCV98YPjUesWgbdYavi7NifFy2cyjw1l1VxzUOFsUcW\n"
-"9SxTgHbP0wBkvUCZ3czY28Sf1hNfQYOL+Q2HklY0bBoQCxfVWhyXWIQ8hBouXJE0bhlffxdp\n"
-"xWXvayHG1VA6v2G5BY3vbzQ6sm8UY78WO5upKv23KzhmBsUs4qpnHkWnjQRmQvaPK++IIGmP\n"
-"MowUc9orhpFjIpryp9vOiYurXccUwVswah+xt54ugQEC7c+WXmPbqOY4twIDAQABo2MwYTAf\n"
-"BgNVHSMEGDAWgBR8cks5x8DbYqVPm6oYNJKiyoOCWTAPBgNVHRMBAf8EBTADAQH/MA4GA1Ud\n"
-"DwEB/wQEAwIBBjAdBgNVHQ4EFgQUfHJLOcfA22KlT5uqGDSSosqDglkwDQYJKoZIhvcNAQEF\n"
-"BQADggEBACrDx0M3j92tpLIM7twUbY8opJhJywyA6vPtI2Z1fcXTIWd50XPFtQO3WKwMVC/G\n"
-"VhMPMdoG52U7HW8228gd+f2ABsqjPWYWqJ1MFn3AlUa1UeTiH9fqBk1jjZaM7+czV0I664zB\n"
-"echNdn3e9rG3geCg+aF4RhcaVpjwTj2rHO3sOdwHSPdj/gauwqRcalsyiMXHM4WsZkJHwlgk\n"
-"meHlPuV1LI5D1l08eB6olYIpUNHRFrrvwb562bTYzB5MRuF3sTGrvSrIzo9uoV1/A3U05K2J\n"
-"RVRevq4opbs/eHnrc7MKDf2+yfdWrPa37S+bISnHOLaVxATywy39FCqQmbkHzJ8=\n"
-"-----END CERTIFICATE-----\n",
-
-/* Swisscom Root CA 2 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIF2TCCA8GgAwIBAgIQHp4o6Ejy5e/DfEoeWhhntjANBgkqhkiG9w0BAQsFADBkMQswCQYD\n"
-"VQQGEwJjaDERMA8GA1UEChMIU3dpc3Njb20xJTAjBgNVBAsTHERpZ2l0YWwgQ2VydGlmaWNh\n"
-"dGUgU2VydmljZXMxGzAZBgNVBAMTElN3aXNzY29tIFJvb3QgQ0EgMjAeFw0xMTA2MjQwODM4\n"
-"MTRaFw0zMTA2MjUwNzM4MTRaMGQxCzAJBgNVBAYTAmNoMREwDwYDVQQKEwhTd2lzc2NvbTEl\n"
-"MCMGA1UECxMcRGlnaXRhbCBDZXJ0aWZpY2F0ZSBTZXJ2aWNlczEbMBkGA1UEAxMSU3dpc3Nj\n"
-"b20gUm9vdCBDQSAyMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAlUJOhJ1R5tMJ\n"
-"6HJaI2nbeHCOFvErjw0DzpPMLgAIe6szjPTpQOYXTKueuEcUMncy3SgM3hhLX3af+Dk7/E6J\n"
-"2HzFZ++r0rk0X2s682Q2zsKwzxNoysjL67XiPS4h3+os1OD5cJZM/2pYmLcX5BtS5X4HAB1f\n"
-"2uY+lQS3aYg5oUFgJWFLlTloYhyxCwWJwDaCFCE/rtuh/bxvHGCGtlOUSbkrRsVPACu/obvL\n"
-"P+DHVxxX6NZp+MEkUp2IVd3Chy50I9AU/SpHWrumnf2U5NGKpV+GY3aFy6//SSj8gO1MedK7\n"
-"5MDvAe5QQQg1I3ArqRa0jG6F6bYRzzHdUyYb3y1aSgJA/MTAtukxGggo5WDDH8SQjhBiYEQN\n"
-"7Aq+VRhxLKX0srwVYv8c474d2h5Xszx+zYIdkeNL6yxSNLCK/RJOlrDrcH+eOfdmQrGrrFLa\n"
-"dkBXeyq96G4DsguAhYidDMfCd7Camlf0uPoTXGiTOmekl9AbmbeGMktg2M7v0Ax/lZ9vh0+H\n"
-"io5fCHyqW/xavqGRn1V9TrALacywlKinh/LTSlDcX3KwFnUey7QYYpqwpzmqm59m2I2mbJYV\n"
-"4+by+PGDYmy7Velhk6M99bFXi08jsJvllGov34zflVEpYKELKeRcVVi3qPyZ7iVNTA6z00yP\n"
-"hOgpD/0QVAKFyPnlw4vP5w8CAwEAAaOBhjCBgzAOBgNVHQ8BAf8EBAMCAYYwHQYDVR0hBBYw\n"
-"FDASBgdghXQBUwIBBgdghXQBUwIBMBIGA1UdEwEB/wQIMAYBAf8CAQcwHQYDVR0OBBYEFE0m\n"
-"ICKJS9PVpAqhb97iEoHF8TwuMB8GA1UdIwQYMBaAFE0mICKJS9PVpAqhb97iEoHF8TwuMA0G\n"
-"CSqGSIb3DQEBCwUAA4ICAQAyCrKkG8t9voJXiblqf/P0wS4RfbgZPnm3qKhyN2abGu2sEzsO\n"
-"v2LwnN+ee6FTSA5BesogpxcbtnjsQJHzQq0Qw1zv/2BZf82Fo4s9SBwlAjxnffUy6S8w5X2l\n"
-"ejjQ82YqZh6NM4OKb3xuqFp1mrjX2lhIREeoTPpMSQpKwhI3qEAMw8jh0FcNlzKVxzqfl9NX\n"
-"+Ave5XLzo9v/tdhZsnPdTSpxsrpJ9csc1fV5yJmz/MFMdOO0vSk3FQQoHt5FRnDsr7p4Dooq\n"
-"zgB53MBfGWcsa0vvaGgLQ+OswWIJ76bdZWGgr4RVSJFSHMYlkSrQwSIjYVmvRRGFHQEkNI/P\n"
-"s/8XciATwoCqISxxOQ7Qj1zB09GOInJGTB2Wrk9xseEFKZZZ9LuedT3PDTcNYtsmjGOpI99n\n"
-"Bjx8Oto0QuFmtEYE3saWmA9LSHokMnWRn6z3aOkquVVlzl1h0ydw2Df+n7mvoC5Wt6NlUe07\n"
-"qxS/TFED6F+KBZvuim6c779o+sjaC+NCydAXFJy3SuCvkychVSa1ZC+N8f+mQAWFBVzKBxlc\n"
-"CxMoTFh/wqXvRdpg065lYZ1Tg3TCrvJcwhbtkj6EPnNgiLx29CzP0H1907he0ZESEOnN3col\n"
-"49XtmS++dYFLJPlFRpTJKSFTnCZFqhMX5OfNeOI5wSsSnqaeG8XmDtkx2Q==\n"
-"-----END CERTIFICATE-----\n",
-
-/* Swisscom Root EV CA 2 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIF4DCCA8igAwIBAgIRAPL6ZOJ0Y9ON/RAdBB92ylgwDQYJKoZIhvcNAQELBQAwZzELMAkG\n"
-"A1UEBhMCY2gxETAPBgNVBAoTCFN3aXNzY29tMSUwIwYDVQQLExxEaWdpdGFsIENlcnRpZmlj\n"
-"YXRlIFNlcnZpY2VzMR4wHAYDVQQDExVTd2lzc2NvbSBSb290IEVWIENBIDIwHhcNMTEwNjI0\n"
-"MDk0NTA4WhcNMzEwNjI1MDg0NTA4WjBnMQswCQYDVQQGEwJjaDERMA8GA1UEChMIU3dpc3Nj\n"
-"b20xJTAjBgNVBAsTHERpZ2l0YWwgQ2VydGlmaWNhdGUgU2VydmljZXMxHjAcBgNVBAMTFVN3\n"
-"aXNzY29tIFJvb3QgRVYgQ0EgMjCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAMT3\n"
-"HS9X6lds93BdY7BxUglgRCgzo3pOCvrY6myLURYaVa5UJsTMRQdBTxB5f3HSek4/OE6zAMaV\n"
-"ylvNwSqD1ycfMQ4jFrclyxy0uYAyXhqdk/HoPGAsp15XGVhRXrwsVgu42O+LgrQ8uMIkqBPH\n"
-"oCE2G3pXKSinLr9xJZDzRINpUKTk4RtiGZQJo/PDvO/0vezbE53PnUgJUmfANykRHvvSEaeF\n"
-"GHR55E+FFOtSN+KxRdjMDUN/rhPSays/p8LiqG12W0OfvrSdsyaGOx9/5fLoZigWJdBLlzin\n"
-"5M8J0TbDC77aO0RYjb7xnglrPvMyxyuHxuxenPaHZa0zKcQvidm5y8kDnftslFGXEBuGCxob\n"
-"P/YCfnvUxVFkKJ3106yDgYjTdLRZncHrYTNaRdHLOdAGalNgHa/2+2m8atwBz735j9m9W8E6\n"
-"X47aD0upm50qKGsaCnw8qyIL5XctcfaCNYGu+HuB5ur+rPQam3Rc6I8k9l2dRsQs0h4rIWqD\n"
-"J2dVSqTjyDKXZpBy2uPUZC5f46Fq9mDU5zXNysRojddxyNMkM3OxbPlq4SjbX8Y96L5V5jcb\n"
-"7STZDxmPX2MYWFCBUWVv8p9+agTnNCRxunZLWB4ZvRVgRaoMEkABnRDixzgHcgplwLa7JSna\n"
-"Fp6LNYth7eVxV4O1PHGf40+/fh6Bn0GXAgMBAAGjgYYwgYMwDgYDVR0PAQH/BAQDAgGGMB0G\n"
-"A1UdIQQWMBQwEgYHYIV0AVMCAgYHYIV0AVMCAjASBgNVHRMBAf8ECDAGAQH/AgEDMB0GA1Ud\n"
-"DgQWBBRF2aWBbj2ITY1x0kbBbkUe88SAnTAfBgNVHSMEGDAWgBRF2aWBbj2ITY1x0kbBbkUe\n"
-"88SAnTANBgkqhkiG9w0BAQsFAAOCAgEAlDpzBp9SSzBc1P6xXCX5145v9Ydkn+0UjrgEjihL\n"
-"j6p7jjm02Vj2e6E1CqGdivdj5eu9OYLU43otb98TPLr+flaYC/NUn81ETm484T4VvwYmneTw\n"
-"kLbUwp4wLh/vx3rEUMfqe9pQy3omywC0Wqu1kx+AiYQElY2NfwmTv9SoqORjbdlk5LgpWgi/\n"
-"UOGED1V7XwgiG/W9mR4U9s70WBCCswo9GcG/W6uqmdjyMb3lOGbcWAXH7WMaLgqXfIeTK7KK\n"
-"4/HsGOV1timH59yLGn602MnTihdsfSlEvoqq9X46Lmgxk7lq2prg2+kupYTNHAq4Sgj5nPFh\n"
-"JpiTt3tm7JFe3VE/23MPrQRYCd0EApUKPtN236YQHoA96M2kZNEzx5LH4k5E4wnJTsJdhw4S\n"
-"nr8PyQUQ3nqjsTzyP6WqJ3mtMX0f/fwZacXduT98zca0wjAefm6S139hdlqP65VNvBFuIXxZ\n"
-"N5nQBrz5Bm0yFqXZaajh3DyAHmBR3NdUIR7KYndP+tiPsys6DXhyyWhBWkdKwqPrGtcKqzwy\n"
-"VcgKEZzfdNbwQBUdyLmPtTbFr/giuMod89a2GQ+fYWVq6nTIfI/DT11lgh/ZDYnadXL77/FH\n"
-"ZxOzyNEZiCcmmpl5fx7kLD977vHeTYuWl8PVP3wbI+2ksx0WckNLIOFZfsLorSa/ovc=\n"
-"-----END CERTIFICATE-----\n",
-
-/* CA Disig Root R1 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIFaTCCA1GgAwIBAgIJAMMDmu5QkG4oMA0GCSqGSIb3DQEBBQUAMFIxCzAJBgNVBAYTAlNL\n"
-"MRMwEQYDVQQHEwpCcmF0aXNsYXZhMRMwEQYDVQQKEwpEaXNpZyBhLnMuMRkwFwYDVQQDExBD\n"
-"QSBEaXNpZyBSb290IFIxMB4XDTEyMDcxOTA5MDY1NloXDTQyMDcxOTA5MDY1NlowUjELMAkG\n"
-"A1UEBhMCU0sxEzARBgNVBAcTCkJyYXRpc2xhdmExEzARBgNVBAoTCkRpc2lnIGEucy4xGTAX\n"
-"BgNVBAMTEENBIERpc2lnIFJvb3QgUjEwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoIC\n"
-"AQCqw3j33Jijp1pedxiy3QRkD2P9m5YJgNXoqqXinCaUOuiZc4yd39ffg/N4T0Dhf9Kn0uXK\n"
-"E5Pn7cZ3Xza1lK/oOI7bm+V8u8yN63Vz4STN5qctGS7Y1oprFOsIYgrY3LMATcMjfF9DCCMy\n"
-"EtztDK3AfQ+lekLZWnDZv6fXARz2m6uOt0qGeKAeVjGu74IKgEH3G8muqzIm1Cxr7X1r5OJe\n"
-"IgpFy4QxTaz+29FHuvlglzmxZcfe+5nkCiKxLU3lSCZpq+Kq8/v8kiky6bM+TR8noc2OuRf7\n"
-"JT7JbvN32g0S9l3HuzYQ1VTW8+DiR0jm3hTaYVKvJrT1cU/J19IG32PK/yHoWQbgCNWEFVP3\n"
-"Q+V8xaCJmGtzxmjOZd69fwX3se72V6FglcXM6pM6vpmumwKjrckWtc7dXpl4fho5frLABaTA\n"
-"gqWjR56M6ly2vGfb5ipN0gTco65F97yLnByn1tUD3AjLLhbKXEAz6GfDLuemROoRRRw1ZS0e\n"
-"RWEkG4IupZ0zXWX4Qfkuy5Q/H6MMMSRE7cderVC6xkGbrPAXZcD4XW9boAo0PO7X6oifmPmv\n"
-"TiT6l7Jkdtqr9O3jw2Dv1fkCyC2fg69naQanMVXVz0tv/wQFx1isXxYb5dKj6zHbHzMVTdDy\n"
-"pVP1y+E9Tmgt2BLdqvLmTZtJ5cUoobqwWsagtQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/\n"
-"MA4GA1UdDwEB/wQEAwIBBjAdBgNVHQ4EFgQUiQq0OJMa5qvum5EY+fU8PjXQ04IwDQYJKoZI\n"
-"hvcNAQEFBQADggIBADKL9p1Kyb4U5YysOMo6CdQbzoaz3evUuii+Eq5FLAR0rBNRxVgYZk2C\n"
-"2tXck8An4b58n1KeElb21Zyp9HWc+jcSjxyT7Ff+Bw+r1RL3D65hXlaASfX8MPWbTx9BLxyE\n"
-"04nH4toCdu0Jz2zBuByDHBb6lM19oMgY0sidbvW9adRtPTXoHqJPYNcHKfyyo6SdbhWSVhlM\n"
-"CrDpfNIZTUJG7L399ldb3Zh+pE3McgODWF3vkzpBemOqfDqo9ayk0d2iLbYq/J8BjuIQscTK\n"
-"5GfbVSUZP/3oNn6z4eGBrxEWi1CXYBmCAMBrTXO40RMHPuq2MU/wQppt4hF05ZSsjYSVPCGv\n"
-"xdpHyN85YmLLW1AL14FABZyb7bq2ix4Eb5YgOe2kfSnbSM6C3NQCjR0EMVrHS/BsYVLXtFHC\n"
-"gWzN4funodKSds+xDzdYpPJScWc/DIh4gInByLUfkmO+p3qKViwaqKactV2zY9ATIKHrkWzQ\n"
-"jX2v3wvkF7mGnjixlAxYjOBVqjtjbZqJYLhkKpLGN/R+Q0O3c+gB53+XD9fyexn9GtePyfqF\n"
-"a3qdnom2piiZk4hA9z7NUaPK6u95RyG1/jLix8NRb76AdPCkwzryT+lf3xkK8jsTQ6wxpLPn\n"
-"6/wY1gGp8yqPNg7rtLG8t0zJa7+h89n07eLw4+1knj0vllJPgFOL\n"
-"-----END CERTIFICATE-----\n",
-
-/* CA Disig Root R2 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIFaTCCA1GgAwIBAgIJAJK4iNuwisFjMA0GCSqGSIb3DQEBCwUAMFIxCzAJBgNVBAYTAlNL\n"
-"MRMwEQYDVQQHEwpCcmF0aXNsYXZhMRMwEQYDVQQKEwpEaXNpZyBhLnMuMRkwFwYDVQQDExBD\n"
-"QSBEaXNpZyBSb290IFIyMB4XDTEyMDcxOTA5MTUzMFoXDTQyMDcxOTA5MTUzMFowUjELMAkG\n"
-"A1UEBhMCU0sxEzARBgNVBAcTCkJyYXRpc2xhdmExEzARBgNVBAoTCkRpc2lnIGEucy4xGTAX\n"
-"BgNVBAMTEENBIERpc2lnIFJvb3QgUjIwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoIC\n"
-"AQCio8QACdaFXS1tFPbCw3OeNcJxVX6B+6tGUODBfEl45qt5WDza/3wcn9iXAng+a0EE6UG9\n"
-"vgMsRfYvZNSrXaNHPWSb6WiaxswbP7q+sos0Ai6YVRn8jG+qX9pMzk0DIaPY0jSTVpbLTAwA\n"
-"FjxfGs3Ix2ymrdMxp7zo5eFm1tL7A7RBZckQrg4FY8aAamkw/dLukO8NJ9+flXP04SXabBbe\n"
-"QTg06ov80egEFGEtQX6sx3dOy1FU+16SGBsEWmjGycT6txOgmLcRK7fWV8x8nhfRyyX+hk4k\n"
-"LlYMeE2eARKmK6cBZW58Yh2EhN/qwGu1pSqVg8NTEQxzHQuyRpDRQjrOQG6Vrf/GlK1ul4SO\n"
-"fW+eioANSW1z4nuSHsPzwfPrLgVv2RvPN3YEyLRa5Beny912H9AZdugsBbPWnDTYltxhh5EF\n"
-"5EQIM8HauQhl1K6yNg3ruji6DOWbnuuNZt2Zz9aJQfYEkoopKW1rOhzndX0CcQ7zwOe9yxnd\n"
-"nWCywmZgtrEE7snmhrmaZkCo5xHtgUUDi/ZnWejBBhG93c+AAk9lQHhcR1DIm+YfgXvkRKhb\n"
-"hZri3lrVx/k6RGZL5DJUfORsnLMOPReisjQS1n6yqEm70XooQL6iFh/f5DcfEXP7kAplQ6IN\n"
-"fPgGAVUzfbANuPT1rqVCV3w2EYx7XsQDnYx5nQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/\n"
-"MA4GA1UdDwEB/wQEAwIBBjAdBgNVHQ4EFgQUtZn4r7CU9eMg1gqtzk5WpC5uQu0wDQYJKoZI\n"
-"hvcNAQELBQADggIBACYGXnDnZTPIgm7ZnBc6G3pmsgH2eDtpXi/q/075KMOYKmFMtCQSin1t\n"
-"ERT3nLXK5ryeJ45MGcipvXrA1zYObYVybqjGom32+nNjf7xueQgcnYqfGopTpti72TVVsRHF\n"
-"qQOzVju5hJMiXn7B9hJSi+osZ7z+Nkz1uM/Rs0mSO9MpDpkblvdhuDvEK7Z4bLQjb/D907Je\n"
-"dR+Zlais9trhxTF7+9FGs9K8Z7RiVLoJ92Owk6Ka+elSLotgEqv89WBW7xBci8QaQtyDW2QO\n"
-"y7W81k/BfDxujRNt+3vrMNDcTa/F1balTFtxyegxvug4BkihGuLq0t4SOVga/4AOgnXmt8kH\n"
-"bA7v/zjxmHHEt38OFdAlab0inSvtBfZGR6ztwPDUO+Ls7pZbkBNOHlY667DvlruWIxG68kOG\n"
-"dGSVyCh13x01utI3gzhTODY7z2zp+WsO0PsE6E9312UBeIYMej4hYvF/Y3EMyZ9E26gnonW+\n"
-"boE+18DrG5gPcFw0sorMwIUY6256s/daoQe/qUKS82Ail+QUoQebTnbAjn39pCXHR+3/H3Os\n"
-"zMOl6W8KjptlwlCFtaOgUxLMVYdh84GuEEZhvUQhuMI9dM9+JDX6HAcOmz0iyu8xL4ysEr3v\n"
-"QCj8KWefshNPZiTEUxnpHikV7+ZtsH8tZ/3zbBt1RqPlShfppNcL\n"
-"-----END CERTIFICATE-----\n",
-
-/* ACCVRAIZ1 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIH0zCCBbugAwIBAgIIXsO3pkN/pOAwDQYJKoZIhvcNAQEFBQAwQjESMBAGA1UEAwwJQUND\n"
-"VlJBSVoxMRAwDgYDVQQLDAdQS0lBQ0NWMQ0wCwYDVQQKDARBQ0NWMQswCQYDVQQGEwJFUzAe\n"
-"Fw0xMTA1MDUwOTM3MzdaFw0zMDEyMzEwOTM3MzdaMEIxEjAQBgNVBAMMCUFDQ1ZSQUlaMTEQ\n"
-"MA4GA1UECwwHUEtJQUNDVjENMAsGA1UECgwEQUNDVjELMAkGA1UEBhMCRVMwggIiMA0GCSqG\n"
-"SIb3DQEBAQUAA4ICDwAwggIKAoICAQCbqau/YUqXry+XZpp0X9DZlv3P4uRm7x8fRzPCRKPf\n"
-"mt4ftVTdFXxpNRFvu8gMjmoYHtiP2Ra8EEg2XPBjs5BaXCQ316PWywlxufEBcoSwfdtNgM38\n"
-"02/J+Nq2DoLSRYWoG2ioPej0RGy9ocLLA76MPhMAhN9KSMDjIgro6TenGEyxCQ0jVn8ETdkX\n"
-"hBilyNpAlHPrzg5XPAOBOp0KoVdDaaxXbXmQeOW1tDvYvEyNKKGno6e6Ak4l0Squ7a4DIrhr\n"
-"IA8wKFSVf+DuzgpmndFALW4ir50awQUZ0m/A8p/4e7MCQvtQqR0tkw8jq8bBD5L/0KIV9VMJ\n"
-"cRz/RROE5iZe+OCIHAr8Fraocwa48GOEAqDGWuzndN9wrqODJerWx5eHk6fGioozl2A3ED6X\n"
-"Pm4pFdahD9GILBKfb6qkxkLrQaLjlUPTAYVtjrs78yM2x/474KElB0iryYl0/wiPgL/AlmXz\n"
-"7uxLaL2diMMxs0Dx6M/2OLuc5NF/1OVYm3z61PMOm3WR5LpSLhl+0fXNWhn8ugb2+1KoS5kE\n"
-"3fj5tItQo05iifCHJPqDQsGH+tUtKSpacXpkatcnYGMN285J9Y0fkIkyF/hzQ7jSWpOGYdbh\n"
-"dQrqeWZ2iE9x6wQl1gpaepPluUsXQA+xtrn13k/c4LOsOxFwYIRKQ26ZIMApcQrAZQIDAQAB\n"
-"o4ICyzCCAscwfQYIKwYBBQUHAQEEcTBvMEwGCCsGAQUFBzAChkBodHRwOi8vd3d3LmFjY3Yu\n"
-"ZXMvZmlsZWFkbWluL0FyY2hpdm9zL2NlcnRpZmljYWRvcy9yYWl6YWNjdjEuY3J0MB8GCCsG\n"
-"AQUFBzABhhNodHRwOi8vb2NzcC5hY2N2LmVzMB0GA1UdDgQWBBTSh7Tj3zcnk1X2VuqB5TbM\n"
-"jB4/vTAPBgNVHRMBAf8EBTADAQH/MB8GA1UdIwQYMBaAFNKHtOPfNyeTVfZW6oHlNsyMHj+9\n"
-"MIIBcwYDVR0gBIIBajCCAWYwggFiBgRVHSAAMIIBWDCCASIGCCsGAQUFBwICMIIBFB6CARAA\n"
-"QQB1AHQAbwByAGkAZABhAGQAIABkAGUAIABDAGUAcgB0AGkAZgBpAGMAYQBjAGkA8wBuACAA\n"
-"UgBhAO0AegAgAGQAZQAgAGwAYQAgAEEAQwBDAFYAIAAoAEEAZwBlAG4AYwBpAGEAIABkAGUA\n"
-"IABUAGUAYwBuAG8AbABvAGcA7QBhACAAeQAgAEMAZQByAHQAaQBmAGkAYwBhAGMAaQDzAG4A\n"
-"IABFAGwAZQBjAHQAcgDzAG4AaQBjAGEALAAgAEMASQBGACAAUQA0ADYAMAAxADEANQA2AEUA\n"
-"KQAuACAAQwBQAFMAIABlAG4AIABoAHQAdABwADoALwAvAHcAdwB3AC4AYQBjAGMAdgAuAGUA\n"
-"czAwBggrBgEFBQcCARYkaHR0cDovL3d3dy5hY2N2LmVzL2xlZ2lzbGFjaW9uX2MuaHRtMFUG\n"
-"A1UdHwROMEwwSqBIoEaGRGh0dHA6Ly93d3cuYWNjdi5lcy9maWxlYWRtaW4vQXJjaGl2b3Mv\n"
-"Y2VydGlmaWNhZG9zL3JhaXphY2N2MV9kZXIuY3JsMA4GA1UdDwEB/wQEAwIBBjAXBgNVHREE\n"
-"EDAOgQxhY2N2QGFjY3YuZXMwDQYJKoZIhvcNAQEFBQADggIBAJcxAp/n/UNnSEQU5CmH7Uwo\n"
-"ZtCPNdpNYbdKl02125DgBS4OxnnQ8pdpD70ER9m+27Up2pvZrqmZ1dM8MJP1jaGo/AaNRPTK\n"
-"FpV8M9xii6g3+CfYCS0b78gUJyCpZET/LtZ1qmxNYEAZSUNUY9rizLpm5U9EelvZaoErQNV/\n"
-"+QEnWCzI7UiRfD+mAM/EKXMRNt6GGT6d7hmKG9Ww7Y49nCrADdg9ZuM8Db3VlFzi4qc1GwQA\n"
-"9j9ajepDvV+JHanBsMyZ4k0ACtrJJ1vnE5Bc5PUzolVt3OAJTS+xJlsndQAJxGJ3KQhfnlms\n"
-"tn6tn1QwIgPBHnFk/vk4CpYY3QIUrCPLBhwepH2NDd4nQeit2hW3sCPdK6jT2iWH7ehVRE2I\n"
-"9DZ+hJp4rPcOVkkO1jMl1oRQQmwgEh0q1b688nCBpHBgvgW1m54ERL5hI6zppSSMEYCUWqKi\n"
-"uUnSwdzRp+0xESyeGabu4VXhwOrPDYTkF7eifKXeVSUG7szAh1xA2syVP1XgNce4hL60Xc16\n"
-"gwFy7ofmXx2utYXGJt/mwZrpHgJHnyqobalbz+xFd3+YJ5oyXSrjhO7FmGYvliAd3djDJ9ew\n"
-"+f7Zfc3Qn48LFFhRny+Lwzgt3uiP1o2HpPVWQxaZLPSkVrQ0uGE3ycJYgBugl6H8WY3pEfbR\n"
-"D0tVNEYqi4Y7\n"
-"-----END CERTIFICATE-----\n",
-
-/* TWCA Global Root CA */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIFQTCCAymgAwIBAgICDL4wDQYJKoZIhvcNAQELBQAwUTELMAkGA1UEBhMCVFcxEjAQBgNV\n"
-"BAoTCVRBSVdBTi1DQTEQMA4GA1UECxMHUm9vdCBDQTEcMBoGA1UEAxMTVFdDQSBHbG9iYWwg\n"
-"Um9vdCBDQTAeFw0xMjA2MjcwNjI4MzNaFw0zMDEyMzExNTU5NTlaMFExCzAJBgNVBAYTAlRX\n"
-"MRIwEAYDVQQKEwlUQUlXQU4tQ0ExEDAOBgNVBAsTB1Jvb3QgQ0ExHDAaBgNVBAMTE1RXQ0Eg\n"
-"R2xvYmFsIFJvb3QgQ0EwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCwBdvI64zE\n"
-"booh745NnHEKH1Jw7W2CnJfF10xORUnLQEK1EjRsGcJ0pDFfhQKX7EMzClPSnIyOt7h52yvV\n"
-"avKOZsTuKwEHktSz0ALfUPZVr2YOy+BHYC8rMjk1Ujoog/h7FsYYuGLWRyWRzvAZEk2tY/XT\n"
-"P3VfKfChMBwqoJimFb3u/Rk28OKRQ4/6ytYQJ0lM793B8YVwm8rqqFpD/G2Gb3PpN0Wp8DbH\n"
-"zIh1HrtsBv+baz4X7GGqcXzGHaL3SekVtTzWoWH1EfcFbx39Eb7QMAfCKbAJTibc46KokWof\n"
-"wpFFiFzlmLhxpRUZyXx1EcxwdE8tmx2RRP1WKKD+u4ZqyPpcC1jcxkt2yKsi2XMPpfRaAok/\n"
-"T54igu6idFMqPVMnaR1sjjIsZAAmY2E2TqNGtz99sy2sbZCilaLOz9qC5wc0GZbpuCGqKX6m\n"
-"OL6OKUohZnkfs8O1CWfe1tQHRvMq2uYiN2DLgbYPoA/pyJV/v1WRBXrPPRXAb94JlAGD1zQb\n"
-"zECl8LibZ9WYkTunhHiVJqRaCPgrdLQABDzfuBSO6N+pjWxnkjMdwLfS7JLIvgm/LCkFbwJr\n"
-"nu+8vyq8W8BQj0FwcYeyTbcEqYSjMq+u7msXi7Kx/mzhkIyIqJdIzshNy/MGz19qCkKxHh53\n"
-"L46g5pIOBvwFItIm4TFRfTLcDwIDAQABoyMwITAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/\n"
-"BAUwAwEB/zANBgkqhkiG9w0BAQsFAAOCAgEAXzSBdu+WHdXltdkCY4QWwa6gcFGn90xHNcgL\n"
-"1yg9iXHZqjNB6hQbbCEAwGxCGX6faVsgQt+i0trEfJdLjbDorMjupWkEmQqSpqsnLhpNgb+E\n"
-"1HAerUf+/UqdM+DyucRFCCEK2mlpc3INvjT+lIutwx4116KD7+U4x6WFH6vPNOw/KP4M8VeG\n"
-"TslV9xzU2KV9Bnpv1d8Q34FOIWWxtuEXeZVFBs5fzNxGiWNoRI2T9GRwoD2dKAXDOXC4Ynsg\n"
-"/eTb6QihuJ49CcdP+yz4k3ZB3lLg4VfSnQO8d57+nile98FRYB/e2guyLXW3Q0iT5/Z5xoRd\n"
-"gFlglPx4mI88k1HtQJAH32RjJMtOcQWh15QaiDLxInQirqWm2BJpTGCjAu4r7NRjkgtevi92\n"
-"a6O2JryPA9gK8kxkRr05YuWW6zRjESjMlfGt7+/cgFhI6Uu46mWs6fyAtbXIRfmswZ/Zuepi\n"
-"iI7E8UuDEq3mi4TWnsLrgxifarsbJGAzcMzs9zLzXNl5fe+epP7JI8Mk7hWSsT2RTyaGvWZz\n"
-"JBPqpK5jwa19hAM8EHiGG3njxPPyBJUgriOCxLM6AGK/5jYk4Ve6xx6QddVfP5VhK8E7zeWz\n"
-"aGHQRiapIVJpLesux+t3zqY6tQMzT3bR51xUAV3LePTJDL/PEo4XLSNolOer/qmyKwbQBM0=\n"
-"-----END CERTIFICATE-----\n",
-
-/* TeliaSonera Root CA v1 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIFODCCAyCgAwIBAgIRAJW+FqD3LkbxezmCcvqLzZYwDQYJKoZIhvcNAQEFBQAwNzEUMBIG\n"
-"A1UECgwLVGVsaWFTb25lcmExHzAdBgNVBAMMFlRlbGlhU29uZXJhIFJvb3QgQ0EgdjEwHhcN\n"
-"MDcxMDE4MTIwMDUwWhcNMzIxMDE4MTIwMDUwWjA3MRQwEgYDVQQKDAtUZWxpYVNvbmVyYTEf\n"
-"MB0GA1UEAwwWVGVsaWFTb25lcmEgUm9vdCBDQSB2MTCCAiIwDQYJKoZIhvcNAQEBBQADggIP\n"
-"ADCCAgoCggIBAMK+6yfwIaPzaSZVfp3FVRaRXP3vIb9TgHot0pGMYzHw7CTww6XScnwQbfQ3\n"
-"t+XmfHnqjLWCi65ItqwA3GV17CpNX8GH9SBlK4GoRz6JI5UwFpB/6FcHSOcZrr9FZ7E3GwYq\n"
-"/t75rH2D+1665I+XZ75Ljo1kB1c4VWk0Nj0TSO9P4tNmHqTPGrdeNjPUtAa9GAH9d4RQAEX1\n"
-"jF3oI7x+/jXh7VB7qTCNGdMJjmhnXb88lxhTuylixcpecsHHltTbLaC0H2kD7OriUPEMPPCs\n"
-"81Mt8Bz17Ww5OXOAFshSsCPN4D7c3TxHoLs1iuKYaIu+5b9y7tL6pe0S7fyYGKkmdtwoSxAg\n"
-"HNN/Fnct7W+A90m7UwW7XWjH1Mh1Fj+JWov3F0fUTPHSiXk+TT2YqGHeOh7S+F4D4MHJHIzT\n"
-"jU3TlTazN19jY5szFPAtJmtTfImMMsJu7D0hADnJoWjiUIMusDor8zagrC/kb2HCUQk5PotT\n"
-"ubtn2txTuXZZNp1D5SDgPTJghSJRt8czu90VL6R4pgd7gUY2BIbdeTXHlSw7sKMXNeVzH7Rc\n"
-"We/a6hBle3rQf5+ztCo3O3CLm1u5K7fsslESl1MpWtTwEhDcTwK7EpIvYtQ/aUN8Ddb8WHUB\n"
-"iJ1YFkveupD/RwGJBmr2X7KQarMCpgKIv7NHfirZ1fpoeDVNAgMBAAGjPzA9MA8GA1UdEwEB\n"
-"/wQFMAMBAf8wCwYDVR0PBAQDAgEGMB0GA1UdDgQWBBTwj1k4ALP1j5qWDNXr+nuqF+gTEjAN\n"
-"BgkqhkiG9w0BAQUFAAOCAgEAvuRcYk4k9AwI//DTDGjkk0kiP0Qnb7tt3oNmzqjMDfz1mgbl\n"
-"dxSR651Be5kqhOX//CHBXfDkH1e3damhXwIm/9fH907eT/j3HEbAek9ALCI18Bmx0GtnLLCo\n"
-"4MBANzX2hFxc469CeP6nyQ1Q6g2EdvZR74NTxnr/DlZJLo961gzmJ1TjTQpgcmLNkQfWpb/I\n"
-"mWvtxBnmq0wROMVvMeJuScg/doAmAyYp4Db29iBT4xdwNBedY2gea+zDTYa4EzAvXUYNR0PV\n"
-"G6pZDrlcjQZIrXSHX8f8MVRBE+LHIQ6e4B4N4cB7Q4WQxYpYxmUKeFfyxiMPAdkgS94P+5KF\n"
-"dSpcc41teyWRyu5FrgZLAMzTsVlQ2jqIOylDRl6XK1TOU2+NSueW+r9xDkKLfP0ooNBIytrE\n"
-"gUy7onOTJsjrDNYmiLbAJM+7vVvrdX3pCI6GMyx5dwlppYn8s3CQh3aP0yK7Qs69cwsgJirQ\n"
-"mz1wHiRszYd2qReWt88NkvuOGKmYSdGe/mBEciG5Ge3C9THxOUiIkCR1VBatzvT4aRRkOfuj\n"
-"uLpwQMcnHL/EVlP6Y2XQ8xwOFvVrhlhNGNTkDY6lnVuR3HYkUD/GKvvZt5y11ubQ2egZixVx\n"
-"SK236thZiNSQvxaz2emsWWFUyBy6ysHK4bkgTI86k4mloMy/0/Z1pHWWbVY=\n"
-"-----END CERTIFICATE-----\n",
-
-/* E-Tugra Certification Authority */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIGSzCCBDOgAwIBAgIIamg+nFGby1MwDQYJKoZIhvcNAQELBQAwgbIxCzAJBgNVBAYTAlRS\n"
-"MQ8wDQYDVQQHDAZBbmthcmExQDA+BgNVBAoMN0UtVHXEn3JhIEVCRyBCaWxpxZ9pbSBUZWtu\n"
-"b2xvamlsZXJpIHZlIEhpem1ldGxlcmkgQS7Fni4xJjAkBgNVBAsMHUUtVHVncmEgU2VydGlm\n"
-"aWthc3lvbiBNZXJrZXppMSgwJgYDVQQDDB9FLVR1Z3JhIENlcnRpZmljYXRpb24gQXV0aG9y\n"
-"aXR5MB4XDTEzMDMwNTEyMDk0OFoXDTIzMDMwMzEyMDk0OFowgbIxCzAJBgNVBAYTAlRSMQ8w\n"
-"DQYDVQQHDAZBbmthcmExQDA+BgNVBAoMN0UtVHXEn3JhIEVCRyBCaWxpxZ9pbSBUZWtub2xv\n"
-"amlsZXJpIHZlIEhpem1ldGxlcmkgQS7Fni4xJjAkBgNVBAsMHUUtVHVncmEgU2VydGlmaWth\n"
-"c3lvbiBNZXJrZXppMSgwJgYDVQQDDB9FLVR1Z3JhIENlcnRpZmljYXRpb24gQXV0aG9yaXR5\n"
-"MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA4vU/kwVRHoViVF56C/UYB4Oufq98\n"
-"99SKa6VjQzm5S/fDxmSJPZQuVIBSOTkHS0vdhQd2h8y/L5VMzH2nPbxHD5hw+IyFHnSOkm0b\n"
-"QNGZDbt1bsipa5rAhDGvykPL6ys06I+XawGb1Q5KCKpbknSFQ9OArqGIW66z6l7LFpp3RMih\n"
-"9lRozt6Plyu6W0ACDGQXwLWTzeHxE2bODHnv0ZEoq1+gElIwcxmOj+GMB6LDu0rw6h8VqO4l\n"
-"zKRG+Bsi77MOQ7osJLjFLFzUHPhdZL3Dk14opz8n8Y4e0ypQBaNV2cvnOVPAmJ6MVGKLJrD3\n"
-"fY185MaeZkJVgkfnsliNZvcHfC425lAcP9tDJMW/hkd5s3kc91r0E+xs+D/iWR+V7kI+ua2o\n"
-"MoVJl0b+SzGPWsutdEcf6ZG33ygEIqDUD13ieU/qbIWGvaimzuT6w+Gzrt48Ue7LE3wBf4QO\n"
-"XVGUnhMMti6lTPk5cDZvlsouDERVxcr6XQKj39ZkjFqzAQqptQpHF//vkUAqjqFGOjGY5RH8\n"
-"zLtJVor8udBhmm9lbObDyz51Sf6Pp+KJxWfXnUYTTjF2OySznhFlhqt/7x3U+LznrFpct1pH\n"
-"XFXOVbQicVtbC/DP3KBhZOqp12gKY6fgDT+gr9Oq0n7vUaDmUStVkhUXU8u3Zg5mTPj5dUyQ\n"
-"5xJwx0UCAwEAAaNjMGEwHQYDVR0OBBYEFC7j27JJ0JxUeVz6Jyr+zE7S6E5UMA8GA1UdEwEB\n"
-"/wQFMAMBAf8wHwYDVR0jBBgwFoAULuPbsknQnFR5XPonKv7MTtLoTlQwDgYDVR0PAQH/BAQD\n"
-"AgEGMA0GCSqGSIb3DQEBCwUAA4ICAQAFNzr0TbdF4kV1JI+2d1LoHNgQk2Xz8lkGpD4eKexd\n"
-"0dCrfOAKkEh47U6YA5n+KGCRHTAduGN8qOY1tfrTYXbm1gdLymmasoR6d5NFFxWfJNCYExL/\n"
-"u6Au/U5Mh/jOXKqYGwXgAEZKgoClM4so3O0409/lPun++1ndYYRP0lSWE2ETPo+Aab6TR7U1\n"
-"Q9Jauz1c77NCR807VRMGsAnb/WP2OogKmW9+4c4bU2pEZiNRCHu8W1Ki/QY3OEBhj0qWuJA3\n"
-"+GbHeJAAFS6LrVE1Uweoa2iu+U48BybNCAVwzDk/dr2l02cmAYamU9JgO3xDf1WKvJUawSg5\n"
-"TB9D0pH0clmKuVb8P7Sd2nCcdlqMQ1DujjByTd//SffGqWfZbawCEeI6FiWnWAjLb1NBnEg4\n"
-"R2gz0dfHj9R0IdTDBZB6/86WiLEVKV0jq9BgoRJP3vQXzTLlyb/IQ639Lo7xr+L0mPoSHyDY\n"
-"wKcMhcWQ9DstliaxLL5Mq+ux0orJ23gTDx4JnW2PAJ8C2sH6H3p6CcRK5ogql5+Ji/03X186\n"
-"zjhZhkuvcQu02PJwT58yE+Owp1fl2tpDy4Q08ijE6m30Ku/Ba3ba+367hTzSU8JNvnHhRdH9\n"
-"I2cNE3X7z2VnIp2usAnRCf8dNL/+I5c30jn6PQ0GC7TbO6Orb1wdtn7os4I07QZcJA==\n"
-"-----END CERTIFICATE-----\n",
-
-/* T-TeleSec GlobalRoot Class 2 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDwzCCAqugAwIBAgIBATANBgkqhkiG9w0BAQsFADCBgjELMAkGA1UEBhMCREUxKzApBgNV\n"
-"BAoMIlQtU3lzdGVtcyBFbnRlcnByaXNlIFNlcnZpY2VzIEdtYkgxHzAdBgNVBAsMFlQtU3lz\n"
-"dGVtcyBUcnVzdCBDZW50ZXIxJTAjBgNVBAMMHFQtVGVsZVNlYyBHbG9iYWxSb290IENsYXNz\n"
-"IDIwHhcNMDgxMDAxMTA0MDE0WhcNMzMxMDAxMjM1OTU5WjCBgjELMAkGA1UEBhMCREUxKzAp\n"
-"BgNVBAoMIlQtU3lzdGVtcyBFbnRlcnByaXNlIFNlcnZpY2VzIEdtYkgxHzAdBgNVBAsMFlQt\n"
-"U3lzdGVtcyBUcnVzdCBDZW50ZXIxJTAjBgNVBAMMHFQtVGVsZVNlYyBHbG9iYWxSb290IENs\n"
-"YXNzIDIwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCqX9obX+hzkeXaXPSi5kfl\n"
-"82hVYAUdAqSzm1nzHoqvNK38DcLZSBnuaY/JIPwhqgcZ7bBcrGXHX+0CfHt8LRvWurmAwhiC\n"
-"FoT6ZrAIxlQjgeTNuUk/9k9uN0goOA/FvudocP05l03Sx5iRUKrERLMjfTlH6VJi1hKTXrcx\n"
-"lkIF+3anHqP1wvzpesVsqXFP6st4vGCvx9702cu+fjOlbpSD8DT6IavqjnKgP6TeMFvvhk1q\n"
-"lVtDRKgQFRzlAVfFmPHmBiiRqiDFt1MmUUOyCxGVWOHAD3bZwI18gfNycJ5v/hqO2V81xrJv\n"
-"NHy+SE/iWjnX2J14np+GPgNeGYtEotXHAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wDgYD\n"
-"VR0PAQH/BAQDAgEGMB0GA1UdDgQWBBS/WSA2AHmgoCJrjNXyYdK4LMuCSjANBgkqhkiG9w0B\n"
-"AQsFAAOCAQEAMQOiYQsfdOhyNsZt+U2e+iKo4YFWz827n+qrkRk4r6p8FU3ztqONpfSO9kSp\n"
-"p+ghla0+AGIWiPACuvxhI+YzmzB6azZie60EI4RYZeLbK4rnJVM3YlNfvNoBYimipidx5joi\n"
-"fsFvHZVwIEoHNN/q/xWA5brXethbdXwFeilHfkCoMRN3zUA7tFFHei4R40cR3p1m0IvVVGb6\n"
-"g1XqfMIpiRvpb7PO4gWEyS8+eIVibslfwXhjdFjASBgMmTnrpMwatXlajRWc2BQN9noHV8ci\n"
-"gwUtPJslJj0Ys6lDfMjIq2SPDqO/nBudMNva0Bkuqjzx+zOAduTNrRlPBSeOE6Fuwg==\n"
-"-----END CERTIFICATE-----\n",
-
-/* Atos TrustedRoot 2011 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDdzCCAl+gAwIBAgIIXDPLYixfszIwDQYJKoZIhvcNAQELBQAwPDEeMBwGA1UEAwwVQXRv\n"
-"cyBUcnVzdGVkUm9vdCAyMDExMQ0wCwYDVQQKDARBdG9zMQswCQYDVQQGEwJERTAeFw0xMTA3\n"
-"MDcxNDU4MzBaFw0zMDEyMzEyMzU5NTlaMDwxHjAcBgNVBAMMFUF0b3MgVHJ1c3RlZFJvb3Qg\n"
-"MjAxMTENMAsGA1UECgwEQXRvczELMAkGA1UEBhMCREUwggEiMA0GCSqGSIb3DQEBAQUAA4IB\n"
-"DwAwggEKAoIBAQCVhTuXbyo7LjvPpvMpNb7PGKw+qtn4TaA+Gke5vJrf8v7MPkfoepbCJI41\n"
-"9KkM/IL9bcFyYie96mvr54rMVD6QUM+A1JX76LWC1BTFtqlVJVfbsVD2sGBkWXppzwO3bw2+\n"
-"yj5vdHLqqjAqc2K+SZFhyBH+DgMq92og3AIVDV4VavzjgsG1xZ1kCWyjWZgHJ8cblithdHFs\n"
-"Q/H3NYkQ4J7sVaE3IqKHBAUsR320HLliKWYoyrfhk/WklAOZuXCFteZI6o1Q/NnezG8HDt0L\n"
-"cp2AMBYHlT8oDv3FdU9T1nSatCQujgKRz3bFmx5VdJx4IbHwLfELn8LVlhgf8FQieowHAgMB\n"
-"AAGjfTB7MB0GA1UdDgQWBBSnpQaxLKYJYO7Rl+lwrrw7GWzbITAPBgNVHRMBAf8EBTADAQH/\n"
-"MB8GA1UdIwQYMBaAFKelBrEspglg7tGX6XCuvDsZbNshMBgGA1UdIAQRMA8wDQYLKwYBBAGw\n"
-"LQMEAQEwDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBCwUAA4IBAQAmdzTblEiGKkGdLD4G\n"
-"kGDEjKwLVLgfuXvTBznk+j57sj1O7Z8jvZfza1zv7v1Apt+hk6EKhqzvINB5Ab149xnYJDE0\n"
-"BAGmuhWawyfc2E8PzBhj/5kPDpFrdRbhIfzYJsdHt6bPWHJxfrrhTZVHO8mvbaG0weyJ9rQP\n"
-"OLXiZNwlz6bb65pcmaHFCN795trV1lpFDMS3wrUU77QR/w4VtfX128a961qn8FYiqTxlVMYV\n"
-"qL2Gns2Dlmh6cYGJ4Qvh6hEbaAjMaZ7snkGeRDImeuKHCnE96+RapNLbxc3G3mB/ufNPRJLv\n"
-"KrcYPqcZ2Qt9sTdBQrC6YB3y/gkRsPCHe6ed\n"
-"-----END CERTIFICATE-----\n",
-
-/* QuoVadis Root CA 1 G3 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIFYDCCA0igAwIBAgIUeFhfLq0sGUvjNwc1NBMotZbUZZMwDQYJKoZIhvcNAQELBQAwSDEL\n"
-"MAkGA1UEBhMCQk0xGTAXBgNVBAoTEFF1b1ZhZGlzIExpbWl0ZWQxHjAcBgNVBAMTFVF1b1Zh\n"
-"ZGlzIFJvb3QgQ0EgMSBHMzAeFw0xMjAxMTIxNzI3NDRaFw00MjAxMTIxNzI3NDRaMEgxCzAJ\n"
-"BgNVBAYTAkJNMRkwFwYDVQQKExBRdW9WYWRpcyBMaW1pdGVkMR4wHAYDVQQDExVRdW9WYWRp\n"
-"cyBSb290IENBIDEgRzMwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCgvlAQjuny\n"
-"bEC0BJyFuTHK3C3kEakEPBtVwedYMB0ktMPvhd6MLOHBPd+C5k+tR4ds7FtJwUrVu4/sh6x/\n"
-"gpqG7D0DmVIB0jWerNrwU8lmPNSsAgHaJNM7qAJGr6Qc4/hzWHa39g6QDbXwz8z6+cZM5cOG\n"
-"MAqNF34168Xfuw6cwI2H44g4hWf6Pser4BOcBRiYz5P1sZK0/CPTz9XEJ0ngnjybCKOLXSoh\n"
-"4Pw5qlPafX7PGglTvF0FBM+hSo+LdoINofjSxxR3W5A2B4GbPgb6Ul5jxaYA/qXpUhtStZI5\n"
-"cgMJYr2wYBZupt0lwgNm3fME0UDiTouG9G/lg6AnhF4EwfWQvTA9xO+oabw4m6SkltFi2mnA\n"
-"AZauy8RRNOoMqv8hjlmPSlzkYZqn0ukqeI1RPToV7qJZjqlc3sX5kCLliEVx3ZGZbHqfPT2Y\n"
-"fF72vhZooF6uCyP8Wg+qInYtyaEQHeTTRCOQiJ/GKubX9ZqzWB4vMIkIG1SitZgj7Ah3HJVd\n"
-"YdHLiZxfokqRmu8hqkkWCKi9YSgxyXSthfbZxbGL0eUQMk1fiyA6PEkfM4VZDdvLCXVDaXP7\n"
-"a3F98N/ETH3Goy7IlXnLc6KOTk0k+17kBL5yG6YnLUlamXrXXAkgt3+UuU/xDRxeiEIbEbfn\n"
-"kduebPRq34wGmAOtzCjvpUfzUwIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB\n"
-"/wQEAwIBBjAdBgNVHQ4EFgQUo5fW816iEOGrRZ88F2Q87gFwnMwwDQYJKoZIhvcNAQELBQAD\n"
-"ggIBABj6W3X8PnrHX3fHyt/PX8MSxEBd1DKquGrX1RUVRpgjpeaQWxiZTOOtQqOCMTaIzen7\n"
-"xASWSIsBx40Bz1szBpZGZnQdT+3Btrm0DWHMY37XLneMlhwqI2hrhVd2cDMT/uFPpiN3GPoa\n"
-"jOi9ZcnPP/TJF9zrx7zABC4tRi9pZsMbj/7sPtPKlL92CiUNqXsCHKnQO18LwIE6PWThv6ct\n"
-"Tr1NxNgpxiIY0MWscgKCP6o6ojoilzHdCGPDdRS5YCgtW2jgFqlmgiNR9etT2DGbe+m3nUvr\n"
-"iBbP+V04ikkwj+3x6xn0dxoxGE1nVGwvb2X52z3sIexe9PSLymBlVNFxZPT5pqOBMzYzcfCk\n"
-"eF9OrYMh3jRJjehZrJ3ydlo28hP0r+AJx2EqbPfgna67hkooby7utHnNkDPDs3b69fBsnQGQ\n"
-"+p6Q9pxyz0fawx/kNSBT8lTR32GDpgLiJTjehTItXnOQUl1CxM49S+H5GYQd1aJQzEH7QRTD\n"
-"vdbJWqNjZgKAvQU6O0ec7AAmTPWIUb+oI38YB7AL7YsmoWTTYUrrXJ/es69nA7Mf3W1daWhp\n"
-"q1467HxpvMc7hU6eFbm0FU/DlXpY18ls6Wy58yljXrQs8C097Vpl4KlbQMJImYFtnh8GKjwS\n"
-"tIsPm6Ik8KaN1nrgS7ZklmOVhMJKzRwuJIczYOXD\n"
-"-----END CERTIFICATE-----\n",
-
-/* QuoVadis Root CA 2 G3 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIFYDCCA0igAwIBAgIURFc0JFuBiZs18s64KztbpybwdSgwDQYJKoZIhvcNAQELBQAwSDEL\n"
-"MAkGA1UEBhMCQk0xGTAXBgNVBAoTEFF1b1ZhZGlzIExpbWl0ZWQxHjAcBgNVBAMTFVF1b1Zh\n"
-"ZGlzIFJvb3QgQ0EgMiBHMzAeFw0xMjAxMTIxODU5MzJaFw00MjAxMTIxODU5MzJaMEgxCzAJ\n"
-"BgNVBAYTAkJNMRkwFwYDVQQKExBRdW9WYWRpcyBMaW1pdGVkMR4wHAYDVQQDExVRdW9WYWRp\n"
-"cyBSb290IENBIDIgRzMwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQChriWyARjc\n"
-"V4g/Ruv5r+LrI3HimtFhZiFfqq8nUeVuGxbULX1QsFN3vXg6YOJkApt8hpvWGo6t/x8Vf9WV\n"
-"HhLL5hSEBMHfNrMWn4rjyduYNM7YMxcoRvynyfDStNVNCXJJ+fKH46nafaF9a7I6JaltUkSs\n"
-"+L5u+9ymc5GQYaYDFCDy54ejiK2toIz/pgslUiXnFgHVy7g1gQyjO/Dh4fxaXc6AcW34Sas+\n"
-"O7q414AB+6XrW7PFXmAqMaCvN+ggOp+oMiwMzAkd056OXbxMmO7FGmh77FOm6RQ1o9/NgJ8M\n"
-"SPsc9PG/Srj61YxxSscfrf5BmrODXfKEVu+lV0POKa2Mq1W/xPtbAd0jIaFYAI7D0GoT7RPj\n"
-"EiuA3GfmlbLNHiJuKvhB1PLKFAeNilUSxmn1uIZoL1NesNKqIcGY5jDjZ1XHm26sGahVpkUG\n"
-"0CM62+tlXSoREfA7T8pt9DTEceT/AFr2XK4jYIVz8eQQsSWu1ZK7E8EM4DnatDlXtas1qnIh\n"
-"O4M15zHfeiFuuDIIfR0ykRVKYnLP43ehvNURG3YBZwjgQQvD6xVu+KQZ2aKrr+InUlYrAoos\n"
-"FCT5v0ICvybIxo/gbjh9Uy3l7ZizlWNof/k19N+IxWA1ksB8aRxhlRbQ694Lrz4EEEVlWFA4\n"
-"r0jyWbYW8jwNkALGcC4BrTwV1wIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB\n"
-"/wQEAwIBBjAdBgNVHQ4EFgQU7edvdlq/YOxJW8ald7tyFnGbxD0wDQYJKoZIhvcNAQELBQAD\n"
-"ggIBAJHfgD9DCX5xwvfrs4iP4VGyvD11+ShdyLyZm3tdquXK4Qr36LLTn91nMX66AarHakE7\n"
-"kNQIXLJgapDwyM4DYvmL7ftuKtwGTTwpD4kWilhMSA/ohGHqPHKmd+RCroijQ1h5fq7KpVMN\n"
-"qT1wvSAZYaRsOPxDMuHBR//47PERIjKWnML2W2mWeyAMQ0GaW/ZZGYjeVYg3UQt4XAoeo0L9\n"
-"x52ID8DyeAIkVJOviYeIyUqAHerQbj5hLja7NQ4nlv1mNDthcnPxFlxHBlRJAHpYErAK74X9\n"
-"sbgzdWqTHBLmYF5vHX/JHyPLhGGfHoJE+V+tYlUkmlKY7VHnoX6XOuYvHxHaU4AshZ6rNRDb\n"
-"Il9qxV6XU/IyAgkwo1jwDQHVcsaxfGl7w/U2Rcxhbl5MlMVerugOXou/983g7aEOGzPuVBj+\n"
-"D77vfoRrQ+NwmNtddbINWQeFFSM51vHfqSYP1kjHs6Yi9TM3WpVHn3u6GBVv/9YUZINJ0gpn\n"
-"IdsPNWNgKCLjsZWDzYWm3S8P52dSbrsvhXz1SnPnxT7AvSESBT/8twNJAlvIJebiVDj1eYeM\n"
-"HVOyToV7BjjHLPj4sHKNJeV3UvQDHEimUF+IIDBu8oJDqz2XhOdT+yHBTw8imoa4WSr2Rz0Z\n"
-"iC3oheGe7IUIarFsNMkd7EgrO3jtZsSOeWmD3n+M\n"
-"-----END CERTIFICATE-----\n",
-
-/* QuoVadis Root CA 3 G3 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIFYDCCA0igAwIBAgIULvWbAiin23r/1aOp7r0DoM8Sah0wDQYJKoZIhvcNAQELBQAwSDEL\n"
-"MAkGA1UEBhMCQk0xGTAXBgNVBAoTEFF1b1ZhZGlzIExpbWl0ZWQxHjAcBgNVBAMTFVF1b1Zh\n"
-"ZGlzIFJvb3QgQ0EgMyBHMzAeFw0xMjAxMTIyMDI2MzJaFw00MjAxMTIyMDI2MzJaMEgxCzAJ\n"
-"BgNVBAYTAkJNMRkwFwYDVQQKExBRdW9WYWRpcyBMaW1pdGVkMR4wHAYDVQQDExVRdW9WYWRp\n"
-"cyBSb290IENBIDMgRzMwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCzyw4QZ47q\n"
-"FJenMioKVjZ/aEzHs286IxSR/xl/pcqs7rN2nXrpixurazHb+gtTTK/FpRp5PIpM/6zfJd5O\n"
-"2YIyC0TeytuMrKNuFoM7pmRLMon7FhY4futD4tN0SsJiCnMK3UmzV9KwCoWdcTzeo8vAMvMB\n"
-"OSBDGzXRU7Ox7sWTaYI+FrUoRqHe6okJ7UO4BUaKhvVZR74bbwEhELn9qdIoyhA5CcoTNs+c\n"
-"ra1AdHkrAj80//ogaX3T7mH1urPnMNA3I4ZyYUUpSFlob3emLoG+B01vr87ERRORFHAGjx+f\n"
-"+IdpsQ7vw4kZ6+ocYfx6bIrc1gMLnia6Et3UVDmrJqMz6nWB2i3ND0/kA9HvFZcba5DFApCT\n"
-"ZgIhsUfei5pKgLlVj7WiL8DWM2fafsSntARE60f75li59wzweyuxwHApw0BiLTtIadwjPEjr\n"
-"ewl5qW3aqDCYz4ByA4imW0aucnl8CAMhZa634RylsSqiMd5mBPfAdOhx3v89WcyWJhKLhZVX\n"
-"GqtrdQtEPREoPHtht+KPZ0/l7DxMYIBpVzgeAVuNVejH38DMdyM0SXV89pgR6y3e7UEuFAUC\n"
-"f+D+IOs15xGsIs5XPd7JMG0QA4XN8f+MFrXBsj6IbGB/kE+V9/YtrQE5BwT6dYB9v0lQ7e/J\n"
-"xHwc64B+27bQ3RP+ydOc17KXqQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB\n"
-"/wQEAwIBBjAdBgNVHQ4EFgQUxhfQvKjqAkPyGwaZXSuQILnXnOQwDQYJKoZIhvcNAQELBQAD\n"
-"ggIBADRh2Va1EodVTd2jNTFGu6QHcrxfYWLopfsLN7E8trP6KZ1/AvWkyaiTt3pxKGmPc+FS\n"
-"kNrVvjrlt3ZqVoAh313m6Tqe5T72omnHKgqwGEfcIHB9UqM+WXzBusnIFUBhynLWcKzSt/Ac\n"
-"5IYp8M7vaGPQtSCKFWGafoaYtMnCdvvMujAWzKNhxnQT5WvvoxXqA/4Ti2Tk08HS6IT7SdEQ\n"
-"TXlm66r99I0xHnAUrdzeZxNMgRVhvLfZkXdxGYFgu/BYpbWcC/ePIlUnwEsBbTuZDdQdm2Nn\n"
-"L9DuDcpmvJRPpq3t/O5jrFc/ZSXPsoaP0Aj/uHYUbt7lJ+yreLVTubY/6CD50qi+YUbKh4yE\n"
-"8/nxoGibIh6BJpsQBJFxwAYf3KDTuVan45gtf4Od34wrnDKOMpTwATwiKp9Dwi7DmDkHOHv8\n"
-"XgBCH/MyJnmDhPbl8MFREsALHgQjDFSlTC9JxUrRtm5gDWv8a4uFJGS3iQ6rJUdbPM9+Sb3H\n"
-"6QrG2vd+DhcI00iX0HGS8A85PjRqHH3Y8iKuu2n0M7SmSFXRDw4m6Oy2Cy2nhTXN/VnIn9HN\n"
-"PlopNLk9hM6xZdRZkZFWdSHBd575euFgndOtBBj0fOtek49TSiIp+EgrPk2GrFt/ywaZWWDY\n"
-"WGWVjUTR939+J399roD1B0y2PpxxVJkES/1Y+Zj0\n"
-"-----END CERTIFICATE-----\n",
-
-/* DigiCert Assured ID Root G2 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDljCCAn6gAwIBAgIQC5McOtY5Z+pnI7/Dr5r0SzANBgkqhkiG9w0BAQsFADBlMQswCQYD\n"
-"VQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNlcnQu\n"
-"Y29tMSQwIgYDVQQDExtEaWdpQ2VydCBBc3N1cmVkIElEIFJvb3QgRzIwHhcNMTMwODAxMTIw\n"
-"MDAwWhcNMzgwMTE1MTIwMDAwWjBlMQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQg\n"
-"SW5jMRkwFwYDVQQLExB3d3cuZGlnaWNlcnQuY29tMSQwIgYDVQQDExtEaWdpQ2VydCBBc3N1\n"
-"cmVkIElEIFJvb3QgRzIwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDZ5ygvUj82\n"
-"ckmIkzTz+GoeMVSAn61UQbVH35ao1K+ALbkKz3X9iaV9JPrjIgwrvJUXCzO/GU1BBpAAvQxN\n"
-"EP4HteccbiJVMWWXvdMX0h5i89vqbFCMP4QMls+3ywPgym2hFEwbid3tALBSfK+RbLE4E9Hp\n"
-"EgjAALAcKxHad3A2m67OeYfcgnDmCXRwVWmvo2ifv922ebPynXApVfSr/5Vh88lAbx3RvpO7\n"
-"04gqu52/clpWcTs/1PPRCv4o76Pu2ZmvA9OPYLfykqGxvYmJHzDNw6YuYjOuFgJ3RFrngQo8\n"
-"p0Quebg/BLxcoIfhG69Rjs3sLPr4/m3wOnyqi+RnlTGNAgMBAAGjQjBAMA8GA1UdEwEB/wQF\n"
-"MAMBAf8wDgYDVR0PAQH/BAQDAgGGMB0GA1UdDgQWBBTOw0q5mVXyuNtgv6l+vVa1lzan1jAN\n"
-"BgkqhkiG9w0BAQsFAAOCAQEAyqVVjOPIQW5pJ6d1Ee88hjZv0p3GeDgdaZaikmkuOGybfQTU\n"
-"iaWxMTeKySHMq2zNixya1r9I0jJmwYrA8y8678Dj1JGG0VDjA9tzd29KOVPt3ibHtX2vK0LR\n"
-"dWLjSisCx1BL4GnilmwORGYQRI+tBev4eaymG+g3NJ1TyWGqolKvSnAWhsI6yLETcDbYz+70\n"
-"CjTVW0z9B5yiutkBclzzTcHdDrEcDcRjvq30FPuJ7KJBDkzMyFdA0G4Dqs0MjomZmWzwPDCv\n"
-"ON9vvKO+KSAnq3T/EyJ43pdSVR6DtVQgA+6uwE9W3jfMw3+qBCe703e4YtsXfJwoIhNzbM8m\n"
-"9Yop5w==\n"
-"-----END CERTIFICATE-----\n",
-
-/* DigiCert Assured ID Root G3 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIICRjCCAc2gAwIBAgIQC6Fa+h3foLVJRK/NJKBs7DAKBggqhkjOPQQDAzBlMQswCQYDVQQG\n"
-"EwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNlcnQuY29t\n"
-"MSQwIgYDVQQDExtEaWdpQ2VydCBBc3N1cmVkIElEIFJvb3QgRzMwHhcNMTMwODAxMTIwMDAw\n"
-"WhcNMzgwMTE1MTIwMDAwWjBlMQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5j\n"
-"MRkwFwYDVQQLExB3d3cuZGlnaWNlcnQuY29tMSQwIgYDVQQDExtEaWdpQ2VydCBBc3N1cmVk\n"
-"IElEIFJvb3QgRzMwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAAQZ57ysRGXtzbg/WPuNsVepRC0F\n"
-"FfLvC/8QdJ+1YlJfZn4f5dwbRXkLzMZTCp2NXQLZqVneAlr2lSoOjThKiknGvMYDOAdfVdp+\n"
-"CW7if17QRSAPWXYQ1qAk8C3eNvJsKTmjQjBAMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/\n"
-"BAQDAgGGMB0GA1UdDgQWBBTL0L2p4ZgFUaFNN6KDec6NHSrkhDAKBggqhkjOPQQDAwNnADBk\n"
-"AjAlpIFFAmsSS3V0T8gj43DydXLefInwz5FyYZ5eEJJZVrmDxxDnOOlYJjZ91eQ0hjkCMHw2\n"
-"U/Aw5WJjOpnitqM7mzT6HtoQknFekROn3aRukswy1vUhZscv6pZjamVFkpUBtA==\n"
-"-----END CERTIFICATE-----\n",
-
-/* DigiCert Global Root G2 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDjjCCAnagAwIBAgIQAzrx5qcRqaC7KGSxHQn65TANBgkqhkiG9w0BAQsFADBhMQswCQYD\n"
-"VQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNlcnQu\n"
-"Y29tMSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBHMjAeFw0xMzA4MDExMjAwMDBa\n"
-"Fw0zODAxMTUxMjAwMDBaMGExCzAJBgNVBAYTAlVTMRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMx\n"
-"GTAXBgNVBAsTEHd3dy5kaWdpY2VydC5jb20xIDAeBgNVBAMTF0RpZ2lDZXJ0IEdsb2JhbCBS\n"
-"b290IEcyMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAuzfNNNx7a8myaJCtSnX/\n"
-"RrohCgiN9RlUyfuI2/Ou8jqJkTx65qsGGmvPrC3oXgkkRLpimn7Wo6h+4FR1IAWsULecYxps\n"
-"MNzaHxmx1x7e/dfgy5SDN67sH0NO3Xss0r0upS/kqbitOtSZpLYl6ZtrAGCSYP9PIUkY92eQ\n"
-"q2EGnI/yuum06ZIya7XzV+hdG82MHauVBJVJ8zUtluNJbd134/tJS7SsVQepj5WztCO7TG1F\n"
-"8PapspUwtP1MVYwnSlcUfIKdzXOS0xZKBgyMUNGPHgm+F6HmIcr9g+UQvIOlCsRnKPZzFBQ9\n"
-"RnbDhxSJITRNrw9FDKZJobq7nMWxM4MphQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MA4G\n"
-"A1UdDwEB/wQEAwIBhjAdBgNVHQ4EFgQUTiJUIBiV5uNu5g/6+rkS7QYXjzkwDQYJKoZIhvcN\n"
-"AQELBQADggEBAGBnKJRvDkhj6zHd6mcY1Yl9PMWLSn/pvtsrF9+wX3N3KjITOYFnQoQj8kVn\n"
-"NeyIv/iPsGEMNKSuIEyExtv4NeF22d+mQrvHRAiGfzZ0JFrabA0UWTW98kndth/Jsw1HKj2Z\n"
-"L7tcu7XUIOGZX1NGFdtom/DzMNU+MeKNhJ7jitralj41E6Vf8PlwUHBHQRFXGU7Aj64GxJUT\n"
-"Fy8bJZ918rGOmaFvE7FBcf6IKshPECBV1/MUReXgRPTqh5Uykw7+U0b6LJ3/iyK5S9kJRaTe\n"
-"pLiaWN0bfVKfjllDiIGknibVb63dDcY3fe0Dkhvld1927jyNxF1WW6LZZm6zNTflMrY=\n"
-"-----END CERTIFICATE-----\n",
-
-/* DigiCert Global Root G3 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIICPzCCAcWgAwIBAgIQBVVWvPJepDU1w6QP1atFcjAKBggqhkjOPQQDAzBhMQswCQYDVQQG\n"
-"EwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNlcnQuY29t\n"
-"MSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBHMzAeFw0xMzA4MDExMjAwMDBaFw0z\n"
-"ODAxMTUxMjAwMDBaMGExCzAJBgNVBAYTAlVTMRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMxGTAX\n"
-"BgNVBAsTEHd3dy5kaWdpY2VydC5jb20xIDAeBgNVBAMTF0RpZ2lDZXJ0IEdsb2JhbCBSb290\n"
-"IEczMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE3afZu4q4C/sLfyHS8L6+c/MzXRq8NOrexpu8\n"
-"0JX28MzQC7phW1FGfp4tn+6OYwwX7Adw9c+ELkCDnOg/QW07rdOkFFk2eJ0DQ+4QE2xy3q6I\n"
-"p6FrtUPOZ9wj/wMco+I+o0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIBhjAd\n"
-"BgNVHQ4EFgQUs9tIpPmhxdiuNkHMEWNpYim8S8YwCgYIKoZIzj0EAwMDaAAwZQIxAK288mw/\n"
-"EkrRLTnDCgmXc/SINoyIJ7vmiI1Qhadj+Z4y3maTD/HMsQmP3Wyr+mt/oAIwOWZbwmSNuJ5Q\n"
-"3KjVSaLtx9zRSX8XAbjIho9OjIgrqJqpisXRAL34VOKa5Vt8sycX\n"
-"-----END CERTIFICATE-----\n",
-
-/* DigiCert Trusted Root G4 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIFkDCCA3igAwIBAgIQBZsbV56OITLiOQe9p3d1XDANBgkqhkiG9w0BAQwFADBiMQswCQYD\n"
-"VQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNlcnQu\n"
-"Y29tMSEwHwYDVQQDExhEaWdpQ2VydCBUcnVzdGVkIFJvb3QgRzQwHhcNMTMwODAxMTIwMDAw\n"
-"WhcNMzgwMTE1MTIwMDAwWjBiMQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5j\n"
-"MRkwFwYDVQQLExB3d3cuZGlnaWNlcnQuY29tMSEwHwYDVQQDExhEaWdpQ2VydCBUcnVzdGVk\n"
-"IFJvb3QgRzQwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC/5pBzaN675F1KPDAi\n"
-"MGkz7MKnJS7JIT3yithZwuEppz1Yq3aaza57G4QNxDAf8xukOBbrVsaXbR2rsnnyyhHS5F/W\n"
-"BTxSD1Ifxp4VpX6+n6lXFllVcq9ok3DCsrp1mWpzMpTREEQQLt+C8weE5nQ7bXHiLQwb7iDV\n"
-"ySAdYyktzuxeTsiT+CFhmzTrBcZe7FsavOvJz82sNEBfsXpm7nfISKhmV1efVFiODCu3T6cw\n"
-"2Vbuyntd463JT17lNecxy9qTXtyOj4DatpGYQJB5w3jHtrHEtWoYOAMQjdjUN6QuBX2I9YI+\n"
-"EJFwq1WCQTLX2wRzKm6RAXwhTNS8rhsDdV14Ztk6MUSaM0C/CNdaSaTC5qmgZ92kJ7yhTzm1\n"
-"EVgX9yRcRo9k98FpiHaYdj1ZXUJ2h4mXaXpI8OCiEhtmmnTK3kse5w5jrubU75KSOp493ADk\n"
-"RSWJtppEGSt+wJS00mFt6zPZxd9LBADMfRyVw4/3IbKyEbe7f/LVjHAsQWCqsWMYRJUadmJ+\n"
-"9oCw++hkpjPRiQfhvbfmQ6QYuKZ3AeEPlAwhHbJUKSWJbOUOUlFHdL4mrLZBdd56rF+NP8m8\n"
-"00ERElvlEFDrMcXKchYiCd98THU/Y+whX8QgUWtvsauGi0/C1kVfnSD8oR7FwI+isX4KJpn1\n"
-"5GkvmB0t9dmpsh3lGwIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIB\n"
-"hjAdBgNVHQ4EFgQU7NfjgtJxXWRM3y5nP+e6mK4cD08wDQYJKoZIhvcNAQEMBQADggIBALth\n"
-"2X2pbL4XxJEbw6GiAI3jZGgPVs93rnD5/ZpKmbnJeFwMDF/k5hQpVgs2SV1EY+CtnJYYZhsj\n"
-"DT156W1r1lT40jzBQ0CuHVD1UvyQO7uYmWlrx8GnqGikJ9yd+SeuMIW59mdNOj6PWTkiU0Tr\n"
-"yF0Dyu1Qen1iIQqAyHNm0aAFYF/opbSnr6j3bTWcfFqK1qI4mfN4i/RN0iAL3gTujJtHgXIN\n"
-"wBQy7zBZLq7gcfJW5GqXb5JQbZaNaHqasjYUegbyJLkJEVDXCLG4iXqEI2FCKeWjzaIgQdfR\n"
-"nGTZ6iahixTXTBmyUEFxPT9NcCOGDErcgdLMMpSEDQgJlxxPwO5rIHQw0uA5NBCFIRUBCOhV\n"
-"Mt5xSdkoF1BN5r5N0XWs0Mr7QbhDparTwwVETyw2m+L64kW4I1NsBm9nVX9GtUw/bihaeSbS\n"
-"pKhil9Ie4u1Ki7wb/UdKDd9nZn6yW0HQO+T0O/QEY+nvwlQAUaCKKsnOeMzV6ocEGLPOr0mI\n"
-"r/OSmbaz5mEP0oUA51Aa5BuVnRmhuZyxm7EAHu/QD09CbMkKvO5D+jpxpchNJqU1/YldvIVi\n"
-"HTLSoCtU7ZpXwdv6EM8Zt4tKG48BtieVU+i2iW1bvGjUI+iLUaJW+fCmgKDWHrO8Dw9TdSmq\n"
-"6hN35N6MgSGtBxBHEa2HPQfRdbzP82Z+\n"
-"-----END CERTIFICATE-----\n",
-
-/* WoSign */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIFdjCCA16gAwIBAgIQXmjWEXGUY1BWAGjzPsnFkTANBgkqhkiG9w0BAQUFADBVMQswCQYD\n"
-"VQQGEwJDTjEaMBgGA1UEChMRV29TaWduIENBIExpbWl0ZWQxKjAoBgNVBAMTIUNlcnRpZmlj\n"
-"YXRpb24gQXV0aG9yaXR5IG9mIFdvU2lnbjAeFw0wOTA4MDgwMTAwMDFaFw0zOTA4MDgwMTAw\n"
-"MDFaMFUxCzAJBgNVBAYTAkNOMRowGAYDVQQKExFXb1NpZ24gQ0EgTGltaXRlZDEqMCgGA1UE\n"
-"AxMhQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkgb2YgV29TaWduMIICIjANBgkqhkiG9w0BAQEF\n"
-"AAOCAg8AMIICCgKCAgEAvcqNrLiRFVaXe2tcesLea9mhsMMQI/qnobLMMfo+2aYpbxY94Gv4\n"
-"uEBf2zmoAHqLoE1UfcIiePyOCbiohdfMlZdLdNiefvAA5A6JrkkoRBoQmTIPJYhTpA2zDxII\n"
-"FgsDcSccf+Hb0v1naMQFXQoOXXDX2JegvFNBmpGN9J42Znp+VsGQX+axaCA2pIwkLCxHC1l2\n"
-"ZjC1vt7tj/id07sBMOby8w7gLJKA84X5KIq0VC6a7fd2/BVoFutKbOsuEo/Uz/4Mx1wdC34F\n"
-"Mr5esAkqQtXJTpCzWQ27en7N1QhatH/YHGkR+ScPewavVIMYe+HdVHpRaG53/Ma/UkpmRqGy\n"
-"Zxq7o093oL5d//xWC0Nyd5DKnvnyOfUNqfTq1+ezEC8wQjchzDBwyYaYD8xYTYO7feUapTeN\n"
-"tqwylwA6Y3EkHp43xP901DfA4v6IRmAR3Qg/UDaruHqklWJqbrDKaiFaafPz+x1wOZXzp26m\n"
-"gYmhiMU7ccqjUu6Du/2gd/Tkb+dC221KmYo0SLwX3OSACCK28jHAPwQ+658geda4BmRkAjHX\n"
-"qc1S+4RFaQkAKtxVi8QGRkvASh0JWzko/amrzgD5LkhLJuYwTKVYyrREgk/nkR4zw7CT/xH8\n"
-"gdLKH3Ep3XZPkiWvHYG3Dy+MwwbMLyejSuQOmbp8HkUff6oZRZb9/D0CAwEAAaNCMEAwDgYD\n"
-"VR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFOFmzw7R8bNLtwYgFP6H\n"
-"EtX2/vs+MA0GCSqGSIb3DQEBBQUAA4ICAQCoy3JAsnbBfnv8rWTjMnvMPLZdRtP1LOJwXcgu\n"
-"2AZ9mNELIaCJWSQBnfmvCX0KI4I01fx8cpm5o9dU9OpScA7F9dY74ToJMuYhOZO9sxXqT2r0\n"
-"9Ys/L3yNWC7F4TmgPsc9SnOeQHrAK2GpZ8nzJLmzbVUsWh2eJXLOC62qx1ViC777Y7NhRCOj\n"
-"y+EaDveaBk3e1CNOIZZbOVtXHS9dCF4Jef98l7VNg64N1uajeeAz0JmWAjCnPv/So0M/BVoG\n"
-"6kQC2nz4SNAzqfkHx5Xh9T71XXG68pWpdIhhWeO/yloTunK0jF02h+mmxTwTv97QRCbut+wu\n"
-"cPrXnbes5cVAWubXbHssw1abR80LzvobtCHXt2a49CUwi1wNuepnsvRtrtWhnk/Yn+knArAd\n"
-"BtaP4/tIEp9/EaEQPkxROpaw0RPxx9gmrjrKkcRpnd8BKWRRb2jaFOwIQZeQjdCygPLPwj2/\n"
-"kWjFgGcexGATVdVhmVd8upUPYUk6ynW8yQqTP2cOEvIo4jEbwFcW3wh8GcF+Dx+FHgo2fFt+\n"
-"J7x6v+Db9NpSvd4MVHAxkUOVyLzwPt0JfjBkUO1/AaQzZ01oT74V77D2AhGiGxMlOtzCWfHj\n"
-"XEa7ZywCRuoeSKbmW9m1vFGikpbbqsY3Iqb+zCB0oy2pLmvLwIIRIbWTee5Ehr7XHuQe+w==\n"
-"-----END CERTIFICATE-----\n",
-
-/* WoSign China */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIFWDCCA0CgAwIBAgIQUHBrzdgT/BtOOzNy0hFIjTANBgkqhkiG9w0BAQsFADBGMQswCQYD\n"
-"VQQGEwJDTjEaMBgGA1UEChMRV29TaWduIENBIExpbWl0ZWQxGzAZBgNVBAMMEkNBIOayg+mA\n"
-"muagueivgeS5pjAeFw0wOTA4MDgwMTAwMDFaFw0zOTA4MDgwMTAwMDFaMEYxCzAJBgNVBAYT\n"
-"AkNOMRowGAYDVQQKExFXb1NpZ24gQ0EgTGltaXRlZDEbMBkGA1UEAwwSQ0Eg5rKD6YCa5qC5\n"
-"6K+B5LmmMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA0EkhHiX8h8EqwqzbdoYG\n"
-"TufQdDTc7WU1/FDWiD+k8H/rD195L4mx/bxjWDeTmzj4t1up+thxx7S8gJeNbEvxUNUqKaqo\n"
-"GXqW5pWOdO2XCld19AXbbQs5uQF/qvbW2mzmBeCkTVL829B0txGMe41P/4eDrv8FAxNXUDf+\n"
-"jJZSEExfv5RxadmWPgxDT74wwJ85dE8GRV2j1lY5aAfMh09Qd5Nx2UQIsYo06Yms25tO4dnk\n"
-"UkWMLhQfkWsZHWgpLFbE4h4TV2TwYeO5Ed+w4VegG63XX9Gv2ystP9Bojg/qnw+LNVgbExz0\n"
-"3jWhCl3W6t8Sb8D7aQdGctyB9gQjF+BNdeFyb7Ao65vh4YOhn0pdr8yb+gIgthhid5E7o9Vl\n"
-"rdx8kHccREGkSovrlXLp9glk3Kgtn3R46MGiCWOc76DbT52VqyBPt7D3h1ymoOQ3OMdc4zUP\n"
-"LK2jgKLsLl3Az+2LBcLmc272idX10kaO6m1jGx6KyX2m+Jzr5dVjhU1zZmkR/sgO9MHHZklT\n"
-"fuQZa/HpelmjbX7FF+Ynxu8b22/8DU0GAbQOXDBGVWCvOGU6yke6rCzMRh+yRpY/8+0mBe53\n"
-"oWprfi1tWFxK1I5nuPHa1UaKJ/kR8slC/k7e3x9cxKSGhxYzoacXGKUN5AXlK8IrC6KVkLn9\n"
-"YDxOiT7nnO4fuwECAwEAAaNCMEAwDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8w\n"
-"HQYDVR0OBBYEFOBNv9ybQV0T6GTwp+kVpOGBwboxMA0GCSqGSIb3DQEBCwUAA4ICAQBqinA4\n"
-"WbbaixjIvirTthnVZil6Xc1bL3McJk6jfW+rtylNpumlEYOnOXOvEESS5iVdT2H6yAa+Tkvv\n"
-"/vMx/sZ8cApBWNromUuWyXi8mHwCKe0JgOYKOoICKuLJL8hWGSbueBwj/feTZU7n85iYr83d\n"
-"2Z5AiDEoOqsuC7CsDCT6eiaY8xJhEPRdF/d+4niXVOKM6Cm6jBAyvd0zaziGfjk9DgNyp115\n"
-"j0WKWa5bIW4xRtVZjc8VX90xJc/bYNaBRHIpAlf2ltTW/+op2znFuCyKGo3Oy+dCMYYFaA6e\n"
-"FN0AkLppRQjbbpCBhqcqBT/mhDn4t/lXX0ykeVoQDF7Va/81XwVRHmyjdanPUIPTfPRm94KN\n"
-"PQx96N97qA4bLJyuQHCH2u2nFoJavjVsIE4iYdm8UXrNemHcSxH5/mc0zy4EZmFcV5cjjPOG\n"
-"G0jfKq+nwf/Yjj4Du9gqsPoUJbJRa4ZDhS4HIxaAjUz7tGM7zMN07RujHv41D198HRaG9Q7D\n"
-"lfEvr10lO1Hm13ZBONFLAzkopR6RctR9q5czxNM+4Gm2KHmgCY0c0f9BckgG/Jou5yD5m6Le\n"
-"ie2uPAmvylezkolwQOQvT8Jwg0DXJCxr5wkf09XHwQj02w47HAcLQxGEIYbpgNR12KvxAmLB\n"
-"sX5VYc8T1yaw15zLKYs4SgsOkI26oQ==\n"
-"-----END CERTIFICATE-----\n",
-
-/* COMODO RSA Certification Authority */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIF2DCCA8CgAwIBAgIQTKr5yttjb+Af907YWwOGnTANBgkqhkiG9w0BAQwFADCBhTELMAkG\n"
-"A1UEBhMCR0IxGzAZBgNVBAgTEkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4GA1UEBxMHU2FsZm9y\n"
-"ZDEaMBgGA1UEChMRQ09NT0RPIENBIExpbWl0ZWQxKzApBgNVBAMTIkNPTU9ETyBSU0EgQ2Vy\n"
-"dGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMTAwMTE5MDAwMDAwWhcNMzgwMTE4MjM1OTU5WjCB\n"
-"hTELMAkGA1UEBhMCR0IxGzAZBgNVBAgTEkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4GA1UEBxMH\n"
-"U2FsZm9yZDEaMBgGA1UEChMRQ09NT0RPIENBIExpbWl0ZWQxKzApBgNVBAMTIkNPTU9ETyBS\n"
-"U0EgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIK\n"
-"AoICAQCR6FSS0gpWsawNJN3Fz0RndJkrN6N9I3AAcbxT38T6KhKPS38QVr2fcHK3YX/JSw8X\n"
-"pz3jsARh7v8Rl8f0hj4K+j5c+ZPmNHrZFGvnnLOFoIJ6dq9xkNfs/Q36nGz637CC9BR++b7E\n"
-"pi9Pf5l/tfxnQ3K9DADWietrLNPtj5gcFKt+5eNu/Nio5JIk2kNrYrhV/erBvGy2i/MOjZrk\n"
-"m2xpmfh4SDBF1a3hDTxFYPwyllEnvGfDyi62a+pGx8cgoLEfZd5ICLqkTqnyg0Y3hOvozIFI\n"
-"Q2dOciqbXL1MGyiKXCJ7tKuY2e7gUYPDCUZObT6Z+pUX2nwzV0E8jVHtC7ZcryxjGt9XyD+8\n"
-"6V3Em69FmeKjWiS0uqlWPc9vqv9JWL7wqP/0uK3pN/u6uPQLOvnoQ0IeidiEyxPx2bvhiWC4\n"
-"jChWrBQdnArncevPDt09qZahSL0896+1DSJMwBGB7FY79tOi4lu3sgQiUpWAk2nojkxl8ZED\n"
-"LXB0AuqLZxUpaVICu9ffUGpVRr+goyhhf3DQw6KqLCGqR84onAZFdr+CGCe01a60y1Dma/RM\n"
-"hnEw6abfFobg2P9A3fvQQoh/ozM6LlweQRGBY84YcWsr7KaKtzFcOmpH4MN5WdYgGq/yapiq\n"
-"crxXStJLnbsQ/LBMQeXtHT1eKJ2czL+zUdqnR+WEUwIDAQABo0IwQDAdBgNVHQ4EFgQUu69+\n"
-"Aj36pvE8hI6t7jiY7NkyMtQwDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wDQYJ\n"
-"KoZIhvcNAQEMBQADggIBAArx1UaEt65Ru2yyTUEUAJNMnMvlwFTPoCWOAvn9sKIN9SCYPBMt\n"
-"rFaisNZ+EZLpLrqeLppysb0ZRGxhNaKatBYSaVqM4dc+pBroLwP0rmEdEBsqpIt6xf4FpuHA\n"
-"1sj+nq6PK7o9mfjYcwlYRm6mnPTXJ9OV2jeDchzTc+CiR5kDOF3VSXkAKRzH7JsgHAckaVd4\n"
-"sjn8OoSgtZx8jb8uk2IntznaFxiuvTwJaP+EmzzV1gsD41eeFPfR60/IvYcjt7ZJQ3mFXLrr\n"
-"kguhxuhoqEwWsRqZCuhTLJK7oQkYdQxlqHvLI7cawiiFwxv/0Cti76R7CZGYZ4wUAc1oBmpj\n"
-"IXUDgIiKboHGhfKppC3n9KUkEEeDys30jXlYsQab5xoq2Z0B15R97QNKyvDb6KkBPvVWmcke\n"
-"jkk9u+UJueBPSZI9FoJAzMxZxuY67RIuaTxslbH9qh17f4a+Hg4yRvv7E491f0yLS0Zj/gA0\n"
-"QHDBw7mh3aZw4gSzQbzpgJHqZJx64SIDqZxubw5lT2yHh17zbqD5daWbQOhTsiedSrnAdyGN\n"
-"/4fy3ryM7xfft0kL0fJuMAsaDk527RH89elWsn2/x20Kk4yl0MC2Hb46TpSi125sC8KKfPog\n"
-"88Tk5c0NqMuRkrF8hey1FGlmDoLnzc7ILaZRfyHBNVOFBkpdn627G190\n"
-"-----END CERTIFICATE-----\n",
-
-/* USERTrust RSA Certification Authority */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIF3jCCA8agAwIBAgIQAf1tMPyjylGoG7xkDjUDLTANBgkqhkiG9w0BAQwFADCBiDELMAkG\n"
-"A1UEBhMCVVMxEzARBgNVBAgTCk5ldyBKZXJzZXkxFDASBgNVBAcTC0plcnNleSBDaXR5MR4w\n"
-"HAYDVQQKExVUaGUgVVNFUlRSVVNUIE5ldHdvcmsxLjAsBgNVBAMTJVVTRVJUcnVzdCBSU0Eg\n"
-"Q2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMTAwMjAxMDAwMDAwWhcNMzgwMTE4MjM1OTU5\n"
-"WjCBiDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCk5ldyBKZXJzZXkxFDASBgNVBAcTC0plcnNl\n"
-"eSBDaXR5MR4wHAYDVQQKExVUaGUgVVNFUlRSVVNUIE5ldHdvcmsxLjAsBgNVBAMTJVVTRVJU\n"
-"cnVzdCBSU0EgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwggIiMA0GCSqGSIb3DQEBAQUAA4IC\n"
-"DwAwggIKAoICAQCAEmUXNg7D2wiz0KxXDXbtzSfTTK1Qg2HiqiBNCS1kCdzOiZ/MPans9s/B\n"
-"3PHTsdZ7NygRK0faOca8Ohm0X6a9fZ2jY0K2dvKpOyuR+OJv0OwWIJAJPuLodMkYtJHUYmTb\n"
-"f6MG8YgYapAiPLz+E/CHFHv25B+O1ORRxhFnRghRy4YUVD+8M/5+bJz/Fp0YvVGONaanZshy\n"
-"Z9shZrHUm3gDwFA66Mzw3LyeTP6vBZY1H1dat//O+T23LLb2VN3I5xI6Ta5MirdcmrS3ID3K\n"
-"fyI0rn47aGYBROcBTkZTmzNg95S+UzeQc0PzMsNT79uq/nROacdrjGCT3sTHDN/hMq7MkztR\n"
-"eJVni+49Vv4M0GkPGw/zJSZrM233bkf6c0Plfg6lZrEpfDKEY1WJxA3Bk1QwGROs0303p+td\n"
-"Omw1XNtB1xLaqUkL39iAigmTYo61Zs8liM2EuLE/pDkP2QKe6xJMlXzzawWpXhaDzLhn4ugT\n"
-"ncxbgtNMs+1b/97lc6wjOy0AvzVVdAlJ2ElYGn+SNuZRkg7zJn0cTRe8yexDJtC/QV9AqURE\n"
-"9JnnV4eeUB9XVKg+/XRjL7FQZQnmWEIuQxpMtPAlR1n6BB6T1CZGSlCBst6+eLf8ZxXhyVeE\n"
-"Hg9j1uliutZfVS7qXMYoCAQlObgOK6nyTJccBz8NUvXt7y+CDwIDAQABo0IwQDAdBgNVHQ4E\n"
-"FgQUU3m/WqorSs9UgOHYm8Cd8rIDZsswDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMB\n"
-"Af8wDQYJKoZIhvcNAQEMBQADggIBAFzUfA3P9wF9QZllDHPFUp/L+M+ZBn8b2kMVn54CVVeW\n"
-"FPFSPCeHlCjtHzoBN6J2/FNQwISbxmtOuowhT6KOVWKR82kV2LyI48SqC/3vqOlLVSoGIG1V\n"
-"eCkZ7l8wXEskEVX/JJpuXior7gtNn3/3ATiUFJVDBwn7YKnuHKsSjKCaXqeYalltiz8I+8jR\n"
-"Ra8YFWSQEg9zKC7F4iRO/Fjs8PRF/iKz6y+O0tlFYQXBl2+odnKPi4w2r78NBc5xjeambx9s\n"
-"pnFixdjQg3IM8WcRiQycE0xyNN+81XHfqnHd4blsjDwSXWXavVcStkNr/+XeTWYRUc+ZruwX\n"
-"tuhxkYzeSf7dNXGiFSeUHM9h4ya7b6NnJSFd5t0dCy5oGzuCr+yDZ4XUmFF0sbmZgIn/f3gZ\n"
-"XHlKYC6SQK5MNyosycdiyA5d9zZbyuAlJQG03RoHnHcAP9Dc1ew91Pq7P8yF1m9/qS3fuQL3\n"
-"9ZeatTXaw2ewh0qpKJ4jjv9cJ2vhsE/zB+4ALtRZh8tSQZXq9EfX7mRBVXyNWQKV3WKdwrnu\n"
-"Wih0hKWbt5DHDAff9Yk2dDLWKMGwsAvgnEzDHNb842m1R0aBL6KCq9NjRHDEjf8tM7qtj3u1\n"
-"cIiuPhnPQCjY/MiQu12ZIvVS5ljFH4gxQ+6IHdfGjjxDah2nGN59PRbxYvnKkKj9\n"
-"-----END CERTIFICATE-----\n",
-
-/* USERTrust ECC Certification Authority */
-"-----BEGIN CERTIFICATE-----\n"
-"MIICjzCCAhWgAwIBAgIQXIuZxVqUxdJxVt7NiYDMJjAKBggqhkjOPQQDAzCBiDELMAkGA1UE\n"
-"BhMCVVMxEzARBgNVBAgTCk5ldyBKZXJzZXkxFDASBgNVBAcTC0plcnNleSBDaXR5MR4wHAYD\n"
-"VQQKExVUaGUgVVNFUlRSVVNUIE5ldHdvcmsxLjAsBgNVBAMTJVVTRVJUcnVzdCBFQ0MgQ2Vy\n"
-"dGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMTAwMjAxMDAwMDAwWhcNMzgwMTE4MjM1OTU5WjCB\n"
-"iDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCk5ldyBKZXJzZXkxFDASBgNVBAcTC0plcnNleSBD\n"
-"aXR5MR4wHAYDVQQKExVUaGUgVVNFUlRSVVNUIE5ldHdvcmsxLjAsBgNVBAMTJVVTRVJUcnVz\n"
-"dCBFQ0MgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAAQa\n"
-"rFRaqfloI+d61SRvU8Za2EurxtW20eZzca7dnNYMYf3boIkDuAUU7FfO7l0/4iGzzvfUinng\n"
-"o4N+LZfQYcTxmdwlkWOrfzCjtHDix6EznPO/LlxTsV+zfTJ/ijTjeXmjQjBAMB0GA1UdDgQW\n"
-"BBQ64QmG1M8ZwpZ2dEl23OA1xmNjmjAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB\n"
-"/zAKBggqhkjOPQQDAwNoADBlAjA2Z6EWCNzklwBBHU6+4WMBzzuqQhFkoJ2UOQIReVx7Hfpk\n"
-"ue4WQrO/isIJxOzksU0CMQDpKmFHjFJKS04YcPbWRNZu9YO6bVi9JNlWSOrvxKJGgYhqOkbR\n"
-"qZtNyWHa0V1Xahg=\n"
-"-----END CERTIFICATE-----\n",
-
-/* GlobalSign ECC Root CA - R4 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIB4TCCAYegAwIBAgIRKjikHJYKBN5CsiilC+g0mAIwCgYIKoZIzj0EAwIwUDEkMCIGA1UE\n"
-"CxMbR2xvYmFsU2lnbiBFQ0MgUm9vdCBDQSAtIFI0MRMwEQYDVQQKEwpHbG9iYWxTaWduMRMw\n"
-"EQYDVQQDEwpHbG9iYWxTaWduMB4XDTEyMTExMzAwMDAwMFoXDTM4MDExOTAzMTQwN1owUDEk\n"
-"MCIGA1UECxMbR2xvYmFsU2lnbiBFQ0MgUm9vdCBDQSAtIFI0MRMwEQYDVQQKEwpHbG9iYWxT\n"
-"aWduMRMwEQYDVQQDEwpHbG9iYWxTaWduMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEuMZ5\n"
-"049sJQ6fLjkZHAOkrprlOQcJFspjsbmG+IpXwVfOQvpzofdlQv8ewQCybnMO/8ch5Rikqtlx\n"
-"P6jUuc6MHaNCMEAwDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYE\n"
-"FFSwe61FuOJAf/sKbvu+M8k8o4TVMAoGCCqGSM49BAMCA0gAMEUCIQDckqGgE6bPA7DmxCGX\n"
-"kPoUVy0D7O48027KqGx2vKLeuwIgJ6iFJzWbVsaj8kfSt24bAgAXqmemFZHe+pTsewv4n4Q=\n"
-"-----END CERTIFICATE-----\n",
-
-/* GlobalSign ECC Root CA - R5 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIICHjCCAaSgAwIBAgIRYFlJ4CYuu1X5CneKcflK2GwwCgYIKoZIzj0EAwMwUDEkMCIGA1UE\n"
-"CxMbR2xvYmFsU2lnbiBFQ0MgUm9vdCBDQSAtIFI1MRMwEQYDVQQKEwpHbG9iYWxTaWduMRMw\n"
-"EQYDVQQDEwpHbG9iYWxTaWduMB4XDTEyMTExMzAwMDAwMFoXDTM4MDExOTAzMTQwN1owUDEk\n"
-"MCIGA1UECxMbR2xvYmFsU2lnbiBFQ0MgUm9vdCBDQSAtIFI1MRMwEQYDVQQKEwpHbG9iYWxT\n"
-"aWduMRMwEQYDVQQDEwpHbG9iYWxTaWduMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAER0UOlvt9\n"
-"Xb/pOdEh+J8LttV7HpI6SFkc8GIxLcB6KP4ap1yztsyX50XUWPrRd21DosCHZTQKH3rd6zwz\n"
-"ocWdTaRvQZU4f8kehOvRnkmSh5SHDDqFSmafnVmTTZdhBoZKo0IwQDAOBgNVHQ8BAf8EBAMC\n"
-"AQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUPeYpSJvqB8ohREom3m7e0oPQn1kwCgYI\n"
-"KoZIzj0EAwMDaAAwZQIxAOVpEslu28YxuglB4Zf4+/2a4n0Sye18ZNPLBSWLVtmg515dTguD\n"
-"nFt2KaAJJiFqYgIwcdK1j1zqO+F4CYWodZI7yFz9SO8NdCKoCOJuxUnOxwy8p2Fp8fc74SrL\n"
-"+SvzZpA3\n"
-"-----END CERTIFICATE-----\n",
-
-/* Staat der Nederlanden Root CA - G3 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIFdDCCA1ygAwIBAgIEAJiiOTANBgkqhkiG9w0BAQsFADBaMQswCQYDVQQGEwJOTDEeMBwG\n"
-"A1UECgwVU3RhYXQgZGVyIE5lZGVybGFuZGVuMSswKQYDVQQDDCJTdGFhdCBkZXIgTmVkZXJs\n"
-"YW5kZW4gUm9vdCBDQSAtIEczMB4XDTEzMTExNDExMjg0MloXDTI4MTExMzIzMDAwMFowWjEL\n"
-"MAkGA1UEBhMCTkwxHjAcBgNVBAoMFVN0YWF0IGRlciBOZWRlcmxhbmRlbjErMCkGA1UEAwwi\n"
-"U3RhYXQgZGVyIE5lZGVybGFuZGVuIFJvb3QgQ0EgLSBHMzCCAiIwDQYJKoZIhvcNAQEBBQAD\n"
-"ggIPADCCAgoCggIBAL4yolQPcPssXFnrbMSkUeiFKrPMSjTysF/zDsccPVMeiAho2G89rcKe\n"
-"zIJnByeHaHE6n3WWIkYFsO2tx1ueKt6c/DrGlaf1F2cY5y9JCAxcz+bMNO14+1Cx3Gsy8KL+\n"
-"tjzk7FqXxz8ecAgwoNzFs21v0IJyEavSgWhZghe3eJJg+szeP4TrjTgzkApyI/o1zCZxMdFy\n"
-"KJLZWyNtZrVtB0LrpjPOktvA9mxjeM3KTj215VKb8b475lRgsGYeCasH/lSJEULR9yS6YHga\n"
-"mPfJEf0WwTUaVHXvQ9Plrk7O53vDxk5hUUurmkVLoR9BvUhTFXFkC4az5S6+zqQbwSmEorXL\n"
-"CCN2QyIkHxcE1G6cxvx/K2Ya7Irl1s9N9WMJtxU51nus6+N86U78dULI7ViVDAZCopz35HCz\n"
-"33JvWjdAidiFpNfxC95DGdRKWCyMijmev4SH8RY7Ngzp07TKbBlBUgmhHbBqv4LvcFEhMtwF\n"
-"dozL92TkA1CvjJFnq8Xy7ljY3r735zHPbMk7ccHViLVlvMDoFxcHErVc0qsgk7TmgoNwNsXN\n"
-"o42ti+yjwUOH5kPiNL6VizXtBznaqB16nzaeErAMZRKQFWDZJkBE41ZgpRDUajz9QdwOWke2\n"
-"75dhdU/Z/seyHdTtXUmzqWrLZoQT1Vyg3N9udwbRcXXIV2+vD3dbAgMBAAGjQjBAMA8GA1Ud\n"
-"EwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgEGMB0GA1UdDgQWBBRUrfrHkleuyjWcLhL75Lpd\n"
-"INyUVzANBgkqhkiG9w0BAQsFAAOCAgEAMJmdBTLIXg47mAE6iqTnB/d6+Oea31BDU5cqPco8\n"
-"R5gu4RV78ZLzYdqQJRZlwJ9UXQ4DO1t3ApyEtg2YXzTdO2PCwyiBwpwpLiniyMMB8jPqKqrM\n"
-"CQj3ZWfGzd/TtiunvczRDnBfuCPRy5FOCvTIeuXZYzbB1N/8Ipf3YF3qKS9Ysr1YvY2WTxB1\n"
-"v0h7PVGHoTx0IsL8B3+A3MSs/mrBcDCw6Y5p4ixpgZQJut3+TcCDjJRYwEYgr5wfAvg1VUkv\n"
-"RtTA8KCWAg8zxXHzniN9lLf9OtMJgwYh/WA9rjLA0u6NpvDntIJ8CsxwyXmA+P5M9zWEGYox\n"
-"+wrZ13+b8KKaa8MFSu1BYBQw0aoRQm7TIwIEC8Zl3d1Sd9qBa7Ko+gE4uZbqKmxnl4mUnrzh\n"
-"VNXkanjvSr0rmj1AfsbAddJu+2gw7OyLnflJNZoaLNmzlTnVHpL3prllL+U9bTpITAjc5CgS\n"
-"KL59NVzq4BZ+Extq1z7XnvwtdbLBFNUjA9tbbws+eC8N3jONFrdI54OagQ97wUNNVQQXOEpR\n"
-"1VmiiXTTn74eS9fGbbeIJG9gkaSChVtWQbzQRKtqE77RLFi3EjNYsjdj3BP1lB0/QFH1T/U6\n"
-"7cjF68IeHRaVesd+QnGTbksVtzDfqu1XhUisHWrdOWnk4Xl4vs4Fv6EM94B7IWcnMFk=\n"
-"-----END CERTIFICATE-----\n",
-
-/* Staat der Nederlanden EV Root CA */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIFcDCCA1igAwIBAgIEAJiWjTANBgkqhkiG9w0BAQsFADBYMQswCQYDVQQGEwJOTDEeMBwG\n"
-"A1UECgwVU3RhYXQgZGVyIE5lZGVybGFuZGVuMSkwJwYDVQQDDCBTdGFhdCBkZXIgTmVkZXJs\n"
-"YW5kZW4gRVYgUm9vdCBDQTAeFw0xMDEyMDgxMTE5MjlaFw0yMjEyMDgxMTEwMjhaMFgxCzAJ\n"
-"BgNVBAYTAk5MMR4wHAYDVQQKDBVTdGFhdCBkZXIgTmVkZXJsYW5kZW4xKTAnBgNVBAMMIFN0\n"
-"YWF0IGRlciBOZWRlcmxhbmRlbiBFViBSb290IENBMIICIjANBgkqhkiG9w0BAQEFAAOCAg8A\n"
-"MIICCgKCAgEA48d+ifkkSzrSM4M1LGns3Amk41GoJSt5uAg94JG6hIXGhaTK5skuU6TJJB79\n"
-"VWZxXSzFYGgEt9nCUiY4iKTWO0Cmws0/zZiTs1QUWJZV1VD+hq2kY39ch/aO5ieSZxeSAgMs\n"
-"3NZmdO3dZ//BYY1jTw+bbRcwJu+r0h8QoPnFfxZpgQNH7R5ojXKhTbImxrpsX23Wr9GxE46p\n"
-"rfNeaXUmGD5BKyF/7otdBwadQ8QpCiv8Kj6GyzyDOvnJDdrFmeK8eEEzduG/L13lpJhQDBXd\n"
-"4Pqcfzho0LKmeqfRMb1+ilgnQ7O6M5HTp5gVXJrm0w912fxBmJc+qiXbj5IusHsMX/FjqTf5\n"
-"m3VpTCgmJdrV8hJwRVXj33NeN/UhbJCONVrJ0yPr08C+eKxCKFhmpUZtcALXEPlLVPxdhkqH\n"
-"z3/KRawRWrUgUY0viEeXOcDPusBCAUCZSCELa6fS/ZbV0b5GnUngC6agIk440ME8MLxwjyx1\n"
-"zNDFjFE7PZQIZCZhfbnDZY8UnCHQqv0XcgOPvZuM5l5Tnrmd74K74bzickFbIZTTRTeU0d8J\n"
-"OV3nI6qaHcptqAqGhYqCvkIH1vI4gnPah1vlPNOePqc7nvQDs/nxfRN0Av+7oeX6AHkcpmZB\n"
-"iFxgV6YuCcS6/ZrPpx9Aw7vMWgpVSzs4dlG4Y4uElBbmVvMCAwEAAaNCMEAwDwYDVR0TAQH/\n"
-"BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFP6rAJCYniT8qcwaivsnuL8wbqg7\n"
-"MA0GCSqGSIb3DQEBCwUAA4ICAQDPdyxuVr5Os7aEAJSrR8kN0nbHhp8dB9O2tLsIeK9p0gtJ\n"
-"3jPFrK3CiAJ9Brc1AsFgyb/E6JTe1NOpEyVa/m6irn0F3H3zbPB+po3u2dfOWBfoqSmuc0iH\n"
-"55vKbimhZF8ZE/euBhD/UcabTVUlT5OZEAFTdfETzsemQUHSv4ilf0X8rLiltTMMgsT7B/Zq\n"
-"5SWEXwbKwYY5EdtYzXc7LMJMD16a4/CrPmEbUCTCwPTxGfARKbalGAKb12NMcIxHowNDXLld\n"
-"RqANb/9Zjr7dn3LDWyvfjFvO5QxGbJKyCqNMVEIYFRIYvdr8unRu/8G2oGTYqV9Vrp9canaW\n"
-"2HNnh/tNf1zuacpzEPuKqf2evTY4SUmH9A4U8OmHuD+nT3pajnnUk+S7aFKErGzp85hwVXIy\n"
-"+TSrK0m1zSBi5Dp6Z2Orltxtrpfs/J92VoguZs9btsmksNcFuuEnL5O7Jiqik7Ab846+HUCj\n"
-"uTaPPoIaGl6I6lD4WeKDRikL40Rc4ZW2aZCaFG+XroHPaO+Zmr615+F/+PoTRxZMzG0IQOeL\n"
-"eG9QgkRQP2YGiqtDhFZKDyAthg710tvSeopLzaXoTvFeJiUBWSOgftL2fiFX1ye8FVdMpEbB\n"
-"4IMeDExNH08GGeL5qPQ6gqGyeUN51q1veieQA6TqJIc/2b3Z6fJfUEkc7uzXLg==\n"
-"-----END CERTIFICATE-----\n",
-
-/* IdenTrust Commercial Root CA 1 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIFYDCCA0igAwIBAgIQCgFCgAAAAUUjyES1AAAAAjANBgkqhkiG9w0BAQsFADBKMQswCQYD\n"
-"VQQGEwJVUzESMBAGA1UEChMJSWRlblRydXN0MScwJQYDVQQDEx5JZGVuVHJ1c3QgQ29tbWVy\n"
-"Y2lhbCBSb290IENBIDEwHhcNMTQwMTE2MTgxMjIzWhcNMzQwMTE2MTgxMjIzWjBKMQswCQYD\n"
-"VQQGEwJVUzESMBAGA1UEChMJSWRlblRydXN0MScwJQYDVQQDEx5JZGVuVHJ1c3QgQ29tbWVy\n"
-"Y2lhbCBSb290IENBIDEwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCnUBneP5k9\n"
-"1DNG8W9RYYKyqU+PZ4ldhNlT3Qwo2dfw/66VQ3KZ+bVdfIrBQuExUHTRgQ18zZshq0PirK1e\n"
-"hm7zCYofWjK9ouuU+ehcCuz/mNKvcbO0U59Oh++SvL3sTzIwiEsXXlfEU8L2ApeN2WIrvyQf\n"
-"Yo3fw7gpS0l4PJNgiCL8mdo2yMKi1CxUAGc1bnO/AljwpN3lsKImesrgNqUZFvX9t++uP0D1\n"
-"bVoE/c40yiTcdCMbXTMTEl3EASX2MN0CXZ/g1Ue9tOsbobtJSdifWwLziuQkkORiT0/Br4sO\n"
-"dBeo0XKIanoBScy0RnnGF7HamB4HWfp1IYVl3ZBWzvurpWCdxJ35UrCLvYf5jysjCiN2O/cz\n"
-"4ckA82n5S6LgTrx+kzmEB/dEcH7+B1rlsazRGMzyNeVJSQjKVsk9+w8YfYs7wRPCTY/JTw43\n"
-"6R+hDmrfYi7LNQZReSzIJTj0+kuniVyc0uMNOYZKdHzVWYfCP04MXFL0PfdSgvHqo6z9STQa\n"
-"KPNBiDoT7uje/5kdX7rL6B7yuVBgwDHTc+XvvqDtMwt0viAgxGds8AgDelWAf0ZOlqf0Hj7h\n"
-"9tgJ4TNkK2PXMl6f+cB7D3hvl7yTmvmcEpB4eoCHFddydJxVdHixuuFucAS6T6C6aMN7/zHw\n"
-"cz09lCqxC0EOoP5NiGVreTO01wIDAQABo0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/\n"
-"BAUwAwEB/zAdBgNVHQ4EFgQU7UQZwNPwBovupHu+QucmVMiONnYwDQYJKoZIhvcNAQELBQAD\n"
-"ggIBAA2ukDL2pkt8RHYZYR4nKM1eVO8lvOMIkPkp165oCOGUAFjvLi5+U1KMtlwH6oi6mYtQ\n"
-"lNeCgN9hCQCTrQ0U5s7B8jeUeLBfnLOic7iPBZM4zY0+sLj7wM+x8uwtLRvM7Kqas6pgghst\n"
-"O8OEPVeKlh6cdbjTMM1gCIOQ045U8U1mwF10A0Cj7oV+wh93nAbowacYXVKV7cndJZ5t+qnt\n"
-"ozo00Fl72u1Q8zW/7esUTTHHYPTa8Yec4kjixsU3+wYQ+nVZZjFHKdp2mhzpgq7vmrlR94gj\n"
-"mmmVYjzlVYA211QC//G5Xc7UI2/YRYRKW2XviQzdFKcgyxilJbQN+QHwotL0AMh0jqEqSI5l\n"
-"2xPE4iUXfeu+h1sXIFRRk0pTAwvsXcoz7WL9RccvW9xYoIA55vrX/hMUpu09lEpCdNTDd1lz\n"
-"zY9GvlU47/rokTLql1gEIt44w8y8bckzOmoKaT+gyOpyj4xjhiO9bTyWnpXgSUyqorkqG5w2\n"
-"gXjtw+hG4iZZRHUe2XWJUc0QhJ1hYMtd+ZciTY6Y5uN/9lu7rs3KSoFrXgvzUeF0K+l+J6fZ\n"
-"mUlO+KWA2yUPHGNiiskzZ2s8EIPGrd6ozRaOjfAHN3Gf8qv8QfXBi+wAN10J5U6A7/qxXDgG\n"
-"pRtK4dw4LTzcqx+QGtVKnO7RcGzM7vRX+Bi6hG6H\n"
-"-----END CERTIFICATE-----\n",
-
-/* IdenTrust Public Sector Root CA 1 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIFZjCCA06gAwIBAgIQCgFCgAAAAUUjz0Z8AAAAAjANBgkqhkiG9w0BAQsFADBNMQswCQYD\n"
-"VQQGEwJVUzESMBAGA1UEChMJSWRlblRydXN0MSowKAYDVQQDEyFJZGVuVHJ1c3QgUHVibGlj\n"
-"IFNlY3RvciBSb290IENBIDEwHhcNMTQwMTE2MTc1MzMyWhcNMzQwMTE2MTc1MzMyWjBNMQsw\n"
-"CQYDVQQGEwJVUzESMBAGA1UEChMJSWRlblRydXN0MSowKAYDVQQDEyFJZGVuVHJ1c3QgUHVi\n"
-"bGljIFNlY3RvciBSb290IENBIDEwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC2\n"
-"IpT8pEiv6EdrCvsnduTyP4o7ekosMSqMjbCpwzFrqHd2hCa2rIFCDQjrVVi7evi8ZX3yoG2L\n"
-"qEfpYnYeEe4IFNGyRBb06tD6Hi9e28tzQa68ALBKK0CyrOE7S8ItneShm+waOh7wCLPQ5CQ1\n"
-"B5+ctMlSbdsHyo+1W/CD80/HLaXIrcuVIKQxKFdYWuSNG5qrng0M8gozOSI5Cpcu81N3uURF\n"
-"/YTLNiCBWS2ab21ISGHKTN9T0a9SvESfqy9rg3LvdYDaBjMbXcjaY8ZNzaxmMc3R3j6HEDbh\n"
-"uaR672BQssvKplbgN6+rNBM5Jeg5ZuSYeqoSmJxZZoY+rfGwyj4GD3vwEUs3oERte8uojHH0\n"
-"1bWRNszwFcYr3lEXsZdMUD2xlVl8BX0tIdUAvwFnol57plzy9yLxkA2T26pEUWbMfXYD62qo\n"
-"KjgZl3YNa4ph+bz27nb9cCvdKTz4Ch5bQhyLVi9VGxyhLrXHFub4qjySjmm2AcG1hp2JDws4\n"
-"lFTo6tyePSW8Uybt1as5qsVATFSrsrTZ2fjXctscvG29ZV/viDUqZi/u9rNl8DONfJhBaUYP\n"
-"Qxxp+pu10GFqzcpL2UyQRqsVWaFHVCkugyhfHMKiq3IXAAaOReyL4jM9f9oZRORicsPfIsby\n"
-"VtTdX5Vy7W1f90gDW/3FKqD2cyOEEBsB5wIDAQABo0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYD\n"
-"VR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQU43HgntinQtnbcZFrlJPrw6PRFKMwDQYJKoZIhvcN\n"
-"AQELBQADggIBAEf63QqwEZE4rU1d9+UOl1QZgkiHVIyqZJnYWv6IAcVYpZmxI1Qjt2odIFfl\n"
-"AWJBF9MJ23XLblSQdf4an4EKwt3X9wnQW3IV5B4Jaj0z8yGa5hV+rVHVDRDtfULAj+7AmgjV\n"
-"QdZcDiFpboBhDhXAuM/FSRJSzL46zNQuOAXeNf0fb7iAaJg9TaDKQGXSc3z1i9kKlT/YPyNt\n"
-"GtEqJBnZhbMX73huqVjRI9PHE+1yJX9dsXNw0H8GlwmEKYBhHfpe/3OsoOOJuBxxFcbeMX8S\n"
-"3OFtm6/n6J91eEyrRjuazr8FGF1NFTwWmhlQBJqymm9li1JfPFgEKCXAZmExfrngdbkaqIHW\n"
-"chezxQMxNRF4eKLg6TCMf4DfWN88uieW4oA0beOY02QnrEh+KHdcxiVhJfiFDGX6xDIvpZgF\n"
-"5PgLZxYWxoK4Mhn5+bl53B/N66+rDt0b20XkeucC4pVd/GnwU2lhlXV5C15V5jgclKlZM57I\n"
-"cXR5f1GJtshquDDIajjDbp7hNxbqBWJMWxJH7ae0s1hWx0nzfxJoCTFx8G34Tkf71oXuxVhA\n"
-"GaQdp/lLQzfcaFpPz+vCZHTetBXZ9FRUGi8c15dxVJCO2SCdUyt/q4/i6jC8UDfv8Ue1fXws\n"
-"BOxonbRJRBD0ckscZOf85muQ3Wl9af0AVqW3rLatt8o+Ae+c\n"
-"-----END CERTIFICATE-----\n",
-
-/* Entrust Root Certification Authority - G2 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIEPjCCAyagAwIBAgIESlOMKDANBgkqhkiG9w0BAQsFADCBvjELMAkGA1UEBhMCVVMxFjAU\n"
-"BgNVBAoTDUVudHJ1c3QsIEluYy4xKDAmBgNVBAsTH1NlZSB3d3cuZW50cnVzdC5uZXQvbGVn\n"
-"YWwtdGVybXMxOTA3BgNVBAsTMChjKSAyMDA5IEVudHJ1c3QsIEluYy4gLSBmb3IgYXV0aG9y\n"
-"aXplZCB1c2Ugb25seTEyMDAGA1UEAxMpRW50cnVzdCBSb290IENlcnRpZmljYXRpb24gQXV0\n"
-"aG9yaXR5IC0gRzIwHhcNMDkwNzA3MTcyNTU0WhcNMzAxMjA3MTc1NTU0WjCBvjELMAkGA1UE\n"
-"BhMCVVMxFjAUBgNVBAoTDUVudHJ1c3QsIEluYy4xKDAmBgNVBAsTH1NlZSB3d3cuZW50cnVz\n"
-"dC5uZXQvbGVnYWwtdGVybXMxOTA3BgNVBAsTMChjKSAyMDA5IEVudHJ1c3QsIEluYy4gLSBm\n"
-"b3IgYXV0aG9yaXplZCB1c2Ugb25seTEyMDAGA1UEAxMpRW50cnVzdCBSb290IENlcnRpZmlj\n"
-"YXRpb24gQXV0aG9yaXR5IC0gRzIwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC6\n"
-"hLZy254Ma+KZ6TABp3bqMriVQRrJ2mFOWHLP/vaCeb9zYQYKpSfYs1/TRU4cctZOMvJyig/3\n"
-"gxnQaoCAAEUesMfnmr8SVycco2gvCoe9amsOXmXzHHfV1IWNcCG0szLni6LVhjkCsbjSR87k\n"
-"yUnEO6fe+1R9V77w6G7CebI6C1XiUJgWMhNcL3hWwcKUs/Ja5CeanyTXxuzQmyWC48zCxEXF\n"
-"jJd6BmsqEZ+pCm5IO2/b1BEZQvePB7/1U1+cPvQXLOZprE4yTGJ36rfo5bs0vBmLrpxR57d+\n"
-"tVOxMyLlbc9wPBr64ptntoP0jaWvYkxN4FisZDQSA/i2jZRjJKRxAgMBAAGjQjBAMA4GA1Ud\n"
-"DwEB/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBRqciZ60B7vfec7aVHUbI2f\n"
-"kBJmqzANBgkqhkiG9w0BAQsFAAOCAQEAeZ8dlsa2eT8ijYfThwMEYGprmi5ZiXMRrEPR9RP/\n"
-"jTkrwPK9T3CMqS/qF8QLVJ7UG5aYMzyorWKiAHarWWluBh1+xLlEjZivEtRh2woZRkfz6/dj\n"
-"wUAFQKXSt/S1mja/qYh2iARVBCuch38aNzx+LaUa2NSJXsq9rD1s2G2v1fN2D807iDginWyT\n"
-"msQ9v4IbZT+mD12q/OWyFcq1rca8PdCE6OoGcrBNOTJ4vz4RnAuknZoh8/CbCzB428Hch0P+\n"
-"vGOaysXCHMnHjf87ElgI5rY97HosTvuDls4MPGmHVHOkc8KT/1EQrBVUAdj8BbGJoX90g5pJ\n"
-"19xOe4pIb4tF9g==\n"
-"-----END CERTIFICATE-----\n",
-
-/* Entrust Root Certification Authority - EC1 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIC+TCCAoCgAwIBAgINAKaLeSkAAAAAUNCR+TAKBggqhkjOPQQDAzCBvzELMAkGA1UEBhMC\n"
-"VVMxFjAUBgNVBAoTDUVudHJ1c3QsIEluYy4xKDAmBgNVBAsTH1NlZSB3d3cuZW50cnVzdC5u\n"
-"ZXQvbGVnYWwtdGVybXMxOTA3BgNVBAsTMChjKSAyMDEyIEVudHJ1c3QsIEluYy4gLSBmb3Ig\n"
-"YXV0aG9yaXplZCB1c2Ugb25seTEzMDEGA1UEAxMqRW50cnVzdCBSb290IENlcnRpZmljYXRp\n"
-"b24gQXV0aG9yaXR5IC0gRUMxMB4XDTEyMTIxODE1MjUzNloXDTM3MTIxODE1NTUzNlowgb8x\n"
-"CzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1FbnRydXN0LCBJbmMuMSgwJgYDVQQLEx9TZWUgd3d3\n"
-"LmVudHJ1c3QubmV0L2xlZ2FsLXRlcm1zMTkwNwYDVQQLEzAoYykgMjAxMiBFbnRydXN0LCBJ\n"
-"bmMuIC0gZm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxMzAxBgNVBAMTKkVudHJ1c3QgUm9vdCBD\n"
-"ZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSAtIEVDMTB2MBAGByqGSM49AgEGBSuBBAAiA2IABIQT\n"
-"ydC6bUF74mzQ61VfZgIaJPRbiWlH47jCffHyAsWfoPZb1YsGGYZPUxBtByQnoaD41UcZYUx9\n"
-"ypMn6nQM72+WCf5j7HBdNq1nd67JnXxVRDqiY1Ef9eNi1KlHBz7MIKNCMEAwDgYDVR0PAQH/\n"
-"BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFLdj5xrdjekIplWDpOBqUEFlEUJJ\n"
-"MAoGCCqGSM49BAMDA2cAMGQCMGF52OVCR98crlOZF7ZvHH3hvxGU0QOIdeSNiaSKd0bebWHv\n"
-"AvX7td/M/k7//qnmpwIwW5nXhTcGtXsI/esni0qU+eH6p44mCOh8kmhtc9hvJqwhAriZtyZB\n"
-"WyVgrtBIGu4G\n"
-"-----END CERTIFICATE-----\n",
-
-/* CFCA EV ROOT */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIFjTCCA3WgAwIBAgIEGErM1jANBgkqhkiG9w0BAQsFADBWMQswCQYDVQQGEwJDTjEwMC4G\n"
-"A1UECgwnQ2hpbmEgRmluYW5jaWFsIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MRUwEwYDVQQD\n"
-"DAxDRkNBIEVWIFJPT1QwHhcNMTIwODA4MDMwNzAxWhcNMjkxMjMxMDMwNzAxWjBWMQswCQYD\n"
-"VQQGEwJDTjEwMC4GA1UECgwnQ2hpbmEgRmluYW5jaWFsIENlcnRpZmljYXRpb24gQXV0aG9y\n"
-"aXR5MRUwEwYDVQQDDAxDRkNBIEVWIFJPT1QwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIK\n"
-"AoICAQDXXWvNED8fBVnVBU03sQ7smCuOFR36k0sXgiFxEFLXUWRwFsJVaU2OFW2fvwwbwuCj\n"
-"Z9YMrM8irq93VCpLTIpTUnrD7i7es3ElweldPe6hL6P3KjzJIx1qqx2hp/Hz7KDVRM8Vz3Iv\n"
-"HWOX6Jn5/ZOkVIBMUtRSqy5J35DNuF++P96hyk0g1CXohClTt7GIH//62pCfCqktQT+x8Rgp\n"
-"7hZZLDRJGqgG16iI0gNyejLi6mhNbiyWZXvKWfry4t3uMCz7zEasxGPrb382KzRzEpR/38wm\n"
-"nvFyXVBlWY9ps4deMm/DGIq1lY+wejfeWkU7xzbh72fROdOXW3NiGUgthxwG+3SYIElz8AXS\n"
-"G7Ggo7cbcNOIabla1jj0Ytwli3i/+Oh+uFzJlU9fpy25IGvPa931DfSCt/SyZi4QKPaXWnuW\n"
-"Fo8BGS1sbn85WAZkgwGDg8NNkt0yxoekN+kWzqotaK8KgWU6cMGbrU1tVMoqLUuFG7OA5nBF\n"
-"DWteNfB/O7ic5ARwiRIlk9oKmSJgamNgTnYGmE69g60dWIolhdLHZR4tjsbftsbhf4oEIRUp\n"
-"dPA+nJCdDC7xij5aqgwJHsfVPKPtl8MeNPo4+QgO48BdK4PRVmrJtqhUUy54Mmc9gn900Pvh\n"
-"tgVguXDbjgv5E1hvcWAQUhC5wUEJ73IfZzF4/5YFjQIDAQABo2MwYTAfBgNVHSMEGDAWgBTj\n"
-"/i39KNALtbq2osS/BqoFjJP7LzAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIBBjAd\n"
-"BgNVHQ4EFgQU4/4t/SjQC7W6tqLEvwaqBYyT+y8wDQYJKoZIhvcNAQELBQADggIBACXGumvr\n"
-"h8vegjmWPfBEp2uEcwPenStPuiB/vHiyz5ewG5zz13ku9Ui20vsXiObTej/tUxPQ4i9qecsA\n"
-"IyjmHjdXNYmEwnZPNDatZ8POQQaIxffu2Bq41gt/UP+TqhdLjOztUmCypAbqTuv0axn96/Ua\n"
-"4CUqmtzHQTb3yHQFhDmVOdYLO6Qn+gjYXB74BGBSESgoA//vU2YApUo0FmZ8/Qmkrp5nGm9B\n"
-"C2sGE5uPhnEFtC+NiWYzKXZUmhH4J/qyP5Hgzg0b8zAarb8iXRvTvyUFTeGSGn+ZnzxEk8rU\n"
-"QElsgIfXBDrDMlI1Dlb4pd19xIsNER9Tyx6yF7Zod1rg1MvIB671Oi6ON7fQAUtDKXeMOZeP\n"
-"glr4UeWJoBjnaH9dCi77o0cOPaYjesYBx4/IXr9tgFa+iiS6M+qf4TIRnvHST4D2G0CvOJ4R\n"
-"UHlzEhLN5mydLIhyPDCBBpEi6lmt2hkuIsKNuYyH4Ga8cyNfIWRjgEj1oDwYPZTISEEdQLpe\n"
-"/v5WOaHIz16eGWRGENoXkbcFgKyLmZJ956LYBws2J+dIeWCKw9cTXPhyQN9Ky8+ZAAoACxGV\n"
-"2lZFA4gKn2fQ1XmxqI1AbQ3CekD6819kR5LLU7m7Wc5P/dAVUwHY3+vZ5nbv0CO7O6l5s9UC\n"
-"Kc2Jo5YPSjXnTkLAdc0Hz+Ys63su\n"
-"-----END CERTIFICATE-----\n",
-
-/* TRKTRUST Elektronik Sertifika Hizmet Salaycs H5 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIEJzCCAw+gAwIBAgIHAI4X/iQggTANBgkqhkiG9w0BAQsFADCBsTELMAkGA1UEBhMCVFIx\n"
-"DzANBgNVBAcMBkFua2FyYTFNMEsGA1UECgxEVMOcUktUUlVTVCBCaWxnaSDEsGxldGnFn2lt\n"
-"IHZlIEJpbGnFn2ltIEfDvHZlbmxpxJ9pIEhpem1ldGxlcmkgQS7Fni4xQjBABgNVBAMMOVTD\n"
-"nFJLVFJVU1QgRWxla3Ryb25payBTZXJ0aWZpa2EgSGl6bWV0IFNhxJ9sYXnEsWPEsXPEsSBI\n"
-"NTAeFw0xMzA0MzAwODA3MDFaFw0yMzA0MjgwODA3MDFaMIGxMQswCQYDVQQGEwJUUjEPMA0G\n"
-"A1UEBwwGQW5rYXJhMU0wSwYDVQQKDERUw5xSS1RSVVNUIEJpbGdpIMSwbGV0acWfaW0gdmUg\n"
-"QmlsacWfaW0gR8O8dmVubGnEn2kgSGl6bWV0bGVyaSBBLsWeLjFCMEAGA1UEAww5VMOcUktU\n"
-"UlVTVCBFbGVrdHJvbmlrIFNlcnRpZmlrYSBIaXptZXQgU2HEn2xhecSxY8Sxc8SxIEg1MIIB\n"
-"IjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEApCUZ4WWe60ghUEoI5RHwWrom/4NZzkQq\n"
-"L/7hzmAD/I0Dpe3/a6i6zDQGn1k19uwsu537jVJp45wnEFPzpALFp/kRGml1bsMdi9GYjZOH\n"
-"p3GXDSHHmflS0yxjXVW86B8BSLlg/kJK9siArs1mep5Fimh34khon6La8eHBEJ/rPCmBp+Ey\n"
-"CNSgBbGM+42WAA4+Jd9ThiI7/PS98wl+d+yG6w8z5UNP9FR1bSmZLmZaQ9/LXMrI5Tjxfjs1\n"
-"nQ/0xVqhzPMggCTTV+wVunUlm+hkS7M0hO8EuPbJbKoCPrZV4jI3X/xml1/N1p7HIL9Nxqw/\n"
-"dV8c7TKcfGkAaZHjIxhT6QIDAQABo0IwQDAdBgNVHQ4EFgQUVpkHHtOsDGlktAxQR95DLL4g\n"
-"wPswDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQELBQADggEB\n"
-"AJ5FdnsXSDLyOIspve6WSk6BGLFRRyDN0GSxDsnZAdkJzsiZ3GglE9Rc8qPoBP5yCccLqh0l\n"
-"VX6Wmle3usURehnmp349hQ71+S4pL+f5bFgWV1Al9j4uPqrtd3GqqpmWRgqujuwqURawXs3q\n"
-"ZwQcWDD1YIq9pr1N5Za0/EKJAWv2cMhQOQwt1WbZyNKzMrcbGW3LM/nfpeYVhDfwwvJllpKQ\n"
-"d/Ct9JDpEXjXk4nAPQu6KfTomZ1yju2dL+6SfaHx/126M2CFYv4HAqGEVka+lgqaE9chTLd8\n"
-"B59OTj+RdPsnnRHM3eaxynFNExc5JsUpISuTKWqW+qtB4Uu2NQvAmxU=\n"
-"-----END CERTIFICATE-----\n",
-
-/* TRKTRUST Elektronik Sertifika Hizmet Salaycs H6 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIEJjCCAw6gAwIBAgIGfaHyZeyKMA0GCSqGSIb3DQEBCwUAMIGxMQswCQYDVQQGEwJUUjEP\n"
-"MA0GA1UEBwwGQW5rYXJhMU0wSwYDVQQKDERUw5xSS1RSVVNUIEJpbGdpIMSwbGV0acWfaW0g\n"
-"dmUgQmlsacWfaW0gR8O8dmVubGnEn2kgSGl6bWV0bGVyaSBBLsWeLjFCMEAGA1UEAww5VMOc\n"
-"UktUUlVTVCBFbGVrdHJvbmlrIFNlcnRpZmlrYSBIaXptZXQgU2HEn2xhecSxY8Sxc8SxIEg2\n"
-"MB4XDTEzMTIxODA5MDQxMFoXDTIzMTIxNjA5MDQxMFowgbExCzAJBgNVBAYTAlRSMQ8wDQYD\n"
-"VQQHDAZBbmthcmExTTBLBgNVBAoMRFTDnFJLVFJVU1QgQmlsZ2kgxLBsZXRpxZ9pbSB2ZSBC\n"
-"aWxpxZ9pbSBHw7x2ZW5sacSfaSBIaXptZXRsZXJpIEEuxZ4uMUIwQAYDVQQDDDlUw5xSS1RS\n"
-"VVNUIEVsZWt0cm9uaWsgU2VydGlmaWthIEhpem1ldCBTYcSfbGF5xLFjxLFzxLEgSDYwggEi\n"
-"MA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCdsGjW6L0UlqMACprx9MfMkU1xeHe59yEm\n"
-"FXNRFpQJRwXiM/VomjX/3EsvMsew7eKC5W/a2uqsxgbPJQ1BgfbBOCK9+bGlprMBvD9QFyv2\n"
-"6WZV1DOzXPhDIHiTVRZwGTLmiddk671IUP320EEDwnS3/faAz1vFq6TWlRKb55cTMgPp1KtD\n"
-"WxbtMyJkKbbSk60vbNg9tvYdDjTu0n2pVQ8g9P0pu5FbHH3GQjhtQiht1AH7zYiXSX6484P4\n"
-"tZgvsycLSF5W506jM7NE1qXyGJTtHB6plVxiSvgNZ1GpryHV+DKdeboaX+UEVU0TRv/yz3TH\n"
-"GmNtwx8XEsMeED5gCLMxAgMBAAGjQjBAMB0GA1UdDgQWBBTdVRcT9qzoSCHK77Wv0QAy7Z6M\n"
-"tTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zANBgkqhkiG9w0BAQsFAAOCAQEA\n"
-"b1gNl0OqFlQ+v6nfkkU/hQu7VtMMUszIv3ZnXuaqs6fvuay0EBQNdH49ba3RfdCaqaXKGDsC\n"
-"QC4qnFAUi/5XfldcEQlLNkVS9z2sFP1E34uXI9TDwe7UU5X+LEr+DXCqu4svLcsyo4LyVN/Y\n"
-"8t3XSHLuSqMplsNEzm61kod2pLv0kmzOLBQJZo6NrRa1xxsJYTvjIKIDgI6tflEATseWhvtD\n"
-"mHd9KMeP2Cpu54Rvl0EpABZeTeIT6lnAY2c6RPuY/ATTMHKm9ocJV612ph1jmv3XZch4gyt1\n"
-"O6VbuA1df74jrlZVlFjvH4GMKrLN5ptjnhi85WsGtAuYSyher4hYyw==\n"
-"-----END CERTIFICATE-----\n",
-
-/* Certinomis - Root CA */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIFkjCCA3qgAwIBAgIBATANBgkqhkiG9w0BAQsFADBaMQswCQYDVQQGEwJGUjETMBEGA1UE\n"
-"ChMKQ2VydGlub21pczEXMBUGA1UECxMOMDAwMiA0MzM5OTg5MDMxHTAbBgNVBAMTFENlcnRp\n"
-"bm9taXMgLSBSb290IENBMB4XDTEzMTAyMTA5MTcxOFoXDTMzMTAyMTA5MTcxOFowWjELMAkG\n"
-"A1UEBhMCRlIxEzARBgNVBAoTCkNlcnRpbm9taXMxFzAVBgNVBAsTDjAwMDIgNDMzOTk4OTAz\n"
-"MR0wGwYDVQQDExRDZXJ0aW5vbWlzIC0gUm9vdCBDQTCCAiIwDQYJKoZIhvcNAQEBBQADggIP\n"
-"ADCCAgoCggIBANTMCQosP5L2fxSeC5yaah1AMGT9qt8OHgZbn1CF6s2Nq0Nn3rD6foCWnoR4\n"
-"kkjW4znuzuRZWJflLieY6pOod5tK8O90gC3rMB+12ceAnGInkYjwSond3IjmFPnVAy//ldu9\n"
-"n+ws+hQVWZUKxkd8aRi5pwP5ynapz8dvtF4F/u7BUrJ1Mofs7SlmO/NKFoL21prbcpjp3vDF\n"
-"TKWrteoB4owuZH9kb/2jJZOLyKIOSY008B/sWEUuNKqEUL3nskoTuLAPrjhdsKkb5nPJWqHZ\n"
-"ZkCqqU2mNAKthH6yI8H7KsZn9DS2sJVqM09xRLWtwHkziOC/7aOgFLScCbAK42C++PhmiM1b\n"
-"8XcF4LVzbsF9Ri6OSyemzTUK/eVNfaoqoynHWmgE6OXWk6RiwsXm9E/G+Z8ajYJJGYrKWUM6\n"
-"6A0ywfRMEwNvbqY/kXPLynNvEiCL7sCCeN5LLsJJwx3tFvYk9CcbXFcx3FXuqB5vbKziRcxX\n"
-"V4p1VxngtViZSTYxPDMBbRZKzbgqg4SGm/lg0h9tkQPTYKbVPZrdd5A9NaSfD171UkRpucC6\n"
-"3M9933zZxKyGIjK8e2uR73r4F2iw4lNVYC2vPsKD2NkJK/DAZNuHi5HMkesE/Xa0lZrmFAYb\n"
-"1TQdvtj/dBxThZngWVJKYe2InmtJiUZ+IFrZ50rlau7SZRFDAgMBAAGjYzBhMA4GA1UdDwEB\n"
-"/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBTvkUz1pcMw6C8I6tNxIqSSaHh0\n"
-"2TAfBgNVHSMEGDAWgBTvkUz1pcMw6C8I6tNxIqSSaHh02TANBgkqhkiG9w0BAQsFAAOCAgEA\n"
-"fj1U2iJdGlg+O1QnurrMyOMaauo++RLrVl89UM7g6kgmJs95Vn6RHJk/0KGRHCwPT5iVWVO9\n"
-"0CLYiF2cN/z7ZMF4jIuaYAnq1fohX9B0ZedQxb8uuQsLrbWwF6YSjNRieOpWauwK0kDDPAUw\n"
-"Pk2Ut59KA9N9J0u2/kTO+hkzGm2kQtHdzMjI1xZSg081lLMSVX3l4kLr5JyTCcBMWwerx20R\n"
-"oFAXlCOotQqSD7J6wWAsOMwaplv/8gzjqh8c3LigkyfeY+N/IZ865Z764BNqdeuWXGKRlI5n\n"
-"U7aJ+BIJy29SWwNyhlCVCNSNh4YVH5Uk2KRvms6knZtt0rJ2BobGVgjF6wnaNsIbW0G+YSrj\n"
-"cOa4pvi2WsS9Iff/ql+hbHY5ZtbqTFXhADObE5hjyW/QASAJN1LnDE8+zbz1X5YnpyACleAu\n"
-"6AdBBR8Vbtaw5BngDwKTACdyxYvRVB9dSsNAl35VpnzBMwQUAR1JIGkLGZOdblgi90AMRgwj\n"
-"Y/M50n92Uaf0yKHxDHYiI0ZSKS3io0EHVmmY0gUJvGnHWmHNj4FgFU2A3ZDifcRQ8ow7bkrH\n"
-"xuaAKzyBvBGAFhAn1/DNP3nMcyrDflOR1m749fPH0FFNjkulW+YZFzvWgQncItzujrnEj1Ph\n"
-"Z7szuIgVRs/taTX/dQ1G885x4cVrhkIGuUE=\n"
-"-----END CERTIFICATE-----\n",
-
-/* OISTE WISeKey Global Root GB CA */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDtTCCAp2gAwIBAgIQdrEgUnTwhYdGs/gjGvbCwDANBgkqhkiG9w0BAQsFADBtMQswCQYD\n"
-"VQQGEwJDSDEQMA4GA1UEChMHV0lTZUtleTEiMCAGA1UECxMZT0lTVEUgRm91bmRhdGlvbiBF\n"
-"bmRvcnNlZDEoMCYGA1UEAxMfT0lTVEUgV0lTZUtleSBHbG9iYWwgUm9vdCBHQiBDQTAeFw0x\n"
-"NDEyMDExNTAwMzJaFw0zOTEyMDExNTEwMzFaMG0xCzAJBgNVBAYTAkNIMRAwDgYDVQQKEwdX\n"
-"SVNlS2V5MSIwIAYDVQQLExlPSVNURSBGb3VuZGF0aW9uIEVuZG9yc2VkMSgwJgYDVQQDEx9P\n"
-"SVNURSBXSVNlS2V5IEdsb2JhbCBSb290IEdCIENBMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A\n"
-"MIIBCgKCAQEA2Be3HEokKtaXscriHvt9OO+Y9bI5mE4nuBFde9IllIiCFSZqGzG7qFshISvY\n"
-"D06fWvGxWuR51jIjK+FTzJlFXHtPrby/h0oLS5daqPZI7H17Dc0hBt+eFf1Biki3IPShehtX\n"
-"1F1Q/7pn2COZH8g/497/b1t3sWtuuMlk9+HKQUYOKXHQuSP8yYFfTvdv37+ErXNku7dCjmn2\n"
-"1HYdfp2nuFeKUWdy19SouJVUQHMD9ur06/4oQnc/nSMbsrY9gBQHTC5P99UKFg29ZkM3fiND\n"
-"ecNAhvVMKdqOmq0NpQSHiB6F4+lT1ZvIiwNjeOvgGUpuuy9rM2RYk61pv48b74JIxwIDAQAB\n"
-"o1EwTzALBgNVHQ8EBAMCAYYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUNQ/INmNe4qPs\n"
-"+TtmFc5RUuORmj0wEAYJKwYBBAGCNxUBBAMCAQAwDQYJKoZIhvcNAQELBQADggEBAEBM+4ey\n"
-"mYGQfp3FsLAmzYh7KzKNbrghcViXfa43FK8+5/ea4n32cZiZBKpDdHij40lhPnOMTZTg+XHE\n"
-"thYOU3gf1qKHLwI5gSk8rxWYITD+KJAAjNHhy/peyP34EEY7onhCkRd0VQreUGdNZtGn//3Z\n"
-"wLWoo4rOZvUPQ82nK1d7Y0Zqqi5S2PTt4W2tKZB4SLrhI6qjiey1q5bAtEuiHZeeevJuQHHf\n"
-"aPFlTc58Bd9TZaml8LGXBHAVRgOY1NK/VLSgWH1Sb9pWJmLU2NuJMW8c8CLC02IcNc1MaRVU\n"
-"GpCY3useX8p3x8uOPUNpnJpY0CQ73xtAln41rYHHTnG6iBM=\n"
-"-----END CERTIFICATE-----\n",
-
-/* Certification Authority of WoSign G2 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDfDCCAmSgAwIBAgIQayXaioidfLwPBbOxemFFRDANBgkqhkiG9w0BAQsFADBYMQswCQYD\n"
-"VQQGEwJDTjEaMBgGA1UEChMRV29TaWduIENBIExpbWl0ZWQxLTArBgNVBAMTJENlcnRpZmlj\n"
-"YXRpb24gQXV0aG9yaXR5IG9mIFdvU2lnbiBHMjAeFw0xNDExMDgwMDU4NThaFw00NDExMDgw\n"
-"MDU4NThaMFgxCzAJBgNVBAYTAkNOMRowGAYDVQQKExFXb1NpZ24gQ0EgTGltaXRlZDEtMCsG\n"
-"A1UEAxMkQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkgb2YgV29TaWduIEcyMIIBIjANBgkqhkiG\n"
-"9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvsXEoCKASU+/2YcRxlPhuw+9YH+v9oIOH9ywjj2X4FA8\n"
-"jzrvZjtFB5sg+OPXJYY1kBaiXW8wGQiHC38Gsp1ij96vkqVg1CuAmlI/9ZqD6TRay9nVYlzm\n"
-"DuDfBpgOgHzKtB0TiGsOqCR3A9DuW/PKaZE1OVbFbeP3PU9ekzgkyhjpJMuSA93MHD0JcOQg\n"
-"5PGurLtzaaNjOg9FD6FKmsLRY6zLEPg95k4ot+vElbGs/V6r+kHLXZ1L3PR8du9nfwB6jdKg\n"
-"GlxNIuG12t12s9R23164i5jIFFTMaxeSt+BKv0mUYQs4kI9dJGwlezt52eJ+na2fmKEG/HgU\n"
-"YFf47oB3sQIDAQABo0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNV\n"
-"HQ4EFgQU+mCp62XF3RYUCE4MD42b4Pdkr2cwDQYJKoZIhvcNAQELBQADggEBAFfDejaCnI2Y\n"
-"4qtAqkePx6db7XznPWZaOzG73/MWM5H8fHulwqZm46qwtyeYP0nXYGdnPzZPSsvxFPpahygc\n"
-"7Y9BMsaV+X3avXtbwrAh449G3CE4Q3RM+zD4F3LBMvzIkRfEzFg3TgvMWvchNSiDbGAtROtS\n"
-"jFA9tWwS1/oJu2yySrHFieT801LYYRf+epSEj3m2M1m6D8QL4nCgS3gu+sif/a+RZQp4OBXl\n"
-"lxcU3fngLDT4ONCEIgDAFFEYKwLcMFrw6AF8NTojrwjkr6qOKEJJLvD1mTS+7Q9LGOHSJDy7\n"
-"XUe3IfKN0QqZjuNuPq1w4I+5ysxugTH2e5x6eeRncRg=\n"
-"-----END CERTIFICATE-----\n",
-
-/* CA WoSign ECC Root */
-"-----BEGIN CERTIFICATE-----\n"
-"MIICCTCCAY+gAwIBAgIQaEpYcIBr8I8C+vbe6LCQkDAKBggqhkjOPQQDAzBGMQswCQYDVQQG\n"
-"EwJDTjEaMBgGA1UEChMRV29TaWduIENBIExpbWl0ZWQxGzAZBgNVBAMTEkNBIFdvU2lnbiBF\n"
-"Q0MgUm9vdDAeFw0xNDExMDgwMDU4NThaFw00NDExMDgwMDU4NThaMEYxCzAJBgNVBAYTAkNO\n"
-"MRowGAYDVQQKExFXb1NpZ24gQ0EgTGltaXRlZDEbMBkGA1UEAxMSQ0EgV29TaWduIEVDQyBS\n"
-"b290MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE4f2OuEMkq5Z7hcK6C62N4DrjJLnSsb6IOsq/\n"
-"Srj57ywvr1FQPEd1bPiUt5v8KB7FVMxjnRZLU8HnIKvNrCXSf4/CwVqCXjCLelTOA7WRf6qU\n"
-"0NGKSMyCBSah1VES1ns2o0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAd\n"
-"BgNVHQ4EFgQUqv3VWqP2h4syhf3RMluARZPzA7gwCgYIKoZIzj0EAwMDaAAwZQIxAOSkhLCB\n"
-"1T2wdKyUpOgOPQB0TKGXa/kNUTyh2Tv0Daupn75OcsqF1NnstTJFGG+rrQIwfcf3aWMvoeGY\n"
-"7xMQ0Xk/0f7qO3/eVvSQsRUR2LIiFdAvwyYua/GRspBl9JrmkO5K\n"
-"-----END CERTIFICATE-----\n",
-
-/* SZAFIR ROOT CA2 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIDcjCCAlqgAwIBAgIUPopdB+xV0jLVt+O2XwHrLdzk1uQwDQYJKoZIhvcNAQELBQAwUTEL\n"
-"MAkGA1UEBhMCUEwxKDAmBgNVBAoMH0tyYWpvd2EgSXpiYSBSb3psaWN6ZW5pb3dhIFMuQS4x\n"
-"GDAWBgNVBAMMD1NaQUZJUiBST09UIENBMjAeFw0xNTEwMTkwNzQzMzBaFw0zNTEwMTkwNzQz\n"
-"MzBaMFExCzAJBgNVBAYTAlBMMSgwJgYDVQQKDB9LcmFqb3dhIEl6YmEgUm96bGljemVuaW93\n"
-"YSBTLkEuMRgwFgYDVQQDDA9TWkFGSVIgUk9PVCBDQTIwggEiMA0GCSqGSIb3DQEBAQUAA4IB\n"
-"DwAwggEKAoIBAQC3vD5QqEvNQLXOYeeWyrSh2gwisPq1e3YAd4wLz32ohswmUeQgPYUM1ljj\n"
-"5/QqGJ3a0a4m7utT3PSQ1hNKDJA8w/Ta0o4NkjrcsbH/ON7Dui1fgLkCvUqdGw+0w8LBZwPd\n"
-"3BucPbOw3gAeqDRHu5rr/gsUvTaE2g0gv/pby6kWIK05YO4vdbbnl5z5Pv1+TW9NL++IDWr6\n"
-"3fE9biCloBK0TXC5ztdyO4mTp4CEHCdJckm1/zuVnsHMyAHs6A6KCpbns6aH5db5BSsNl0Bw\n"
-"PLqsdVqc1U2dAgrSS5tmS0YHF2Wtn2yIANwiieDhZNRnvDF5YTy7ykHNXGoAyDw4jlivAgMB\n"
-"AAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgEGMB0GA1UdDgQWBBQuFqlK\n"
-"GLXLzPVvUPMjX/hd56zwyDANBgkqhkiG9w0BAQsFAAOCAQEAtXP4A9xZWx126aMqe5Aosk3A\n"
-"M0+qmrHUuOQn/6mWmc5G4G18TKI4pAZw8PRBEew/R40/cof5O/2kbytTAOD/OblqBw7rHRz2\n"
-"onKQy4I9EYKL0rufKq8h5mOGnXkZ7/e7DDWQw4rtTw/1zBLZpD67oPwglV9PJi8RI4NOdQcP\n"
-"v5vRtB3pEAT+ymCPoky4rc/hkA/NrgrHXXu3UNLUYfrVFdvXn4dRVOul4+vJhaAlIDf7js4M\n"
-"NIThPIGyd05DpYhfhmehPea0XGG2Ptv+tyjFogeutcrKjSoS75ftwjCkySp6+/NNIxuZMzSg\n"
-"LvWpCz/UXeHPhJ/iGcJfitYgHuNztw==\n"
-"-----END CERTIFICATE-----\n",
-
-/* Certum Trusted Network CA 2 */
-"-----BEGIN CERTIFICATE-----\n"
-"MIIF0jCCA7qgAwIBAgIQIdbQSk8lD8kyN/yqXhKN6TANBgkqhkiG9w0BAQ0FADCBgDELMAkG\n"
-"A1UEBhMCUEwxIjAgBgNVBAoTGVVuaXpldG8gVGVjaG5vbG9naWVzIFMuQS4xJzAlBgNVBAsT\n"
-"HkNlcnR1bSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTEkMCIGA1UEAxMbQ2VydHVtIFRydXN0\n"
-"ZWQgTmV0d29yayBDQSAyMCIYDzIwMTExMDA2MDgzOTU2WhgPMjA0NjEwMDYwODM5NTZaMIGA\n"
-"MQswCQYDVQQGEwJQTDEiMCAGA1UEChMZVW5pemV0byBUZWNobm9sb2dpZXMgUy5BLjEnMCUG\n"
-"A1UECxMeQ2VydHVtIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MSQwIgYDVQQDExtDZXJ0dW0g\n"
-"VHJ1c3RlZCBOZXR3b3JrIENBIDIwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC9\n"
-"+Xj45tWADGSdhhuWZGc/IjoedQF97/tcZ4zJzFxrqZHmuULlIEub2pt7uZld2ZuAS9eEQCsn\n"
-"0+i6MLs+CRqnSZXvK0AkwpfHp+6bJe+oCgCXhVqqndwpyeI1B+twTUrWwbNWuKFBOJvR+zF/\n"
-"j+Bf4bE/D44WSWDXBo0Y+aomEKsq09DRZ40bRr5HMNUuctHFY9rnY3lEfktjJImGLjQ/KUxS\n"
-"iyqnwOKRKIm5wFv5HdnnJ63/mgKXwcZQkpsCLL2puTRZCr+ESv/f/rOf69me4Jgj7KZrdxYq\n"
-"28ytOxykh9xGc14ZYmhFV+SQgkK7QtbwYeDBoz1mo130GO6IyY0XRSmZMnUCMe4pJshrAua1\n"
-"YkV/NxVaI2iJ1D7eTiew8EAMvE0Xy02isx7QBlrd9pPPV3WZ9fqGGmd4s7+W/jTcvedSVuWz\n"
-"5XV710GRBdxdaeOVDUO5/IOWOZV7bIBaTxNyxtd9KXpEulKkKtVBRgkg/iKgtlswjbyJDNXX\n"
-"cPiHUv3a76xRLgezTv7QCdpw75j6VuZt27VXS9zlLCUVyJ4ueE742pyehizKV/Ma5ciSixqC\n"
-"lnrDvFASadgOWkaLOusm+iPJtrCBvkIApPjW/jAux9JG9uWOdf3yzLnQh1vMBhBgu4M1t15n\n"
-"3kfsmUjxpKEV/q2MYo45VU85FrmxY53/twIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0G\n"
-"A1UdDgQWBBS2oVQ5AsOgP46KvPrU+Bym0ToO/TAOBgNVHQ8BAf8EBAMCAQYwDQYJKoZIhvcN\n"
-"AQENBQADggIBAHGlDs7k6b8/ONWJWsQCYftMxRQXLYtPU2sQF/xlhMcQSZDe28cmk4gmb3DW\n"
-"Al45oPePq5a1pRNcgRRtDoGCERuKTsZPpd1iHkTfCVn0W3cLN+mLIMb4Ck4uWBzrM9DPhmDJ\n"
-"2vuAL55MYIR4PSFk1vtBHxgP58l1cb29XN40hz5BsA72udY/CROWFC/emh1auVbONTqwX3BN\n"
-"XuMp8SMoclm2q8KMZiYcdywmdjWLKKdpoPk79SPdhRB0yZADVpHnr7pH1BKXESLjokmUbOe3\n"
-"lEu6LaTaM4tMpkT/WjzGHWTYtTHkpjx6qFcL2+1hGsvxznN3Y6SHb0xRONbkX8eftoEq5IVI\n"
-"eVheO/jbAoJnwTnbw3RLPTYe+SmTiGhbqEQZIfCn6IENLOiTNrQ3ssqwGyZ6miUfmpqAnksq\n"
-"P/ujmv5zMnHCnsZy4YpoJ/HkD7TETKVhk/iXEAcqMCWpuchxuO9ozC1+9eB+D4Kob7a6bIND\n"
-"d82Kkhehnlt4Fj1F4jNy3eFmypnTycUm/Q1oBEauttmbjL4ZvrHG8hnjXALKLNhvSgfZyTXa\n"
-"QHXyxKcZb55CEJh15pWLYLztxRLXis7VmFxWlgPF7ncGNf/P5O4/E2Hu29othfDNrp2yGAlF\n"
-"w5Khchf8R7agCyzxxN5DaAhqXzvwdmP7zAYspsbiDrW5viSP\n"
-"-----END CERTIFICATE-----\n",
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/node_stat_watcher.h
+++ /dev/null
@@ -1,43 +0,0 @@
-#ifndef SRC_NODE_STAT_WATCHER_H_
-#define SRC_NODE_STAT_WATCHER_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "node.h"
-#include "async-wrap.h"
-#include "env.h"
-#include "uv.h"
-#include "v8.h"
-
-namespace node {
-
-class StatWatcher : public AsyncWrap {
- public:
-  ~StatWatcher() override;
-
-  static void Initialize(Environment* env, v8::Local<v8::Object> target);
-
- protected:
-  StatWatcher(Environment* env, v8::Local<v8::Object> wrap);
-
-  static void New(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void Start(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void Stop(const v8::FunctionCallbackInfo<v8::Value>& args);
-
-  size_t self_size() const override { return sizeof(*this); }
-
- private:
-  static void Callback(uv_fs_poll_t* handle,
-                       int status,
-                       const uv_stat_t* prev,
-                       const uv_stat_t* curr);
-  void Stop();
-
-  uv_fs_poll_t* watcher_;
-};
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_NODE_STAT_WATCHER_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/node_url.h
+++ /dev/null
@@ -1,632 +0,0 @@
-#ifndef SRC_NODE_URL_H_
-#define SRC_NODE_URL_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "node.h"
-#include <string>
-
-namespace node {
-namespace url {
-
-#define BIT_AT(a, i)                                                          \
-  (!!((unsigned int) (a)[(unsigned int) (i) >> 3] &                           \
-  (1 << ((unsigned int) (i) & 7))))
-#define TAB_AND_NEWLINE(ch)                                                   \
-  (ch == 0x09 || ch == 0x0a || ch == 0x0d)
-#define ASCII_DIGIT(ch)                                                       \
-  (ch >= 0x30 && ch <= 0x39)
-#define ASCII_HEX_DIGIT(ch)                                                   \
-  (ASCII_DIGIT(ch) || (ch >= 0x41 && ch <= 0x46) || (ch >= 0x61 && ch <= 0x66))
-#define ASCII_ALPHA(ch)                                                       \
-  ((ch >= 0x41 && ch <= 0x5a) || (ch >= 0x61 && ch <= 0x7a))
-#define ASCII_ALPHANUMERIC(ch)                                                \
-  (ASCII_DIGIT(ch) || ASCII_ALPHA(ch))
-#define TO_LOWER(ch)                                                          \
-  (ASCII_ALPHA(ch) ? (ch | 0x20) : ch)
-#define SCHEME_CHAR(ch)                                                       \
-  (ASCII_ALPHANUMERIC(ch) || ch == '+' || ch == '-' || ch == '.')
-#define WINDOWS_DRIVE_LETTER(ch, next)                                        \
-  (ASCII_ALPHA(ch) && (next == ':' || next == '|'))
-#define NORMALIZED_WINDOWS_DRIVE_LETTER(str)                                  \
-  (str.length() == 2 &&                                                       \
-  ASCII_ALPHA(str[0]) &&                                                      \
-  str[1] == ':')
-
-static const char* hex[256] = {
-  "%00", "%01", "%02", "%03", "%04", "%05", "%06", "%07",
-  "%08", "%09", "%0A", "%0B", "%0C", "%0D", "%0E", "%0F",
-  "%10", "%11", "%12", "%13", "%14", "%15", "%16", "%17",
-  "%18", "%19", "%1A", "%1B", "%1C", "%1D", "%1E", "%1F",
-  "%20", "%21", "%22", "%23", "%24", "%25", "%26", "%27",
-  "%28", "%29", "%2A", "%2B", "%2C", "%2D", "%2E", "%2F",
-  "%30", "%31", "%32", "%33", "%34", "%35", "%36", "%37",
-  "%38", "%39", "%3A", "%3B", "%3C", "%3D", "%3E", "%3F",
-  "%40", "%41", "%42", "%43", "%44", "%45", "%46", "%47",
-  "%48", "%49", "%4A", "%4B", "%4C", "%4D", "%4E", "%4F",
-  "%50", "%51", "%52", "%53", "%54", "%55", "%56", "%57",
-  "%58", "%59", "%5A", "%5B", "%5C", "%5D", "%5E", "%5F",
-  "%60", "%61", "%62", "%63", "%64", "%65", "%66", "%67",
-  "%68", "%69", "%6A", "%6B", "%6C", "%6D", "%6E", "%6F",
-  "%70", "%71", "%72", "%73", "%74", "%75", "%76", "%77",
-  "%78", "%79", "%7A", "%7B", "%7C", "%7D", "%7E", "%7F",
-  "%80", "%81", "%82", "%83", "%84", "%85", "%86", "%87",
-  "%88", "%89", "%8A", "%8B", "%8C", "%8D", "%8E", "%8F",
-  "%90", "%91", "%92", "%93", "%94", "%95", "%96", "%97",
-  "%98", "%99", "%9A", "%9B", "%9C", "%9D", "%9E", "%9F",
-  "%A0", "%A1", "%A2", "%A3", "%A4", "%A5", "%A6", "%A7",
-  "%A8", "%A9", "%AA", "%AB", "%AC", "%AD", "%AE", "%AF",
-  "%B0", "%B1", "%B2", "%B3", "%B4", "%B5", "%B6", "%B7",
-  "%B8", "%B9", "%BA", "%BB", "%BC", "%BD", "%BE", "%BF",
-  "%C0", "%C1", "%C2", "%C3", "%C4", "%C5", "%C6", "%C7",
-  "%C8", "%C9", "%CA", "%CB", "%CC", "%CD", "%CE", "%CF",
-  "%D0", "%D1", "%D2", "%D3", "%D4", "%D5", "%D6", "%D7",
-  "%D8", "%D9", "%DA", "%DB", "%DC", "%DD", "%DE", "%DF",
-  "%E0", "%E1", "%E2", "%E3", "%E4", "%E5", "%E6", "%E7",
-  "%E8", "%E9", "%EA", "%EB", "%EC", "%ED", "%EE", "%EF",
-  "%F0", "%F1", "%F2", "%F3", "%F4", "%F5", "%F6", "%F7",
-  "%F8", "%F9", "%FA", "%FB", "%FC", "%FD", "%FE", "%FF"
-};
-
-static const uint8_t SIMPLE_ENCODE_SET[32] = {
-  // 00     01     02     03     04     05     06     07
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // 08     09     0A     0B     0C     0D     0E     0F
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // 10     11     12     13     14     15     16     17
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // 18     19     1A     1B     1C     1D     1E     1F
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // 20     21     22     23     24     25     26     27
-    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 28     29     2A     2B     2C     2D     2E     2F
-    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 30     31     32     33     34     35     36     37
-    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 38     39     3A     3B     3C     3D     3E     3F
-    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 40     41     42     43     44     45     46     47
-    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 48     49     4A     4B     4C     4D     4E     4F
-    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 50     51     52     53     54     55     56     57
-    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 58     59     5A     5B     5C     5D     5E     5F
-    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 60     61     62     63     64     65     66     67
-    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 68     69     6A     6B     6C     6D     6E     6F
-    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 70     71     72     73     74     75     76     77
-    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 78     79     7A     7B     7C     7D     7E     7F
-    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x80,
-  // 80     81     82     83     84     85     86     87
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // 88     89     8A     8B     8C     8D     8E     8F
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // 90     91     92     93     94     95     96     97
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // 98     99     9A     9B     9C     9D     9E     9F
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // A0     A1     A2     A3     A4     A5     A6     A7
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // A8     A9     AA     AB     AC     AD     AE     AF
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // B0     B1     B2     B3     B4     B5     B6     B7
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // B8     B9     BA     BB     BC     BD     BE     BF
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // C0     C1     C2     C3     C4     C5     C6     C7
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // C8     C9     CA     CB     CC     CD     CE     CF
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // D0     D1     D2     D3     D4     D5     D6     D7
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // D8     D9     DA     DB     DC     DD     DE     DF
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // E0     E1     E2     E3     E4     E5     E6     E7
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // E8     E9     EA     EB     EC     ED     EE     EF
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // F0     F1     F2     F3     F4     F5     F6     F7
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // F8     F9     FA     FB     FC     FD     FE     FF
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80
-};
-
-static const uint8_t DEFAULT_ENCODE_SET[32] = {
-  // 00     01     02     03     04     05     06     07
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // 08     09     0A     0B     0C     0D     0E     0F
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // 10     11     12     13     14     15     16     17
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // 18     19     1A     1B     1C     1D     1E     1F
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // 20     21     22     23     24     25     26     27
-    0x01 | 0x00 | 0x04 | 0x08 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 28     29     2A     2B     2C     2D     2E     2F
-    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 30     31     32     33     34     35     36     37
-    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 38     39     3A     3B     3C     3D     3E     3F
-    0x00 | 0x00 | 0x00 | 0x00 | 0x10 | 0x00 | 0x40 | 0x80,
-  // 40     41     42     43     44     45     46     47
-    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 48     49     4A     4B     4C     4D     4E     4F
-    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 50     51     52     53     54     55     56     57
-    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 58     59     5A     5B     5C     5D     5E     5F
-    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 60     61     62     63     64     65     66     67
-    0x01 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 68     69     6A     6B     6C     6D     6E     6F
-    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 70     71     72     73     74     75     76     77
-    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 78     79     7A     7B     7C     7D     7E     7F
-    0x00 | 0x00 | 0x00 | 0x08 | 0x00 | 0x20 | 0x00 | 0x80,
-  // 80     81     82     83     84     85     86     87
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // 88     89     8A     8B     8C     8D     8E     8F
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // 90     91     92     93     94     95     96     97
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // 98     99     9A     9B     9C     9D     9E     9F
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // A0     A1     A2     A3     A4     A5     A6     A7
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // A8     A9     AA     AB     AC     AD     AE     AF
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // B0     B1     B2     B3     B4     B5     B6     B7
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // B8     B9     BA     BB     BC     BD     BE     BF
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // C0     C1     C2     C3     C4     C5     C6     C7
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // C8     C9     CA     CB     CC     CD     CE     CF
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // D0     D1     D2     D3     D4     D5     D6     D7
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // D8     D9     DA     DB     DC     DD     DE     DF
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // E0     E1     E2     E3     E4     E5     E6     E7
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // E8     E9     EA     EB     EC     ED     EE     EF
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // F0     F1     F2     F3     F4     F5     F6     F7
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // F8     F9     FA     FB     FC     FD     FE     FF
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80
-};
-
-static const uint8_t USERINFO_ENCODE_SET[32] = {
-  // 00     01     02     03     04     05     06     07
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // 08     09     0A     0B     0C     0D     0E     0F
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // 10     11     12     13     14     15     16     17
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // 18     19     1A     1B     1C     1D     1E     1F
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // 20     21     22     23     24     25     26     27
-    0x01 | 0x00 | 0x04 | 0x08 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 28     29     2A     2B     2C     2D     2E     2F
-    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x80,
-  // 30     31     32     33     34     35     36     37
-    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 38     39     3A     3B     3C     3D     3E     3F
-    0x00 | 0x00 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // 40     41     42     43     44     45     46     47
-    0x01 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 48     49     4A     4B     4C     4D     4E     4F
-    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 50     51     52     53     54     55     56     57
-    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 58     59     5A     5B     5C     5D     5E     5F
-    0x00 | 0x00 | 0x00 | 0x08 | 0x10 | 0x20 | 0x40 | 0x00,
-  // 60     61     62     63     64     65     66     67
-    0x01 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 68     69     6A     6B     6C     6D     6E     6F
-    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 70     71     72     73     74     75     76     77
-    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 78     79     7A     7B     7C     7D     7E     7F
-    0x00 | 0x00 | 0x00 | 0x08 | 0x10 | 0x20 | 0x00 | 0x80,
-  // 80     81     82     83     84     85     86     87
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // 88     89     8A     8B     8C     8D     8E     8F
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // 90     91     92     93     94     95     96     97
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // 98     99     9A     9B     9C     9D     9E     9F
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // A0     A1     A2     A3     A4     A5     A6     A7
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // A8     A9     AA     AB     AC     AD     AE     AF
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // B0     B1     B2     B3     B4     B5     B6     B7
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // B8     B9     BA     BB     BC     BD     BE     BF
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // C0     C1     C2     C3     C4     C5     C6     C7
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // C8     C9     CA     CB     CC     CD     CE     CF
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // D0     D1     D2     D3     D4     D5     D6     D7
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // D8     D9     DA     DB     DC     DD     DE     DF
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // E0     E1     E2     E3     E4     E5     E6     E7
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // E8     E9     EA     EB     EC     ED     EE     EF
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // F0     F1     F2     F3     F4     F5     F6     F7
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // F8     F9     FA     FB     FC     FD     FE     FF
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80
-};
-
-static const uint8_t QUERY_ENCODE_SET[32] = {
-  // 00     01     02     03     04     05     06     07
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // 08     09     0A     0B     0C     0D     0E     0F
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // 10     11     12     13     14     15     16     17
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // 18     19     1A     1B     1C     1D     1E     1F
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // 20     21     22     23     24     25     26     27
-    0x01 | 0x00 | 0x04 | 0x08 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 28     29     2A     2B     2C     2D     2E     2F
-    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 30     31     32     33     34     35     36     37
-    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 38     39     3A     3B     3C     3D     3E     3F
-    0x00 | 0x00 | 0x00 | 0x00 | 0x10 | 0x00 | 0x40 | 0x00,
-  // 40     41     42     43     44     45     46     47
-    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 48     49     4A     4B     4C     4D     4E     4F
-    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 50     51     52     53     54     55     56     57
-    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 58     59     5A     5B     5C     5D     5E     5F
-    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 60     61     62     63     64     65     66     67
-    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 68     69     6A     6B     6C     6D     6E     6F
-    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 70     71     72     73     74     75     76     77
-    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
-  // 78     79     7A     7B     7C     7D     7E     7F
-    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x80,
-  // 80     81     82     83     84     85     86     87
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // 88     89     8A     8B     8C     8D     8E     8F
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // 90     91     92     93     94     95     96     97
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // 98     99     9A     9B     9C     9D     9E     9F
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // A0     A1     A2     A3     A4     A5     A6     A7
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // A8     A9     AA     AB     AC     AD     AE     AF
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // B0     B1     B2     B3     B4     B5     B6     B7
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // B8     B9     BA     BB     BC     BD     BE     BF
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // C0     C1     C2     C3     C4     C5     C6     C7
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // C8     C9     CA     CB     CC     CD     CE     CF
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // D0     D1     D2     D3     D4     D5     D6     D7
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // D8     D9     DA     DB     DC     DD     DE     DF
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // E0     E1     E2     E3     E4     E5     E6     E7
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // E8     E9     EA     EB     EC     ED     EE     EF
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // F0     F1     F2     F3     F4     F5     F6     F7
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
-  // F8     F9     FA     FB     FC     FD     FE     FF
-    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80
-};
-
-// Must return true if the character is to be percent-encoded
-typedef bool (*must_escape_cb)(const unsigned char ch);
-
-// Appends ch to str. If test(ch) returns true, the ch will
-// be percent-encoded then appended.
-static inline void AppendOrEscape(std::string* str,
-                                  const unsigned char ch,
-                                  must_escape_cb test) {
-  if (test(ch))
-    *str += hex[ch];
-  else
-    *str += ch;
-}
-
-static inline bool SimpleEncodeSet(const unsigned char ch) {
-  return BIT_AT(SIMPLE_ENCODE_SET, ch);
-}
-
-static inline bool DefaultEncodeSet(const unsigned char ch) {
-  return BIT_AT(DEFAULT_ENCODE_SET, ch);
-}
-
-static inline bool UserinfoEncodeSet(const unsigned char ch) {
-  return BIT_AT(USERINFO_ENCODE_SET, ch);
-}
-
-static inline bool QueryEncodeSet(const unsigned char ch) {
-  return BIT_AT(QUERY_ENCODE_SET, ch);
-}
-
-static inline unsigned hex2bin(const char ch) {
-  if (ch >= '0' && ch <= '9')
-    return ch - '0';
-  if (ch >= 'A' && ch <= 'F')
-    return 10 + (ch - 'A');
-  if (ch >= 'a' && ch <= 'f')
-    return 10 + (ch - 'a');
-  return static_cast<unsigned>(-1);
-}
-
-static inline void PercentDecode(const char* input,
-                                 size_t len,
-                                 std::string* dest) {
-  if (len == 0)
-    return;
-  dest->reserve(len);
-  const char* pointer = input;
-  const char* end = input + len;
-  size_t remaining = pointer - end - 1;
-  while (pointer < end) {
-    const char ch = pointer[0];
-    remaining = (end - pointer) + 1;
-    if (ch != '%' || remaining < 2 ||
-        (ch == '%' &&
-         (!ASCII_HEX_DIGIT(pointer[1]) ||
-          !ASCII_HEX_DIGIT(pointer[2])))) {
-      *dest += ch;
-      pointer++;
-      continue;
-    } else {
-      unsigned a = hex2bin(pointer[1]);
-      unsigned b = hex2bin(pointer[2]);
-      char c = static_cast<char>(a * 16 + b);
-      *dest += c;
-      pointer += 3;
-    }
-  }
-}
-
-#define SPECIALS(XX)                                                          \
-  XX("ftp:", 21)                                                              \
-  XX("file:", -1)                                                             \
-  XX("gopher:", 70)                                                           \
-  XX("http:", 80)                                                             \
-  XX("https:", 443)                                                           \
-  XX("ws:", 80)                                                               \
-  XX("wss:", 443)
-
-#define PARSESTATES(XX)                                                       \
-  XX(kSchemeStart)                                                            \
-  XX(kScheme)                                                                 \
-  XX(kNoScheme)                                                               \
-  XX(kSpecialRelativeOrAuthority)                                             \
-  XX(kPathOrAuthority)                                                        \
-  XX(kRelative)                                                               \
-  XX(kRelativeSlash)                                                          \
-  XX(kSpecialAuthoritySlashes)                                                \
-  XX(kSpecialAuthorityIgnoreSlashes)                                          \
-  XX(kAuthority)                                                              \
-  XX(kHost)                                                                   \
-  XX(kHostname)                                                               \
-  XX(kPort)                                                                   \
-  XX(kFile)                                                                   \
-  XX(kFileSlash)                                                              \
-  XX(kFileHost)                                                               \
-  XX(kPathStart)                                                              \
-  XX(kPath)                                                                   \
-  XX(kCannotBeBase)                                                           \
-  XX(kQuery)                                                                  \
-  XX(kFragment)
-
-#define FLAGS(XX)                                                             \
-  XX(URL_FLAGS_NONE, 0)                                                       \
-  XX(URL_FLAGS_FAILED, 0x01)                                                  \
-  XX(URL_FLAGS_CANNOT_BE_BASE, 0x02)                                          \
-  XX(URL_FLAGS_INVALID_PARSE_STATE, 0x04)                                     \
-  XX(URL_FLAGS_TERMINATED, 0x08)                                              \
-  XX(URL_FLAGS_SPECIAL, 0x10)                                                 \
-  XX(URL_FLAGS_HAS_SCHEME, 0x20)                                              \
-  XX(URL_FLAGS_HAS_USERNAME, 0x40)                                            \
-  XX(URL_FLAGS_HAS_PASSWORD, 0x80)                                            \
-  XX(URL_FLAGS_HAS_HOST, 0x100)                                               \
-  XX(URL_FLAGS_HAS_PATH, 0x200)                                               \
-  XX(URL_FLAGS_HAS_QUERY, 0x400)                                              \
-  XX(URL_FLAGS_HAS_FRAGMENT, 0x800)
-
-#define ARGS(XX)                                                              \
-  XX(ARG_FLAGS)                                                               \
-  XX(ARG_PROTOCOL)                                                            \
-  XX(ARG_USERNAME)                                                            \
-  XX(ARG_PASSWORD)                                                            \
-  XX(ARG_HOST)                                                                \
-  XX(ARG_PORT)                                                                \
-  XX(ARG_PATH)                                                                \
-  XX(ARG_QUERY)                                                               \
-  XX(ARG_FRAGMENT)
-
-#define ERR_ARGS(XX)                                                          \
-  XX(ERR_ARG_FLAGS)                                                           \
-  XX(ERR_ARG_INPUT)                                                           \
-
-static const char kEOL = -1;
-
-enum url_parse_state {
-  kUnknownState = -1,
-#define XX(name) name,
-  PARSESTATES(XX)
-#undef XX
-};
-
-enum url_flags {
-#define XX(name, val) name = val,
-  FLAGS(XX)
-#undef XX
-};
-
-enum url_cb_args {
-#define XX(name) name,
-  ARGS(XX)
-#undef XX
-};
-
-enum url_error_cb_args {
-#define XX(name) name,
-  ERR_ARGS(XX)
-#undef XX
-} url_error_cb_args;
-
-static inline bool IsSpecial(std::string scheme) {
-#define XX(name, _) if (scheme == name) return true;
-  SPECIALS(XX);
-#undef XX
-  return false;
-}
-
-static inline int NormalizePort(std::string scheme, int p) {
-#define XX(name, port) if (scheme == name && p == port) return -1;
-  SPECIALS(XX);
-#undef XX
-  return p;
-}
-
-struct url_data {
-  int32_t flags = URL_FLAGS_NONE;
-  int port = -1;
-  std::string scheme;
-  std::string username;
-  std::string password;
-  std::string host;
-  std::string query;
-  std::string fragment;
-  std::vector<std::string> path;
-};
-
-union url_host_value {
-  std::string domain;
-  uint32_t ipv4;
-  uint16_t ipv6[8];
-  ~url_host_value() {}
-};
-
-enum url_host_type {
-  HOST_TYPE_FAILED = -1,
-  HOST_TYPE_DOMAIN = 0,
-  HOST_TYPE_IPV4 = 1,
-  HOST_TYPE_IPV6 = 2
-};
-
-struct url_host {
-  url_host_value value;
-  enum url_host_type type;
-};
-
-class URL {
- public:
-  static void Parse(const char* input,
-                    const size_t len,
-                    enum url_parse_state state_override,
-                    struct url_data* url,
-                    const struct url_data* base,
-                    bool has_base);
-
-  URL(const char* input, const size_t len) {
-    Parse(input, len, kUnknownState, &context_, nullptr, false);
-  }
-
-  URL(const char* input, const size_t len, const URL* base) {
-    if (base != nullptr)
-      Parse(input, len, kUnknownState, &context_, &(base->context_), true);
-    else
-      Parse(input, len, kUnknownState, &context_, nullptr, false);
-  }
-
-  URL(const char* input, const size_t len,
-      const char* base, const size_t baselen) {
-    if (base != nullptr && baselen > 0) {
-      URL _base(base, baselen);
-      Parse(input, len, kUnknownState, &context_, &(_base.context_), true);
-    } else {
-      Parse(input, len, kUnknownState, &context_, nullptr, false);
-    }
-  }
-
-  explicit URL(std::string input) :
-      URL(input.c_str(), input.length()) {}
-
-  URL(std::string input, const URL* base) :
-      URL(input.c_str(), input.length(), base) {}
-
-  URL(std::string input, std::string base) :
-      URL(input.c_str(), input.length(), base.c_str(), base.length()) {}
-
-  int32_t flags() {
-    return context_.flags;
-  }
-
-  int port() {
-    return context_.port;
-  }
-
-  const std::string& protocol() const {
-    return context_.scheme;
-  }
-
-  const std::string& username() const {
-    return context_.username;
-  }
-
-  const std::string& password() const {
-    return context_.password;
-  }
-
-  const std::string& host() const {
-    return context_.host;
-  }
-
-  const std::string& query() const {
-    return context_.query;
-  }
-
-  const std::string& fragment() const {
-    return context_.fragment;
-  }
-
-  std::string path() {
-    std::string ret;
-    for (auto i = context_.path.begin(); i != context_.path.end(); i++) {
-      ret += '/';
-      ret += *i;
-    }
-    return ret;
-  }
-
- private:
-  struct url_data context_;
-};
-
-}  // namespace url
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_NODE_URL_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/node_version.h
+++ /dev/null
@@ -1,57 +0,0 @@
-#ifndef SRC_NODE_VERSION_H_
-#define SRC_NODE_VERSION_H_
-
-#define NODE_MAJOR_VERSION 7
-#define NODE_MINOR_VERSION 9
-#define NODE_PATCH_VERSION 0
-
-#define NODE_VERSION_IS_RELEASE 1
-
-#ifndef NODE_STRINGIFY
-#define NODE_STRINGIFY(n) NODE_STRINGIFY_HELPER(n)
-#define NODE_STRINGIFY_HELPER(n) #n
-#endif
-
-#ifndef NODE_TAG
-# if NODE_VERSION_IS_RELEASE
-#  define NODE_TAG ""
-# else
-#  define NODE_TAG "-pre"
-# endif
-#else
-// NODE_TAG is passed without quotes when rc.exe is run from msbuild
-# define NODE_EXE_VERSION NODE_STRINGIFY(NODE_MAJOR_VERSION) "." \
-                          NODE_STRINGIFY(NODE_MINOR_VERSION) "." \
-                          NODE_STRINGIFY(NODE_PATCH_VERSION)     \
-                          NODE_STRINGIFY(NODE_TAG)
-#endif
-
-# define NODE_VERSION_STRING  NODE_STRINGIFY(NODE_MAJOR_VERSION) "." \
-                              NODE_STRINGIFY(NODE_MINOR_VERSION) "." \
-                              NODE_STRINGIFY(NODE_PATCH_VERSION)     \
-                              NODE_TAG
-#ifndef NODE_EXE_VERSION
-# define NODE_EXE_VERSION NODE_VERSION_STRING
-#endif
-
-#define NODE_VERSION "v" NODE_VERSION_STRING
-
-
-#define NODE_VERSION_AT_LEAST(major, minor, patch) \
-  (( (major) < NODE_MAJOR_VERSION) \
-  || ((major) == NODE_MAJOR_VERSION && (minor) < NODE_MINOR_VERSION) \
-  || ((major) == NODE_MAJOR_VERSION && \
-      (minor) == NODE_MINOR_VERSION && (patch) <= NODE_PATCH_VERSION))
-
-/**
- * Node.js will refuse to load modules that weren't compiled against its own
- * module ABI number, exposed as the process.versions.modules property.
- *
- * When this version number is changed, node.js will refuse
- * to load older modules.  This should be done whenever
- * an API is broken in the C++ side, including in v8 or
- * other dependencies.
- */
-#define NODE_MODULE_VERSION 54 /* Node.js v7.0.0 */
-
-#endif  // SRC_NODE_VERSION_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/node_watchdog.h
+++ /dev/null
@@ -1,103 +0,0 @@
-#ifndef SRC_NODE_WATCHDOG_H_
-#define SRC_NODE_WATCHDOG_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "v8.h"
-#include "uv.h"
-#include "node_mutex.h"
-#include <vector>
-
-#ifdef __POSIX__
-#include <pthread.h>
-#endif
-
-namespace node {
-
-class Watchdog {
- public:
-  explicit Watchdog(v8::Isolate* isolate, uint64_t ms);
-  ~Watchdog();
-
-  void Dispose();
-
-  v8::Isolate* isolate() { return isolate_; }
-  bool HasTimedOut() { return timed_out_; }
- private:
-  void Destroy();
-
-  static void Run(void* arg);
-  static void Async(uv_async_t* async);
-  static void Timer(uv_timer_t* timer);
-
-  v8::Isolate* isolate_;
-  uv_thread_t thread_;
-  uv_loop_t* loop_;
-  uv_async_t async_;
-  uv_timer_t timer_;
-  bool timed_out_;
-  bool destroyed_;
-};
-
-class SigintWatchdog {
- public:
-  explicit SigintWatchdog(v8::Isolate* isolate);
-  ~SigintWatchdog();
-
-  void Dispose();
-
-  v8::Isolate* isolate() { return isolate_; }
-  bool HasReceivedSignal() { return received_signal_; }
-  void HandleSigint();
-
- private:
-  void Destroy();
-
-  v8::Isolate* isolate_;
-  bool received_signal_;
-  bool destroyed_;
-};
-
-class SigintWatchdogHelper {
- public:
-  static SigintWatchdogHelper* GetInstance() { return &instance; }
-  void Register(SigintWatchdog* watchdog);
-  void Unregister(SigintWatchdog* watchdog);
-  bool HasPendingSignal();
-
-  int Start();
-  bool Stop();
-
- private:
-  SigintWatchdogHelper();
-  ~SigintWatchdogHelper();
-
-  static bool InformWatchdogsAboutSignal();
-  static SigintWatchdogHelper instance;
-
-  int start_stop_count_;
-
-  Mutex mutex_;
-  Mutex list_mutex_;
-  std::vector<SigintWatchdog*> watchdogs_;
-  bool has_pending_signal_;
-
-#ifdef __POSIX__
-  pthread_t thread_;
-  uv_sem_t sem_;
-  bool has_running_thread_;
-  bool stopping_;
-
-  static void* RunSigintWatchdog(void* arg);
-  static void HandleSignal(int signum);
-#else
-  bool watchdog_disabled_;
-  static BOOL WINAPI WinCtrlCHandlerRoutine(DWORD dwCtrlType);
-#endif
-};
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_NODE_WATCHDOG_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/node_win32_etw_provider-inl.h
+++ /dev/null
@@ -1,272 +0,0 @@
-#ifndef SRC_NODE_WIN32_ETW_PROVIDER_INL_H_
-#define SRC_NODE_WIN32_ETW_PROVIDER_INL_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "node_win32_etw_provider.h"
-#include "node_etw_provider.h"
-
-#if defined(_WIN64)
-# define ETW_WRITE_INTPTR_DATA ETW_WRITE_INT64_DATA
-#else
-# define ETW_WRITE_INTPTR_DATA ETW_WRITE_INT32_DATA
-#endif
-
-namespace node {
-
-// From node_win32_etw_provider.cc
-extern REGHANDLE node_provider;
-extern EventWriteFunc event_write;
-extern int events_enabled;
-
-#define ETW_WRITE_STRING_DATA(data_descriptor, data)                          \
-  EventDataDescCreate(data_descriptor,                                        \
-                      data,                                                   \
-                      (strlen(data) + 1) * sizeof(*data));
-
-#define ETW_WRITE_INT32_DATA(data_descriptor, data)  \
-  EventDataDescCreate(data_descriptor, data, sizeof(int32_t));
-
-#define ETW_WRITE_INT64_DATA(data_descriptor, data)  \
-  EventDataDescCreate(data_descriptor, data, sizeof(int64_t));
-
-#define ETW_WRITE_ADDRESS_DATA(data_descriptor, data)  \
-  EventDataDescCreate(data_descriptor, data, sizeof(intptr_t));
-
-#define ETW_WRITE_INT16_DATA(data_descriptor, data)  \
-  EventDataDescCreate(data_descriptor, data, sizeof(int16_t));
-
-#define ETW_WRITE_WSTRING_DATA_LENGTH(data_descriptor, data, data_len_bytes)  \
-  EventDataDescCreate(data_descriptor,                                        \
-                      data,                                                   \
-                      data_len_bytes);
-
-#define ETW_WRITE_NET_CONNECTION(descriptors, conn)                           \
-  ETW_WRITE_INT32_DATA(descriptors, &conn->fd);                               \
-  ETW_WRITE_INT32_DATA(descriptors + 1, &conn->port);                         \
-  ETW_WRITE_STRING_DATA(descriptors + 2, conn->remote);                       \
-  ETW_WRITE_INT32_DATA(descriptors + 3, &conn->buffered);
-
-#define ETW_WRITE_HTTP_SERVER_REQUEST(descriptors, req)                       \
-  ETW_WRITE_STRING_DATA(descriptors, req->url);                               \
-  ETW_WRITE_STRING_DATA(descriptors + 1, req->method);                        \
-  ETW_WRITE_STRING_DATA(descriptors + 2, req->forwardedFor);
-
-#define ETW_WRITE_HTTP_CLIENT_REQUEST(descriptors, req)                       \
-  ETW_WRITE_STRING_DATA(descriptors, req->url);                               \
-  ETW_WRITE_STRING_DATA(descriptors + 1, req->method);
-
-#define ETW_WRITE_GC(descriptors, type, flags)                                \
-  ETW_WRITE_INT32_DATA(descriptors, &type);                                   \
-  ETW_WRITE_INT32_DATA(descriptors + 1, &flags);
-
-#define ETW_WRITE_V8ADDRESSCHANGE(descriptors, addr1, addr2)                  \
-    ETW_WRITE_ADDRESS_DATA(descriptors, &addr1);                              \
-    ETW_WRITE_ADDRESS_DATA(descriptors + 1, &addr2);
-
-#define ETW_WRITE_JSMETHOD_LOADUNLOAD(descriptors,                            \
-                                      context,                                \
-                                      startAddr,                              \
-                                      size,                                   \
-                                      id,                                     \
-                                      flags,                                  \
-                                      rangeId,                                \
-                                      sourceId,                               \
-                                      line,                                   \
-                                      col,                                    \
-                                      name,                                   \
-                                      name_len_bytes)                         \
-    ETW_WRITE_ADDRESS_DATA(descriptors, &context);                            \
-    ETW_WRITE_ADDRESS_DATA(descriptors + 1, &startAddr);                      \
-    ETW_WRITE_INT64_DATA(descriptors + 2, &size);                             \
-    ETW_WRITE_INTPTR_DATA(descriptors + 3, &id);                              \
-    ETW_WRITE_INT16_DATA(descriptors + 4, &flags);                            \
-    ETW_WRITE_INT16_DATA(descriptors + 5, &rangeId);                          \
-    ETW_WRITE_INT64_DATA(descriptors + 6, &sourceId);                         \
-    ETW_WRITE_INT32_DATA(descriptors + 7, &line);                             \
-    ETW_WRITE_INT32_DATA(descriptors + 8, &col);                              \
-    ETW_WRITE_WSTRING_DATA_LENGTH(descriptors + 9, name, name_len_bytes);
-
-
-#define ETW_WRITE_EVENT(eventDescriptor, dataDescriptors)                     \
-  DWORD status = event_write(node_provider,                                   \
-                             &eventDescriptor,                                \
-                             sizeof(dataDescriptors) /                        \
-                                 sizeof(*dataDescriptors),                    \
-                             dataDescriptors);                                \
-  CHECK_EQ(status, ERROR_SUCCESS);
-
-#define ETW_WRITE_EMPTY_EVENT(eventDescriptor)                                \
-  DWORD status = event_write(node_provider,                                   \
-                             &eventDescriptor,                                \
-                             0,                                               \
-                             NULL);                                           \
-  CHECK_EQ(status, ERROR_SUCCESS);
-
-
-void NODE_HTTP_SERVER_REQUEST(node_dtrace_http_server_request_t* req,
-    node_dtrace_connection_t* conn, const char *remote, int port,
-    const char *method, const char *url, int fd) {
-  EVENT_DATA_DESCRIPTOR descriptors[7];
-  ETW_WRITE_HTTP_SERVER_REQUEST(descriptors, req);
-  ETW_WRITE_NET_CONNECTION(descriptors + 3, conn);
-  ETW_WRITE_EVENT(NODE_HTTP_SERVER_REQUEST_EVENT, descriptors);
-}
-
-
-void NODE_HTTP_SERVER_RESPONSE(node_dtrace_connection_t* conn,
-    const char *remote, int port, int fd) {
-  EVENT_DATA_DESCRIPTOR descriptors[4];
-  ETW_WRITE_NET_CONNECTION(descriptors, conn);
-  ETW_WRITE_EVENT(NODE_HTTP_SERVER_RESPONSE_EVENT, descriptors);
-}
-
-
-void NODE_HTTP_CLIENT_REQUEST(node_dtrace_http_client_request_t* req,
-    node_dtrace_connection_t* conn, const char *remote, int port,
-    const char *method, const char *url, int fd) {
-  EVENT_DATA_DESCRIPTOR descriptors[6];
-  ETW_WRITE_HTTP_CLIENT_REQUEST(descriptors, req);
-  ETW_WRITE_NET_CONNECTION(descriptors + 2, conn);
-  ETW_WRITE_EVENT(NODE_HTTP_CLIENT_REQUEST_EVENT, descriptors);
-}
-
-
-void NODE_HTTP_CLIENT_RESPONSE(node_dtrace_connection_t* conn,
-    const char *remote, int port, int fd) {
-  EVENT_DATA_DESCRIPTOR descriptors[4];
-  ETW_WRITE_NET_CONNECTION(descriptors, conn);
-  ETW_WRITE_EVENT(NODE_HTTP_CLIENT_RESPONSE_EVENT, descriptors);
-}
-
-
-void NODE_NET_SERVER_CONNECTION(node_dtrace_connection_t* conn,
-    const char *remote, int port, int fd) {
-  EVENT_DATA_DESCRIPTOR descriptors[4];
-  ETW_WRITE_NET_CONNECTION(descriptors, conn);
-  ETW_WRITE_EVENT(NODE_NET_SERVER_CONNECTION_EVENT, descriptors);
-}
-
-
-void NODE_NET_STREAM_END(node_dtrace_connection_t* conn,
-    const char *remote, int port, int fd) {
-  EVENT_DATA_DESCRIPTOR descriptors[4];
-  ETW_WRITE_NET_CONNECTION(descriptors, conn);
-  ETW_WRITE_EVENT(NODE_NET_STREAM_END_EVENT, descriptors);
-}
-
-
-void NODE_GC_START(v8::GCType type,
-                   v8::GCCallbackFlags flags,
-                   v8::Isolate* isolate) {
-  if (events_enabled > 0) {
-    EVENT_DATA_DESCRIPTOR descriptors[2];
-    ETW_WRITE_GC(descriptors, type, flags);
-    ETW_WRITE_EVENT(NODE_GC_START_EVENT, descriptors);
-  }
-}
-
-
-void NODE_GC_DONE(v8::GCType type,
-                  v8::GCCallbackFlags flags,
-                  v8::Isolate* isolate) {
-  if (events_enabled > 0) {
-    EVENT_DATA_DESCRIPTOR descriptors[2];
-    ETW_WRITE_GC(descriptors, type, flags);
-    ETW_WRITE_EVENT(NODE_GC_DONE_EVENT, descriptors);
-  }
-}
-
-
-void NODE_V8SYMBOL_REMOVE(const void* addr1, const void* addr2) {
-  if (events_enabled > 0) {
-    EVENT_DATA_DESCRIPTOR descriptors[2];
-    ETW_WRITE_V8ADDRESSCHANGE(descriptors, addr1, addr2);
-    ETW_WRITE_EVENT(NODE_V8SYMBOL_REMOVE_EVENT, descriptors);
-  }
-}
-
-
-void NODE_V8SYMBOL_MOVE(const void* addr1, const void* addr2) {
-  if (events_enabled > 0) {
-    EVENT_DATA_DESCRIPTOR descriptors[2];
-    ETW_WRITE_V8ADDRESSCHANGE(descriptors, addr1, addr2);
-    ETW_WRITE_EVENT(NODE_V8SYMBOL_MOVE_EVENT, descriptors);
-  }
-}
-
-
-void NODE_V8SYMBOL_RESET() {
-  if (events_enabled > 0) {
-    ETW_WRITE_EMPTY_EVENT(NODE_V8SYMBOL_RESET_EVENT);
-  }
-}
-
-#define SETSYMBUF(s)  \
-  wcscpy(symbuf, s);  \
-  symbol_len = arraysize(s) - 1;
-
-void NODE_V8SYMBOL_ADD(LPCSTR symbol,
-                       int symbol_len,
-                       const void* addr1,
-                       int len) {
-  if (events_enabled > 0) {
-    wchar_t symbuf[128];
-    if (symbol == nullptr) {
-      SETSYMBUF(L"nullptr");
-    } else {
-      symbol_len = MultiByteToWideChar(CP_ACP,
-                                       0,
-                                       symbol,
-                                       symbol_len,
-                                       symbuf,
-                                       128);
-      if (symbol_len == 0) {
-        SETSYMBUF(L"Invalid");
-      } else {
-        if (symbol_len > 127) {
-          symbol_len = 127;
-        }
-        symbuf[symbol_len] = L'\0';
-      }
-    }
-    void* context = nullptr;
-    INT64 size = (INT64)len;
-    INT_PTR id = (INT_PTR)addr1;
-    INT16 flags = 0;
-    INT16 rangeid = 1;
-    INT32 col = 1;
-    INT32 line = 1;
-    INT64 sourceid = 0;
-    EVENT_DATA_DESCRIPTOR descriptors[10];
-    ETW_WRITE_JSMETHOD_LOADUNLOAD(descriptors,
-                                  context,
-                                  addr1,
-                                  size,
-                                  id,
-                                  flags,
-                                  rangeid,
-                                  sourceid,
-                                  line,
-                                  col,
-                                  symbuf,
-                                  (symbol_len + 1) * sizeof(symbuf[0]));
-    ETW_WRITE_EVENT(MethodLoad, descriptors);
-  }
-}
-#undef SETSYMBUF
-
-
-bool NODE_HTTP_SERVER_REQUEST_ENABLED() { return events_enabled > 0; }
-bool NODE_HTTP_SERVER_RESPONSE_ENABLED() { return events_enabled > 0; }
-bool NODE_HTTP_CLIENT_REQUEST_ENABLED() { return events_enabled > 0; }
-bool NODE_HTTP_CLIENT_RESPONSE_ENABLED() { return events_enabled > 0; }
-bool NODE_NET_SERVER_CONNECTION_ENABLED() { return events_enabled > 0; }
-bool NODE_NET_STREAM_END_ENABLED() { return events_enabled > 0; }
-bool NODE_V8SYMBOL_ENABLED() { return events_enabled > 0; }
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_NODE_WIN32_ETW_PROVIDER_INL_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/node_win32_etw_provider.h
+++ /dev/null
@@ -1,78 +0,0 @@
-#ifndef SRC_NODE_WIN32_ETW_PROVIDER_H_
-#define SRC_NODE_WIN32_ETW_PROVIDER_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "node_dtrace.h"
-#include <evntprov.h>
-
-namespace node {
-
-#if defined(_MSC_VER)
-# define INLINE __forceinline
-#else
-# define INLINE inline
-#endif
-
-typedef ULONG (NTAPI *EventRegisterFunc)(
-  LPCGUID ProviderId,
-  PENABLECALLBACK EnableCallback,
-  PVOID CallbackContext,
-  PREGHANDLE RegHandle
-);
-
-typedef ULONG (NTAPI *EventUnregisterFunc)(
-  REGHANDLE RegHandle
-);
-
-typedef ULONG (NTAPI *EventWriteFunc)(
-  REGHANDLE RegHandle,
-  PCEVENT_DESCRIPTOR EventDescriptor,
-  ULONG UserDataCount,
-  PEVENT_DATA_DESCRIPTOR UserData
-);
-
-void init_etw();
-void shutdown_etw();
-
-INLINE void NODE_HTTP_SERVER_REQUEST(node_dtrace_http_server_request_t* req,
-  node_dtrace_connection_t* conn, const char *remote, int port,
-  const char *method, const char *url, int fd);
-INLINE void NODE_HTTP_SERVER_RESPONSE(node_dtrace_connection_t* conn,
-  const char *remote, int port, int fd);
-INLINE void NODE_HTTP_CLIENT_REQUEST(node_dtrace_http_client_request_t* req,
-  node_dtrace_connection_t* conn, const char *remote, int port,
-  const char *method, const char *url, int fd);
-INLINE void NODE_HTTP_CLIENT_RESPONSE(node_dtrace_connection_t* conn,
-  const char *remote, int port, int fd);
-INLINE void NODE_NET_SERVER_CONNECTION(node_dtrace_connection_t* conn,
-  const char *remote, int port, int fd);
-INLINE void NODE_NET_STREAM_END(node_dtrace_connection_t* conn,
-  const char *remote, int port, int fd);
-INLINE void NODE_GC_START(v8::GCType type,
-                          v8::GCCallbackFlags flags,
-                          v8::Isolate* isolate);
-INLINE void NODE_GC_DONE(v8::GCType type,
-                         v8::GCCallbackFlags flags,
-                         v8::Isolate* isolate);
-INLINE void NODE_V8SYMBOL_REMOVE(const void* addr1, const void* addr2);
-INLINE void NODE_V8SYMBOL_MOVE(const void* addr1, const void* addr2);
-INLINE void NODE_V8SYMBOL_RESET();
-INLINE void NODE_V8SYMBOL_ADD(LPCSTR symbol,
-                              int symbol_len,
-                              const void* addr1,
-                              int len);
-
-INLINE bool NODE_HTTP_SERVER_REQUEST_ENABLED();
-INLINE bool NODE_HTTP_SERVER_RESPONSE_ENABLED();
-INLINE bool NODE_HTTP_CLIENT_REQUEST_ENABLED();
-INLINE bool NODE_HTTP_CLIENT_RESPONSE_ENABLED();
-INLINE bool NODE_NET_SERVER_CONNECTION_ENABLED();
-INLINE bool NODE_NET_STREAM_END_ENABLED();
-INLINE bool NODE_V8SYMBOL_ENABLED();
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_NODE_WIN32_ETW_PROVIDER_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/node_win32_perfctr_provider.h
+++ /dev/null
@@ -1,37 +0,0 @@
-#ifndef SRC_NODE_WIN32_PERFCTR_PROVIDER_H_
-#define SRC_NODE_WIN32_PERFCTR_PROVIDER_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#if defined(_MSC_VER)
-# define INLINE __forceinline
-#else
-# define INLINE inline
-#endif
-
-namespace node {
-
-extern HANDLE NodeCounterProvider;
-
-INLINE bool NODE_COUNTER_ENABLED() { return NodeCounterProvider != nullptr; }
-void NODE_COUNT_HTTP_SERVER_REQUEST();
-void NODE_COUNT_HTTP_SERVER_RESPONSE();
-void NODE_COUNT_HTTP_CLIENT_REQUEST();
-void NODE_COUNT_HTTP_CLIENT_RESPONSE();
-void NODE_COUNT_SERVER_CONN_OPEN();
-void NODE_COUNT_SERVER_CONN_CLOSE();
-void NODE_COUNT_NET_BYTES_SENT(int bytes);
-void NODE_COUNT_NET_BYTES_RECV(int bytes);
-uint64_t NODE_COUNT_GET_GC_RAWTIME();
-void NODE_COUNT_GC_PERCENTTIME(unsigned int percent);
-void NODE_COUNT_PIPE_BYTES_SENT(int bytes);
-void NODE_COUNT_PIPE_BYTES_RECV(int bytes);
-
-void InitPerfCountersWin32();
-void TermPerfCountersWin32();
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_NODE_WIN32_PERFCTR_PROVIDER_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/node_wrap.h
+++ /dev/null
@@ -1,56 +0,0 @@
-#ifndef SRC_NODE_WRAP_H_
-#define SRC_NODE_WRAP_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "env.h"
-#include "env-inl.h"
-#include "js_stream.h"
-#include "pipe_wrap.h"
-#include "tcp_wrap.h"
-#include "tty_wrap.h"
-#include "udp_wrap.h"
-#include "util.h"
-#include "util-inl.h"
-#include "uv.h"
-#include "v8.h"
-
-namespace node {
-
-#define WITH_GENERIC_UV_STREAM(env, obj, BODY, ELSE)                          \
-    do {                                                                      \
-      if (env->tcp_constructor_template().IsEmpty() == false &&               \
-          env->tcp_constructor_template()->HasInstance(obj)) {                \
-        TCPWrap* const wrap = Unwrap<TCPWrap>(obj);                           \
-        BODY                                                                  \
-      } else if (env->tty_constructor_template().IsEmpty() == false &&        \
-                 env->tty_constructor_template()->HasInstance(obj)) {         \
-        TTYWrap* const wrap = Unwrap<TTYWrap>(obj);                           \
-        BODY                                                                  \
-      } else if (env->pipe_constructor_template().IsEmpty() == false &&       \
-                 env->pipe_constructor_template()->HasInstance(obj)) {        \
-        PipeWrap* const wrap = Unwrap<PipeWrap>(obj);                         \
-        BODY                                                                  \
-      } else {                                                                \
-        ELSE                                                                  \
-      }                                                                       \
-    } while (0)
-
-inline uv_stream_t* HandleToStream(Environment* env,
-                                   v8::Local<v8::Object> obj) {
-  v8::HandleScope scope(env->isolate());
-
-  WITH_GENERIC_UV_STREAM(env, obj, {
-    if (wrap == nullptr)
-      return nullptr;
-    return reinterpret_cast<uv_stream_t*>(wrap->UVHandle());
-  }, {});
-
-  return nullptr;
-}
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_NODE_WRAP_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/pipe_wrap.h
+++ /dev/null
@@ -1,44 +0,0 @@
-#ifndef SRC_PIPE_WRAP_H_
-#define SRC_PIPE_WRAP_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "async-wrap.h"
-#include "connection_wrap.h"
-#include "env.h"
-
-namespace node {
-
-class PipeWrap : public ConnectionWrap<PipeWrap, uv_pipe_t> {
- public:
-  static v8::Local<v8::Object> Instantiate(Environment* env, AsyncWrap* parent);
-  static void Initialize(v8::Local<v8::Object> target,
-                         v8::Local<v8::Value> unused,
-                         v8::Local<v8::Context> context);
-
-  size_t self_size() const override { return sizeof(*this); }
-
- private:
-  PipeWrap(Environment* env,
-           v8::Local<v8::Object> object,
-           bool ipc,
-           AsyncWrap* parent);
-
-  static void New(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void Bind(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void Listen(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void Connect(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void Open(const v8::FunctionCallbackInfo<v8::Value>& args);
-
-#ifdef _WIN32
-  static void SetPendingInstances(
-      const v8::FunctionCallbackInfo<v8::Value>& args);
-#endif
-};
-
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_PIPE_WRAP_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/req-wrap-inl.h
+++ /dev/null
@@ -1,46 +0,0 @@
-#ifndef SRC_REQ_WRAP_INL_H_
-#define SRC_REQ_WRAP_INL_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "req-wrap.h"
-#include "async-wrap.h"
-#include "async-wrap-inl.h"
-#include "env.h"
-#include "env-inl.h"
-#include "util.h"
-#include "util-inl.h"
-
-namespace node {
-
-template <typename T>
-ReqWrap<T>::ReqWrap(Environment* env,
-                    v8::Local<v8::Object> object,
-                    AsyncWrap::ProviderType provider)
-    : AsyncWrap(env, object, provider) {
-  if (env->in_domain())
-    object->Set(env->domain_string(), env->domain_array()->Get(0));
-
-  // FIXME(bnoordhuis) The fact that a reinterpret_cast is needed is
-  // arguably a good indicator that there should be more than one queue.
-  env->req_wrap_queue()->PushBack(reinterpret_cast<ReqWrap<uv_req_t>*>(this));
-}
-
-template <typename T>
-ReqWrap<T>::~ReqWrap() {
-  CHECK_EQ(req_.data, this);  // Assert that someone has called Dispatched().
-  CHECK_EQ(false, persistent().IsEmpty());
-  ClearWrap(object());
-  persistent().Reset();
-}
-
-template <typename T>
-void ReqWrap<T>::Dispatched() {
-  req_.data = this;
-}
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_REQ_WRAP_INL_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/req-wrap.h
+++ /dev/null
@@ -1,40 +0,0 @@
-#ifndef SRC_REQ_WRAP_H_
-#define SRC_REQ_WRAP_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "async-wrap.h"
-#include "env.h"
-#include "util.h"
-#include "v8.h"
-
-namespace node {
-
-template <typename T>
-class ReqWrap : public AsyncWrap {
- public:
-  inline ReqWrap(Environment* env,
-                 v8::Local<v8::Object> object,
-                 AsyncWrap::ProviderType provider);
-  inline ~ReqWrap() override;
-  inline void Dispatched();  // Call this after the req has been dispatched.
-  T* req() { return &req_; }
-
- private:
-  friend class Environment;
-  ListNode<ReqWrap> req_wrap_queue_;
-
- protected:
-  // req_wrap_queue_ needs to be at a fixed offset from the start of the class
-  // because it is used by ContainerOf to calculate the address of the embedding
-  // ReqWrap. ContainerOf compiles down to simple, fixed pointer arithmetic.
-  // sizeof(req_) depends on the type of T, so req_wrap_queue_ would
-  // no longer be at a fixed offset if it came after req_.
-  T req_;
-};
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_REQ_WRAP_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/spawn_sync.h
+++ /dev/null
@@ -1,229 +0,0 @@
-#ifndef SRC_SPAWN_SYNC_H_
-#define SRC_SPAWN_SYNC_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "node.h"
-#include "node_buffer.h"
-
-namespace node {
-
-using v8::Array;
-using v8::Context;
-using v8::FunctionCallbackInfo;
-using v8::HandleScope;
-using v8::Integer;
-using v8::Isolate;
-using v8::Local;
-using v8::Null;
-using v8::Number;
-using v8::Object;
-using v8::String;
-using v8::Value;
-
-
-class SyncProcessOutputBuffer;
-class SyncProcessStdioPipe;
-class SyncProcessRunner;
-
-
-class SyncProcessOutputBuffer {
-  static const unsigned int kBufferSize = 65536;
-
- public:
-  inline SyncProcessOutputBuffer();
-
-  inline void OnAlloc(size_t suggested_size, uv_buf_t* buf) const;
-  inline void OnRead(const uv_buf_t* buf, size_t nread);
-
-  inline size_t Copy(char* dest) const;
-
-  inline unsigned int available() const;
-  inline unsigned int used() const;
-
-  inline SyncProcessOutputBuffer* next() const;
-  inline void set_next(SyncProcessOutputBuffer* next);
-
- private:
-  // Use unsigned int because that's what `uv_buf_init` takes.
-  mutable char data_[kBufferSize];
-  unsigned int used_;
-
-  SyncProcessOutputBuffer* next_;
-};
-
-
-class SyncProcessStdioPipe {
-  enum Lifecycle {
-    kUninitialized = 0,
-    kInitialized,
-    kStarted,
-    kClosing,
-    kClosed
-  };
-
- public:
-  SyncProcessStdioPipe(SyncProcessRunner* process_handler,
-                       bool readable,
-                       bool writable,
-                       uv_buf_t input_buffer);
-  ~SyncProcessStdioPipe();
-
-  int Initialize(uv_loop_t* loop);
-  int Start();
-  void Close();
-
-  Local<Object> GetOutputAsBuffer(Environment* env) const;
-
-  inline bool readable() const;
-  inline bool writable() const;
-  inline uv_stdio_flags uv_flags() const;
-
-  inline uv_pipe_t* uv_pipe() const;
-  inline uv_stream_t* uv_stream() const;
-  inline uv_handle_t* uv_handle() const;
-
- private:
-  inline size_t OutputLength() const;
-  inline void CopyOutput(char* dest) const;
-
-  inline void OnAlloc(size_t suggested_size, uv_buf_t* buf);
-  inline void OnRead(const uv_buf_t* buf, ssize_t nread);
-  inline void OnWriteDone(int result);
-  inline void OnShutdownDone(int result);
-  inline void OnClose();
-
-  inline void SetError(int error);
-
-  static void AllocCallback(uv_handle_t* handle,
-                            size_t suggested_size,
-                            uv_buf_t* buf);
-  static void ReadCallback(uv_stream_t* stream,
-                           ssize_t nread,
-                           const uv_buf_t* buf);
-  static void WriteCallback(uv_write_t* req, int result);
-  static void ShutdownCallback(uv_shutdown_t* req, int result);
-  static void CloseCallback(uv_handle_t* handle);
-
-  SyncProcessRunner* process_handler_;
-
-  bool readable_;
-  bool writable_;
-  uv_buf_t input_buffer_;
-
-  SyncProcessOutputBuffer* first_output_buffer_;
-  SyncProcessOutputBuffer* last_output_buffer_;
-
-  mutable uv_pipe_t uv_pipe_;
-  uv_write_t write_req_;
-  uv_shutdown_t shutdown_req_;
-
-  Lifecycle lifecycle_;
-};
-
-
-class SyncProcessRunner {
-  enum Lifecycle {
-    kUninitialized = 0,
-    kInitialized,
-    kHandlesClosed
-  };
-
- public:
-  static void Initialize(Local<Object> target,
-                         Local<Value> unused,
-                         Local<Context> context);
-  static void Spawn(const FunctionCallbackInfo<Value>& args);
-
- private:
-  friend class SyncProcessStdioPipe;
-
-  explicit SyncProcessRunner(Environment* env_);
-  ~SyncProcessRunner();
-
-  inline Environment* env() const;
-
-  Local<Object> Run(Local<Value> options);
-  void TryInitializeAndRunLoop(Local<Value> options);
-  void CloseHandlesAndDeleteLoop();
-
-  void CloseStdioPipes();
-  void CloseKillTimer();
-
-  void Kill();
-  void IncrementBufferSizeAndCheckOverflow(ssize_t length);
-
-  void OnExit(int64_t exit_status, int term_signal);
-  void OnKillTimerTimeout();
-
-  int GetError();
-  void SetError(int error);
-  void SetPipeError(int pipe_error);
-
-  Local<Object> BuildResultObject();
-  Local<Array> BuildOutputArray();
-
-  int ParseOptions(Local<Value> js_value);
-  int ParseStdioOptions(Local<Value> js_value);
-  int ParseStdioOption(int child_fd, Local<Object> js_stdio_option);
-
-  inline int AddStdioIgnore(uint32_t child_fd);
-  inline int AddStdioPipe(uint32_t child_fd,
-                          bool readable,
-                          bool writable,
-                          uv_buf_t input_buffer);
-  inline int AddStdioInheritFD(uint32_t child_fd, int inherit_fd);
-
-  static bool IsSet(Local<Value> value);
-  int CopyJsString(Local<Value> js_value, const char** target);
-  int CopyJsStringArray(Local<Value> js_value, char** target);
-
-  static void ExitCallback(uv_process_t* handle,
-                           int64_t exit_status,
-                           int term_signal);
-  static void KillTimerCallback(uv_timer_t* handle);
-  static void KillTimerCloseCallback(uv_handle_t* handle);
-
-  size_t max_buffer_;
-  uint64_t timeout_;
-  int kill_signal_;
-
-  uv_loop_t* uv_loop_;
-
-  uint32_t stdio_count_;
-  uv_stdio_container_t* uv_stdio_containers_;
-  SyncProcessStdioPipe** stdio_pipes_;
-  bool stdio_pipes_initialized_;
-
-  uv_process_options_t uv_process_options_;
-  const char* file_buffer_;
-  char* args_buffer_;
-  char* env_buffer_;
-  const char* cwd_buffer_;
-
-  uv_process_t uv_process_;
-  bool killed_;
-
-  size_t buffered_output_size_;
-  int64_t exit_status_;
-  int term_signal_;
-
-  uv_timer_t uv_timer_;
-  bool kill_timer_initialized_;
-
-  // Errors that happen in one of the pipe handlers are stored in the
-  // `pipe_error` field. They are treated as "low-priority", only to be
-  // reported if no more serious errors happened.
-  int error_;
-  int pipe_error_;
-
-  Lifecycle lifecycle_;
-
-  Environment* env_;
-};
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_SPAWN_SYNC_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/stream_base-inl.h
+++ /dev/null
@@ -1,169 +0,0 @@
-#ifndef SRC_STREAM_BASE_INL_H_
-#define SRC_STREAM_BASE_INL_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "stream_base.h"
-
-#include "node.h"
-#include "env.h"
-#include "env-inl.h"
-#include "v8.h"
-
-namespace node {
-
-using v8::External;
-using v8::FunctionCallbackInfo;
-using v8::FunctionTemplate;
-using v8::HandleScope;
-using v8::Local;
-using v8::Object;
-using v8::PropertyAttribute;
-using v8::PropertyCallbackInfo;
-using v8::String;
-using v8::Value;
-
-template <class Base>
-void StreamBase::AddMethods(Environment* env,
-                            Local<FunctionTemplate> t,
-                            int flags) {
-  HandleScope scope(env->isolate());
-
-  enum PropertyAttribute attributes =
-      static_cast<PropertyAttribute>(v8::ReadOnly | v8::DontDelete);
-  t->InstanceTemplate()->SetAccessor(env->fd_string(),
-                                     GetFD<Base>,
-                                     nullptr,
-                                     env->as_external(),
-                                     v8::DEFAULT,
-                                     attributes);
-
-  t->InstanceTemplate()->SetAccessor(env->external_stream_string(),
-                                     GetExternal<Base>,
-                                     nullptr,
-                                     env->as_external(),
-                                     v8::DEFAULT,
-                                     attributes);
-
-  t->InstanceTemplate()->SetAccessor(env->bytes_read_string(),
-                                     GetBytesRead<Base>,
-                                     nullptr,
-                                     env->as_external(),
-                                     v8::DEFAULT,
-                                     attributes);
-
-  env->SetProtoMethod(t, "readStart", JSMethod<Base, &StreamBase::ReadStart>);
-  env->SetProtoMethod(t, "readStop", JSMethod<Base, &StreamBase::ReadStop>);
-  if ((flags & kFlagNoShutdown) == 0)
-    env->SetProtoMethod(t, "shutdown", JSMethod<Base, &StreamBase::Shutdown>);
-  if ((flags & kFlagHasWritev) != 0)
-    env->SetProtoMethod(t, "writev", JSMethod<Base, &StreamBase::Writev>);
-  env->SetProtoMethod(t,
-                      "writeBuffer",
-                      JSMethod<Base, &StreamBase::WriteBuffer>);
-  env->SetProtoMethod(t,
-                      "writeAsciiString",
-                      JSMethod<Base, &StreamBase::WriteString<ASCII> >);
-  env->SetProtoMethod(t,
-                      "writeUtf8String",
-                      JSMethod<Base, &StreamBase::WriteString<UTF8> >);
-  env->SetProtoMethod(t,
-                      "writeUcs2String",
-                      JSMethod<Base, &StreamBase::WriteString<UCS2> >);
-  env->SetProtoMethod(t,
-                      "writeLatin1String",
-                      JSMethod<Base, &StreamBase::WriteString<LATIN1> >);
-}
-
-
-template <class Base>
-void StreamBase::GetFD(Local<String> key,
-                       const PropertyCallbackInfo<Value>& args) {
-  Base* handle = Unwrap<Base>(args.Holder());
-
-  // Mimic implementation of StreamBase::GetFD() and UDPWrap::GetFD().
-  ASSIGN_OR_RETURN_UNWRAP(&handle,
-                          args.Holder(),
-                          args.GetReturnValue().Set(UV_EINVAL));
-
-  StreamBase* wrap = static_cast<StreamBase*>(handle);
-  if (!wrap->IsAlive())
-    return args.GetReturnValue().Set(UV_EINVAL);
-
-  args.GetReturnValue().Set(wrap->GetFD());
-}
-
-
-template <class Base>
-void StreamBase::GetBytesRead(Local<String> key,
-                              const PropertyCallbackInfo<Value>& args) {
-  Base* handle = Unwrap<Base>(args.Holder());
-
-  // The handle instance hasn't been set. So no bytes could have been read.
-  ASSIGN_OR_RETURN_UNWRAP(&handle,
-                          args.Holder(),
-                          args.GetReturnValue().Set(0));
-
-  StreamBase* wrap = static_cast<StreamBase*>(handle);
-  // uint64_t -> double. 53bits is enough for all real cases.
-  args.GetReturnValue().Set(static_cast<double>(wrap->bytes_read_));
-}
-
-
-template <class Base>
-void StreamBase::GetExternal(Local<String> key,
-                             const PropertyCallbackInfo<Value>& args) {
-  Base* handle = Unwrap<Base>(args.Holder());
-
-  ASSIGN_OR_RETURN_UNWRAP(&handle, args.Holder());
-
-  StreamBase* wrap = static_cast<StreamBase*>(handle);
-  Local<External> ext = External::New(args.GetIsolate(), wrap);
-  args.GetReturnValue().Set(ext);
-}
-
-
-template <class Base,
-          int (StreamBase::*Method)(const FunctionCallbackInfo<Value>& args)>
-void StreamBase::JSMethod(const FunctionCallbackInfo<Value>& args) {
-  Base* handle = Unwrap<Base>(args.Holder());
-
-  ASSIGN_OR_RETURN_UNWRAP(&handle, args.Holder());
-
-  StreamBase* wrap = static_cast<StreamBase*>(handle);
-  if (!wrap->IsAlive())
-    return args.GetReturnValue().Set(UV_EINVAL);
-
-  args.GetReturnValue().Set((wrap->*Method)(args));
-}
-
-
-WriteWrap* WriteWrap::New(Environment* env,
-                          Local<Object> obj,
-                          StreamBase* wrap,
-                          DoneCb cb,
-                          size_t extra) {
-  size_t storage_size = ROUND_UP(sizeof(WriteWrap), kAlignSize) + extra;
-  char* storage = new char[storage_size];
-
-  return new(storage) WriteWrap(env, obj, wrap, cb, storage_size);
-}
-
-
-void WriteWrap::Dispose() {
-  this->~WriteWrap();
-  delete[] reinterpret_cast<char*>(this);
-}
-
-
-char* WriteWrap::Extra(size_t offset) {
-  return reinterpret_cast<char*>(this) +
-         ROUND_UP(sizeof(*this), kAlignSize) +
-         offset;
-}
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_STREAM_BASE_INL_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/stream_base.h
+++ /dev/null
@@ -1,293 +0,0 @@
-#ifndef SRC_STREAM_BASE_H_
-#define SRC_STREAM_BASE_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "env.h"
-#include "async-wrap.h"
-#include "req-wrap.h"
-#include "req-wrap-inl.h"
-#include "node.h"
-#include "util.h"
-
-#include "v8.h"
-
-namespace node {
-
-// Forward declarations
-class StreamBase;
-
-template <class Req>
-class StreamReq {
- public:
-  typedef void (*DoneCb)(Req* req, int status);
-
-  explicit StreamReq(DoneCb cb) : cb_(cb) {
-  }
-
-  inline void Done(int status, const char* error_str = nullptr) {
-    Req* req = static_cast<Req*>(this);
-    Environment* env = req->env();
-    if (error_str != nullptr) {
-      req->object()->Set(env->error_string(),
-                         OneByteString(env->isolate(), error_str));
-    }
-
-    cb_(req, status);
-  }
-
- private:
-  DoneCb cb_;
-};
-
-class ShutdownWrap : public ReqWrap<uv_shutdown_t>,
-                     public StreamReq<ShutdownWrap> {
- public:
-  ShutdownWrap(Environment* env,
-               v8::Local<v8::Object> req_wrap_obj,
-               StreamBase* wrap,
-               DoneCb cb)
-      : ReqWrap(env, req_wrap_obj, AsyncWrap::PROVIDER_SHUTDOWNWRAP),
-        StreamReq<ShutdownWrap>(cb),
-        wrap_(wrap) {
-    Wrap(req_wrap_obj, this);
-  }
-
-  static void NewShutdownWrap(const v8::FunctionCallbackInfo<v8::Value>& args) {
-    CHECK(args.IsConstructCall());
-  }
-
-  static ShutdownWrap* from_req(uv_shutdown_t* req) {
-    return ContainerOf(&ShutdownWrap::req_, req);
-  }
-
-  inline StreamBase* wrap() const { return wrap_; }
-  size_t self_size() const override { return sizeof(*this); }
-
- private:
-  StreamBase* const wrap_;
-};
-
-class WriteWrap: public ReqWrap<uv_write_t>,
-                 public StreamReq<WriteWrap> {
- public:
-  static inline WriteWrap* New(Environment* env,
-                               v8::Local<v8::Object> obj,
-                               StreamBase* wrap,
-                               DoneCb cb,
-                               size_t extra = 0);
-  inline void Dispose();
-  inline char* Extra(size_t offset = 0);
-
-  inline StreamBase* wrap() const { return wrap_; }
-
-  size_t self_size() const override { return storage_size_; }
-
-  static void NewWriteWrap(const v8::FunctionCallbackInfo<v8::Value>& args) {
-    CHECK(args.IsConstructCall());
-  }
-
-  static WriteWrap* from_req(uv_write_t* req) {
-    return ContainerOf(&WriteWrap::req_, req);
-  }
-
-  static const size_t kAlignSize = 16;
-
- protected:
-  WriteWrap(Environment* env,
-            v8::Local<v8::Object> obj,
-            StreamBase* wrap,
-            DoneCb cb,
-            size_t storage_size)
-      : ReqWrap(env, obj, AsyncWrap::PROVIDER_WRITEWRAP),
-        StreamReq<WriteWrap>(cb),
-        wrap_(wrap),
-        storage_size_(storage_size) {
-    Wrap(obj, this);
-  }
-
-  void* operator new(size_t size) = delete;
-  void* operator new(size_t size, char* storage) { return storage; }
-
-  // This is just to keep the compiler happy. It should never be called, since
-  // we don't use exceptions in node.
-  void operator delete(void* ptr, char* storage) { UNREACHABLE(); }
-
- private:
-  // People should not be using the non-placement new and delete operator on a
-  // WriteWrap. Ensure this never happens.
-  void operator delete(void* ptr) { UNREACHABLE(); }
-
-  StreamBase* const wrap_;
-  const size_t storage_size_;
-};
-
-class StreamResource {
- public:
-  template <class T>
-  struct Callback {
-    Callback() : fn(nullptr), ctx(nullptr) {}
-    Callback(T fn, void* ctx) : fn(fn), ctx(ctx) {}
-    Callback(const Callback&) = default;
-
-    inline bool is_empty() { return fn == nullptr; }
-    inline void clear() {
-      fn = nullptr;
-      ctx = nullptr;
-    }
-
-    T fn;
-    void* ctx;
-  };
-
-  typedef void (*AfterWriteCb)(WriteWrap* w, void* ctx);
-  typedef void (*AllocCb)(size_t size, uv_buf_t* buf, void* ctx);
-  typedef void (*ReadCb)(ssize_t nread,
-                         const uv_buf_t* buf,
-                         uv_handle_type pending,
-                         void* ctx);
-  typedef void (*DestructCb)(void* ctx);
-
-  StreamResource() : bytes_read_(0) {
-  }
-  virtual ~StreamResource() {
-    if (!destruct_cb_.is_empty())
-      destruct_cb_.fn(destruct_cb_.ctx);
-  }
-
-  virtual int DoShutdown(ShutdownWrap* req_wrap) = 0;
-  virtual int DoTryWrite(uv_buf_t** bufs, size_t* count);
-  virtual int DoWrite(WriteWrap* w,
-                      uv_buf_t* bufs,
-                      size_t count,
-                      uv_stream_t* send_handle) = 0;
-  virtual const char* Error() const;
-  virtual void ClearError();
-
-  // Events
-  inline void OnAfterWrite(WriteWrap* w) {
-    if (!after_write_cb_.is_empty())
-      after_write_cb_.fn(w, after_write_cb_.ctx);
-  }
-
-  inline void OnAlloc(size_t size, uv_buf_t* buf) {
-    if (!alloc_cb_.is_empty())
-      alloc_cb_.fn(size, buf, alloc_cb_.ctx);
-  }
-
-  inline void OnRead(ssize_t nread,
-                     const uv_buf_t* buf,
-                     uv_handle_type pending = UV_UNKNOWN_HANDLE) {
-    if (nread > 0)
-      bytes_read_ += static_cast<uint64_t>(nread);
-    if (!read_cb_.is_empty())
-      read_cb_.fn(nread, buf, pending, read_cb_.ctx);
-  }
-
-  inline void set_after_write_cb(Callback<AfterWriteCb> c) {
-    after_write_cb_ = c;
-  }
-
-  inline void set_alloc_cb(Callback<AllocCb> c) { alloc_cb_ = c; }
-  inline void set_read_cb(Callback<ReadCb> c) { read_cb_ = c; }
-  inline void set_destruct_cb(Callback<DestructCb> c) { destruct_cb_ = c; }
-
-  inline Callback<AfterWriteCb> after_write_cb() { return after_write_cb_; }
-  inline Callback<AllocCb> alloc_cb() { return alloc_cb_; }
-  inline Callback<ReadCb> read_cb() { return read_cb_; }
-  inline Callback<DestructCb> destruct_cb() { return destruct_cb_; }
-
- private:
-  Callback<AfterWriteCb> after_write_cb_;
-  Callback<AllocCb> alloc_cb_;
-  Callback<ReadCb> read_cb_;
-  Callback<DestructCb> destruct_cb_;
-  uint64_t bytes_read_;
-
-  friend class StreamBase;
-};
-
-class StreamBase : public StreamResource {
- public:
-  enum Flags {
-    kFlagNone = 0x0,
-    kFlagHasWritev = 0x1,
-    kFlagNoShutdown = 0x2
-  };
-
-  template <class Base>
-  static inline void AddMethods(Environment* env,
-                                v8::Local<v8::FunctionTemplate> target,
-                                int flags = kFlagNone);
-
-  virtual void* Cast() = 0;
-  virtual bool IsAlive() = 0;
-  virtual bool IsClosing() = 0;
-  virtual bool IsIPCPipe();
-  virtual int GetFD();
-
-  virtual int ReadStart() = 0;
-  virtual int ReadStop() = 0;
-
-  inline void Consume() {
-    CHECK_EQ(consumed_, false);
-    consumed_ = true;
-  }
-
-  template <class Outer>
-  inline Outer* Cast() { return static_cast<Outer*>(Cast()); }
-
-  void EmitData(ssize_t nread,
-                v8::Local<v8::Object> buf,
-                v8::Local<v8::Object> handle);
-
- protected:
-  explicit StreamBase(Environment* env) : env_(env), consumed_(false) {
-  }
-
-  virtual ~StreamBase() = default;
-
-  // One of these must be implemented
-  virtual AsyncWrap* GetAsyncWrap();
-  virtual v8::Local<v8::Object> GetObject();
-
-  // Libuv callbacks
-  static void AfterShutdown(ShutdownWrap* req, int status);
-  static void AfterWrite(WriteWrap* req, int status);
-
-  // JS Methods
-  int ReadStart(const v8::FunctionCallbackInfo<v8::Value>& args);
-  int ReadStop(const v8::FunctionCallbackInfo<v8::Value>& args);
-  int Shutdown(const v8::FunctionCallbackInfo<v8::Value>& args);
-  int Writev(const v8::FunctionCallbackInfo<v8::Value>& args);
-  int WriteBuffer(const v8::FunctionCallbackInfo<v8::Value>& args);
-  template <enum encoding enc>
-  int WriteString(const v8::FunctionCallbackInfo<v8::Value>& args);
-
-  template <class Base>
-  static void GetFD(v8::Local<v8::String> key,
-                    const v8::PropertyCallbackInfo<v8::Value>& args);
-
-  template <class Base>
-  static void GetExternal(v8::Local<v8::String> key,
-                          const v8::PropertyCallbackInfo<v8::Value>& args);
-
-  template <class Base>
-  static void GetBytesRead(v8::Local<v8::String> key,
-                           const v8::PropertyCallbackInfo<v8::Value>& args);
-
-  template <class Base,
-            int (StreamBase::*Method)(
-      const v8::FunctionCallbackInfo<v8::Value>& args)>
-  static void JSMethod(const v8::FunctionCallbackInfo<v8::Value>& args);
-
- private:
-  Environment* env_;
-  bool consumed_;
-};
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_STREAM_BASE_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/stream_wrap.h
+++ /dev/null
@@ -1,110 +0,0 @@
-#ifndef SRC_STREAM_WRAP_H_
-#define SRC_STREAM_WRAP_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "stream_base.h"
-
-#include "env.h"
-#include "handle_wrap.h"
-#include "string_bytes.h"
-#include "v8.h"
-
-namespace node {
-
-// Forward declaration
-class StreamWrap;
-
-class StreamWrap : public HandleWrap, public StreamBase {
- public:
-  static void Initialize(v8::Local<v8::Object> target,
-                         v8::Local<v8::Value> unused,
-                         v8::Local<v8::Context> context);
-
-  int GetFD() override;
-  void* Cast() override;
-  bool IsAlive() override;
-  bool IsClosing() override;
-  bool IsIPCPipe() override;
-
-  // JavaScript functions
-  int ReadStart() override;
-  int ReadStop() override;
-
-  // Resource implementation
-  int DoShutdown(ShutdownWrap* req_wrap) override;
-  int DoTryWrite(uv_buf_t** bufs, size_t* count) override;
-  int DoWrite(WriteWrap* w,
-              uv_buf_t* bufs,
-              size_t count,
-              uv_stream_t* send_handle) override;
-
-  inline uv_stream_t* stream() const {
-    return stream_;
-  }
-
-  inline bool is_named_pipe() const {
-    return stream()->type == UV_NAMED_PIPE;
-  }
-
-  inline bool is_named_pipe_ipc() const {
-    return is_named_pipe() &&
-           reinterpret_cast<const uv_pipe_t*>(stream())->ipc != 0;
-  }
-
-  inline bool is_tcp() const {
-    return stream()->type == UV_TCP;
-  }
-
- protected:
-  StreamWrap(Environment* env,
-             v8::Local<v8::Object> object,
-             uv_stream_t* stream,
-             AsyncWrap::ProviderType provider,
-             AsyncWrap* parent = nullptr);
-
-  ~StreamWrap() {
-  }
-
-  AsyncWrap* GetAsyncWrap() override;
-  void UpdateWriteQueueSize();
-
-  static void AddMethods(Environment* env,
-                         v8::Local<v8::FunctionTemplate> target,
-                         int flags = StreamBase::kFlagNone);
-
- private:
-  static void SetBlocking(const v8::FunctionCallbackInfo<v8::Value>& args);
-
-  // Callbacks for libuv
-  static void OnAlloc(uv_handle_t* handle,
-                      size_t suggested_size,
-                      uv_buf_t* buf);
-
-  static void OnRead(uv_stream_t* handle,
-                     ssize_t nread,
-                     const uv_buf_t* buf);
-  static void OnReadCommon(uv_stream_t* handle,
-                           ssize_t nread,
-                           const uv_buf_t* buf,
-                           uv_handle_type pending);
-  static void AfterWrite(uv_write_t* req, int status);
-  static void AfterShutdown(uv_shutdown_t* req, int status);
-
-  // Resource interface implementation
-  static void OnAfterWriteImpl(WriteWrap* w, void* ctx);
-  static void OnAllocImpl(size_t size, uv_buf_t* buf, void* ctx);
-  static void OnReadImpl(ssize_t nread,
-                         const uv_buf_t* buf,
-                         uv_handle_type pending,
-                         void* ctx);
-
-  uv_stream_t* const stream_;
-};
-
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_STREAM_WRAP_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/string_bytes.h
+++ /dev/null
@@ -1,115 +0,0 @@
-#ifndef SRC_STRING_BYTES_H_
-#define SRC_STRING_BYTES_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-// Decodes a v8::Local<v8::String> or Buffer to a raw char*
-
-#include "v8.h"
-#include "node.h"
-#include "env.h"
-#include "env-inl.h"
-#include "util.h"
-
-namespace node {
-
-class StringBytes {
- public:
-  class InlineDecoder : public MaybeStackBuffer<char> {
-   public:
-    inline bool Decode(Environment* env,
-                       v8::Local<v8::String> string,
-                       v8::Local<v8::Value> encoding,
-                       enum encoding _default) {
-      enum encoding enc = ParseEncoding(env->isolate(), encoding, _default);
-      if (!StringBytes::IsValidString(env->isolate(), string, enc)) {
-        env->ThrowTypeError("Bad input string");
-        return false;
-      }
-
-      const size_t storage = StringBytes::StorageSize(env->isolate(),
-                                                      string,
-                                                      enc);
-      AllocateSufficientStorage(storage);
-      const size_t length = StringBytes::Write(env->isolate(),
-                                               out(),
-                                               storage,
-                                               string,
-                                               enc);
-
-      // No zero terminator is included when using this method.
-      SetLength(length);
-      return true;
-    }
-
-    inline size_t size() const { return length(); }
-  };
-
-  // Does the string match the encoding? Quick but non-exhaustive.
-  // Example: a HEX string must have a length that's a multiple of two.
-  // FIXME(bnoordhuis) IsMaybeValidString()? Naming things is hard...
-  static bool IsValidString(v8::Isolate* isolate,
-                            v8::Local<v8::String> string,
-                            enum encoding enc);
-
-  // Fast, but can be 2 bytes oversized for Base64, and
-  // as much as triple UTF-8 strings <= 65536 chars in length
-  static size_t StorageSize(v8::Isolate* isolate,
-                            v8::Local<v8::Value> val,
-                            enum encoding enc);
-
-  // Precise byte count, but slightly slower for Base64 and
-  // very much slower for UTF-8
-  static size_t Size(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     enum encoding enc);
-
-  // If the string is external then assign external properties to data and len,
-  // then return true. If not return false.
-  static bool GetExternalParts(v8::Isolate* isolate,
-                               v8::Local<v8::Value> val,
-                               const char** data,
-                               size_t* len);
-
-  // Write the bytes from the string or buffer into the char*
-  // returns the number of bytes written, which will always be
-  // <= buflen.  Use StorageSize/Size first to know how much
-  // memory to allocate.
-  static size_t Write(v8::Isolate* isolate,
-                      char* buf,
-                      size_t buflen,
-                      v8::Local<v8::Value> val,
-                      enum encoding enc,
-                      int* chars_written = nullptr);
-
-  // Take the bytes in the src, and turn it into a Buffer or String.
-  // Don't call with encoding=UCS2.
-  static v8::Local<v8::Value> Encode(v8::Isolate* isolate,
-                                     const char* buf,
-                                     size_t buflen,
-                                     enum encoding encoding);
-
-  // The input buffer should be in host endianness.
-  static v8::Local<v8::Value> Encode(v8::Isolate* isolate,
-                                     const uint16_t* buf,
-                                     size_t buflen);
-
-  static v8::Local<v8::Value> Encode(v8::Isolate* isolate,
-                                     const char* buf,
-                                     enum encoding encoding);
-
- private:
-  static size_t WriteUCS2(char* buf,
-                          size_t buflen,
-                          size_t nbytes,
-                          const char* data,
-                          v8::Local<v8::String> str,
-                          int flags,
-                          size_t* chars_written);
-};
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_STRING_BYTES_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/string_search.h
+++ /dev/null
@@ -1,669 +0,0 @@
-// Copyright 2011 the V8 project authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef SRC_STRING_SEARCH_H_
-#define SRC_STRING_SEARCH_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "node.h"
-#include <string.h>
-
-namespace node {
-namespace stringsearch {
-
-
-// Returns the maximum of the two parameters.
-template <typename T>
-T Max(T a, T b) {
-  return a < b ? b : a;
-}
-
-
-static const uint32_t kMaxOneByteCharCodeU = 0xff;
-
-template <typename T>
-class Vector {
- public:
-  Vector(T* data, size_t length, bool isForward)
-      : start_(data), length_(length), is_forward_(isForward) {
-    ASSERT(length > 0 && data != nullptr);
-  }
-
-  // Returns the start of the memory range.
-  // For vector v this is NOT necessarily &v[0], see forward().
-  const T* start() const { return start_; }
-
-  // Returns the length of the vector, in characters.
-  size_t length() const { return length_; }
-
-  // Returns true if the Vector is front-to-back, false if back-to-front.
-  // In the latter case, v[0] corresponds to the *end* of the memory range.
-  size_t forward() const { return is_forward_; }
-
-  // Access individual vector elements - checks bounds in debug mode.
-  T& operator[](size_t index) const {
-    ASSERT(index < length_);
-    return start_[is_forward_ ? index : (length_ - index - 1)];
-  }
-
- private:
-  T* start_;
-  size_t length_;
-  bool is_forward_;
-};
-
-
-//---------------------------------------------------------------------
-// String Search object.
-//---------------------------------------------------------------------
-
-// Class holding constants and methods that apply to all string search variants,
-// independently of subject and pattern char size.
-class StringSearchBase {
- protected:
-  // Cap on the maximal shift in the Boyer-Moore implementation. By setting a
-  // limit, we can fix the size of tables. For a needle longer than this limit,
-  // search will not be optimal, since we only build tables for a suffix
-  // of the string, but it is a safe approximation.
-  static const int kBMMaxShift = 250;
-
-  // Reduce alphabet to this size.
-  // One of the tables used by Boyer-Moore and Boyer-Moore-Horspool has size
-  // proportional to the input alphabet. We reduce the alphabet size by
-  // equating input characters modulo a smaller alphabet size. This gives
-  // a potentially less efficient searching, but is a safe approximation.
-  // For needles using only characters in the same Unicode 256-code point page,
-  // there is no search speed degradation.
-  static const int kLatin1AlphabetSize = 256;
-  static const int kUC16AlphabetSize = 256;
-
-  // Bad-char shift table stored in the state. It's length is the alphabet size.
-  // For patterns below this length, the skip length of Boyer-Moore is too short
-  // to compensate for the algorithmic overhead compared to simple brute force.
-  static const int kBMMinPatternLength = 8;
-
-  // Store for the BoyerMoore(Horspool) bad char shift table.
-  static int kBadCharShiftTable[kUC16AlphabetSize];
-  // Store for the BoyerMoore good suffix shift table.
-  static int kGoodSuffixShiftTable[kBMMaxShift + 1];
-  // Table used temporarily while building the BoyerMoore good suffix
-  // shift table.
-  static int kSuffixTable[kBMMaxShift + 1];
-};
-
-template <typename Char>
-class StringSearch : private StringSearchBase {
- public:
-  explicit StringSearch(Vector<const Char> pattern)
-      : pattern_(pattern), start_(0) {
-    if (pattern.length() >= kBMMaxShift) {
-      start_ = pattern.length() - kBMMaxShift;
-    }
-
-    size_t pattern_length = pattern_.length();
-    CHECK_GT(pattern_length, 0);
-    if (pattern_length < kBMMinPatternLength) {
-      if (pattern_length == 1) {
-        strategy_ = &SingleCharSearch;
-        return;
-      }
-      strategy_ = &LinearSearch;
-      return;
-    }
-    strategy_ = &InitialSearch;
-  }
-
-  size_t Search(Vector<const Char> subject, size_t index) {
-    return strategy_(this, subject, index);
-  }
-
-  static inline int AlphabetSize() {
-    if (sizeof(Char) == 1) {
-      // Latin1 needle.
-      return kLatin1AlphabetSize;
-    } else {
-      // UC16 needle.
-      return kUC16AlphabetSize;
-    }
-
-    static_assert(sizeof(Char) == sizeof(uint8_t) ||
-                  sizeof(Char) == sizeof(uint16_t),
-                  "sizeof(Char) == sizeof(uint16_t) || sizeof(uint8_t)");
-  }
-
- private:
-  typedef size_t (*SearchFunction)(
-      StringSearch<Char>*,
-      Vector<const Char>,
-      size_t);
-
-  static size_t SingleCharSearch(StringSearch<Char>* search,
-                                 Vector<const Char> subject,
-                                 size_t start_index);
-
-  static size_t LinearSearch(StringSearch<Char>* search,
-                             Vector<const Char> subject,
-                             size_t start_index);
-
-  static size_t InitialSearch(StringSearch<Char>* search,
-                              Vector<const Char> subject,
-                              size_t start_index);
-
-  static size_t BoyerMooreHorspoolSearch(
-      StringSearch<Char>* search,
-      Vector<const Char> subject,
-      size_t start_index);
-
-  static size_t BoyerMooreSearch(StringSearch<Char>* search,
-                                 Vector<const Char> subject,
-                                 size_t start_index);
-
-  void PopulateBoyerMooreHorspoolTable();
-
-  void PopulateBoyerMooreTable();
-
-  static inline int CharOccurrence(int* bad_char_occurrence,
-                                   Char char_code) {
-    if (sizeof(Char) == 1) {
-      return bad_char_occurrence[static_cast<int>(char_code)];
-    }
-    // Both pattern and subject are UC16. Reduce character to equivalence class.
-    int equiv_class = char_code % kUC16AlphabetSize;
-    return bad_char_occurrence[equiv_class];
-  }
-
-  // Store for the BoyerMoore(Horspool) bad char shift table.
-  // Return a table covering the last kBMMaxShift+1 positions of
-  // pattern.
-  int* bad_char_table() { return kBadCharShiftTable; }
-
-  // Store for the BoyerMoore good suffix shift table.
-  int* good_suffix_shift_table() {
-    // Return biased pointer that maps the range  [start_..pattern_.length()
-    // to the kGoodSuffixShiftTable array.
-    return kGoodSuffixShiftTable - start_;
-  }
-
-  // Table used temporarily while building the BoyerMoore good suffix
-  // shift table.
-  int* suffix_table() {
-    // Return biased pointer that maps the range  [start_..pattern_.length()
-    // to the kSuffixTable array.
-    return kSuffixTable - start_;
-  }
-
-  // The pattern to search for.
-  Vector<const Char> pattern_;
-  // Pointer to implementation of the search.
-  SearchFunction strategy_;
-  // Cache value of Max(0, pattern_length() - kBMMaxShift)
-  size_t start_;
-};
-
-
-template <typename T, typename U>
-inline T AlignDown(T value, U alignment) {
-  return reinterpret_cast<T>(
-      (reinterpret_cast<uintptr_t>(value) & ~(alignment - 1)));
-}
-
-
-inline uint8_t GetHighestValueByte(uint16_t character) {
-  return Max(static_cast<uint8_t>(character & 0xFF),
-             static_cast<uint8_t>(character >> 8));
-}
-
-
-inline uint8_t GetHighestValueByte(uint8_t character) { return character; }
-
-
-// Searches for a byte value in a memory buffer, back to front.
-// Uses memrchr(3) on systems which support it, for speed.
-// Falls back to a vanilla for loop on non-GNU systems such as Windows.
-inline const void* MemrchrFill(const void* haystack, uint8_t needle,
-                               size_t haystack_len) {
-#ifdef _GNU_SOURCE
-  return memrchr(haystack, needle, haystack_len);
-#else
-  const uint8_t* haystack8 = static_cast<const uint8_t*>(haystack);
-  for (size_t i = haystack_len - 1; i != static_cast<size_t>(-1); i--) {
-    if (haystack8[i] == needle) {
-      return haystack8 + i;
-    }
-  }
-  return nullptr;
-#endif
-}
-
-
-// Finds the first occurrence of *two-byte* character pattern[0] in the string
-// `subject`. Does not check that the whole pattern matches.
-template <typename Char>
-inline size_t FindFirstCharacter(Vector<const Char> pattern,
-                                 Vector<const Char> subject, size_t index) {
-  const Char pattern_first_char = pattern[0];
-  const size_t max_n = (subject.length() - pattern.length() + 1);
-
-  // For speed, search for the more `rare` of the two bytes in pattern[0]
-  // using memchr / memrchr (which are much faster than a simple for loop).
-  const uint8_t search_byte = GetHighestValueByte(pattern_first_char);
-  size_t pos = index;
-  do {
-    const size_t bytes_to_search = (max_n - pos) * sizeof(Char);
-    const void* void_pos;
-    if (subject.forward()) {
-      // Assert that bytes_to_search won't overflow
-      CHECK_LE(pos, max_n);
-      CHECK_LE(max_n - pos, SIZE_MAX / sizeof(Char));
-      void_pos = memchr(subject.start() + pos, search_byte, bytes_to_search);
-    } else {
-      CHECK_LE(pos, subject.length());
-      CHECK_LE(subject.length() - pos, SIZE_MAX / sizeof(Char));
-      void_pos = MemrchrFill(subject.start() + pattern.length() - 1,
-                             search_byte,
-                             bytes_to_search);
-    }
-    const Char* char_pos = static_cast<const Char*>(void_pos);
-    if (char_pos == nullptr)
-      return subject.length();
-
-    // Then, for each match, verify that the full two bytes match pattern[0].
-    char_pos = AlignDown(char_pos, sizeof(Char));
-    size_t raw_pos = static_cast<size_t>(char_pos - subject.start());
-    pos = subject.forward() ? raw_pos : (subject.length() - raw_pos - 1);
-    if (subject[pos] == pattern_first_char) {
-      // Match found, hooray.
-      return pos;
-    }
-    // Search byte matched, but the other byte of pattern[0] didn't. Keep going.
-  } while (++pos < max_n);
-
-  return subject.length();
-}
-
-
-// Finds the first occurrence of the byte pattern[0] in string `subject`.
-// Does not verify that the whole pattern matches.
-template <>
-inline size_t FindFirstCharacter(Vector<const uint8_t> pattern,
-                                 Vector<const uint8_t> subject,
-                                 size_t index) {
-  const uint8_t pattern_first_char = pattern[0];
-  const size_t subj_len = subject.length();
-  const size_t max_n = (subject.length() - pattern.length() + 1);
-
-  const void* pos;
-  if (subject.forward()) {
-    pos = memchr(subject.start() + index, pattern_first_char, max_n - index);
-  } else {
-    pos = MemrchrFill(subject.start() + pattern.length() - 1,
-                      pattern_first_char,
-                      max_n - index);
-  }
-  const uint8_t* char_pos = static_cast<const uint8_t*>(pos);
-  if (char_pos == nullptr) {
-    return subj_len;
-  }
-
-  size_t raw_pos = static_cast<size_t>(char_pos - subject.start());
-  return subject.forward() ? raw_pos : (subj_len - raw_pos - 1);
-}
-
-//---------------------------------------------------------------------
-// Single Character Pattern Search Strategy
-//---------------------------------------------------------------------
-
-template <typename Char>
-size_t StringSearch<Char>::SingleCharSearch(
-    StringSearch<Char>* search,
-    Vector<const Char> subject,
-    size_t index) {
-  CHECK_EQ(1, search->pattern_.length());
-  return FindFirstCharacter(search->pattern_, subject, index);
-}
-
-//---------------------------------------------------------------------
-// Linear Search Strategy
-//---------------------------------------------------------------------
-
-// Simple linear search for short patterns. Never bails out.
-template <typename Char>
-size_t StringSearch<Char>::LinearSearch(
-    StringSearch<Char>* search,
-    Vector<const Char> subject,
-    size_t index) {
-  Vector<const Char> pattern = search->pattern_;
-  CHECK_GT(pattern.length(), 1);
-  const size_t pattern_length = pattern.length();
-  const size_t n = subject.length() - pattern_length;
-  for (size_t i = index; i <= n; i++) {
-    i = FindFirstCharacter(pattern, subject, i);
-    if (i == subject.length())
-      return subject.length();
-    ASSERT_LE(i, n);
-
-    bool matches = true;
-    for (size_t j = 1; j < pattern_length; j++) {
-      if (pattern[j] != subject[i + j]) {
-        matches = false;
-        break;
-      }
-    }
-    if (matches) {
-      return i;
-    }
-  }
-  return subject.length();
-}
-
-//---------------------------------------------------------------------
-// Boyer-Moore string search
-//---------------------------------------------------------------------
-
-template <typename Char>
-size_t StringSearch<Char>::BoyerMooreSearch(
-    StringSearch<Char>* search,
-    Vector<const Char> subject,
-    size_t start_index) {
-  Vector<const Char> pattern = search->pattern_;
-  const size_t subject_length = subject.length();
-  const size_t pattern_length = pattern.length();
-  // Only preprocess at most kBMMaxShift last characters of pattern.
-  size_t start = search->start_;
-
-  int* bad_char_occurrence = search->bad_char_table();
-  int* good_suffix_shift = search->good_suffix_shift_table();
-
-  Char last_char = pattern[pattern_length - 1];
-  size_t index = start_index;
-  // Continue search from i.
-  while (index <= subject_length - pattern_length) {
-    size_t j = pattern_length - 1;
-    int c;
-    while (last_char != (c = subject[index + j])) {
-      int shift = j - CharOccurrence(bad_char_occurrence, c);
-      index += shift;
-      if (index > subject_length - pattern_length) {
-        return subject.length();
-      }
-    }
-    while (pattern[j] == (c = subject[index + j])) {
-      if (j == 0) {
-        return index;
-      }
-      j--;
-    }
-    if (j < start) {
-      // we have matched more than our tables allow us to be smart about.
-      // Fall back on BMH shift.
-      index += pattern_length - 1 -
-               CharOccurrence(bad_char_occurrence,
-                              static_cast<Char>(last_char));
-    } else {
-      int gs_shift = good_suffix_shift[j + 1];
-      int bc_occ = CharOccurrence(bad_char_occurrence, c);
-      int shift = j - bc_occ;
-      if (gs_shift > shift) {
-        shift = gs_shift;
-      }
-      index += shift;
-    }
-  }
-
-  return subject.length();
-}
-
-template <typename Char>
-void StringSearch<Char>::PopulateBoyerMooreTable() {
-  const size_t pattern_length = pattern_.length();
-  Vector<const Char> pattern = pattern_;
-  // Only look at the last kBMMaxShift characters of pattern (from start_
-  // to pattern_length).
-  const size_t start = start_;
-  const size_t length = pattern_length - start;
-
-  // Biased tables so that we can use pattern indices as table indices,
-  // even if we only cover the part of the pattern from offset start.
-  int* shift_table = good_suffix_shift_table();
-  int* suffix_table = this->suffix_table();
-
-  // Initialize table.
-  for (size_t i = start; i < pattern_length; i++) {
-    shift_table[i] = length;
-  }
-  shift_table[pattern_length] = 1;
-  suffix_table[pattern_length] = pattern_length + 1;
-
-  if (pattern_length <= start) {
-    return;
-  }
-
-  // Find suffixes.
-  Char last_char = pattern_[pattern_length - 1];
-  size_t suffix = pattern_length + 1;
-  {
-    size_t i = pattern_length;
-    while (i > start) {
-      Char c = pattern[i - 1];
-      while (suffix <= pattern_length && c != pattern[suffix - 1]) {
-        if (static_cast<size_t>(shift_table[suffix]) == length) {
-          shift_table[suffix] = suffix - i;
-        }
-        suffix = suffix_table[suffix];
-      }
-      suffix_table[--i] = --suffix;
-      if (suffix == pattern_length) {
-        // No suffix to extend, so we check against last_char only.
-        while ((i > start) && (pattern[i - 1] != last_char)) {
-          if (static_cast<size_t>(shift_table[pattern_length]) == length) {
-            shift_table[pattern_length] = pattern_length - i;
-          }
-          suffix_table[--i] = pattern_length;
-        }
-        if (i > start) {
-          suffix_table[--i] = --suffix;
-        }
-      }
-    }
-  }
-  // Build shift table using suffixes.
-  if (suffix < pattern_length) {
-    for (size_t i = start; i <= pattern_length; i++) {
-      if (static_cast<size_t>(shift_table[i]) == length) {
-        shift_table[i] = suffix - start;
-      }
-      if (i == suffix) {
-        suffix = suffix_table[suffix];
-      }
-    }
-  }
-}
-
-//---------------------------------------------------------------------
-// Boyer-Moore-Horspool string search.
-//---------------------------------------------------------------------
-
-template <typename Char>
-size_t StringSearch<Char>::BoyerMooreHorspoolSearch(
-    StringSearch<Char>* search,
-    Vector<const Char> subject,
-    size_t start_index) {
-  Vector<const Char> pattern = search->pattern_;
-  const size_t subject_length = subject.length();
-  const size_t pattern_length = pattern.length();
-  int* char_occurrences = search->bad_char_table();
-  int64_t badness = -pattern_length;
-
-  // How bad we are doing without a good-suffix table.
-  Char last_char = pattern[pattern_length - 1];
-  int last_char_shift =
-      pattern_length - 1 -
-      CharOccurrence(char_occurrences, static_cast<Char>(last_char));
-
-  // Perform search
-  size_t index = start_index;  // No matches found prior to this index.
-  while (index <= subject_length - pattern_length) {
-    size_t j = pattern_length - 1;
-    int subject_char;
-    while (last_char != (subject_char = subject[index + j])) {
-      int bc_occ = CharOccurrence(char_occurrences, subject_char);
-      int shift = j - bc_occ;
-      index += shift;
-      badness += 1 - shift;  // at most zero, so badness cannot increase.
-      if (index > subject_length - pattern_length) {
-        return subject_length;
-      }
-    }
-    j--;
-    while (pattern[j] == (subject[index + j])) {
-      if (j == 0) {
-        return index;
-      }
-      j--;
-    }
-    index += last_char_shift;
-    // Badness increases by the number of characters we have
-    // checked, and decreases by the number of characters we
-    // can skip by shifting. It's a measure of how we are doing
-    // compared to reading each character exactly once.
-    badness += (pattern_length - j) - last_char_shift;
-    if (badness > 0) {
-      search->PopulateBoyerMooreTable();
-      search->strategy_ = &BoyerMooreSearch;
-      return BoyerMooreSearch(search, subject, index);
-    }
-  }
-  return subject.length();
-}
-
-template <typename Char>
-void StringSearch<Char>::PopulateBoyerMooreHorspoolTable() {
-  const size_t pattern_length = pattern_.length();
-
-  int* bad_char_occurrence = bad_char_table();
-
-  // Only preprocess at most kBMMaxShift last characters of pattern.
-  const size_t start = start_;
-  // Run forwards to populate bad_char_table, so that *last* instance
-  // of character equivalence class is the one registered.
-  // Notice: Doesn't include the last character.
-  const size_t table_size = AlphabetSize();
-  if (start == 0) {
-    // All patterns less than kBMMaxShift in length.
-    memset(bad_char_occurrence, -1, table_size * sizeof(*bad_char_occurrence));
-  } else {
-    for (size_t i = 0; i < table_size; i++) {
-      bad_char_occurrence[i] = start - 1;
-    }
-  }
-  for (size_t i = start; i < pattern_length - 1; i++) {
-    Char c = pattern_[i];
-    int bucket = (sizeof(Char) == 1) ? c : c % AlphabetSize();
-    bad_char_occurrence[bucket] = i;
-  }
-}
-
-//---------------------------------------------------------------------
-// Linear string search with bailout to BMH.
-//---------------------------------------------------------------------
-
-// Simple linear search for short patterns, which bails out if the string
-// isn't found very early in the subject. Upgrades to BoyerMooreHorspool.
-template <typename Char>
-size_t StringSearch<Char>::InitialSearch(
-    StringSearch<Char>* search,
-    Vector<const Char> subject,
-    size_t index) {
-  Vector<const Char> pattern = search->pattern_;
-  const size_t pattern_length = pattern.length();
-  // Badness is a count of how much work we have done.  When we have
-  // done enough work we decide it's probably worth switching to a better
-  // algorithm.
-  int64_t badness = -10 - (pattern_length << 2);
-
-  // We know our pattern is at least 2 characters, we cache the first so
-  // the common case of the first character not matching is faster.
-  for (size_t i = index, n = subject.length() - pattern_length; i <= n; i++) {
-    badness++;
-    if (badness <= 0) {
-      i = FindFirstCharacter(pattern, subject, i);
-      if (i == subject.length())
-        return subject.length();
-      ASSERT_LE(i, n);
-      size_t j = 1;
-      do {
-        if (pattern[j] != subject[i + j]) {
-          break;
-        }
-        j++;
-      } while (j < pattern_length);
-      if (j == pattern_length) {
-        return i;
-      }
-      badness += j;
-    } else {
-      search->PopulateBoyerMooreHorspoolTable();
-      search->strategy_ = &BoyerMooreHorspoolSearch;
-      return BoyerMooreHorspoolSearch(search, subject, i);
-    }
-  }
-  return subject.length();
-}
-
-// Perform a a single stand-alone search.
-// If searching multiple times for the same pattern, a search
-// object should be constructed once and the Search function then called
-// for each search.
-template <typename Char>
-size_t SearchString(Vector<const Char> subject,
-                    Vector<const Char> pattern,
-                    size_t start_index) {
-  StringSearch<Char> search(pattern);
-  return search.Search(subject, start_index);
-}
-}  // namespace stringsearch
-}  // namespace node
-
-namespace node {
-using node::stringsearch::Vector;
-
-template <typename Char>
-size_t SearchString(const Char* haystack,
-                    size_t haystack_length,
-                    const Char* needle,
-                    size_t needle_length,
-                    size_t start_index,
-                    bool is_forward) {
-  // To do a reverse search (lastIndexOf instead of indexOf) without redundant
-  // code, create two vectors that are reversed views into the input strings.
-  // For example, v_needle[0] would return the *last* character of the needle.
-  // So we're searching for the first instance of rev(needle) in rev(haystack)
-  Vector<const Char> v_needle = Vector<const Char>(
-      needle, needle_length, is_forward);
-  Vector<const Char> v_haystack = Vector<const Char>(
-      haystack, haystack_length, is_forward);
-  ASSERT(haystack_length >= needle_length);
-  size_t diff = haystack_length - needle_length;
-  size_t relative_start_index;
-  if (is_forward) {
-    relative_start_index = start_index;
-  } else if (diff < start_index) {
-    relative_start_index = 0;
-  } else {
-    relative_start_index = diff - start_index;
-  }
-  size_t pos = node::stringsearch::SearchString(
-      v_haystack, v_needle, relative_start_index);
-  if (pos == haystack_length) {
-    // not found
-    return pos;
-  }
-  return is_forward ? pos : (haystack_length - needle_length - pos);
-}
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_STRING_SEARCH_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/tcp_wrap.h
+++ /dev/null
@@ -1,52 +0,0 @@
-#ifndef SRC_TCP_WRAP_H_
-#define SRC_TCP_WRAP_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "async-wrap.h"
-#include "env.h"
-#include "connection_wrap.h"
-
-namespace node {
-
-class TCPWrap : public ConnectionWrap<TCPWrap, uv_tcp_t> {
- public:
-  static v8::Local<v8::Object> Instantiate(Environment* env, AsyncWrap* parent);
-  static void Initialize(v8::Local<v8::Object> target,
-                         v8::Local<v8::Value> unused,
-                         v8::Local<v8::Context> context);
-
-  size_t self_size() const override { return sizeof(*this); }
-
- private:
-  typedef uv_tcp_t HandleType;
-
-  template <typename T,
-            int (*F)(const typename T::HandleType*, sockaddr*, int*)>
-  friend void GetSockOrPeerName(const v8::FunctionCallbackInfo<v8::Value>&);
-
-  TCPWrap(Environment* env, v8::Local<v8::Object> object, AsyncWrap* parent);
-  ~TCPWrap();
-
-  static void New(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void SetNoDelay(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void SetKeepAlive(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void Bind(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void Bind6(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void Listen(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void Connect(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void Connect6(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void Open(const v8::FunctionCallbackInfo<v8::Value>& args);
-
-#ifdef _WIN32
-  static void SetSimultaneousAccepts(
-      const v8::FunctionCallbackInfo<v8::Value>& args);
-#endif
-};
-
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_TCP_WRAP_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/tls_wrap.h
+++ /dev/null
@@ -1,174 +0,0 @@
-#ifndef SRC_TLS_WRAP_H_
-#define SRC_TLS_WRAP_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "node.h"
-#include "node_crypto.h"  // SSLWrap
-
-#include "async-wrap.h"
-#include "env.h"
-#include "stream_wrap.h"
-#include "util.h"
-#include "v8.h"
-
-#include <openssl/ssl.h>
-
-namespace node {
-
-// Forward-declarations
-class NodeBIO;
-class WriteWrap;
-namespace crypto {
-class SecureContext;
-}
-
-class TLSWrap : public AsyncWrap,
-                public crypto::SSLWrap<TLSWrap>,
-                public StreamBase {
- public:
-  ~TLSWrap() override;
-
-  static void Initialize(v8::Local<v8::Object> target,
-                         v8::Local<v8::Value> unused,
-                         v8::Local<v8::Context> context);
-
-  void* Cast() override;
-  int GetFD() override;
-  bool IsAlive() override;
-  bool IsClosing() override;
-
-  // JavaScript functions
-  int ReadStart() override;
-  int ReadStop() override;
-
-  int DoShutdown(ShutdownWrap* req_wrap) override;
-  int DoWrite(WriteWrap* w,
-              uv_buf_t* bufs,
-              size_t count,
-              uv_stream_t* send_handle) override;
-  const char* Error() const override;
-  void ClearError() override;
-
-  void NewSessionDoneCb();
-
-  size_t self_size() const override { return sizeof(*this); }
-
-  void clear_stream() { stream_ = nullptr; }
-
- protected:
-  static const int kClearOutChunkSize = 16384;
-
-  // Maximum number of bytes for hello parser
-  static const int kMaxHelloLength = 16384;
-
-  // Usual ServerHello + Certificate size
-  static const int kInitialClientBufferLength = 4096;
-
-  // Maximum number of buffers passed to uv_write()
-  static const int kSimultaneousBufferCount = 10;
-
-  // Write callback queue's item
-  class WriteItem {
-   public:
-    explicit WriteItem(WriteWrap* w) : w_(w) {
-    }
-    ~WriteItem() {
-      w_ = nullptr;
-    }
-
-    WriteWrap* w_;
-    ListNode<WriteItem> member_;
-  };
-
-  TLSWrap(Environment* env,
-          Kind kind,
-          StreamBase* stream,
-          crypto::SecureContext* sc);
-
-  static void SSLInfoCallback(const SSL* ssl_, int where, int ret);
-  void InitSSL();
-  void EncOut();
-  static void EncOutCb(WriteWrap* req_wrap, int status);
-  bool ClearIn();
-  void ClearOut();
-  void MakePending();
-  bool InvokeQueued(int status, const char* error_str = nullptr);
-
-  inline void Cycle() {
-    // Prevent recursion
-    if (++cycle_depth_ > 1)
-      return;
-
-    for (; cycle_depth_ > 0; cycle_depth_--) {
-      ClearIn();
-      ClearOut();
-      EncOut();
-    }
-  }
-
-  AsyncWrap* GetAsyncWrap() override;
-  bool IsIPCPipe() override;
-
-  // Resource implementation
-  static void OnAfterWriteImpl(WriteWrap* w, void* ctx);
-  static void OnAllocImpl(size_t size, uv_buf_t* buf, void* ctx);
-  static void OnReadImpl(ssize_t nread,
-                         const uv_buf_t* buf,
-                         uv_handle_type pending,
-                         void* ctx);
-  static void OnAfterWriteSelf(WriteWrap* w, void* ctx);
-  static void OnAllocSelf(size_t size, uv_buf_t* buf, void* ctx);
-  static void OnReadSelf(ssize_t nread,
-                         const uv_buf_t* buf,
-                         uv_handle_type pending,
-                         void* ctx);
-  static void OnDestructImpl(void* ctx);
-
-  void DoRead(ssize_t nread, const uv_buf_t* buf, uv_handle_type pending);
-
-  // If |msg| is not nullptr, caller is responsible for calling `delete[] *msg`.
-  v8::Local<v8::Value> GetSSLError(int status, int* err, const char** msg);
-
-  static void OnClientHelloParseEnd(void* arg);
-  static void Wrap(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void Receive(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void Start(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void SetVerifyMode(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void EnableSessionCallbacks(
-      const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void EnableCertCb(
-      const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void DestroySSL(const v8::FunctionCallbackInfo<v8::Value>& args);
-
-#ifdef SSL_CTRL_SET_TLSEXT_SERVERNAME_CB
-  static void GetServername(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void SetServername(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static int SelectSNIContextCallback(SSL* s, int* ad, void* arg);
-#endif  // SSL_CTRL_SET_TLSEXT_SERVERNAME_CB
-
-  crypto::SecureContext* sc_;
-  StreamBase* stream_;
-  BIO* enc_in_;
-  BIO* enc_out_;
-  NodeBIO* clear_in_;
-  size_t write_size_;
-  typedef ListHead<WriteItem, &WriteItem::member_> WriteItemList;
-  WriteItemList write_item_queue_;
-  WriteItemList pending_write_items_;
-  bool started_;
-  bool established_;
-  bool shutdown_;
-  const char* error_;
-  int cycle_depth_;
-
-  // If true - delivered EOF to the js-land, either after `close_notify`, or
-  // after the `UV_EOF` on socket.
-  bool eof_;
-};
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_TLS_WRAP_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/tracing/agent.h
+++ /dev/null
@@ -1,31 +0,0 @@
-#ifndef SRC_TRACING_AGENT_H_
-#define SRC_TRACING_AGENT_H_
-
-#include "tracing/node_trace_buffer.h"
-#include "tracing/node_trace_writer.h"
-#include "uv.h"
-#include "v8.h"
-
-namespace node {
-namespace tracing {
-
-class Agent {
- public:
-  explicit Agent();
-  void Start(v8::Platform* platform, const std::string& enabled_categories);
-  void Stop();
-
- private:
-  bool IsStarted() { return platform_ != nullptr; }
-  static void ThreadCb(void* arg);
-
-  uv_thread_t thread_;
-  uv_loop_t tracing_loop_;
-  v8::Platform* platform_ = nullptr;
-  TracingController* tracing_controller_ = nullptr;
-};
-
-}  // namespace tracing
-}  // namespace node
-
-#endif  // SRC_TRACING_AGENT_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/tracing/node_trace_buffer.h
+++ /dev/null
@@ -1,87 +0,0 @@
-#ifndef SRC_NODE_TRACE_BUFFER_H_
-#define SRC_NODE_TRACE_BUFFER_H_
-
-#include "node_mutex.h"
-#include "tracing/node_trace_writer.h"
-#include "libplatform/v8-tracing.h"
-
-#include <atomic>
-
-namespace node {
-namespace tracing {
-
-using v8::platform::tracing::TraceBuffer;
-using v8::platform::tracing::TraceBufferChunk;
-using v8::platform::tracing::TraceObject;
-
-// forward declaration
-class NodeTraceBuffer;
-
-class InternalTraceBuffer {
- public:
-  InternalTraceBuffer(size_t max_chunks, uint32_t id,
-                      NodeTraceWriter* trace_writer);
-
-  TraceObject* AddTraceEvent(uint64_t* handle);
-  TraceObject* GetEventByHandle(uint64_t handle);
-  void Flush(bool blocking);
-  bool IsFull() const {
-    return total_chunks_ == max_chunks_ && chunks_[total_chunks_ - 1]->IsFull();
-  }
-  bool IsFlushing() const {
-    return flushing_;
-  }
-
- private:
-  uint64_t MakeHandle(size_t chunk_index, uint32_t chunk_seq,
-                      size_t event_index) const;
-  void ExtractHandle(uint64_t handle, uint32_t* buffer_id, size_t* chunk_index,
-                     uint32_t* chunk_seq, size_t* event_index) const;
-  size_t Capacity() const { return max_chunks_ * TraceBufferChunk::kChunkSize; }
-
-  Mutex mutex_;
-  bool flushing_;
-  size_t max_chunks_;
-  NodeTraceWriter* trace_writer_;
-  std::vector<std::unique_ptr<TraceBufferChunk>> chunks_;
-  size_t total_chunks_ = 0;
-  uint32_t current_chunk_seq_ = 1;
-  uint32_t id_;
-};
-
-class NodeTraceBuffer : public TraceBuffer {
- public:
-  NodeTraceBuffer(size_t max_chunks, NodeTraceWriter* trace_writer,
-                  uv_loop_t* tracing_loop);
-  ~NodeTraceBuffer();
-
-  TraceObject* AddTraceEvent(uint64_t* handle) override;
-  TraceObject* GetEventByHandle(uint64_t handle) override;
-  bool Flush() override;
-
-  static const size_t kBufferChunks = 1024;
-
- private:
-  bool TryLoadAvailableBuffer();
-  static void NonBlockingFlushSignalCb(uv_async_t* signal);
-  static void ExitSignalCb(uv_async_t* signal);
-
-  uv_loop_t* tracing_loop_;
-  uv_async_t flush_signal_;
-  uv_async_t exit_signal_;
-  bool exited_ = false;
-  // Used exclusively for exit logic.
-  Mutex exit_mutex_;
-  // Used to wait until async handles have been closed.
-  ConditionVariable exit_cond_;
-  std::unique_ptr<NodeTraceWriter> trace_writer_;
-  // TODO: Change std::atomic to something less contentious.
-  std::atomic<InternalTraceBuffer*> current_buf_;
-  InternalTraceBuffer buffer1_;
-  InternalTraceBuffer buffer2_;
-};
-
-}  // namespace tracing
-}  // namespace node
-
-#endif  // SRC_NODE_TRACING_CONTROLLER_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/tracing/node_trace_writer.h
+++ /dev/null
@@ -1,74 +0,0 @@
-#ifndef SRC_NODE_TRACE_WRITER_H_
-#define SRC_NODE_TRACE_WRITER_H_
-
-#include <sstream>
-#include <queue>
-
-#include "node_mutex.h"
-#include "libplatform/v8-tracing.h"
-#include "uv.h"
-
-namespace node {
-namespace tracing {
-
-using v8::platform::tracing::TraceObject;
-using v8::platform::tracing::TraceWriter;
-using v8::platform::tracing::TracingController;
-
-class NodeTraceWriter : public TraceWriter {
- public:
-  NodeTraceWriter(uv_loop_t* tracing_loop);
-  ~NodeTraceWriter();
-
-  void AppendTraceEvent(TraceObject* trace_event) override;
-  void Flush() override;
-  void Flush(bool blocking);
-
-  static const int kTracesPerFile = 1 << 19;
-
- private:
-  struct WriteRequest {
-    uv_fs_t req;
-    NodeTraceWriter* writer;
-    std::string str;
-    int highest_request_id;
-  };
-
-  static void WriteCb(uv_fs_t* req);
-  void OpenNewFileForStreaming();
-  void WriteToFile(std::string&& str, int highest_request_id);
-  void WriteSuffix();
-  static void FlushSignalCb(uv_async_t* signal);
-  void FlushPrivate();
-  static void ExitSignalCb(uv_async_t* signal);
-
-  uv_loop_t* tracing_loop_;
-  // Triggers callback to initiate writing the contents of stream_ to disk.
-  uv_async_t flush_signal_;
-  // Triggers callback to close async objects, ending the tracing thread.
-  uv_async_t exit_signal_;
-  // Prevents concurrent R/W on state related to serialized trace data
-  // before it's written to disk, namely stream_ and total_traces_.
-  Mutex stream_mutex_;
-  // Prevents concurrent R/W on state related to write requests.
-  Mutex request_mutex_;
-  // Allows blocking calls to Flush() to wait on a condition for
-  // trace events to be written to disk.
-  ConditionVariable request_cond_;
-  // Used to wait until async handles have been closed.
-  ConditionVariable exit_cond_;
-  int fd_ = -1;
-  std::queue<WriteRequest*> write_req_queue_;
-  int num_write_requests_ = 0;
-  int highest_request_id_completed_ = 0;
-  int total_traces_ = 0;
-  int file_num_ = 0;
-  std::ostringstream stream_;
-  TraceWriter* json_trace_writer_ = nullptr;
-  bool exited_ = false;
-};
-
-}  // namespace tracing
-}  // namespace node
-
-#endif  // SRC_NODE_TRACE_WRITER_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/tracing/trace_event.h
+++ /dev/null
@@ -1,1710 +0,0 @@
-// Copyright 2015 the V8 project authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef SRC_TRACING_TRACE_EVENT_H_
-#define SRC_TRACING_TRACE_EVENT_H_
-
-#include <stddef.h>
-
-#include "v8-platform.h"
-
-// This header file defines implementation details of how the trace macros in
-// trace_event_common.h collect and store trace events. Anything not
-// implementation-specific should go in trace_macros_common.h instead of here.
-
-// From v8/base/trace_event/common/trace_event_common.h
-
-// This header file defines the set of trace_event macros without specifying
-// how the events actually get collected and stored. If you need to expose trace
-// events to some other universe, you can copy-and-paste this file as well as
-// trace_event.h, modifying the macros contained there as necessary for the
-// target platform. The end result is that multiple libraries can funnel events
-// through to a shared trace event collector.
-
-// IMPORTANT: To avoid conflicts, if you need to modify this file for a library,
-// land your change in base/ first, and then copy-and-paste it.
-
-// Trace events are for tracking application performance and resource usage.
-// Macros are provided to track:
-//    Begin and end of function calls
-//    Counters
-//
-// Events are issued against categories. Whereas LOG's
-// categories are statically defined, TRACE categories are created
-// implicitly with a string. For example:
-//   TRACE_EVENT_INSTANT0("MY_SUBSYSTEM", "SomeImportantEvent",
-//                        TRACE_EVENT_SCOPE_THREAD)
-//
-// It is often the case that one trace may belong in multiple categories at the
-// same time. The first argument to the trace can be a comma-separated list of
-// categories, forming a category group, like:
-//
-// TRACE_EVENT_INSTANT0("input,views", "OnMouseOver", TRACE_EVENT_SCOPE_THREAD)
-//
-// We can enable/disable tracing of OnMouseOver by enabling/disabling either
-// category.
-//
-// Events can be INSTANT, or can be pairs of BEGIN and END in the same scope:
-//   TRACE_EVENT_BEGIN0("MY_SUBSYSTEM", "SomethingCostly")
-//   doSomethingCostly()
-//   TRACE_EVENT_END0("MY_SUBSYSTEM", "SomethingCostly")
-// Note: our tools can't always determine the correct BEGIN/END pairs unless
-// these are used in the same scope. Use ASYNC_BEGIN/ASYNC_END macros if you
-// need them to be in separate scopes.
-//
-// A common use case is to trace entire function scopes. This
-// issues a trace BEGIN and END automatically:
-//   void doSomethingCostly() {
-//     TRACE_EVENT0("MY_SUBSYSTEM", "doSomethingCostly");
-//     ...
-//   }
-//
-// Additional parameters can be associated with an event:
-//   void doSomethingCostly2(int howMuch) {
-//     TRACE_EVENT1("MY_SUBSYSTEM", "doSomethingCostly",
-//         "howMuch", howMuch);
-//     ...
-//   }
-//
-// The trace system will automatically add to this information the
-// current process id, thread id, and a timestamp in microseconds.
-//
-// To trace an asynchronous procedure such as an IPC send/receive, use
-// ASYNC_BEGIN and ASYNC_END:
-//   [single threaded sender code]
-//     static int send_count = 0;
-//     ++send_count;
-//     TRACE_EVENT_ASYNC_BEGIN0("ipc", "message", send_count);
-//     Send(new MyMessage(send_count));
-//   [receive code]
-//     void OnMyMessage(send_count) {
-//       TRACE_EVENT_ASYNC_END0("ipc", "message", send_count);
-//     }
-// The third parameter is a unique ID to match ASYNC_BEGIN/ASYNC_END pairs.
-// ASYNC_BEGIN and ASYNC_END can occur on any thread of any traced process.
-// Pointers can be used for the ID parameter, and they will be mangled
-// internally so that the same pointer on two different processes will not
-// match. For example:
-//   class MyTracedClass {
-//    public:
-//     MyTracedClass() {
-//       TRACE_EVENT_ASYNC_BEGIN0("category", "MyTracedClass", this);
-//     }
-//     ~MyTracedClass() {
-//       TRACE_EVENT_ASYNC_END0("category", "MyTracedClass", this);
-//     }
-//   }
-//
-// Trace event also supports counters, which is a way to track a quantity
-// as it varies over time. Counters are created with the following macro:
-//   TRACE_COUNTER1("MY_SUBSYSTEM", "myCounter", g_myCounterValue);
-//
-// Counters are process-specific. The macro itself can be issued from any
-// thread, however.
-//
-// Sometimes, you want to track two counters at once. You can do this with two
-// counter macros:
-//   TRACE_COUNTER1("MY_SUBSYSTEM", "myCounter0", g_myCounterValue[0]);
-//   TRACE_COUNTER1("MY_SUBSYSTEM", "myCounter1", g_myCounterValue[1]);
-// Or you can do it with a combined macro:
-//   TRACE_COUNTER2("MY_SUBSYSTEM", "myCounter",
-//       "bytesPinned", g_myCounterValue[0],
-//       "bytesAllocated", g_myCounterValue[1]);
-// This indicates to the tracing UI that these counters should be displayed
-// in a single graph, as a summed area chart.
-//
-// Since counters are in a global namespace, you may want to disambiguate with a
-// unique ID, by using the TRACE_COUNTER_ID* variations.
-//
-// By default, trace collection is compiled in, but turned off at runtime.
-// Collecting trace data is the responsibility of the embedding
-// application. In Chrome's case, navigating to about:tracing will turn on
-// tracing and display data collected across all active processes.
-//
-//
-// Memory scoping note:
-// Tracing copies the pointers, not the string content, of the strings passed
-// in for category_group, name, and arg_names.  Thus, the following code will
-// cause problems:
-//     char* str = strdup("importantName");
-//     TRACE_EVENT_INSTANT0("SUBSYSTEM", str);  // BAD!
-//     free(str);                   // Trace system now has dangling pointer
-//
-// To avoid this issue with the |name| and |arg_name| parameters, use the
-// TRACE_EVENT_COPY_XXX overloads of the macros at additional runtime overhead.
-// Notes: The category must always be in a long-lived char* (i.e. static const).
-//        The |arg_values|, when used, are always deep copied with the _COPY
-//        macros.
-//
-// When are string argument values copied:
-// const char* arg_values are only referenced by default:
-//     TRACE_EVENT1("category", "name",
-//                  "arg1", "literal string is only referenced");
-// Use TRACE_STR_COPY to force copying of a const char*:
-//     TRACE_EVENT1("category", "name",
-//                  "arg1", TRACE_STR_COPY("string will be copied"));
-// std::string arg_values are always copied:
-//     TRACE_EVENT1("category", "name",
-//                  "arg1", std::string("string will be copied"));
-//
-//
-// Convertable notes:
-// Converting a large data type to a string can be costly. To help with this,
-// the trace framework provides an interface ConvertableToTraceFormat. If you
-// inherit from it and implement the AppendAsTraceFormat method the trace
-// framework will call back to your object to convert a trace output time. This
-// means, if the category for the event is disabled, the conversion will not
-// happen.
-//
-//   class MyData : public base::trace_event::ConvertableToTraceFormat {
-//    public:
-//     MyData() {}
-//     void AppendAsTraceFormat(std::string* out) const override {
-//       out->append("{\"foo\":1}");
-//     }
-//    private:
-//     ~MyData() override {}
-//     DISALLOW_COPY_AND_ASSIGN(MyData);
-//   };
-//
-//   TRACE_EVENT1("foo", "bar", "data",
-//                std::unique_ptr<ConvertableToTraceFormat>(new MyData()));
-//
-// The trace framework will take ownership if the passed pointer and it will
-// be free'd when the trace buffer is flushed.
-//
-// Note, we only do the conversion when the buffer is flushed, so the provided
-// data object should not be modified after it's passed to the trace framework.
-//
-//
-// Thread Safety:
-// A thread safe singleton and mutex are used for thread safety. Category
-// enabled flags are used to limit the performance impact when the system
-// is not enabled.
-//
-// TRACE_EVENT macros first cache a pointer to a category. The categories are
-// statically allocated and safe at all times, even after exit. Fetching a
-// category is protected by the TraceLog::lock_. Multiple threads initializing
-// the static variable is safe, as they will be serialized by the lock and
-// multiple calls will return the same pointer to the category.
-//
-// Then the category_group_enabled flag is checked. This is a unsigned char, and
-// not intended to be multithread safe. It optimizes access to AddTraceEvent
-// which is threadsafe internally via TraceLog::lock_. The enabled flag may
-// cause some threads to incorrectly call or skip calling AddTraceEvent near
-// the time of the system being enabled or disabled. This is acceptable as
-// we tolerate some data loss while the system is being enabled/disabled and
-// because AddTraceEvent is threadsafe internally and checks the enabled state
-// again under lock.
-//
-// Without the use of these static category pointers and enabled flags all
-// trace points would carry a significant performance cost of acquiring a lock
-// and resolving the category.
-
-#if defined(TRACE_EVENT0)
-#error "Another copy of this file has already been included."
-#endif
-
-// This will mark the trace event as disabled by default. The user will need
-// to explicitly enable the event.
-#define TRACE_DISABLED_BY_DEFAULT(name) "disabled-by-default-" name
-
-// Records a pair of begin and end events called "name" for the current
-// scope, with 0, 1 or 2 associated arguments. If the category is not
-// enabled, then this does nothing.
-// - category and name strings must have application lifetime (statics or
-//   literals). They may not include " chars.
-#define TRACE_EVENT0(category_group, name)    \
-  INTERNAL_TRACE_EVENT_ADD_SCOPED(category_group, name)
-#define TRACE_EVENT_WITH_FLOW0(category_group, name, bind_id, flow_flags)  \
-  INTERNAL_TRACE_EVENT_ADD_SCOPED_WITH_FLOW(category_group, name, bind_id, \
-                                            flow_flags)
-#define TRACE_EVENT1(category_group, name, arg1_name, arg1_val) \
-  INTERNAL_TRACE_EVENT_ADD_SCOPED(category_group, name, arg1_name, arg1_val)
-#define TRACE_EVENT_WITH_FLOW1(category_group, name, bind_id, flow_flags,  \
-                               arg1_name, arg1_val)                        \
-  INTERNAL_TRACE_EVENT_ADD_SCOPED_WITH_FLOW(category_group, name, bind_id, \
-                                            flow_flags, arg1_name, arg1_val)
-#define TRACE_EVENT2(category_group, name, arg1_name, arg1_val, arg2_name,   \
-                     arg2_val)                                               \
-  INTERNAL_TRACE_EVENT_ADD_SCOPED(category_group, name, arg1_name, arg1_val, \
-                                  arg2_name, arg2_val)
-#define TRACE_EVENT_WITH_FLOW2(category_group, name, bind_id, flow_flags,    \
-                               arg1_name, arg1_val, arg2_name, arg2_val)     \
-  INTERNAL_TRACE_EVENT_ADD_SCOPED_WITH_FLOW(category_group, name, bind_id,   \
-                                            flow_flags, arg1_name, arg1_val, \
-                                            arg2_name, arg2_val)
-
-// UNSHIPPED_TRACE_EVENT* are like TRACE_EVENT* except that they are not
-// included in official builds.
-
-#if OFFICIAL_BUILD
-#undef TRACING_IS_OFFICIAL_BUILD
-#define TRACING_IS_OFFICIAL_BUILD 1
-#elif !defined(TRACING_IS_OFFICIAL_BUILD)
-#define TRACING_IS_OFFICIAL_BUILD 0
-#endif
-
-#if TRACING_IS_OFFICIAL_BUILD
-#define UNSHIPPED_TRACE_EVENT0(category_group, name) (void)0
-#define UNSHIPPED_TRACE_EVENT1(category_group, name, arg1_name, arg1_val) \
-  (void)0
-#define UNSHIPPED_TRACE_EVENT2(category_group, name, arg1_name, arg1_val, \
-                               arg2_name, arg2_val)                       \
-  (void)0
-#define UNSHIPPED_TRACE_EVENT_INSTANT0(category_group, name, scope) (void)0
-#define UNSHIPPED_TRACE_EVENT_INSTANT1(category_group, name, scope, arg1_name, \
-                                       arg1_val)                               \
-  (void)0
-#define UNSHIPPED_TRACE_EVENT_INSTANT2(category_group, name, scope, arg1_name, \
-                                       arg1_val, arg2_name, arg2_val)          \
-  (void)0
-#else
-#define UNSHIPPED_TRACE_EVENT0(category_group, name) \
-  TRACE_EVENT0(category_group, name)
-#define UNSHIPPED_TRACE_EVENT1(category_group, name, arg1_name, arg1_val) \
-  TRACE_EVENT1(category_group, name, arg1_name, arg1_val)
-#define UNSHIPPED_TRACE_EVENT2(category_group, name, arg1_name, arg1_val, \
-                               arg2_name, arg2_val)                       \
-  TRACE_EVENT2(category_group, name, arg1_name, arg1_val, arg2_name, arg2_val)
-#define UNSHIPPED_TRACE_EVENT_INSTANT0(category_group, name, scope) \
-  TRACE_EVENT_INSTANT0(category_group, name, scope)
-#define UNSHIPPED_TRACE_EVENT_INSTANT1(category_group, name, scope, arg1_name, \
-                                       arg1_val)                               \
-  TRACE_EVENT_INSTANT1(category_group, name, scope, arg1_name, arg1_val)
-#define UNSHIPPED_TRACE_EVENT_INSTANT2(category_group, name, scope, arg1_name, \
-                                       arg1_val, arg2_name, arg2_val)          \
-  TRACE_EVENT_INSTANT2(category_group, name, scope, arg1_name, arg1_val,       \
-                       arg2_name, arg2_val)
-#endif
-
-// Records a single event called "name" immediately, with 0, 1 or 2
-// associated arguments. If the category is not enabled, then this
-// does nothing.
-// - category and name strings must have application lifetime (statics or
-//   literals). They may not include " chars.
-#define TRACE_EVENT_INSTANT0(category_group, name, scope)                   \
-  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_INSTANT, category_group, name, \
-                           TRACE_EVENT_FLAG_NONE | scope)
-#define TRACE_EVENT_INSTANT1(category_group, name, scope, arg1_name, arg1_val) \
-  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_INSTANT, category_group, name,    \
-                           TRACE_EVENT_FLAG_NONE | scope, arg1_name, arg1_val)
-#define TRACE_EVENT_INSTANT2(category_group, name, scope, arg1_name, arg1_val, \
-                             arg2_name, arg2_val)                              \
-  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_INSTANT, category_group, name,    \
-                           TRACE_EVENT_FLAG_NONE | scope, arg1_name, arg1_val, \
-                           arg2_name, arg2_val)
-#define TRACE_EVENT_COPY_INSTANT0(category_group, name, scope)              \
-  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_INSTANT, category_group, name, \
-                           TRACE_EVENT_FLAG_COPY | scope)
-#define TRACE_EVENT_COPY_INSTANT1(category_group, name, scope, arg1_name,   \
-                                  arg1_val)                                 \
-  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_INSTANT, category_group, name, \
-                           TRACE_EVENT_FLAG_COPY | scope, arg1_name, arg1_val)
-#define TRACE_EVENT_COPY_INSTANT2(category_group, name, scope, arg1_name,      \
-                                  arg1_val, arg2_name, arg2_val)               \
-  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_INSTANT, category_group, name,    \
-                           TRACE_EVENT_FLAG_COPY | scope, arg1_name, arg1_val, \
-                           arg2_name, arg2_val)
-
-#define TRACE_EVENT_INSTANT_WITH_TIMESTAMP0(category_group, name, scope, \
-                                            timestamp)                   \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                    \
-      TRACE_EVENT_PHASE_INSTANT, category_group, name, 0, 0, timestamp,  \
-      TRACE_EVENT_FLAG_NONE | scope)
-
-// Syntactic sugars for the sampling tracing in the main thread.
-#define TRACE_EVENT_SCOPED_SAMPLING_STATE(category, name) \
-  TRACE_EVENT_SCOPED_SAMPLING_STATE_FOR_BUCKET(0, category, name)
-#define TRACE_EVENT_GET_SAMPLING_STATE() \
-  TRACE_EVENT_GET_SAMPLING_STATE_FOR_BUCKET(0)
-#define TRACE_EVENT_SET_SAMPLING_STATE(category, name) \
-  TRACE_EVENT_SET_SAMPLING_STATE_FOR_BUCKET(0, category, name)
-#define TRACE_EVENT_SET_NONCONST_SAMPLING_STATE(categoryAndName) \
-  TRACE_EVENT_SET_NONCONST_SAMPLING_STATE_FOR_BUCKET(0, categoryAndName)
-
-// Records a single BEGIN event called "name" immediately, with 0, 1 or 2
-// associated arguments. If the category is not enabled, then this
-// does nothing.
-// - category and name strings must have application lifetime (statics or
-//   literals). They may not include " chars.
-#define TRACE_EVENT_BEGIN0(category_group, name)                          \
-  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_BEGIN, category_group, name, \
-                           TRACE_EVENT_FLAG_NONE)
-#define TRACE_EVENT_BEGIN1(category_group, name, arg1_name, arg1_val)     \
-  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_BEGIN, category_group, name, \
-                           TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val)
-#define TRACE_EVENT_BEGIN2(category_group, name, arg1_name, arg1_val,     \
-                           arg2_name, arg2_val)                           \
-  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_BEGIN, category_group, name, \
-                           TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val,    \
-                           arg2_name, arg2_val)
-#define TRACE_EVENT_COPY_BEGIN0(category_group, name)                     \
-  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_BEGIN, category_group, name, \
-                           TRACE_EVENT_FLAG_COPY)
-#define TRACE_EVENT_COPY_BEGIN1(category_group, name, arg1_name, arg1_val) \
-  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_BEGIN, category_group, name,  \
-                           TRACE_EVENT_FLAG_COPY, arg1_name, arg1_val)
-#define TRACE_EVENT_COPY_BEGIN2(category_group, name, arg1_name, arg1_val, \
-                                arg2_name, arg2_val)                       \
-  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_BEGIN, category_group, name,  \
-                           TRACE_EVENT_FLAG_COPY, arg1_name, arg1_val,     \
-                           arg2_name, arg2_val)
-
-// Similar to TRACE_EVENT_BEGINx but with a custom |at| timestamp provided.
-// - |id| is used to match the _BEGIN event with the _END event.
-//   Events are considered to match if their category_group, name and id values
-//   all match. |id| must either be a pointer or an integer value up to 64 bits.
-//   If it's a pointer, the bits will be xored with a hash of the process ID so
-//   that the same pointer on two different processes will not collide.
-#define TRACE_EVENT_BEGIN_WITH_ID_TID_AND_TIMESTAMP0(category_group, name, id, \
-                                                     thread_id, timestamp)     \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                          \
-      TRACE_EVENT_PHASE_ASYNC_BEGIN, category_group, name, id, thread_id,      \
-      timestamp, TRACE_EVENT_FLAG_NONE)
-#define TRACE_EVENT_COPY_BEGIN_WITH_ID_TID_AND_TIMESTAMP0(                \
-    category_group, name, id, thread_id, timestamp)                       \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                     \
-      TRACE_EVENT_PHASE_ASYNC_BEGIN, category_group, name, id, thread_id, \
-      timestamp, TRACE_EVENT_FLAG_COPY)
-#define TRACE_EVENT_COPY_BEGIN_WITH_ID_TID_AND_TIMESTAMP1(                \
-    category_group, name, id, thread_id, timestamp, arg1_name, arg1_val)  \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                     \
-      TRACE_EVENT_PHASE_ASYNC_BEGIN, category_group, name, id, thread_id, \
-      timestamp, TRACE_EVENT_FLAG_COPY, arg1_name, arg1_val)
-#define TRACE_EVENT_COPY_BEGIN_WITH_ID_TID_AND_TIMESTAMP2(                \
-    category_group, name, id, thread_id, timestamp, arg1_name, arg1_val,  \
-    arg2_name, arg2_val)                                                  \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                     \
-      TRACE_EVENT_PHASE_ASYNC_BEGIN, category_group, name, id, thread_id, \
-      timestamp, TRACE_EVENT_FLAG_COPY, arg1_name, arg1_val, arg2_name,   \
-      arg2_val)
-
-// Records a single END event for "name" immediately. If the category
-// is not enabled, then this does nothing.
-// - category and name strings must have application lifetime (statics or
-//   literals). They may not include " chars.
-#define TRACE_EVENT_END0(category_group, name)                          \
-  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_END, category_group, name, \
-                           TRACE_EVENT_FLAG_NONE)
-#define TRACE_EVENT_END1(category_group, name, arg1_name, arg1_val)     \
-  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_END, category_group, name, \
-                           TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val)
-#define TRACE_EVENT_END2(category_group, name, arg1_name, arg1_val, arg2_name, \
-                         arg2_val)                                             \
-  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_END, category_group, name,        \
-                           TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val,         \
-                           arg2_name, arg2_val)
-#define TRACE_EVENT_COPY_END0(category_group, name)                     \
-  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_END, category_group, name, \
-                           TRACE_EVENT_FLAG_COPY)
-#define TRACE_EVENT_COPY_END1(category_group, name, arg1_name, arg1_val) \
-  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_END, category_group, name,  \
-                           TRACE_EVENT_FLAG_COPY, arg1_name, arg1_val)
-#define TRACE_EVENT_COPY_END2(category_group, name, arg1_name, arg1_val, \
-                              arg2_name, arg2_val)                       \
-  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_END, category_group, name,  \
-                           TRACE_EVENT_FLAG_COPY, arg1_name, arg1_val,   \
-                           arg2_name, arg2_val)
-
-#define TRACE_EVENT_MARK_WITH_TIMESTAMP1(category_group, name, timestamp, \
-                                         arg1_name, arg1_val)             \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                     \
-      TRACE_EVENT_PHASE_MARK, category_group, name, 0, 0, timestamp,      \
-      TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val)
-
-#define TRACE_EVENT_COPY_MARK(category_group, name)                      \
-  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_MARK, category_group, name, \
-                           TRACE_EVENT_FLAG_COPY)
-
-#define TRACE_EVENT_COPY_MARK_WITH_TIMESTAMP(category_group, name, timestamp) \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                         \
-      TRACE_EVENT_PHASE_MARK, category_group, name, 0, 0, timestamp,          \
-      TRACE_EVENT_FLAG_COPY)
-
-// Similar to TRACE_EVENT_ENDx but with a custom |at| timestamp provided.
-// - |id| is used to match the _BEGIN event with the _END event.
-//   Events are considered to match if their category_group, name and id values
-//   all match. |id| must either be a pointer or an integer value up to 64 bits.
-//   If it's a pointer, the bits will be xored with a hash of the process ID so
-//   that the same pointer on two different processes will not collide.
-#define TRACE_EVENT_END_WITH_ID_TID_AND_TIMESTAMP0(category_group, name, id, \
-                                                   thread_id, timestamp)     \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                        \
-      TRACE_EVENT_PHASE_ASYNC_END, category_group, name, id, thread_id,      \
-      timestamp, TRACE_EVENT_FLAG_NONE)
-#define TRACE_EVENT_COPY_END_WITH_ID_TID_AND_TIMESTAMP0(                \
-    category_group, name, id, thread_id, timestamp)                     \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                   \
-      TRACE_EVENT_PHASE_ASYNC_END, category_group, name, id, thread_id, \
-      timestamp, TRACE_EVENT_FLAG_COPY)
-#define TRACE_EVENT_COPY_END_WITH_ID_TID_AND_TIMESTAMP1(                 \
-    category_group, name, id, thread_id, timestamp, arg1_name, arg1_val) \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                    \
-      TRACE_EVENT_PHASE_ASYNC_END, category_group, name, id, thread_id,  \
-      timestamp, TRACE_EVENT_FLAG_COPY, arg1_name, arg1_val)
-#define TRACE_EVENT_COPY_END_WITH_ID_TID_AND_TIMESTAMP2(                 \
-    category_group, name, id, thread_id, timestamp, arg1_name, arg1_val, \
-    arg2_name, arg2_val)                                                 \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                    \
-      TRACE_EVENT_PHASE_ASYNC_END, category_group, name, id, thread_id,  \
-      timestamp, TRACE_EVENT_FLAG_COPY, arg1_name, arg1_val, arg2_name,  \
-      arg2_val)
-
-// Records the value of a counter called "name" immediately. Value
-// must be representable as a 32 bit integer.
-// - category and name strings must have application lifetime (statics or
-//   literals). They may not include " chars.
-#define TRACE_COUNTER1(category_group, name, value)                         \
-  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_COUNTER, category_group, name, \
-                           TRACE_EVENT_FLAG_NONE, "value",                  \
-                           static_cast<int>(value))
-#define TRACE_COPY_COUNTER1(category_group, name, value)                    \
-  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_COUNTER, category_group, name, \
-                           TRACE_EVENT_FLAG_COPY, "value",                  \
-                           static_cast<int>(value))
-
-// Records the values of a multi-parted counter called "name" immediately.
-// The UI will treat value1 and value2 as parts of a whole, displaying their
-// values as a stacked-bar chart.
-// - category and name strings must have application lifetime (statics or
-//   literals). They may not include " chars.
-#define TRACE_COUNTER2(category_group, name, value1_name, value1_val,       \
-                       value2_name, value2_val)                             \
-  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_COUNTER, category_group, name, \
-                           TRACE_EVENT_FLAG_NONE, value1_name,              \
-                           static_cast<int>(value1_val), value2_name,       \
-                           static_cast<int>(value2_val))
-#define TRACE_COPY_COUNTER2(category_group, name, value1_name, value1_val,  \
-                            value2_name, value2_val)                        \
-  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_COUNTER, category_group, name, \
-                           TRACE_EVENT_FLAG_COPY, value1_name,              \
-                           static_cast<int>(value1_val), value2_name,       \
-                           static_cast<int>(value2_val))
-
-// Similar to TRACE_COUNTERx, but with a custom |timestamp| provided.
-#define TRACE_COUNTER_WITH_TIMESTAMP1(category_group, name, timestamp, value) \
-  INTERNAL_TRACE_EVENT_ADD_WITH_TIMESTAMP(                                    \
-      TRACE_EVENT_PHASE_COUNTER, category_group, name, timestamp,             \
-      TRACE_EVENT_FLAG_NONE, "value", static_cast<int>(value))
-
-#define TRACE_COUNTER_WITH_TIMESTAMP2(category_group, name, timestamp,      \
-                                      value1_name, value1_val, value2_name, \
-                                      value2_val)                           \
-  INTERNAL_TRACE_EVENT_ADD_WITH_TIMESTAMP(                                  \
-      TRACE_EVENT_PHASE_COUNTER, category_group, name, timestamp,           \
-      TRACE_EVENT_FLAG_NONE, value1_name, static_cast<int>(value1_val),     \
-      value2_name, static_cast<int>(value2_val))
-
-// Records the value of a counter called "name" immediately. Value
-// must be representable as a 32 bit integer.
-// - category and name strings must have application lifetime (statics or
-//   literals). They may not include " chars.
-// - |id| is used to disambiguate counters with the same name. It must either
-//   be a pointer or an integer value up to 64 bits. If it's a pointer, the bits
-//   will be xored with a hash of the process ID so that the same pointer on
-//   two different processes will not collide.
-#define TRACE_COUNTER_ID1(category_group, name, id, value)                    \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_COUNTER, category_group, \
-                                   name, id, TRACE_EVENT_FLAG_NONE, "value",  \
-                                   static_cast<int>(value))
-#define TRACE_COPY_COUNTER_ID1(category_group, name, id, value)               \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_COUNTER, category_group, \
-                                   name, id, TRACE_EVENT_FLAG_COPY, "value",  \
-                                   static_cast<int>(value))
-
-// Records the values of a multi-parted counter called "name" immediately.
-// The UI will treat value1 and value2 as parts of a whole, displaying their
-// values as a stacked-bar chart.
-// - category and name strings must have application lifetime (statics or
-//   literals). They may not include " chars.
-// - |id| is used to disambiguate counters with the same name. It must either
-//   be a pointer or an integer value up to 64 bits. If it's a pointer, the bits
-//   will be xored with a hash of the process ID so that the same pointer on
-//   two different processes will not collide.
-#define TRACE_COUNTER_ID2(category_group, name, id, value1_name, value1_val,  \
-                          value2_name, value2_val)                            \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_COUNTER, category_group, \
-                                   name, id, TRACE_EVENT_FLAG_NONE,           \
-                                   value1_name, static_cast<int>(value1_val), \
-                                   value2_name, static_cast<int>(value2_val))
-#define TRACE_COPY_COUNTER_ID2(category_group, name, id, value1_name,         \
-                               value1_val, value2_name, value2_val)           \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_COUNTER, category_group, \
-                                   name, id, TRACE_EVENT_FLAG_COPY,           \
-                                   value1_name, static_cast<int>(value1_val), \
-                                   value2_name, static_cast<int>(value2_val))
-
-// TRACE_EVENT_SAMPLE_* events are injected by the sampling profiler.
-#define TRACE_EVENT_SAMPLE_WITH_TID_AND_TIMESTAMP0(category_group, name,       \
-                                                   thread_id, timestamp)       \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                          \
-      TRACE_EVENT_PHASE_SAMPLE, category_group, name, 0, thread_id, timestamp, \
-      TRACE_EVENT_FLAG_NONE)
-
-#define TRACE_EVENT_SAMPLE_WITH_TID_AND_TIMESTAMP1(                            \
-    category_group, name, thread_id, timestamp, arg1_name, arg1_val)           \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                          \
-      TRACE_EVENT_PHASE_SAMPLE, category_group, name, 0, thread_id, timestamp, \
-      TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val)
-
-#define TRACE_EVENT_SAMPLE_WITH_TID_AND_TIMESTAMP2(category_group, name,       \
-                                                   thread_id, timestamp,       \
-                                                   arg1_name, arg1_val,        \
-                                                   arg2_name, arg2_val)        \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                          \
-      TRACE_EVENT_PHASE_SAMPLE, category_group, name, 0, thread_id, timestamp, \
-      TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val, arg2_name, arg2_val)
-
-// ASYNC_STEP_* APIs should be only used by legacy code. New code should
-// consider using NESTABLE_ASYNC_* APIs to describe substeps within an async
-// event.
-// Records a single ASYNC_BEGIN event called "name" immediately, with 0, 1 or 2
-// associated arguments. If the category is not enabled, then this
-// does nothing.
-// - category and name strings must have application lifetime (statics or
-//   literals). They may not include " chars.
-// - |id| is used to match the ASYNC_BEGIN event with the ASYNC_END event. ASYNC
-//   events are considered to match if their category_group, name and id values
-//   all match. |id| must either be a pointer or an integer value up to 64 bits.
-//   If it's a pointer, the bits will be xored with a hash of the process ID so
-//   that the same pointer on two different processes will not collide.
-//
-// An asynchronous operation can consist of multiple phases. The first phase is
-// defined by the ASYNC_BEGIN calls. Additional phases can be defined using the
-// ASYNC_STEP_INTO or ASYNC_STEP_PAST macros. The ASYNC_STEP_INTO macro will
-// annotate the block following the call. The ASYNC_STEP_PAST macro will
-// annotate the block prior to the call. Note that any particular event must use
-// only STEP_INTO or STEP_PAST macros; they can not mix and match. When the
-// operation completes, call ASYNC_END.
-//
-// An ASYNC trace typically occurs on a single thread (if not, they will only be
-// drawn on the thread defined in the ASYNC_BEGIN event), but all events in that
-// operation must use the same |name| and |id|. Each step can have its own
-// args.
-#define TRACE_EVENT_ASYNC_BEGIN0(category_group, name, id)        \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_ASYNC_BEGIN, \
-                                   category_group, name, id,      \
-                                   TRACE_EVENT_FLAG_NONE)
-#define TRACE_EVENT_ASYNC_BEGIN1(category_group, name, id, arg1_name, \
-                                 arg1_val)                            \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_ASYNC_BEGIN,     \
-                                   category_group, name, id,          \
-                                   TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val)
-#define TRACE_EVENT_ASYNC_BEGIN2(category_group, name, id, arg1_name, \
-                                 arg1_val, arg2_name, arg2_val)       \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                   \
-      TRACE_EVENT_PHASE_ASYNC_BEGIN, category_group, name, id,        \
-      TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val, arg2_name, arg2_val)
-#define TRACE_EVENT_COPY_ASYNC_BEGIN0(category_group, name, id)   \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_ASYNC_BEGIN, \
-                                   category_group, name, id,      \
-                                   TRACE_EVENT_FLAG_COPY)
-#define TRACE_EVENT_COPY_ASYNC_BEGIN1(category_group, name, id, arg1_name, \
-                                      arg1_val)                            \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_ASYNC_BEGIN,          \
-                                   category_group, name, id,               \
-                                   TRACE_EVENT_FLAG_COPY, arg1_name, arg1_val)
-#define TRACE_EVENT_COPY_ASYNC_BEGIN2(category_group, name, id, arg1_name, \
-                                      arg1_val, arg2_name, arg2_val)       \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                        \
-      TRACE_EVENT_PHASE_ASYNC_BEGIN, category_group, name, id,             \
-      TRACE_EVENT_FLAG_COPY, arg1_name, arg1_val, arg2_name, arg2_val)
-
-// Similar to TRACE_EVENT_ASYNC_BEGINx but with a custom |at| timestamp
-// provided.
-#define TRACE_EVENT_ASYNC_BEGIN_WITH_TIMESTAMP0(category_group, name, id, \
-                                                timestamp)                \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                     \
-      TRACE_EVENT_PHASE_ASYNC_BEGIN, category_group, name, id,            \
-      TRACE_EVENT_API_CURRENT_THREAD_ID, timestamp, TRACE_EVENT_FLAG_NONE)
-#define TRACE_EVENT_ASYNC_BEGIN_WITH_TIMESTAMP1(                           \
-    category_group, name, id, timestamp, arg1_name, arg1_val)              \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                      \
-      TRACE_EVENT_PHASE_ASYNC_BEGIN, category_group, name, id,             \
-      TRACE_EVENT_API_CURRENT_THREAD_ID, timestamp, TRACE_EVENT_FLAG_NONE, \
-      arg1_name, arg1_val)
-#define TRACE_EVENT_ASYNC_BEGIN_WITH_TIMESTAMP2(category_group, name, id,      \
-                                                timestamp, arg1_name,          \
-                                                arg1_val, arg2_name, arg2_val) \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                          \
-      TRACE_EVENT_PHASE_ASYNC_BEGIN, category_group, name, id,                 \
-      TRACE_EVENT_API_CURRENT_THREAD_ID, timestamp, TRACE_EVENT_FLAG_NONE,     \
-      arg1_name, arg1_val, arg2_name, arg2_val)
-#define TRACE_EVENT_COPY_ASYNC_BEGIN_WITH_TIMESTAMP0(category_group, name, id, \
-                                                     timestamp)                \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                          \
-      TRACE_EVENT_PHASE_ASYNC_BEGIN, category_group, name, id,                 \
-      TRACE_EVENT_API_CURRENT_THREAD_ID, timestamp, TRACE_EVENT_FLAG_COPY)
-
-// Records a single ASYNC_STEP_INTO event for |step| immediately. If the
-// category is not enabled, then this does nothing. The |name| and |id| must
-// match the ASYNC_BEGIN event above. The |step| param identifies this step
-// within the async event. This should be called at the beginning of the next
-// phase of an asynchronous operation. The ASYNC_BEGIN event must not have any
-// ASYNC_STEP_PAST events.
-#define TRACE_EVENT_ASYNC_STEP_INTO0(category_group, name, id, step)  \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_ASYNC_STEP_INTO, \
-                                   category_group, name, id,          \
-                                   TRACE_EVENT_FLAG_NONE, "step", step)
-#define TRACE_EVENT_ASYNC_STEP_INTO1(category_group, name, id, step, \
-                                     arg1_name, arg1_val)            \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                  \
-      TRACE_EVENT_PHASE_ASYNC_STEP_INTO, category_group, name, id,   \
-      TRACE_EVENT_FLAG_NONE, "step", step, arg1_name, arg1_val)
-
-// Similar to TRACE_EVENT_ASYNC_STEP_INTOx but with a custom |at| timestamp
-// provided.
-#define TRACE_EVENT_ASYNC_STEP_INTO_WITH_TIMESTAMP0(category_group, name, id, \
-                                                    step, timestamp)          \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                         \
-      TRACE_EVENT_PHASE_ASYNC_STEP_INTO, category_group, name, id,            \
-      TRACE_EVENT_API_CURRENT_THREAD_ID, timestamp, TRACE_EVENT_FLAG_NONE,    \
-      "step", step)
-
-// Records a single ASYNC_STEP_PAST event for |step| immediately. If the
-// category is not enabled, then this does nothing. The |name| and |id| must
-// match the ASYNC_BEGIN event above. The |step| param identifies this step
-// within the async event. This should be called at the beginning of the next
-// phase of an asynchronous operation. The ASYNC_BEGIN event must not have any
-// ASYNC_STEP_INTO events.
-#define TRACE_EVENT_ASYNC_STEP_PAST0(category_group, name, id, step)  \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_ASYNC_STEP_PAST, \
-                                   category_group, name, id,          \
-                                   TRACE_EVENT_FLAG_NONE, "step", step)
-#define TRACE_EVENT_ASYNC_STEP_PAST1(category_group, name, id, step, \
-                                     arg1_name, arg1_val)            \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                  \
-      TRACE_EVENT_PHASE_ASYNC_STEP_PAST, category_group, name, id,   \
-      TRACE_EVENT_FLAG_NONE, "step", step, arg1_name, arg1_val)
-
-// Records a single ASYNC_END event for "name" immediately. If the category
-// is not enabled, then this does nothing.
-#define TRACE_EVENT_ASYNC_END0(category_group, name, id)        \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_ASYNC_END, \
-                                   category_group, name, id,    \
-                                   TRACE_EVENT_FLAG_NONE)
-#define TRACE_EVENT_ASYNC_END1(category_group, name, id, arg1_name, arg1_val) \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_ASYNC_END,               \
-                                   category_group, name, id,                  \
-                                   TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val)
-#define TRACE_EVENT_ASYNC_END2(category_group, name, id, arg1_name, arg1_val, \
-                               arg2_name, arg2_val)                           \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                           \
-      TRACE_EVENT_PHASE_ASYNC_END, category_group, name, id,                  \
-      TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val, arg2_name, arg2_val)
-#define TRACE_EVENT_COPY_ASYNC_END0(category_group, name, id)   \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_ASYNC_END, \
-                                   category_group, name, id,    \
-                                   TRACE_EVENT_FLAG_COPY)
-#define TRACE_EVENT_COPY_ASYNC_END1(category_group, name, id, arg1_name, \
-                                    arg1_val)                            \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_ASYNC_END,          \
-                                   category_group, name, id,             \
-                                   TRACE_EVENT_FLAG_COPY, arg1_name, arg1_val)
-#define TRACE_EVENT_COPY_ASYNC_END2(category_group, name, id, arg1_name, \
-                                    arg1_val, arg2_name, arg2_val)       \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                      \
-      TRACE_EVENT_PHASE_ASYNC_END, category_group, name, id,             \
-      TRACE_EVENT_FLAG_COPY, arg1_name, arg1_val, arg2_name, arg2_val)
-
-// Similar to TRACE_EVENT_ASYNC_ENDx but with a custom |at| timestamp provided.
-#define TRACE_EVENT_ASYNC_END_WITH_TIMESTAMP0(category_group, name, id, \
-                                              timestamp)                \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                   \
-      TRACE_EVENT_PHASE_ASYNC_END, category_group, name, id,            \
-      TRACE_EVENT_API_CURRENT_THREAD_ID, timestamp, TRACE_EVENT_FLAG_NONE)
-#define TRACE_EVENT_ASYNC_END_WITH_TIMESTAMP1(category_group, name, id,       \
-                                              timestamp, arg1_name, arg1_val) \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                         \
-      TRACE_EVENT_PHASE_ASYNC_END, category_group, name, id,                  \
-      TRACE_EVENT_API_CURRENT_THREAD_ID, timestamp, TRACE_EVENT_FLAG_NONE,    \
-      arg1_name, arg1_val)
-#define TRACE_EVENT_ASYNC_END_WITH_TIMESTAMP2(category_group, name, id,       \
-                                              timestamp, arg1_name, arg1_val, \
-                                              arg2_name, arg2_val)            \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                         \
-      TRACE_EVENT_PHASE_ASYNC_END, category_group, name, id,                  \
-      TRACE_EVENT_API_CURRENT_THREAD_ID, timestamp, TRACE_EVENT_FLAG_NONE,    \
-      arg1_name, arg1_val, arg2_name, arg2_val)
-
-// NESTABLE_ASYNC_* APIs are used to describe an async operation, which can
-// be nested within a NESTABLE_ASYNC event and/or have inner NESTABLE_ASYNC
-// events.
-// - category and name strings must have application lifetime (statics or
-//   literals). They may not include " chars.
-// - A pair of NESTABLE_ASYNC_BEGIN event and NESTABLE_ASYNC_END event is
-//   considered as a match if their category_group, name and id all match.
-// - |id| must either be a pointer or an integer value up to 64 bits.
-//   If it's a pointer, the bits will be xored with a hash of the process ID so
-//   that the same pointer on two different processes will not collide.
-// - |id| is used to match a child NESTABLE_ASYNC event with its parent
-//   NESTABLE_ASYNC event. Therefore, events in the same nested event tree must
-//   be logged using the same id and category_group.
-//
-// Unmatched NESTABLE_ASYNC_END event will be parsed as an event that starts
-// at the first NESTABLE_ASYNC event of that id, and unmatched
-// NESTABLE_ASYNC_BEGIN event will be parsed as an event that ends at the last
-// NESTABLE_ASYNC event of that id. Corresponding warning messages for
-// unmatched events will be shown in the analysis view.
-
-// Records a single NESTABLE_ASYNC_BEGIN event called "name" immediately, with
-// 0, 1 or 2 associated arguments. If the category is not enabled, then this
-// does nothing.
-#define TRACE_EVENT_NESTABLE_ASYNC_BEGIN0(category_group, name, id)        \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN, \
-                                   category_group, name, id,               \
-                                   TRACE_EVENT_FLAG_NONE)
-#define TRACE_EVENT_NESTABLE_ASYNC_BEGIN1(category_group, name, id, arg1_name, \
-                                          arg1_val)                            \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN,     \
-                                   category_group, name, id,                   \
-                                   TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val)
-#define TRACE_EVENT_NESTABLE_ASYNC_BEGIN2(category_group, name, id, arg1_name, \
-                                          arg1_val, arg2_name, arg2_val)       \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                            \
-      TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN, category_group, name, id,        \
-      TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val, arg2_name, arg2_val)
-// Records a single NESTABLE_ASYNC_END event called "name" immediately, with 0
-// or 2 associated arguments. If the category is not enabled, then this does
-// nothing.
-#define TRACE_EVENT_NESTABLE_ASYNC_END0(category_group, name, id)        \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_NESTABLE_ASYNC_END, \
-                                   category_group, name, id,             \
-                                   TRACE_EVENT_FLAG_NONE)
-// Records a single NESTABLE_ASYNC_END event called "name" immediately, with 1
-// associated argument. If the category is not enabled, then this does nothing.
-#define TRACE_EVENT_NESTABLE_ASYNC_END1(category_group, name, id, arg1_name, \
-                                        arg1_val)                            \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_NESTABLE_ASYNC_END,     \
-                                   category_group, name, id,                 \
-                                   TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val)
-#define TRACE_EVENT_NESTABLE_ASYNC_END2(category_group, name, id, arg1_name, \
-                                        arg1_val, arg2_name, arg2_val)       \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                          \
-      TRACE_EVENT_PHASE_NESTABLE_ASYNC_END, category_group, name, id,        \
-      TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val, arg2_name, arg2_val)
-
-// Records a single NESTABLE_ASYNC_INSTANT event called "name" immediately,
-// with one associated argument. If the category is not enabled, then this
-// does nothing.
-#define TRACE_EVENT_NESTABLE_ASYNC_INSTANT1(category_group, name, id,        \
-                                            arg1_name, arg1_val)             \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_NESTABLE_ASYNC_INSTANT, \
-                                   category_group, name, id,                 \
-                                   TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val)
-// Records a single NESTABLE_ASYNC_INSTANT event called "name" immediately,
-// with 2 associated arguments. If the category is not enabled, then this
-// does nothing.
-#define TRACE_EVENT_NESTABLE_ASYNC_INSTANT2(                              \
-    category_group, name, id, arg1_name, arg1_val, arg2_name, arg2_val)   \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                       \
-      TRACE_EVENT_PHASE_NESTABLE_ASYNC_INSTANT, category_group, name, id, \
-      TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val, arg2_name, arg2_val)
-
-#define TRACE_EVENT_COPY_NESTABLE_ASYNC_BEGIN_WITH_TTS2(                       \
-    category_group, name, id, arg1_name, arg1_val, arg2_name, arg2_val)        \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                            \
-      TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN, category_group, name, id,        \
-      TRACE_EVENT_FLAG_ASYNC_TTS | TRACE_EVENT_FLAG_COPY, arg1_name, arg1_val, \
-      arg2_name, arg2_val)
-#define TRACE_EVENT_COPY_NESTABLE_ASYNC_END_WITH_TTS2(                         \
-    category_group, name, id, arg1_name, arg1_val, arg2_name, arg2_val)        \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                            \
-      TRACE_EVENT_PHASE_NESTABLE_ASYNC_END, category_group, name, id,          \
-      TRACE_EVENT_FLAG_ASYNC_TTS | TRACE_EVENT_FLAG_COPY, arg1_name, arg1_val, \
-      arg2_name, arg2_val)
-
-// Similar to TRACE_EVENT_NESTABLE_ASYNC_{BEGIN,END}x but with a custom
-// |timestamp| provided.
-#define TRACE_EVENT_NESTABLE_ASYNC_BEGIN_WITH_TIMESTAMP0(category_group, name, \
-                                                         id, timestamp)        \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                          \
-      TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN, category_group, name, id,        \
-      TRACE_EVENT_API_CURRENT_THREAD_ID, timestamp, TRACE_EVENT_FLAG_NONE)
-
-#define TRACE_EVENT_NESTABLE_ASYNC_END_WITH_TIMESTAMP0(category_group, name, \
-                                                       id, timestamp)        \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                        \
-      TRACE_EVENT_PHASE_NESTABLE_ASYNC_END, category_group, name, id,        \
-      TRACE_EVENT_API_CURRENT_THREAD_ID, timestamp, TRACE_EVENT_FLAG_NONE)
-
-#define TRACE_EVENT_COPY_NESTABLE_ASYNC_BEGIN_WITH_TIMESTAMP0(          \
-    category_group, name, id, timestamp)                                \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                   \
-      TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN, category_group, name, id, \
-      TRACE_EVENT_API_CURRENT_THREAD_ID, timestamp, TRACE_EVENT_FLAG_COPY)
-#define TRACE_EVENT_COPY_NESTABLE_ASYNC_END_WITH_TIMESTAMP0(          \
-    category_group, name, id, timestamp)                              \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                 \
-      TRACE_EVENT_PHASE_NESTABLE_ASYNC_END, category_group, name, id, \
-      TRACE_EVENT_API_CURRENT_THREAD_ID, timestamp, TRACE_EVENT_FLAG_COPY)
-
-// Records a single NESTABLE_ASYNC_INSTANT event called "name" immediately,
-// with 2 associated arguments. If the category is not enabled, then this
-// does nothing.
-#define TRACE_EVENT_NESTABLE_ASYNC_INSTANT2(                              \
-    category_group, name, id, arg1_name, arg1_val, arg2_name, arg2_val)   \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                       \
-      TRACE_EVENT_PHASE_NESTABLE_ASYNC_INSTANT, category_group, name, id, \
-      TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val, arg2_name, arg2_val)
-
-// Records a single FLOW_BEGIN event called "name" immediately, with 0, 1 or 2
-// associated arguments. If the category is not enabled, then this
-// does nothing.
-// - category and name strings must have application lifetime (statics or
-//   literals). They may not include " chars.
-// - |id| is used to match the FLOW_BEGIN event with the FLOW_END event. FLOW
-//   events are considered to match if their category_group, name and id values
-//   all match. |id| must either be a pointer or an integer value up to 64 bits.
-//   If it's a pointer, the bits will be xored with a hash of the process ID so
-//   that the same pointer on two different processes will not collide.
-// FLOW events are different from ASYNC events in how they are drawn by the
-// tracing UI. A FLOW defines asynchronous data flow, such as posting a task
-// (FLOW_BEGIN) and later executing that task (FLOW_END). Expect FLOWs to be
-// drawn as lines or arrows from FLOW_BEGIN scopes to FLOW_END scopes. Similar
-// to ASYNC, a FLOW can consist of multiple phases. The first phase is defined
-// by the FLOW_BEGIN calls. Additional phases can be defined using the FLOW_STEP
-// macros. When the operation completes, call FLOW_END. An async operation can
-// span threads and processes, but all events in that operation must use the
-// same |name| and |id|. Each event can have its own args.
-#define TRACE_EVENT_FLOW_BEGIN0(category_group, name, id)        \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_FLOW_BEGIN, \
-                                   category_group, name, id,     \
-                                   TRACE_EVENT_FLAG_NONE)
-#define TRACE_EVENT_FLOW_BEGIN1(category_group, name, id, arg1_name, arg1_val) \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_FLOW_BEGIN,               \
-                                   category_group, name, id,                   \
-                                   TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val)
-#define TRACE_EVENT_FLOW_BEGIN2(category_group, name, id, arg1_name, arg1_val, \
-                                arg2_name, arg2_val)                           \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                            \
-      TRACE_EVENT_PHASE_FLOW_BEGIN, category_group, name, id,                  \
-      TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val, arg2_name, arg2_val)
-#define TRACE_EVENT_COPY_FLOW_BEGIN0(category_group, name, id)   \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_FLOW_BEGIN, \
-                                   category_group, name, id,     \
-                                   TRACE_EVENT_FLAG_COPY)
-#define TRACE_EVENT_COPY_FLOW_BEGIN1(category_group, name, id, arg1_name, \
-                                     arg1_val)                            \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_FLOW_BEGIN,          \
-                                   category_group, name, id,              \
-                                   TRACE_EVENT_FLAG_COPY, arg1_name, arg1_val)
-#define TRACE_EVENT_COPY_FLOW_BEGIN2(category_group, name, id, arg1_name, \
-                                     arg1_val, arg2_name, arg2_val)       \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                       \
-      TRACE_EVENT_PHASE_FLOW_BEGIN, category_group, name, id,             \
-      TRACE_EVENT_FLAG_COPY, arg1_name, arg1_val, arg2_name, arg2_val)
-
-// Records a single FLOW_STEP event for |step| immediately. If the category
-// is not enabled, then this does nothing. The |name| and |id| must match the
-// FLOW_BEGIN event above. The |step| param identifies this step within the
-// async event. This should be called at the beginning of the next phase of an
-// asynchronous operation.
-#define TRACE_EVENT_FLOW_STEP0(category_group, name, id, step)  \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_FLOW_STEP, \
-                                   category_group, name, id,    \
-                                   TRACE_EVENT_FLAG_NONE, "step", step)
-#define TRACE_EVENT_FLOW_STEP1(category_group, name, id, step, arg1_name, \
-                               arg1_val)                                  \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                       \
-      TRACE_EVENT_PHASE_FLOW_STEP, category_group, name, id,              \
-      TRACE_EVENT_FLAG_NONE, "step", step, arg1_name, arg1_val)
-#define TRACE_EVENT_COPY_FLOW_STEP0(category_group, name, id, step) \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_FLOW_STEP,     \
-                                   category_group, name, id,        \
-                                   TRACE_EVENT_FLAG_COPY, "step", step)
-#define TRACE_EVENT_COPY_FLOW_STEP1(category_group, name, id, step, arg1_name, \
-                                    arg1_val)                                  \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                            \
-      TRACE_EVENT_PHASE_FLOW_STEP, category_group, name, id,                   \
-      TRACE_EVENT_FLAG_COPY, "step", step, arg1_name, arg1_val)
-
-// Records a single FLOW_END event for "name" immediately. If the category
-// is not enabled, then this does nothing.
-#define TRACE_EVENT_FLOW_END0(category_group, name, id)                        \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_FLOW_END, category_group, \
-                                   name, id, TRACE_EVENT_FLAG_NONE)
-#define TRACE_EVENT_FLOW_END_BIND_TO_ENCLOSING0(category_group, name, id)      \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_FLOW_END, category_group, \
-                                   name, id,                                   \
-                                   TRACE_EVENT_FLAG_BIND_TO_ENCLOSING)
-#define TRACE_EVENT_FLOW_END1(category_group, name, id, arg1_name, arg1_val)   \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_FLOW_END, category_group, \
-                                   name, id, TRACE_EVENT_FLAG_NONE, arg1_name, \
-                                   arg1_val)
-#define TRACE_EVENT_FLOW_END2(category_group, name, id, arg1_name, arg1_val,   \
-                              arg2_name, arg2_val)                             \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_FLOW_END, category_group, \
-                                   name, id, TRACE_EVENT_FLAG_NONE, arg1_name, \
-                                   arg1_val, arg2_name, arg2_val)
-#define TRACE_EVENT_COPY_FLOW_END0(category_group, name, id)                   \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_FLOW_END, category_group, \
-                                   name, id, TRACE_EVENT_FLAG_COPY)
-#define TRACE_EVENT_COPY_FLOW_END1(category_group, name, id, arg1_name,        \
-                                   arg1_val)                                   \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_FLOW_END, category_group, \
-                                   name, id, TRACE_EVENT_FLAG_COPY, arg1_name, \
-                                   arg1_val)
-#define TRACE_EVENT_COPY_FLOW_END2(category_group, name, id, arg1_name,        \
-                                   arg1_val, arg2_name, arg2_val)              \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_FLOW_END, category_group, \
-                                   name, id, TRACE_EVENT_FLAG_COPY, arg1_name, \
-                                   arg1_val, arg2_name, arg2_val)
-
-// Special trace event macro to trace task execution with the location where it
-// was posted from.
-#define TRACE_TASK_EXECUTION(run_function, task) \
-  INTERNAL_TRACE_TASK_EXECUTION(run_function, task)
-
-// TRACE_EVENT_METADATA* events are information related to other
-// injected events, not events in their own right.
-#define TRACE_EVENT_METADATA1(category_group, name, arg1_name, arg1_val) \
-  INTERNAL_TRACE_EVENT_METADATA_ADD(category_group, name, arg1_name, arg1_val)
-
-// Records a clock sync event.
-#define TRACE_EVENT_CLOCK_SYNC_RECEIVER(sync_id)                               \
-  INTERNAL_TRACE_EVENT_ADD(                                                    \
-      TRACE_EVENT_PHASE_CLOCK_SYNC, "__metadata", "clock_sync",                \
-      TRACE_EVENT_FLAG_NONE, "sync_id", sync_id)
-#define TRACE_EVENT_CLOCK_SYNC_ISSUER(sync_id, issue_ts, issue_end_ts)         \
-  INTERNAL_TRACE_EVENT_ADD_WITH_TIMESTAMP(                                     \
-      TRACE_EVENT_PHASE_CLOCK_SYNC, "__metadata", "clock_sync",                \
-      issue_end_ts.ToInternalValue(), TRACE_EVENT_FLAG_NONE,                   \
-      "sync_id", sync_id, "issue_ts", issue_ts.ToInternalValue())
-
-// Macros to track the life time and value of arbitrary client objects.
-// See also TraceTrackableObject.
-#define TRACE_EVENT_OBJECT_CREATED_WITH_ID(category_group, name, id) \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                  \
-      TRACE_EVENT_PHASE_CREATE_OBJECT, category_group, name,         \
-      TRACE_ID_DONT_MANGLE(id), TRACE_EVENT_FLAG_NONE)
-
-#define TRACE_EVENT_OBJECT_SNAPSHOT_WITH_ID(category_group, name, id, \
-                                            snapshot)                 \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                   \
-      TRACE_EVENT_PHASE_SNAPSHOT_OBJECT, category_group, name,        \
-      TRACE_ID_DONT_MANGLE(id), TRACE_EVENT_FLAG_NONE, "snapshot", snapshot)
-
-#define TRACE_EVENT_OBJECT_SNAPSHOT_WITH_ID_AND_TIMESTAMP(                    \
-    category_group, name, id, timestamp, snapshot)                            \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                         \
-      TRACE_EVENT_PHASE_SNAPSHOT_OBJECT, category_group, name,                \
-      TRACE_ID_DONT_MANGLE(id), TRACE_EVENT_API_CURRENT_THREAD_ID, timestamp, \
-      TRACE_EVENT_FLAG_NONE, "snapshot", snapshot)
-
-#define TRACE_EVENT_OBJECT_DELETED_WITH_ID(category_group, name, id) \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                  \
-      TRACE_EVENT_PHASE_DELETE_OBJECT, category_group, name,         \
-      TRACE_ID_DONT_MANGLE(id), TRACE_EVENT_FLAG_NONE)
-
-// Records entering and leaving trace event contexts. |category_group| and
-// |name| specify the context category and type. |context| is a
-// snapshotted context object id.
-#define TRACE_EVENT_ENTER_CONTEXT(category_group, name, context) \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                              \
-      TRACE_EVENT_PHASE_ENTER_CONTEXT, category_group, name,     \
-      TRACE_ID_DONT_MANGLE(context), TRACE_EVENT_FLAG_NONE)
-#define TRACE_EVENT_LEAVE_CONTEXT(category_group, name, context) \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                              \
-      TRACE_EVENT_PHASE_LEAVE_CONTEXT, category_group, name,     \
-      TRACE_ID_DONT_MANGLE(context), TRACE_EVENT_FLAG_NONE)
-#define TRACE_EVENT_SCOPED_CONTEXT(category_group, name, context) \
-  INTERNAL_TRACE_EVENT_SCOPED_CONTEXT(category_group, name,       \
-                                      TRACE_ID_DONT_MANGLE(context))
-
-// Macro to specify that two trace IDs are identical. For example,
-// TRACE_BIND_IDS(
-//     "category", "name",
-//     TRACE_ID_WITH_SCOPE("net::URLRequest", 0x1000),
-//     TRACE_ID_WITH_SCOPE("blink::ResourceFetcher::FetchRequest", 0x2000))
-// tells the trace consumer that events with ID ("net::URLRequest", 0x1000) from
-// the current process have the same ID as events with ID
-// ("blink::ResourceFetcher::FetchRequest", 0x2000).
-#define TRACE_BIND_IDS(category_group, name, id, bind_id) \
-  INTERNAL_TRACE_EVENT_ADD_BIND_IDS(category_group, name, id, bind_id);
-
-// Macro to efficiently determine if a given category group is enabled.
-#define TRACE_EVENT_CATEGORY_GROUP_ENABLED(category_group, ret)             \
-  do {                                                                      \
-    INTERNAL_TRACE_EVENT_GET_CATEGORY_INFO(category_group);                 \
-    if (INTERNAL_TRACE_EVENT_CATEGORY_GROUP_ENABLED_FOR_RECORDING_MODE()) { \
-      *ret = true;                                                          \
-    } else {                                                                \
-      *ret = false;                                                         \
-    }                                                                       \
-  } while (0)
-
-// Macro to explicitly warm up a given category group. This could be useful in
-// cases where we want to initialize a category group before any trace events
-// for that category group is reported. For example, to have a category group
-// always show up in the "record categories" list for manually selecting
-// settings in about://tracing.
-#define TRACE_EVENT_WARMUP_CATEGORY(category_group) \
-  INTERNAL_TRACE_EVENT_GET_CATEGORY_INFO(category_group)
-
-// Macro to efficiently determine, through polling, if a new trace has begun.
-#define TRACE_EVENT_IS_NEW_TRACE(ret)                                      \
-  do {                                                                     \
-    static int INTERNAL_TRACE_EVENT_UID(lastRecordingNumber) = 0;          \
-    int num_traces_recorded = TRACE_EVENT_API_GET_NUM_TRACES_RECORDED();   \
-    if (num_traces_recorded != -1 &&                                       \
-        num_traces_recorded !=                                             \
-            INTERNAL_TRACE_EVENT_UID(lastRecordingNumber)) {               \
-      INTERNAL_TRACE_EVENT_UID(lastRecordingNumber) = num_traces_recorded; \
-      *ret = true;                                                         \
-    } else {                                                               \
-      *ret = false;                                                        \
-    }                                                                      \
-  } while (0)
-
-// Notes regarding the following definitions:
-// New values can be added and propagated to third party libraries, but existing
-// definitions must never be changed, because third party libraries may use old
-// definitions.
-
-// Phase indicates the nature of an event entry. E.g. part of a begin/end pair.
-#define TRACE_EVENT_PHASE_BEGIN ('B')
-#define TRACE_EVENT_PHASE_END ('E')
-#define TRACE_EVENT_PHASE_COMPLETE ('X')
-#define TRACE_EVENT_PHASE_INSTANT ('I')
-#define TRACE_EVENT_PHASE_ASYNC_BEGIN ('S')
-#define TRACE_EVENT_PHASE_ASYNC_STEP_INTO ('T')
-#define TRACE_EVENT_PHASE_ASYNC_STEP_PAST ('p')
-#define TRACE_EVENT_PHASE_ASYNC_END ('F')
-#define TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN ('b')
-#define TRACE_EVENT_PHASE_NESTABLE_ASYNC_END ('e')
-#define TRACE_EVENT_PHASE_NESTABLE_ASYNC_INSTANT ('n')
-#define TRACE_EVENT_PHASE_FLOW_BEGIN ('s')
-#define TRACE_EVENT_PHASE_FLOW_STEP ('t')
-#define TRACE_EVENT_PHASE_FLOW_END ('f')
-#define TRACE_EVENT_PHASE_METADATA ('M')
-#define TRACE_EVENT_PHASE_COUNTER ('C')
-#define TRACE_EVENT_PHASE_SAMPLE ('P')
-#define TRACE_EVENT_PHASE_CREATE_OBJECT ('N')
-#define TRACE_EVENT_PHASE_SNAPSHOT_OBJECT ('O')
-#define TRACE_EVENT_PHASE_DELETE_OBJECT ('D')
-#define TRACE_EVENT_PHASE_MEMORY_DUMP ('v')
-#define TRACE_EVENT_PHASE_MARK ('R')
-#define TRACE_EVENT_PHASE_CLOCK_SYNC ('c')
-#define TRACE_EVENT_PHASE_ENTER_CONTEXT ('(')
-#define TRACE_EVENT_PHASE_LEAVE_CONTEXT (')')
-#define TRACE_EVENT_PHASE_BIND_IDS ('=')
-
-// Flags for changing the behavior of TRACE_EVENT_API_ADD_TRACE_EVENT.
-#define TRACE_EVENT_FLAG_NONE (static_cast<unsigned int>(0))
-#define TRACE_EVENT_FLAG_COPY (static_cast<unsigned int>(1 << 0))
-#define TRACE_EVENT_FLAG_HAS_ID (static_cast<unsigned int>(1 << 1))
-#define TRACE_EVENT_FLAG_MANGLE_ID (static_cast<unsigned int>(1 << 2))
-#define TRACE_EVENT_FLAG_SCOPE_OFFSET (static_cast<unsigned int>(1 << 3))
-#define TRACE_EVENT_FLAG_SCOPE_EXTRA (static_cast<unsigned int>(1 << 4))
-#define TRACE_EVENT_FLAG_EXPLICIT_TIMESTAMP (static_cast<unsigned int>(1 << 5))
-#define TRACE_EVENT_FLAG_ASYNC_TTS (static_cast<unsigned int>(1 << 6))
-#define TRACE_EVENT_FLAG_BIND_TO_ENCLOSING (static_cast<unsigned int>(1 << 7))
-#define TRACE_EVENT_FLAG_FLOW_IN (static_cast<unsigned int>(1 << 8))
-#define TRACE_EVENT_FLAG_FLOW_OUT (static_cast<unsigned int>(1 << 9))
-#define TRACE_EVENT_FLAG_HAS_CONTEXT_ID (static_cast<unsigned int>(1 << 10))
-#define TRACE_EVENT_FLAG_HAS_PROCESS_ID (static_cast<unsigned int>(1 << 11))
-
-#define TRACE_EVENT_FLAG_SCOPE_MASK                          \
-  (static_cast<unsigned int>(TRACE_EVENT_FLAG_SCOPE_OFFSET | \
-                             TRACE_EVENT_FLAG_SCOPE_EXTRA))
-
-// Type values for identifying types in the TraceValue union.
-#define TRACE_VALUE_TYPE_BOOL (static_cast<unsigned char>(1))
-#define TRACE_VALUE_TYPE_UINT (static_cast<unsigned char>(2))
-#define TRACE_VALUE_TYPE_INT (static_cast<unsigned char>(3))
-#define TRACE_VALUE_TYPE_DOUBLE (static_cast<unsigned char>(4))
-#define TRACE_VALUE_TYPE_POINTER (static_cast<unsigned char>(5))
-#define TRACE_VALUE_TYPE_STRING (static_cast<unsigned char>(6))
-#define TRACE_VALUE_TYPE_COPY_STRING (static_cast<unsigned char>(7))
-#define TRACE_VALUE_TYPE_CONVERTABLE (static_cast<unsigned char>(8))
-
-// Enum reflecting the scope of an INSTANT event. Must fit within
-// TRACE_EVENT_FLAG_SCOPE_MASK.
-#define TRACE_EVENT_SCOPE_GLOBAL (static_cast<unsigned char>(0 << 3))
-#define TRACE_EVENT_SCOPE_PROCESS (static_cast<unsigned char>(1 << 3))
-#define TRACE_EVENT_SCOPE_THREAD (static_cast<unsigned char>(2 << 3))
-
-#define TRACE_EVENT_SCOPE_NAME_GLOBAL ('g')
-#define TRACE_EVENT_SCOPE_NAME_PROCESS ('p')
-#define TRACE_EVENT_SCOPE_NAME_THREAD ('t')
-
-
-// The pointer returned from GetCategoryGroupEnabled() points to a
-// value with zero or more of the following bits. Used in this class only.
-// The TRACE_EVENT macros should only use the value as a bool.
-// These values must be in sync with macro values in trace_log.h in
-// chromium.
-enum CategoryGroupEnabledFlags {
-  // Category group enabled for the recording mode.
-  kEnabledForRecording_CategoryGroupEnabledFlags = 1 << 0,
-  // Category group enabled by SetEventCallbackEnabled().
-  kEnabledForEventCallback_CategoryGroupEnabledFlags = 1 << 2,
-  // Category group enabled to export events to ETW.
-  kEnabledForETWExport_CategoryGroupEnabledFlags = 1 << 3,
-};
-
-// By default, const char* asrgument values are assumed to have long-lived scope
-// and will not be copied. Use this macro to force a const char* to be copied.
-#define TRACE_STR_COPY(str) node::tracing::TraceStringWithCopy(str)
-
-// By default, uint64 ID argument values are not mangled with the Process ID in
-// TRACE_EVENT_ASYNC macros. Use this macro to force Process ID mangling.
-#define TRACE_ID_MANGLE(id) node::tracing::TraceID::ForceMangle(id)
-
-// By default, pointers are mangled with the Process ID in TRACE_EVENT_ASYNC
-// macros. Use this macro to prevent Process ID mangling.
-#define TRACE_ID_DONT_MANGLE(id) node::tracing::TraceID::DontMangle(id)
-
-// By default, trace IDs are eventually converted to a single 64-bit number. Use
-// this macro to add a scope string.
-#define TRACE_ID_WITH_SCOPE(scope, id) \
-  node::tracing::TraceID::WithScope(scope, id)
-
-// Sets the current sample state to the given category and name (both must be
-// constant strings). These states are intended for a sampling profiler.
-// Implementation note: we store category and name together because we don't
-// want the inconsistency/expense of storing two pointers.
-// |thread_bucket| is [0..2] and is used to statically isolate samples in one
-// thread from others.
-#define TRACE_EVENT_SET_SAMPLING_STATE_FOR_BUCKET(bucket_number, category, \
-                                                  name)                    \
-  node::tracing::TraceEventSamplingStateScope<bucket_number>::Set( \
-      category "\0" name)
-
-// Returns a current sampling state of the given bucket.
-#define TRACE_EVENT_GET_SAMPLING_STATE_FOR_BUCKET(bucket_number) \
-  node::tracing::TraceEventSamplingStateScope<bucket_number>::Current()
-
-// Creates a scope of a sampling state of the given bucket.
-//
-// {  // The sampling state is set within this scope.
-//    TRACE_EVENT_SAMPLING_STATE_SCOPE_FOR_BUCKET(0, "category", "name");
-//    ...;
-// }
-#define TRACE_EVENT_SCOPED_SAMPLING_STATE_FOR_BUCKET(bucket_number, category, \
-                                                     name)                    \
-  node::tracing::TraceEventSamplingStateScope<bucket_number>                   \
-      traceEventSamplingScope(category "\0" name);
-
-
-#define INTERNAL_TRACE_EVENT_CATEGORY_GROUP_ENABLED_FOR_RECORDING_MODE() \
-  *INTERNAL_TRACE_EVENT_UID(category_group_enabled) &                    \
-      (kEnabledForRecording_CategoryGroupEnabledFlags |                  \
-       kEnabledForEventCallback_CategoryGroupEnabledFlags)
-
-// The following macro has no implementation, but it needs to exist since
-// it gets called from scoped trace events. It cannot call UNIMPLEMENTED()
-// since an empty implementation is a valid one.
-#define INTERNAL_TRACE_MEMORY(category, name)
-
-////////////////////////////////////////////////////////////////////////////////
-// Implementation specific tracing API definitions.
-
-// Get a pointer to the enabled state of the given trace category. Only
-// long-lived literal strings should be given as the category group. The
-// returned pointer can be held permanently in a local static for example. If
-// the unsigned char is non-zero, tracing is enabled. If tracing is enabled,
-// TRACE_EVENT_API_ADD_TRACE_EVENT can be called. It's OK if tracing is disabled
-// between the load of the tracing state and the call to
-// TRACE_EVENT_API_ADD_TRACE_EVENT, because this flag only provides an early out
-// for best performance when tracing is disabled.
-// const uint8_t*
-//     TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED(const char* category_group)
-#define TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED              \
-  node::tracing::TraceEventHelper::GetCurrentPlatform() \
-      ->GetCategoryGroupEnabled
-
-// Get the number of times traces have been recorded. This is used to implement
-// the TRACE_EVENT_IS_NEW_TRACE facility.
-// unsigned int TRACE_EVENT_API_GET_NUM_TRACES_RECORDED()
-#define TRACE_EVENT_API_GET_NUM_TRACES_RECORDED UNIMPLEMENTED()
-
-// Add a trace event to the platform tracing system.
-// uint64_t TRACE_EVENT_API_ADD_TRACE_EVENT(
-//                    char phase,
-//                    const uint8_t* category_group_enabled,
-//                    const char* name,
-//                    const char* scope,
-//                    uint64_t id,
-//                    uint64_t bind_id,
-//                    int num_args,
-//                    const char** arg_names,
-//                    const uint8_t* arg_types,
-//                    const uint64_t* arg_values,
-//                    unsigned int flags)
-#define TRACE_EVENT_API_ADD_TRACE_EVENT \
-  node::tracing::TraceEventHelper::GetCurrentPlatform()->AddTraceEvent
-
-// Set the duration field of a COMPLETE trace event.
-// void TRACE_EVENT_API_UPDATE_TRACE_EVENT_DURATION(
-//     const uint8_t* category_group_enabled,
-//     const char* name,
-//     uint64_t id)
-#define TRACE_EVENT_API_UPDATE_TRACE_EVENT_DURATION             \
-  node::tracing::TraceEventHelper::GetCurrentPlatform() \
-      ->UpdateTraceEventDuration
-
-// Defines atomic operations used internally by the tracing system.
-#define TRACE_EVENT_API_ATOMIC_WORD intptr_t
-#define TRACE_EVENT_API_ATOMIC_LOAD(var) (var)
-#define TRACE_EVENT_API_ATOMIC_STORE(var, value) (var) = (value)
-
-// The thread buckets for the sampling profiler.
-extern TRACE_EVENT_API_ATOMIC_WORD g_trace_state[3];
-
-#define TRACE_EVENT_API_THREAD_BUCKET(thread_bucket) \
-  g_trace_state[thread_bucket]
-
-////////////////////////////////////////////////////////////////////////////////
-
-// Implementation detail: trace event macros create temporary variables
-// to keep instrumentation overhead low. These macros give each temporary
-// variable a unique name based on the line number to prevent name collisions.
-#define INTERNAL_TRACE_EVENT_UID3(a, b) trace_event_unique_##a##b
-#define INTERNAL_TRACE_EVENT_UID2(a, b) INTERNAL_TRACE_EVENT_UID3(a, b)
-#define INTERNAL_TRACE_EVENT_UID(name_prefix) \
-  INTERNAL_TRACE_EVENT_UID2(name_prefix, __LINE__)
-
-// Implementation detail: internal macro to create static category.
-// No barriers are needed, because this code is designed to operate safely
-// even when the unsigned char* points to garbage data (which may be the case
-// on processors without cache coherency).
-// TODO(fmeawad): This implementation contradicts that we can have a different
-// configuration for each isolate,
-// https://code.google.com/p/v8/issues/detail?id=4563
-#define INTERNAL_TRACE_EVENT_GET_CATEGORY_INFO_CUSTOM_VARIABLES(             \
-    category_group, atomic, category_group_enabled)                          \
-  category_group_enabled =                                                   \
-      reinterpret_cast<const uint8_t*>(TRACE_EVENT_API_ATOMIC_LOAD(atomic)); \
-  if (!category_group_enabled) {                                             \
-    category_group_enabled =                                                 \
-        TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED(category_group);          \
-    TRACE_EVENT_API_ATOMIC_STORE(                                            \
-        atomic, reinterpret_cast<TRACE_EVENT_API_ATOMIC_WORD>(               \
-                    category_group_enabled));                                \
-  }
-
-#define INTERNAL_TRACE_EVENT_GET_CATEGORY_INFO(category_group)             \
-  static TRACE_EVENT_API_ATOMIC_WORD INTERNAL_TRACE_EVENT_UID(atomic) = 0; \
-  const uint8_t* INTERNAL_TRACE_EVENT_UID(category_group_enabled);         \
-  INTERNAL_TRACE_EVENT_GET_CATEGORY_INFO_CUSTOM_VARIABLES(                 \
-      category_group, INTERNAL_TRACE_EVENT_UID(atomic),                    \
-      INTERNAL_TRACE_EVENT_UID(category_group_enabled));
-
-// Implementation detail: internal macro to create static category and add
-// event if the category is enabled.
-#define INTERNAL_TRACE_EVENT_ADD(phase, category_group, name, flags, ...)    \
-  do {                                                                       \
-    INTERNAL_TRACE_EVENT_GET_CATEGORY_INFO(category_group);                  \
-    if (INTERNAL_TRACE_EVENT_CATEGORY_GROUP_ENABLED_FOR_RECORDING_MODE()) {  \
-      node::tracing::AddTraceEvent(                                  \
-          phase, INTERNAL_TRACE_EVENT_UID(category_group_enabled), name,     \
-          node::tracing::kGlobalScope, node::tracing::kNoId, \
-          node::tracing::kNoId, flags, ##__VA_ARGS__);               \
-    }                                                                        \
-  } while (0)
-
-// Implementation detail: internal macro to create static category and add begin
-// event if the category is enabled. Also adds the end event when the scope
-// ends.
-#define INTERNAL_TRACE_EVENT_ADD_SCOPED(category_group, name, ...)           \
-  INTERNAL_TRACE_EVENT_GET_CATEGORY_INFO(category_group);                    \
-  node::tracing::ScopedTracer INTERNAL_TRACE_EVENT_UID(tracer);      \
-  if (INTERNAL_TRACE_EVENT_CATEGORY_GROUP_ENABLED_FOR_RECORDING_MODE()) {    \
-    uint64_t h = node::tracing::AddTraceEvent(                       \
-        TRACE_EVENT_PHASE_COMPLETE,                                          \
-        INTERNAL_TRACE_EVENT_UID(category_group_enabled), name,              \
-        node::tracing::kGlobalScope, node::tracing::kNoId,   \
-        node::tracing::kNoId, TRACE_EVENT_FLAG_NONE, ##__VA_ARGS__); \
-    INTERNAL_TRACE_EVENT_UID(tracer)                                         \
-        .Initialize(INTERNAL_TRACE_EVENT_UID(category_group_enabled), name,  \
-                    h);                                                      \
-  }
-
-#define INTERNAL_TRACE_EVENT_ADD_SCOPED_WITH_FLOW(category_group, name,     \
-                                                  bind_id, flow_flags, ...) \
-  INTERNAL_TRACE_EVENT_GET_CATEGORY_INFO(category_group);                   \
-  node::tracing::ScopedTracer INTERNAL_TRACE_EVENT_UID(tracer);     \
-  if (INTERNAL_TRACE_EVENT_CATEGORY_GROUP_ENABLED_FOR_RECORDING_MODE()) {   \
-    unsigned int trace_event_flags = flow_flags;                            \
-    node::tracing::TraceID trace_event_bind_id(bind_id,             \
-                                                       &trace_event_flags); \
-    uint64_t h = node::tracing::AddTraceEvent(                      \
-        TRACE_EVENT_PHASE_COMPLETE,                                         \
-        INTERNAL_TRACE_EVENT_UID(category_group_enabled), name,             \
-        node::tracing::kGlobalScope, node::tracing::kNoId,  \
-        trace_event_bind_id.raw_id(), trace_event_flags, ##__VA_ARGS__);    \
-    INTERNAL_TRACE_EVENT_UID(tracer)                                        \
-        .Initialize(INTERNAL_TRACE_EVENT_UID(category_group_enabled), name, \
-                    h);                                                     \
-  }
-
-// Implementation detail: internal macro to create static category and add
-// event if the category is enabled.
-#define INTERNAL_TRACE_EVENT_ADD_WITH_ID(phase, category_group, name, id,      \
-                                         flags, ...)                           \
-  do {                                                                         \
-    INTERNAL_TRACE_EVENT_GET_CATEGORY_INFO(category_group);                    \
-    if (INTERNAL_TRACE_EVENT_CATEGORY_GROUP_ENABLED_FOR_RECORDING_MODE()) {    \
-      unsigned int trace_event_flags = flags | TRACE_EVENT_FLAG_HAS_ID;        \
-      node::tracing::TraceID trace_event_trace_id(id,                  \
-                                                          &trace_event_flags); \
-      node::tracing::AddTraceEvent(                                    \
-          phase, INTERNAL_TRACE_EVENT_UID(category_group_enabled), name,       \
-          trace_event_trace_id.scope(), trace_event_trace_id.raw_id(),         \
-          node::tracing::kNoId, trace_event_flags, ##__VA_ARGS__);     \
-    }                                                                          \
-  } while (0)
-
-// Adds a trace event with a given timestamp. Not Implemented.
-#define INTERNAL_TRACE_EVENT_ADD_WITH_TIMESTAMP(phase, category_group, name, \
-                                                timestamp, flags, ...)       \
-  UNIMPLEMENTED()
-
-// Adds a trace event with a given id and timestamp. Not Implemented.
-#define INTERNAL_TRACE_EVENT_ADD_WITH_ID_AND_TIMESTAMP(     \
-    phase, category_group, name, id, timestamp, flags, ...) \
-  UNIMPLEMENTED()
-
-// Adds a trace event with a given id, thread_id, and timestamp. Not
-// Implemented.
-#define INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(            \
-    phase, category_group, name, id, thread_id, timestamp, flags, ...) \
-  UNIMPLEMENTED()
-
-// Enter and leave a context based on the current scope.
-#define INTERNAL_TRACE_EVENT_SCOPED_CONTEXT(category_group, name, context) \
-  struct INTERNAL_TRACE_EVENT_UID(ScopedContext) {                         \
-   public:                                                                 \
-    INTERNAL_TRACE_EVENT_UID(ScopedContext)(uint64_t cid) : cid_(cid) {    \
-      TRACE_EVENT_ENTER_CONTEXT(category_group, name, cid_);               \
-    }                                                                      \
-    ~INTERNAL_TRACE_EVENT_UID(ScopedContext)() {                           \
-      TRACE_EVENT_LEAVE_CONTEXT(category_group, name, cid_);               \
-    }                                                                      \
-                                                                           \
-   private:                                                                \
-    /* Local class friendly DISALLOW_COPY_AND_ASSIGN */                    \
-    INTERNAL_TRACE_EVENT_UID(ScopedContext)                                \
-    (const INTERNAL_TRACE_EVENT_UID(ScopedContext)&) {}                    \
-    void operator=(const INTERNAL_TRACE_EVENT_UID(ScopedContext)&) {}      \
-    uint64_t cid_;                                                         \
-  };                                                                       \
-  INTERNAL_TRACE_EVENT_UID(ScopedContext)                                  \
-  INTERNAL_TRACE_EVENT_UID(scoped_context)(context.raw_id());
-
-namespace node {
-namespace tracing {
-
-// Specify these values when the corresponding argument of AddTraceEvent is not
-// used.
-const int kZeroNumArgs = 0;
-const decltype(nullptr) kGlobalScope = nullptr;
-const uint64_t kNoId = 0;
-
-class TraceEventHelper {
- public:
-  static void SetCurrentPlatform(v8::Platform* platform);
-  static v8::Platform* GetCurrentPlatform();
-};
-
-// TraceID encapsulates an ID that can either be an integer or pointer. Pointers
-// are by default mangled with the Process ID so that they are unlikely to
-// collide when the same pointer is used on different processes.
-class TraceID {
- public:
-  class WithScope {
-   public:
-    WithScope(const char* scope, uint64_t raw_id)
-        : scope_(scope), raw_id_(raw_id) {}
-    uint64_t raw_id() const { return raw_id_; }
-    const char* scope() const { return scope_; }
-
-   private:
-    const char* scope_ = nullptr;
-    uint64_t raw_id_;
-  };
-
-  class DontMangle {
-   public:
-    explicit DontMangle(const void* raw_id)
-        : raw_id_(static_cast<uint64_t>(reinterpret_cast<uintptr_t>(raw_id))) {}
-    explicit DontMangle(uint64_t raw_id) : raw_id_(raw_id) {}
-    explicit DontMangle(unsigned int raw_id) : raw_id_(raw_id) {}
-    explicit DontMangle(uint16_t raw_id) : raw_id_(raw_id) {}
-    explicit DontMangle(unsigned char raw_id) : raw_id_(raw_id) {}
-    explicit DontMangle(int64_t raw_id)
-        : raw_id_(static_cast<uint64_t>(raw_id)) {}
-    explicit DontMangle(int raw_id) : raw_id_(static_cast<uint64_t>(raw_id)) {}
-    explicit DontMangle(int16_t raw_id)
-        : raw_id_(static_cast<uint64_t>(raw_id)) {}
-    explicit DontMangle(signed char raw_id)
-        : raw_id_(static_cast<uint64_t>(raw_id)) {}
-    explicit DontMangle(WithScope scoped_id)
-        : scope_(scoped_id.scope()), raw_id_(scoped_id.raw_id()) {}
-    const char* scope() const { return scope_; }
-    uint64_t raw_id() const { return raw_id_; }
-
-   private:
-    const char* scope_ = nullptr;
-    uint64_t raw_id_;
-  };
-
-  class ForceMangle {
-   public:
-    explicit ForceMangle(uint64_t raw_id) : raw_id_(raw_id) {}
-    explicit ForceMangle(unsigned int raw_id) : raw_id_(raw_id) {}
-    explicit ForceMangle(uint16_t raw_id) : raw_id_(raw_id) {}
-    explicit ForceMangle(unsigned char raw_id) : raw_id_(raw_id) {}
-    explicit ForceMangle(int64_t raw_id)
-        : raw_id_(static_cast<uint64_t>(raw_id)) {}
-    explicit ForceMangle(int raw_id) : raw_id_(static_cast<uint64_t>(raw_id)) {}
-    explicit ForceMangle(int16_t raw_id)
-        : raw_id_(static_cast<uint64_t>(raw_id)) {}
-    explicit ForceMangle(signed char raw_id)
-        : raw_id_(static_cast<uint64_t>(raw_id)) {}
-    uint64_t raw_id() const { return raw_id_; }
-
-   private:
-    uint64_t raw_id_;
-  };
-
-  TraceID(const void* raw_id, unsigned int* flags)
-      : raw_id_(static_cast<uint64_t>(reinterpret_cast<uintptr_t>(raw_id))) {
-    *flags |= TRACE_EVENT_FLAG_MANGLE_ID;
-  }
-  TraceID(ForceMangle raw_id, unsigned int* flags) : raw_id_(raw_id.raw_id()) {
-    *flags |= TRACE_EVENT_FLAG_MANGLE_ID;
-  }
-  TraceID(DontMangle maybe_scoped_id, unsigned int* flags)
-      : scope_(maybe_scoped_id.scope()), raw_id_(maybe_scoped_id.raw_id()) {}
-  TraceID(uint64_t raw_id, unsigned int* flags) : raw_id_(raw_id) {
-    (void)flags;
-  }
-  TraceID(unsigned int raw_id, unsigned int* flags) : raw_id_(raw_id) {
-    (void)flags;
-  }
-  TraceID(uint16_t raw_id, unsigned int* flags) : raw_id_(raw_id) {
-    (void)flags;
-  }
-  TraceID(unsigned char raw_id, unsigned int* flags) : raw_id_(raw_id) {
-    (void)flags;
-  }
-  TraceID(int64_t raw_id, unsigned int* flags)
-      : raw_id_(static_cast<uint64_t>(raw_id)) {
-    (void)flags;
-  }
-  TraceID(int raw_id, unsigned int* flags)
-      : raw_id_(static_cast<uint64_t>(raw_id)) {
-    (void)flags;
-  }
-  TraceID(int16_t raw_id, unsigned int* flags)
-      : raw_id_(static_cast<uint64_t>(raw_id)) {
-    (void)flags;
-  }
-  TraceID(signed char raw_id, unsigned int* flags)
-      : raw_id_(static_cast<uint64_t>(raw_id)) {
-    (void)flags;
-  }
-  TraceID(WithScope scoped_id, unsigned int* flags)
-      : scope_(scoped_id.scope()), raw_id_(scoped_id.raw_id()) {}
-
-  uint64_t raw_id() const { return raw_id_; }
-  const char* scope() const { return scope_; }
-
- private:
-  const char* scope_ = nullptr;
-  uint64_t raw_id_;
-};
-
-// Simple union to store various types as uint64_t.
-union TraceValueUnion {
-  bool as_bool;
-  uint64_t as_uint;
-  int64_t as_int;
-  double as_double;
-  const void* as_pointer;
-  const char* as_string;
-};
-
-// Simple container for const char* that should be copied instead of retained.
-class TraceStringWithCopy {
- public:
-  explicit TraceStringWithCopy(const char* str) : str_(str) {}
-  operator const char*() const { return str_; }
-
- private:
-  const char* str_;
-};
-
-// Define SetTraceValue for each allowed type. It stores the type and
-// value in the return arguments. This allows this API to avoid declaring any
-// structures so that it is portable to third_party libraries.
-#define INTERNAL_DECLARE_SET_TRACE_VALUE(actual_type, union_member,         \
-                                         value_type_id)                     \
-  static inline void SetTraceValue(actual_type arg, unsigned char* type, \
-                                      uint64_t* value) {                    \
-    TraceValueUnion type_value;                                             \
-    type_value.union_member = arg;                                          \
-    *type = value_type_id;                                                  \
-    *value = type_value.as_uint;                                            \
-  }
-// Simpler form for int types that can be safely casted.
-#define INTERNAL_DECLARE_SET_TRACE_VALUE_INT(actual_type, value_type_id)    \
-  static inline void SetTraceValue(actual_type arg, unsigned char* type, \
-                                      uint64_t* value) {                    \
-    *type = value_type_id;                                                  \
-    *value = static_cast<uint64_t>(arg);                                    \
-  }
-
-INTERNAL_DECLARE_SET_TRACE_VALUE_INT(uint64_t, TRACE_VALUE_TYPE_UINT)
-INTERNAL_DECLARE_SET_TRACE_VALUE_INT(unsigned int, TRACE_VALUE_TYPE_UINT)
-INTERNAL_DECLARE_SET_TRACE_VALUE_INT(uint16_t, TRACE_VALUE_TYPE_UINT)
-INTERNAL_DECLARE_SET_TRACE_VALUE_INT(unsigned char, TRACE_VALUE_TYPE_UINT)
-INTERNAL_DECLARE_SET_TRACE_VALUE_INT(int64_t, TRACE_VALUE_TYPE_INT)
-INTERNAL_DECLARE_SET_TRACE_VALUE_INT(int, TRACE_VALUE_TYPE_INT)
-INTERNAL_DECLARE_SET_TRACE_VALUE_INT(int16_t, TRACE_VALUE_TYPE_INT)
-INTERNAL_DECLARE_SET_TRACE_VALUE_INT(signed char, TRACE_VALUE_TYPE_INT)
-INTERNAL_DECLARE_SET_TRACE_VALUE(bool, as_bool, TRACE_VALUE_TYPE_BOOL)
-INTERNAL_DECLARE_SET_TRACE_VALUE(double, as_double, TRACE_VALUE_TYPE_DOUBLE)
-INTERNAL_DECLARE_SET_TRACE_VALUE(const void*, as_pointer,
-                                 TRACE_VALUE_TYPE_POINTER)
-INTERNAL_DECLARE_SET_TRACE_VALUE(const char*, as_string,
-                                 TRACE_VALUE_TYPE_STRING)
-INTERNAL_DECLARE_SET_TRACE_VALUE(const TraceStringWithCopy&, as_string,
-                                 TRACE_VALUE_TYPE_COPY_STRING)
-
-#undef INTERNAL_DECLARE_SET_TRACE_VALUE
-#undef INTERNAL_DECLARE_SET_TRACE_VALUE_INT
-
-// These AddTraceEvent template
-// function is defined here instead of in the macro, because the arg_values
-// could be temporary objects, such as std::string. In order to store
-// pointers to the internal c_str and pass through to the tracing API,
-// the arg_values must live throughout these procedures.
-
-static inline uint64_t AddTraceEvent(char phase,
-                                        const uint8_t* category_group_enabled,
-                                        const char* name, const char* scope,
-                                        uint64_t id, uint64_t bind_id,
-                                        unsigned int flags) {
-  return TRACE_EVENT_API_ADD_TRACE_EVENT(phase, category_group_enabled, name,
-                                         scope, id, bind_id, kZeroNumArgs, NULL,
-                                         NULL, NULL, flags);
-}
-
-template <class ARG1_TYPE>
-static inline uint64_t AddTraceEvent(
-    char phase, const uint8_t* category_group_enabled, const char* name,
-    const char* scope, uint64_t id, uint64_t bind_id, unsigned int flags,
-    const char* arg1_name, const ARG1_TYPE& arg1_val) {
-  const int num_args = 1;
-  uint8_t arg_types[1];
-  uint64_t arg_values[1];
-  SetTraceValue(arg1_val, &arg_types[0], &arg_values[0]);
-  return TRACE_EVENT_API_ADD_TRACE_EVENT(
-      phase, category_group_enabled, name, scope, id, bind_id, num_args,
-      &arg1_name, arg_types, arg_values, flags);
-}
-
-template <class ARG1_TYPE, class ARG2_TYPE>
-static inline uint64_t AddTraceEvent(
-    char phase, const uint8_t* category_group_enabled, const char* name,
-    const char* scope, uint64_t id, uint64_t bind_id, unsigned int flags,
-    const char* arg1_name, const ARG1_TYPE& arg1_val, const char* arg2_name,
-    const ARG2_TYPE& arg2_val) {
-  const int num_args = 2;
-  const char* arg_names[2] = {arg1_name, arg2_name};
-  unsigned char arg_types[2];
-  uint64_t arg_values[2];
-  SetTraceValue(arg1_val, &arg_types[0], &arg_values[0]);
-  SetTraceValue(arg2_val, &arg_types[1], &arg_values[1]);
-  return TRACE_EVENT_API_ADD_TRACE_EVENT(
-      phase, category_group_enabled, name, scope, id, bind_id, num_args,
-      arg_names, arg_types, arg_values, flags);
-}
-
-// Used by TRACE_EVENTx macros. Do not use directly.
-class ScopedTracer {
- public:
-  // Note: members of data_ intentionally left uninitialized. See Initialize.
-  ScopedTracer() : p_data_(NULL) {}
-
-  ~ScopedTracer() {
-    if (p_data_ && *data_.category_group_enabled)
-      TRACE_EVENT_API_UPDATE_TRACE_EVENT_DURATION(
-          data_.category_group_enabled, data_.name, data_.event_handle);
-  }
-
-  void Initialize(const uint8_t* category_group_enabled, const char* name,
-                  uint64_t event_handle) {
-    data_.category_group_enabled = category_group_enabled;
-    data_.name = name;
-    data_.event_handle = event_handle;
-    p_data_ = &data_;
-  }
-
- private:
-  // This Data struct workaround is to avoid initializing all the members
-  // in Data during construction of this object, since this object is always
-  // constructed, even when tracing is disabled. If the members of Data were
-  // members of this class instead, compiler warnings occur about potential
-  // uninitialized accesses.
-  struct Data {
-    const uint8_t* category_group_enabled;
-    const char* name;
-    uint64_t event_handle;
-  };
-  Data* p_data_;
-  Data data_;
-};
-
-// Used by TRACE_EVENT_BINARY_EFFICIENTx macro. Do not use directly.
-class ScopedTraceBinaryEfficient {
- public:
-  ScopedTraceBinaryEfficient(const char* category_group, const char* name);
-  ~ScopedTraceBinaryEfficient();
-
- private:
-  const uint8_t* category_group_enabled_;
-  const char* name_;
-  uint64_t event_handle_;
-};
-
-// TraceEventSamplingStateScope records the current sampling state
-// and sets a new sampling state. When the scope exists, it restores
-// the sampling state having recorded.
-template <size_t BucketNumber>
-class TraceEventSamplingStateScope {
- public:
-  explicit TraceEventSamplingStateScope(const char* category_and_name) {
-    previous_state_ = TraceEventSamplingStateScope<BucketNumber>::Current();
-    TraceEventSamplingStateScope<BucketNumber>::Set(category_and_name);
-  }
-
-  ~TraceEventSamplingStateScope() {
-    TraceEventSamplingStateScope<BucketNumber>::Set(previous_state_);
-  }
-
-  static inline const char* Current() {
-    return reinterpret_cast<const char*>(
-        TRACE_EVENT_API_ATOMIC_LOAD(g_trace_state[BucketNumber]));
-  }
-
-  static inline void Set(const char* category_and_name) {
-    TRACE_EVENT_API_ATOMIC_STORE(g_trace_state[BucketNumber],
-                                 reinterpret_cast<TRACE_EVENT_API_ATOMIC_WORD>(
-                                     const_cast<char*>(category_and_name)));
-  }
-
- private:
-  const char* previous_state_;
-};
-
-}  // namespace tracing
-}  // namespace node
-
-#endif  // SRC_TRACING_TRACE_EVENT_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/tree.h
+++ /dev/null
@@ -1,768 +0,0 @@
-/*-
- * Copyright 2002 Niels Provos <provos@citi.umich.edu>
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef  UV_TREE_H_
-#define  UV_TREE_H_
-
-#ifndef UV__UNUSED
-# if __GNUC__
-#  define UV__UNUSED __attribute__((unused))
-# else
-#  define UV__UNUSED
-# endif
-#endif
-
-/*
- * This file defines data structures for different types of trees:
- * splay trees and red-black trees.
- *
- * A splay tree is a self-organizing data structure.  Every operation
- * on the tree causes a splay to happen.  The splay moves the requested
- * node to the root of the tree and partly rebalances it.
- *
- * This has the benefit that request locality causes faster lookups as
- * the requested nodes move to the top of the tree.  On the other hand,
- * every lookup causes memory writes.
- *
- * The Balance Theorem bounds the total access time for m operations
- * and n inserts on an initially empty tree as O((m + n)lg n).  The
- * amortized cost for a sequence of m accesses to a splay tree is O(lg n);
- *
- * A red-black tree is a binary search tree with the node color as an
- * extra attribute.  It fulfills a set of conditions:
- *  - every search path from the root to a leaf consists of the
- *    same number of black nodes,
- *  - each red node (except for the root) has a black parent,
- *  - each leaf node is black.
- *
- * Every operation on a red-black tree is bounded as O(lg n).
- * The maximum height of a red-black tree is 2lg (n+1).
- */
-
-#define SPLAY_HEAD(name, type)                                                \
-struct name {                                                                 \
-  struct type *sph_root; /* root of the tree */                               \
-}
-
-#define SPLAY_INITIALIZER(root)                                               \
-  { NULL }
-
-#define SPLAY_INIT(root) do {                                                 \
-  (root)->sph_root = NULL;                                                    \
-} while (/*CONSTCOND*/ 0)
-
-#define SPLAY_ENTRY(type)                                                     \
-struct {                                                                      \
-  struct type *spe_left;          /* left element */                          \
-  struct type *spe_right;         /* right element */                         \
-}
-
-#define SPLAY_LEFT(elm, field)    (elm)->field.spe_left
-#define SPLAY_RIGHT(elm, field)   (elm)->field.spe_right
-#define SPLAY_ROOT(head)          (head)->sph_root
-#define SPLAY_EMPTY(head)         (SPLAY_ROOT(head) == NULL)
-
-/* SPLAY_ROTATE_{LEFT,RIGHT} expect that tmp hold SPLAY_{RIGHT,LEFT} */
-#define SPLAY_ROTATE_RIGHT(head, tmp, field) do {                             \
-  SPLAY_LEFT((head)->sph_root, field) = SPLAY_RIGHT(tmp, field);              \
-  SPLAY_RIGHT(tmp, field) = (head)->sph_root;                                 \
-  (head)->sph_root = tmp;                                                     \
-} while (/*CONSTCOND*/ 0)
-
-#define SPLAY_ROTATE_LEFT(head, tmp, field) do {                              \
-  SPLAY_RIGHT((head)->sph_root, field) = SPLAY_LEFT(tmp, field);              \
-  SPLAY_LEFT(tmp, field) = (head)->sph_root;                                  \
-  (head)->sph_root = tmp;                                                     \
-} while (/*CONSTCOND*/ 0)
-
-#define SPLAY_LINKLEFT(head, tmp, field) do {                                 \
-  SPLAY_LEFT(tmp, field) = (head)->sph_root;                                  \
-  tmp = (head)->sph_root;                                                     \
-  (head)->sph_root = SPLAY_LEFT((head)->sph_root, field);                     \
-} while (/*CONSTCOND*/ 0)
-
-#define SPLAY_LINKRIGHT(head, tmp, field) do {                                \
-  SPLAY_RIGHT(tmp, field) = (head)->sph_root;                                 \
-  tmp = (head)->sph_root;                                                     \
-  (head)->sph_root = SPLAY_RIGHT((head)->sph_root, field);                    \
-} while (/*CONSTCOND*/ 0)
-
-#define SPLAY_ASSEMBLE(head, node, left, right, field) do {                   \
-  SPLAY_RIGHT(left, field) = SPLAY_LEFT((head)->sph_root, field);             \
-  SPLAY_LEFT(right, field) = SPLAY_RIGHT((head)->sph_root, field);            \
-  SPLAY_LEFT((head)->sph_root, field) = SPLAY_RIGHT(node, field);             \
-  SPLAY_RIGHT((head)->sph_root, field) = SPLAY_LEFT(node, field);             \
-} while (/*CONSTCOND*/ 0)
-
-/* Generates prototypes and inline functions */
-
-#define SPLAY_PROTOTYPE(name, type, field, cmp)                               \
-void name##_SPLAY(struct name *, struct type *);                              \
-void name##_SPLAY_MINMAX(struct name *, int);                                 \
-struct type *name##_SPLAY_INSERT(struct name *, struct type *);               \
-struct type *name##_SPLAY_REMOVE(struct name *, struct type *);               \
-                                                                              \
-/* Finds the node with the same key as elm */                                 \
-static __inline struct type *                                                 \
-name##_SPLAY_FIND(struct name *head, struct type *elm)                        \
-{                                                                             \
-  if (SPLAY_EMPTY(head))                                                      \
-    return(NULL);                                                             \
-  name##_SPLAY(head, elm);                                                    \
-  if ((cmp)(elm, (head)->sph_root) == 0)                                      \
-    return (head->sph_root);                                                  \
-  return (NULL);                                                              \
-}                                                                             \
-                                                                              \
-static __inline struct type *                                                 \
-name##_SPLAY_NEXT(struct name *head, struct type *elm)                        \
-{                                                                             \
-  name##_SPLAY(head, elm);                                                    \
-  if (SPLAY_RIGHT(elm, field) != NULL) {                                      \
-    elm = SPLAY_RIGHT(elm, field);                                            \
-    while (SPLAY_LEFT(elm, field) != NULL) {                                  \
-      elm = SPLAY_LEFT(elm, field);                                           \
-    }                                                                         \
-  } else                                                                      \
-    elm = NULL;                                                               \
-  return (elm);                                                               \
-}                                                                             \
-                                                                              \
-static __inline struct type *                                                 \
-name##_SPLAY_MIN_MAX(struct name *head, int val)                              \
-{                                                                             \
-  name##_SPLAY_MINMAX(head, val);                                             \
-  return (SPLAY_ROOT(head));                                                  \
-}
-
-/* Main splay operation.
- * Moves node close to the key of elm to top
- */
-#define SPLAY_GENERATE(name, type, field, cmp)                                \
-struct type *                                                                 \
-name##_SPLAY_INSERT(struct name *head, struct type *elm)                      \
-{                                                                             \
-    if (SPLAY_EMPTY(head)) {                                                  \
-      SPLAY_LEFT(elm, field) = SPLAY_RIGHT(elm, field) = NULL;                \
-    } else {                                                                  \
-      int __comp;                                                             \
-      name##_SPLAY(head, elm);                                                \
-      __comp = (cmp)(elm, (head)->sph_root);                                  \
-      if(__comp < 0) {                                                        \
-        SPLAY_LEFT(elm, field) = SPLAY_LEFT((head)->sph_root, field);         \
-        SPLAY_RIGHT(elm, field) = (head)->sph_root;                           \
-        SPLAY_LEFT((head)->sph_root, field) = NULL;                           \
-      } else if (__comp > 0) {                                                \
-        SPLAY_RIGHT(elm, field) = SPLAY_RIGHT((head)->sph_root, field);       \
-        SPLAY_LEFT(elm, field) = (head)->sph_root;                            \
-        SPLAY_RIGHT((head)->sph_root, field) = NULL;                          \
-      } else                                                                  \
-        return ((head)->sph_root);                                            \
-    }                                                                         \
-    (head)->sph_root = (elm);                                                 \
-    return (NULL);                                                            \
-}                                                                             \
-                                                                              \
-struct type *                                                                 \
-name##_SPLAY_REMOVE(struct name *head, struct type *elm)                      \
-{                                                                             \
-  struct type *__tmp;                                                         \
-  if (SPLAY_EMPTY(head))                                                      \
-    return (NULL);                                                            \
-  name##_SPLAY(head, elm);                                                    \
-  if ((cmp)(elm, (head)->sph_root) == 0) {                                    \
-    if (SPLAY_LEFT((head)->sph_root, field) == NULL) {                        \
-      (head)->sph_root = SPLAY_RIGHT((head)->sph_root, field);                \
-    } else {                                                                  \
-      __tmp = SPLAY_RIGHT((head)->sph_root, field);                           \
-      (head)->sph_root = SPLAY_LEFT((head)->sph_root, field);                 \
-      name##_SPLAY(head, elm);                                                \
-      SPLAY_RIGHT((head)->sph_root, field) = __tmp;                           \
-    }                                                                         \
-    return (elm);                                                             \
-  }                                                                           \
-  return (NULL);                                                              \
-}                                                                             \
-                                                                              \
-void                                                                          \
-name##_SPLAY(struct name *head, struct type *elm)                             \
-{                                                                             \
-  struct type __node, *__left, *__right, *__tmp;                              \
-  int __comp;                                                                 \
-                                                                              \
-  SPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;            \
-  __left = __right = &__node;                                                 \
-                                                                              \
-  while ((__comp = (cmp)(elm, (head)->sph_root)) != 0) {                      \
-    if (__comp < 0) {                                                         \
-      __tmp = SPLAY_LEFT((head)->sph_root, field);                            \
-      if (__tmp == NULL)                                                      \
-        break;                                                                \
-      if ((cmp)(elm, __tmp) < 0){                                             \
-        SPLAY_ROTATE_RIGHT(head, __tmp, field);                               \
-        if (SPLAY_LEFT((head)->sph_root, field) == NULL)                      \
-          break;                                                              \
-      }                                                                       \
-      SPLAY_LINKLEFT(head, __right, field);                                   \
-    } else if (__comp > 0) {                                                  \
-      __tmp = SPLAY_RIGHT((head)->sph_root, field);                           \
-      if (__tmp == NULL)                                                      \
-        break;                                                                \
-      if ((cmp)(elm, __tmp) > 0){                                             \
-        SPLAY_ROTATE_LEFT(head, __tmp, field);                                \
-        if (SPLAY_RIGHT((head)->sph_root, field) == NULL)                     \
-          break;                                                              \
-      }                                                                       \
-      SPLAY_LINKRIGHT(head, __left, field);                                   \
-    }                                                                         \
-  }                                                                           \
-  SPLAY_ASSEMBLE(head, &__node, __left, __right, field);                      \
-}                                                                             \
-                                                                              \
-/* Splay with either the minimum or the maximum element                       \
- * Used to find minimum or maximum element in tree.                           \
- */                                                                           \
-void name##_SPLAY_MINMAX(struct name *head, int __comp)                       \
-{                                                                             \
-  struct type __node, *__left, *__right, *__tmp;                              \
-                                                                              \
-  SPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;            \
-  __left = __right = &__node;                                                 \
-                                                                              \
-  while (1) {                                                                 \
-    if (__comp < 0) {                                                         \
-      __tmp = SPLAY_LEFT((head)->sph_root, field);                            \
-      if (__tmp == NULL)                                                      \
-        break;                                                                \
-      if (__comp < 0){                                                        \
-        SPLAY_ROTATE_RIGHT(head, __tmp, field);                               \
-        if (SPLAY_LEFT((head)->sph_root, field) == NULL)                      \
-          break;                                                              \
-      }                                                                       \
-      SPLAY_LINKLEFT(head, __right, field);                                   \
-    } else if (__comp > 0) {                                                  \
-      __tmp = SPLAY_RIGHT((head)->sph_root, field);                           \
-      if (__tmp == NULL)                                                      \
-        break;                                                                \
-      if (__comp > 0) {                                                       \
-        SPLAY_ROTATE_LEFT(head, __tmp, field);                                \
-        if (SPLAY_RIGHT((head)->sph_root, field) == NULL)                     \
-          break;                                                              \
-      }                                                                       \
-      SPLAY_LINKRIGHT(head, __left, field);                                   \
-    }                                                                         \
-  }                                                                           \
-  SPLAY_ASSEMBLE(head, &__node, __left, __right, field);                      \
-}
-
-#define SPLAY_NEGINF  -1
-#define SPLAY_INF     1
-
-#define SPLAY_INSERT(name, x, y)  name##_SPLAY_INSERT(x, y)
-#define SPLAY_REMOVE(name, x, y)  name##_SPLAY_REMOVE(x, y)
-#define SPLAY_FIND(name, x, y)    name##_SPLAY_FIND(x, y)
-#define SPLAY_NEXT(name, x, y)    name##_SPLAY_NEXT(x, y)
-#define SPLAY_MIN(name, x)        (SPLAY_EMPTY(x) ? NULL                      \
-                                  : name##_SPLAY_MIN_MAX(x, SPLAY_NEGINF))
-#define SPLAY_MAX(name, x)        (SPLAY_EMPTY(x) ? NULL                      \
-                                  : name##_SPLAY_MIN_MAX(x, SPLAY_INF))
-
-#define SPLAY_FOREACH(x, name, head)                                          \
-  for ((x) = SPLAY_MIN(name, head);                                           \
-       (x) != NULL;                                                           \
-       (x) = SPLAY_NEXT(name, head, x))
-
-/* Macros that define a red-black tree */
-#define RB_HEAD(name, type)                                                   \
-struct name {                                                                 \
-  struct type *rbh_root; /* root of the tree */                               \
-}
-
-#define RB_INITIALIZER(root)                                                  \
-  { NULL }
-
-#define RB_INIT(root) do {                                                    \
-  (root)->rbh_root = NULL;                                                    \
-} while (/*CONSTCOND*/ 0)
-
-#define RB_BLACK  0
-#define RB_RED    1
-#define RB_ENTRY(type)                                                        \
-struct {                                                                      \
-  struct type *rbe_left;        /* left element */                            \
-  struct type *rbe_right;       /* right element */                           \
-  struct type *rbe_parent;      /* parent element */                          \
-  int rbe_color;                /* node color */                              \
-}
-
-#define RB_LEFT(elm, field)     (elm)->field.rbe_left
-#define RB_RIGHT(elm, field)    (elm)->field.rbe_right
-#define RB_PARENT(elm, field)   (elm)->field.rbe_parent
-#define RB_COLOR(elm, field)    (elm)->field.rbe_color
-#define RB_ROOT(head)           (head)->rbh_root
-#define RB_EMPTY(head)          (RB_ROOT(head) == NULL)
-
-#define RB_SET(elm, parent, field) do {                                       \
-  RB_PARENT(elm, field) = parent;                                             \
-  RB_LEFT(elm, field) = RB_RIGHT(elm, field) = NULL;                          \
-  RB_COLOR(elm, field) = RB_RED;                                              \
-} while (/*CONSTCOND*/ 0)
-
-#define RB_SET_BLACKRED(black, red, field) do {                               \
-  RB_COLOR(black, field) = RB_BLACK;                                          \
-  RB_COLOR(red, field) = RB_RED;                                              \
-} while (/*CONSTCOND*/ 0)
-
-#ifndef RB_AUGMENT
-#define RB_AUGMENT(x)  do {} while (0)
-#endif
-
-#define RB_ROTATE_LEFT(head, elm, tmp, field) do {                            \
-  (tmp) = RB_RIGHT(elm, field);                                               \
-  if ((RB_RIGHT(elm, field) = RB_LEFT(tmp, field)) != NULL) {                 \
-    RB_PARENT(RB_LEFT(tmp, field), field) = (elm);                            \
-  }                                                                           \
-  RB_AUGMENT(elm);                                                            \
-  if ((RB_PARENT(tmp, field) = RB_PARENT(elm, field)) != NULL) {              \
-    if ((elm) == RB_LEFT(RB_PARENT(elm, field), field))                       \
-      RB_LEFT(RB_PARENT(elm, field), field) = (tmp);                          \
-    else                                                                      \
-      RB_RIGHT(RB_PARENT(elm, field), field) = (tmp);                         \
-  } else                                                                      \
-    (head)->rbh_root = (tmp);                                                 \
-  RB_LEFT(tmp, field) = (elm);                                                \
-  RB_PARENT(elm, field) = (tmp);                                              \
-  RB_AUGMENT(tmp);                                                            \
-  if ((RB_PARENT(tmp, field)))                                                \
-    RB_AUGMENT(RB_PARENT(tmp, field));                                        \
-} while (/*CONSTCOND*/ 0)
-
-#define RB_ROTATE_RIGHT(head, elm, tmp, field) do {                           \
-  (tmp) = RB_LEFT(elm, field);                                                \
-  if ((RB_LEFT(elm, field) = RB_RIGHT(tmp, field)) != NULL) {                 \
-    RB_PARENT(RB_RIGHT(tmp, field), field) = (elm);                           \
-  }                                                                           \
-  RB_AUGMENT(elm);                                                            \
-  if ((RB_PARENT(tmp, field) = RB_PARENT(elm, field)) != NULL) {              \
-    if ((elm) == RB_LEFT(RB_PARENT(elm, field), field))                       \
-      RB_LEFT(RB_PARENT(elm, field), field) = (tmp);                          \
-    else                                                                      \
-      RB_RIGHT(RB_PARENT(elm, field), field) = (tmp);                         \
-  } else                                                                      \
-    (head)->rbh_root = (tmp);                                                 \
-  RB_RIGHT(tmp, field) = (elm);                                               \
-  RB_PARENT(elm, field) = (tmp);                                              \
-  RB_AUGMENT(tmp);                                                            \
-  if ((RB_PARENT(tmp, field)))                                                \
-    RB_AUGMENT(RB_PARENT(tmp, field));                                        \
-} while (/*CONSTCOND*/ 0)
-
-/* Generates prototypes and inline functions */
-#define  RB_PROTOTYPE(name, type, field, cmp)                                 \
-  RB_PROTOTYPE_INTERNAL(name, type, field, cmp,)
-#define  RB_PROTOTYPE_STATIC(name, type, field, cmp)                          \
-  RB_PROTOTYPE_INTERNAL(name, type, field, cmp, UV__UNUSED static)
-#define RB_PROTOTYPE_INTERNAL(name, type, field, cmp, attr)                   \
-attr void name##_RB_INSERT_COLOR(struct name *, struct type *);               \
-attr void name##_RB_REMOVE_COLOR(struct name *, struct type *, struct type *);\
-attr struct type *name##_RB_REMOVE(struct name *, struct type *);             \
-attr struct type *name##_RB_INSERT(struct name *, struct type *);             \
-attr struct type *name##_RB_FIND(struct name *, struct type *);               \
-attr struct type *name##_RB_NFIND(struct name *, struct type *);              \
-attr struct type *name##_RB_NEXT(struct type *);                              \
-attr struct type *name##_RB_PREV(struct type *);                              \
-attr struct type *name##_RB_MINMAX(struct name *, int);                       \
-                                                                              \
-
-/* Main rb operation.
- * Moves node close to the key of elm to top
- */
-#define  RB_GENERATE(name, type, field, cmp)                                  \
-  RB_GENERATE_INTERNAL(name, type, field, cmp,)
-#define  RB_GENERATE_STATIC(name, type, field, cmp)                           \
-  RB_GENERATE_INTERNAL(name, type, field, cmp, UV__UNUSED static)
-#define RB_GENERATE_INTERNAL(name, type, field, cmp, attr)                    \
-attr void                                                                     \
-name##_RB_INSERT_COLOR(struct name *head, struct type *elm)                   \
-{                                                                             \
-  struct type *parent, *gparent, *tmp;                                        \
-  while ((parent = RB_PARENT(elm, field)) != NULL &&                          \
-      RB_COLOR(parent, field) == RB_RED) {                                    \
-    gparent = RB_PARENT(parent, field);                                       \
-    if (parent == RB_LEFT(gparent, field)) {                                  \
-      tmp = RB_RIGHT(gparent, field);                                         \
-      if (tmp && RB_COLOR(tmp, field) == RB_RED) {                            \
-        RB_COLOR(tmp, field) = RB_BLACK;                                      \
-        RB_SET_BLACKRED(parent, gparent, field);                              \
-        elm = gparent;                                                        \
-        continue;                                                             \
-      }                                                                       \
-      if (RB_RIGHT(parent, field) == elm) {                                   \
-        RB_ROTATE_LEFT(head, parent, tmp, field);                             \
-        tmp = parent;                                                         \
-        parent = elm;                                                         \
-        elm = tmp;                                                            \
-      }                                                                       \
-      RB_SET_BLACKRED(parent, gparent, field);                                \
-      RB_ROTATE_RIGHT(head, gparent, tmp, field);                             \
-    } else {                                                                  \
-      tmp = RB_LEFT(gparent, field);                                          \
-      if (tmp && RB_COLOR(tmp, field) == RB_RED) {                            \
-        RB_COLOR(tmp, field) = RB_BLACK;                                      \
-        RB_SET_BLACKRED(parent, gparent, field);                              \
-        elm = gparent;                                                        \
-        continue;                                                             \
-      }                                                                       \
-      if (RB_LEFT(parent, field) == elm) {                                    \
-        RB_ROTATE_RIGHT(head, parent, tmp, field);                            \
-        tmp = parent;                                                         \
-        parent = elm;                                                         \
-        elm = tmp;                                                            \
-      }                                                                       \
-      RB_SET_BLACKRED(parent, gparent, field);                                \
-      RB_ROTATE_LEFT(head, gparent, tmp, field);                              \
-    }                                                                         \
-  }                                                                           \
-  RB_COLOR(head->rbh_root, field) = RB_BLACK;                                 \
-}                                                                             \
-                                                                              \
-attr void                                                                     \
-name##_RB_REMOVE_COLOR(struct name *head, struct type *parent,                \
-    struct type *elm)                                                         \
-{                                                                             \
-  struct type *tmp;                                                           \
-  while ((elm == NULL || RB_COLOR(elm, field) == RB_BLACK) &&                 \
-      elm != RB_ROOT(head)) {                                                 \
-    if (RB_LEFT(parent, field) == elm) {                                      \
-      tmp = RB_RIGHT(parent, field);                                          \
-      if (RB_COLOR(tmp, field) == RB_RED) {                                   \
-        RB_SET_BLACKRED(tmp, parent, field);                                  \
-        RB_ROTATE_LEFT(head, parent, tmp, field);                             \
-        tmp = RB_RIGHT(parent, field);                                        \
-      }                                                                       \
-      if ((RB_LEFT(tmp, field) == NULL ||                                     \
-          RB_COLOR(RB_LEFT(tmp, field), field) == RB_BLACK) &&                \
-          (RB_RIGHT(tmp, field) == NULL ||                                    \
-          RB_COLOR(RB_RIGHT(tmp, field), field) == RB_BLACK)) {               \
-        RB_COLOR(tmp, field) = RB_RED;                                        \
-        elm = parent;                                                         \
-        parent = RB_PARENT(elm, field);                                       \
-      } else {                                                                \
-        if (RB_RIGHT(tmp, field) == NULL ||                                   \
-            RB_COLOR(RB_RIGHT(tmp, field), field) == RB_BLACK) {              \
-          struct type *oleft;                                                 \
-          if ((oleft = RB_LEFT(tmp, field))                                   \
-              != NULL)                                                        \
-            RB_COLOR(oleft, field) = RB_BLACK;                                \
-          RB_COLOR(tmp, field) = RB_RED;                                      \
-          RB_ROTATE_RIGHT(head, tmp, oleft, field);                           \
-          tmp = RB_RIGHT(parent, field);                                      \
-        }                                                                     \
-        RB_COLOR(tmp, field) = RB_COLOR(parent, field);                       \
-        RB_COLOR(parent, field) = RB_BLACK;                                   \
-        if (RB_RIGHT(tmp, field))                                             \
-          RB_COLOR(RB_RIGHT(tmp, field), field) = RB_BLACK;                   \
-        RB_ROTATE_LEFT(head, parent, tmp, field);                             \
-        elm = RB_ROOT(head);                                                  \
-        break;                                                                \
-      }                                                                       \
-    } else {                                                                  \
-      tmp = RB_LEFT(parent, field);                                           \
-      if (RB_COLOR(tmp, field) == RB_RED) {                                   \
-        RB_SET_BLACKRED(tmp, parent, field);                                  \
-        RB_ROTATE_RIGHT(head, parent, tmp, field);                            \
-        tmp = RB_LEFT(parent, field);                                         \
-      }                                                                       \
-      if ((RB_LEFT(tmp, field) == NULL ||                                     \
-          RB_COLOR(RB_LEFT(tmp, field), field) == RB_BLACK) &&                \
-          (RB_RIGHT(tmp, field) == NULL ||                                    \
-          RB_COLOR(RB_RIGHT(tmp, field), field) == RB_BLACK)) {               \
-        RB_COLOR(tmp, field) = RB_RED;                                        \
-        elm = parent;                                                         \
-        parent = RB_PARENT(elm, field);                                       \
-      } else {                                                                \
-        if (RB_LEFT(tmp, field) == NULL ||                                    \
-            RB_COLOR(RB_LEFT(tmp, field), field) == RB_BLACK) {               \
-          struct type *oright;                                                \
-          if ((oright = RB_RIGHT(tmp, field))                                 \
-              != NULL)                                                        \
-            RB_COLOR(oright, field) = RB_BLACK;                               \
-          RB_COLOR(tmp, field) = RB_RED;                                      \
-          RB_ROTATE_LEFT(head, tmp, oright, field);                           \
-          tmp = RB_LEFT(parent, field);                                       \
-        }                                                                     \
-        RB_COLOR(tmp, field) = RB_COLOR(parent, field);                       \
-        RB_COLOR(parent, field) = RB_BLACK;                                   \
-        if (RB_LEFT(tmp, field))                                              \
-          RB_COLOR(RB_LEFT(tmp, field), field) = RB_BLACK;                    \
-        RB_ROTATE_RIGHT(head, parent, tmp, field);                            \
-        elm = RB_ROOT(head);                                                  \
-        break;                                                                \
-      }                                                                       \
-    }                                                                         \
-  }                                                                           \
-  if (elm)                                                                    \
-    RB_COLOR(elm, field) = RB_BLACK;                                          \
-}                                                                             \
-                                                                              \
-attr struct type *                                                            \
-name##_RB_REMOVE(struct name *head, struct type *elm)                         \
-{                                                                             \
-  struct type *child, *parent, *old = elm;                                    \
-  int color;                                                                  \
-  if (RB_LEFT(elm, field) == NULL)                                            \
-    child = RB_RIGHT(elm, field);                                             \
-  else if (RB_RIGHT(elm, field) == NULL)                                      \
-    child = RB_LEFT(elm, field);                                              \
-  else {                                                                      \
-    struct type *left;                                                        \
-    elm = RB_RIGHT(elm, field);                                               \
-    while ((left = RB_LEFT(elm, field)) != NULL)                              \
-      elm = left;                                                             \
-    child = RB_RIGHT(elm, field);                                             \
-    parent = RB_PARENT(elm, field);                                           \
-    color = RB_COLOR(elm, field);                                             \
-    if (child)                                                                \
-      RB_PARENT(child, field) = parent;                                       \
-    if (parent) {                                                             \
-      if (RB_LEFT(parent, field) == elm)                                      \
-        RB_LEFT(parent, field) = child;                                       \
-      else                                                                    \
-        RB_RIGHT(parent, field) = child;                                      \
-      RB_AUGMENT(parent);                                                     \
-    } else                                                                    \
-      RB_ROOT(head) = child;                                                  \
-    if (RB_PARENT(elm, field) == old)                                         \
-      parent = elm;                                                           \
-    (elm)->field = (old)->field;                                              \
-    if (RB_PARENT(old, field)) {                                              \
-      if (RB_LEFT(RB_PARENT(old, field), field) == old)                       \
-        RB_LEFT(RB_PARENT(old, field), field) = elm;                          \
-      else                                                                    \
-        RB_RIGHT(RB_PARENT(old, field), field) = elm;                         \
-      RB_AUGMENT(RB_PARENT(old, field));                                      \
-    } else                                                                    \
-      RB_ROOT(head) = elm;                                                    \
-    RB_PARENT(RB_LEFT(old, field), field) = elm;                              \
-    if (RB_RIGHT(old, field))                                                 \
-      RB_PARENT(RB_RIGHT(old, field), field) = elm;                           \
-    if (parent) {                                                             \
-      left = parent;                                                          \
-      do {                                                                    \
-        RB_AUGMENT(left);                                                     \
-      } while ((left = RB_PARENT(left, field)) != NULL);                      \
-    }                                                                         \
-    goto color;                                                               \
-  }                                                                           \
-  parent = RB_PARENT(elm, field);                                             \
-  color = RB_COLOR(elm, field);                                               \
-  if (child)                                                                  \
-    RB_PARENT(child, field) = parent;                                         \
-  if (parent) {                                                               \
-    if (RB_LEFT(parent, field) == elm)                                        \
-      RB_LEFT(parent, field) = child;                                         \
-    else                                                                      \
-      RB_RIGHT(parent, field) = child;                                        \
-    RB_AUGMENT(parent);                                                       \
-  } else                                                                      \
-    RB_ROOT(head) = child;                                                    \
-color:                                                                        \
-  if (color == RB_BLACK)                                                      \
-    name##_RB_REMOVE_COLOR(head, parent, child);                              \
-  return (old);                                                               \
-}                                                                             \
-                                                                              \
-/* Inserts a node into the RB tree */                                         \
-attr struct type *                                                            \
-name##_RB_INSERT(struct name *head, struct type *elm)                         \
-{                                                                             \
-  struct type *tmp;                                                           \
-  struct type *parent = NULL;                                                 \
-  int comp = 0;                                                               \
-  tmp = RB_ROOT(head);                                                        \
-  while (tmp) {                                                               \
-    parent = tmp;                                                             \
-    comp = (cmp)(elm, parent);                                                \
-    if (comp < 0)                                                             \
-      tmp = RB_LEFT(tmp, field);                                              \
-    else if (comp > 0)                                                        \
-      tmp = RB_RIGHT(tmp, field);                                             \
-    else                                                                      \
-      return (tmp);                                                           \
-  }                                                                           \
-  RB_SET(elm, parent, field);                                                 \
-  if (parent != NULL) {                                                       \
-    if (comp < 0)                                                             \
-      RB_LEFT(parent, field) = elm;                                           \
-    else                                                                      \
-      RB_RIGHT(parent, field) = elm;                                          \
-    RB_AUGMENT(parent);                                                       \
-  } else                                                                      \
-    RB_ROOT(head) = elm;                                                      \
-  name##_RB_INSERT_COLOR(head, elm);                                          \
-  return (NULL);                                                              \
-}                                                                             \
-                                                                              \
-/* Finds the node with the same key as elm */                                 \
-attr struct type *                                                            \
-name##_RB_FIND(struct name *head, struct type *elm)                           \
-{                                                                             \
-  struct type *tmp = RB_ROOT(head);                                           \
-  int comp;                                                                   \
-  while (tmp) {                                                               \
-    comp = cmp(elm, tmp);                                                     \
-    if (comp < 0)                                                             \
-      tmp = RB_LEFT(tmp, field);                                              \
-    else if (comp > 0)                                                        \
-      tmp = RB_RIGHT(tmp, field);                                             \
-    else                                                                      \
-      return (tmp);                                                           \
-  }                                                                           \
-  return (NULL);                                                              \
-}                                                                             \
-                                                                              \
-/* Finds the first node greater than or equal to the search key */            \
-attr struct type *                                                            \
-name##_RB_NFIND(struct name *head, struct type *elm)                          \
-{                                                                             \
-  struct type *tmp = RB_ROOT(head);                                           \
-  struct type *res = NULL;                                                    \
-  int comp;                                                                   \
-  while (tmp) {                                                               \
-    comp = cmp(elm, tmp);                                                     \
-    if (comp < 0) {                                                           \
-      res = tmp;                                                              \
-      tmp = RB_LEFT(tmp, field);                                              \
-    }                                                                         \
-    else if (comp > 0)                                                        \
-      tmp = RB_RIGHT(tmp, field);                                             \
-    else                                                                      \
-      return (tmp);                                                           \
-  }                                                                           \
-  return (res);                                                               \
-}                                                                             \
-                                                                              \
-/* ARGSUSED */                                                                \
-attr struct type *                                                            \
-name##_RB_NEXT(struct type *elm)                                              \
-{                                                                             \
-  if (RB_RIGHT(elm, field)) {                                                 \
-    elm = RB_RIGHT(elm, field);                                               \
-    while (RB_LEFT(elm, field))                                               \
-      elm = RB_LEFT(elm, field);                                              \
-  } else {                                                                    \
-    if (RB_PARENT(elm, field) &&                                              \
-        (elm == RB_LEFT(RB_PARENT(elm, field), field)))                       \
-      elm = RB_PARENT(elm, field);                                            \
-    else {                                                                    \
-      while (RB_PARENT(elm, field) &&                                         \
-          (elm == RB_RIGHT(RB_PARENT(elm, field), field)))                    \
-        elm = RB_PARENT(elm, field);                                          \
-      elm = RB_PARENT(elm, field);                                            \
-    }                                                                         \
-  }                                                                           \
-  return (elm);                                                               \
-}                                                                             \
-                                                                              \
-/* ARGSUSED */                                                                \
-attr struct type *                                                            \
-name##_RB_PREV(struct type *elm)                                              \
-{                                                                             \
-  if (RB_LEFT(elm, field)) {                                                  \
-    elm = RB_LEFT(elm, field);                                                \
-    while (RB_RIGHT(elm, field))                                              \
-      elm = RB_RIGHT(elm, field);                                             \
-  } else {                                                                    \
-    if (RB_PARENT(elm, field) &&                                              \
-        (elm == RB_RIGHT(RB_PARENT(elm, field), field)))                      \
-      elm = RB_PARENT(elm, field);                                            \
-    else {                                                                    \
-      while (RB_PARENT(elm, field) &&                                         \
-          (elm == RB_LEFT(RB_PARENT(elm, field), field)))                     \
-        elm = RB_PARENT(elm, field);                                          \
-      elm = RB_PARENT(elm, field);                                            \
-    }                                                                         \
-  }                                                                           \
-  return (elm);                                                               \
-}                                                                             \
-                                                                              \
-attr struct type *                                                            \
-name##_RB_MINMAX(struct name *head, int val)                                  \
-{                                                                             \
-  struct type *tmp = RB_ROOT(head);                                           \
-  struct type *parent = NULL;                                                 \
-  while (tmp) {                                                               \
-    parent = tmp;                                                             \
-    if (val < 0)                                                              \
-      tmp = RB_LEFT(tmp, field);                                              \
-    else                                                                      \
-      tmp = RB_RIGHT(tmp, field);                                             \
-  }                                                                           \
-  return (parent);                                                            \
-}
-
-#define RB_NEGINF   -1
-#define RB_INF      1
-
-#define RB_INSERT(name, x, y)   name##_RB_INSERT(x, y)
-#define RB_REMOVE(name, x, y)   name##_RB_REMOVE(x, y)
-#define RB_FIND(name, x, y)     name##_RB_FIND(x, y)
-#define RB_NFIND(name, x, y)    name##_RB_NFIND(x, y)
-#define RB_NEXT(name, x, y)     name##_RB_NEXT(y)
-#define RB_PREV(name, x, y)     name##_RB_PREV(y)
-#define RB_MIN(name, x)         name##_RB_MINMAX(x, RB_NEGINF)
-#define RB_MAX(name, x)         name##_RB_MINMAX(x, RB_INF)
-
-#define RB_FOREACH(x, name, head)                                             \
-  for ((x) = RB_MIN(name, head);                                              \
-       (x) != NULL;                                                           \
-       (x) = name##_RB_NEXT(x))
-
-#define RB_FOREACH_FROM(x, name, y)                                           \
-  for ((x) = (y);                                                             \
-      ((x) != NULL) && ((y) = name##_RB_NEXT(x), (x) != NULL);                \
-       (x) = (y))
-
-#define RB_FOREACH_SAFE(x, name, head, y)                                     \
-  for ((x) = RB_MIN(name, head);                                              \
-      ((x) != NULL) && ((y) = name##_RB_NEXT(x), (x) != NULL);                \
-       (x) = (y))
-
-#define RB_FOREACH_REVERSE(x, name, head)                                     \
-  for ((x) = RB_MAX(name, head);                                              \
-       (x) != NULL;                                                           \
-       (x) = name##_RB_PREV(x))
-
-#define RB_FOREACH_REVERSE_FROM(x, name, y)                                   \
-  for ((x) = (y);                                                             \
-      ((x) != NULL) && ((y) = name##_RB_PREV(x), (x) != NULL);                \
-       (x) = (y))
-
-#define RB_FOREACH_REVERSE_SAFE(x, name, head, y)                             \
-  for ((x) = RB_MAX(name, head);                                              \
-      ((x) != NULL) && ((y) = name##_RB_PREV(x), (x) != NULL);                \
-       (x) = (y))
-
-#endif  /* UV_TREE_H_ */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/tty_wrap.h
+++ /dev/null
@@ -1,41 +0,0 @@
-#ifndef SRC_TTY_WRAP_H_
-#define SRC_TTY_WRAP_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "env.h"
-#include "handle_wrap.h"
-#include "stream_wrap.h"
-
-namespace node {
-
-class TTYWrap : public StreamWrap {
- public:
-  static void Initialize(v8::Local<v8::Object> target,
-                         v8::Local<v8::Value> unused,
-                         v8::Local<v8::Context> context);
-
-  uv_tty_t* UVHandle();
-
-  size_t self_size() const override { return sizeof(*this); }
-
- private:
-  TTYWrap(Environment* env,
-          v8::Local<v8::Object> object,
-          int fd,
-          bool readable);
-
-  static void GuessHandleType(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void IsTTY(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void GetWindowSize(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void SetRawMode(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void New(const v8::FunctionCallbackInfo<v8::Value>& args);
-
-  uv_tty_t handle_;
-};
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_TTY_WRAP_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/udp_wrap.h
+++ /dev/null
@@ -1,76 +0,0 @@
-#ifndef SRC_UDP_WRAP_H_
-#define SRC_UDP_WRAP_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "async-wrap.h"
-#include "env.h"
-#include "handle_wrap.h"
-#include "req-wrap.h"
-#include "req-wrap-inl.h"
-#include "uv.h"
-#include "v8.h"
-
-namespace node {
-
-class UDPWrap: public HandleWrap {
- public:
-  static void Initialize(v8::Local<v8::Object> target,
-                         v8::Local<v8::Value> unused,
-                         v8::Local<v8::Context> context);
-  static void GetFD(v8::Local<v8::String>,
-                    const v8::PropertyCallbackInfo<v8::Value>&);
-  static void New(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void Bind(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void Send(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void Bind6(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void Send6(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void RecvStart(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void RecvStop(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void AddMembership(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void DropMembership(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void SetMulticastTTL(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void SetMulticastLoopback(
-      const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void SetBroadcast(const v8::FunctionCallbackInfo<v8::Value>& args);
-  static void SetTTL(const v8::FunctionCallbackInfo<v8::Value>& args);
-
-  static v8::Local<v8::Object> Instantiate(Environment* env, AsyncWrap* parent);
-  uv_udp_t* UVHandle();
-
-  size_t self_size() const override { return sizeof(*this); }
-
- private:
-  typedef uv_udp_t HandleType;
-
-  template <typename T,
-            int (*F)(const typename T::HandleType*, sockaddr*, int*)>
-  friend void GetSockOrPeerName(const v8::FunctionCallbackInfo<v8::Value>&);
-
-  UDPWrap(Environment* env, v8::Local<v8::Object> object, AsyncWrap* parent);
-
-  static void DoBind(const v8::FunctionCallbackInfo<v8::Value>& args,
-                     int family);
-  static void DoSend(const v8::FunctionCallbackInfo<v8::Value>& args,
-                     int family);
-  static void SetMembership(const v8::FunctionCallbackInfo<v8::Value>& args,
-                            uv_membership membership);
-
-  static void OnAlloc(uv_handle_t* handle,
-                      size_t suggested_size,
-                      uv_buf_t* buf);
-  static void OnSend(uv_udp_send_t* req, int status);
-  static void OnRecv(uv_udp_t* handle,
-                     ssize_t nread,
-                     const uv_buf_t* buf,
-                     const struct sockaddr* addr,
-                     unsigned int flags);
-
-  uv_udp_t handle_;
-};
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_UDP_WRAP_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/util-inl.h
+++ /dev/null
@@ -1,403 +0,0 @@
-#ifndef SRC_UTIL_INL_H_
-#define SRC_UTIL_INL_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "util.h"
-#include <cstring>
-
-#if defined(_MSC_VER)
-#include <intrin.h>
-#define BSWAP_2(x) _byteswap_ushort(x)
-#define BSWAP_4(x) _byteswap_ulong(x)
-#define BSWAP_8(x) _byteswap_uint64(x)
-#else
-#define BSWAP_2(x) ((x) << 8) | ((x) >> 8)
-#define BSWAP_4(x)                                                            \
-  (((x) & 0xFF) << 24) |                                                      \
-  (((x) & 0xFF00) << 8) |                                                     \
-  (((x) >> 8) & 0xFF00) |                                                     \
-  (((x) >> 24) & 0xFF)
-#define BSWAP_8(x)                                                            \
-  (((x) & 0xFF00000000000000ull) >> 56) |                                     \
-  (((x) & 0x00FF000000000000ull) >> 40) |                                     \
-  (((x) & 0x0000FF0000000000ull) >> 24) |                                     \
-  (((x) & 0x000000FF00000000ull) >> 8) |                                      \
-  (((x) & 0x00000000FF000000ull) << 8) |                                      \
-  (((x) & 0x0000000000FF0000ull) << 24) |                                     \
-  (((x) & 0x000000000000FF00ull) << 40) |                                     \
-  (((x) & 0x00000000000000FFull) << 56)
-#endif
-
-namespace node {
-
-template <typename T>
-ListNode<T>::ListNode() : prev_(this), next_(this) {}
-
-template <typename T>
-ListNode<T>::~ListNode() {
-  Remove();
-}
-
-template <typename T>
-void ListNode<T>::Remove() {
-  prev_->next_ = next_;
-  next_->prev_ = prev_;
-  prev_ = this;
-  next_ = this;
-}
-
-template <typename T>
-bool ListNode<T>::IsEmpty() const {
-  return prev_ == this;
-}
-
-template <typename T, ListNode<T> (T::*M)>
-ListHead<T, M>::Iterator::Iterator(ListNode<T>* node) : node_(node) {}
-
-template <typename T, ListNode<T> (T::*M)>
-T* ListHead<T, M>::Iterator::operator*() const {
-  return ContainerOf(M, node_);
-}
-
-template <typename T, ListNode<T> (T::*M)>
-const typename ListHead<T, M>::Iterator&
-ListHead<T, M>::Iterator::operator++() {
-  node_ = node_->next_;
-  return *this;
-}
-
-template <typename T, ListNode<T> (T::*M)>
-bool ListHead<T, M>::Iterator::operator!=(const Iterator& that) const {
-  return node_ != that.node_;
-}
-
-template <typename T, ListNode<T> (T::*M)>
-ListHead<T, M>::~ListHead() {
-  while (IsEmpty() == false)
-    head_.next_->Remove();
-}
-
-template <typename T, ListNode<T> (T::*M)>
-void ListHead<T, M>::MoveBack(ListHead* that) {
-  if (IsEmpty())
-    return;
-  ListNode<T>* to = &that->head_;
-  head_.next_->prev_ = to->prev_;
-  to->prev_->next_ = head_.next_;
-  head_.prev_->next_ = to;
-  to->prev_ = head_.prev_;
-  head_.prev_ = &head_;
-  head_.next_ = &head_;
-}
-
-template <typename T, ListNode<T> (T::*M)>
-void ListHead<T, M>::PushBack(T* element) {
-  ListNode<T>* that = &(element->*M);
-  head_.prev_->next_ = that;
-  that->prev_ = head_.prev_;
-  that->next_ = &head_;
-  head_.prev_ = that;
-}
-
-template <typename T, ListNode<T> (T::*M)>
-void ListHead<T, M>::PushFront(T* element) {
-  ListNode<T>* that = &(element->*M);
-  head_.next_->prev_ = that;
-  that->prev_ = &head_;
-  that->next_ = head_.next_;
-  head_.next_ = that;
-}
-
-template <typename T, ListNode<T> (T::*M)>
-bool ListHead<T, M>::IsEmpty() const {
-  return head_.IsEmpty();
-}
-
-template <typename T, ListNode<T> (T::*M)>
-T* ListHead<T, M>::PopFront() {
-  if (IsEmpty())
-    return nullptr;
-  ListNode<T>* node = head_.next_;
-  node->Remove();
-  return ContainerOf(M, node);
-}
-
-template <typename T, ListNode<T> (T::*M)>
-typename ListHead<T, M>::Iterator ListHead<T, M>::begin() const {
-  return Iterator(head_.next_);
-}
-
-template <typename T, ListNode<T> (T::*M)>
-typename ListHead<T, M>::Iterator ListHead<T, M>::end() const {
-  return Iterator(const_cast<ListNode<T>*>(&head_));
-}
-
-template <typename Inner, typename Outer>
-ContainerOfHelper<Inner, Outer>::ContainerOfHelper(Inner Outer::*field,
-                                                   Inner* pointer)
-    : pointer_(reinterpret_cast<Outer*>(
-          reinterpret_cast<uintptr_t>(pointer) -
-          reinterpret_cast<uintptr_t>(&(static_cast<Outer*>(0)->*field)))) {
-}
-
-template <typename Inner, typename Outer>
-template <typename TypeName>
-ContainerOfHelper<Inner, Outer>::operator TypeName*() const {
-  return static_cast<TypeName*>(pointer_);
-}
-
-template <typename Inner, typename Outer>
-inline ContainerOfHelper<Inner, Outer> ContainerOf(Inner Outer::*field,
-                                                   Inner* pointer) {
-  return ContainerOfHelper<Inner, Outer>(field, pointer);
-}
-
-template <class TypeName>
-inline v8::Local<TypeName> PersistentToLocal(
-    v8::Isolate* isolate,
-    const v8::Persistent<TypeName>& persistent) {
-  if (persistent.IsWeak()) {
-    return WeakPersistentToLocal(isolate, persistent);
-  } else {
-    return StrongPersistentToLocal(persistent);
-  }
-}
-
-template <class TypeName>
-inline v8::Local<TypeName> StrongPersistentToLocal(
-    const v8::Persistent<TypeName>& persistent) {
-  return *reinterpret_cast<v8::Local<TypeName>*>(
-      const_cast<v8::Persistent<TypeName>*>(&persistent));
-}
-
-template <class TypeName>
-inline v8::Local<TypeName> WeakPersistentToLocal(
-    v8::Isolate* isolate,
-    const v8::Persistent<TypeName>& persistent) {
-  return v8::Local<TypeName>::New(isolate, persistent);
-}
-
-inline v8::Local<v8::String> OneByteString(v8::Isolate* isolate,
-                                           const char* data,
-                                           int length) {
-  return v8::String::NewFromOneByte(isolate,
-                                    reinterpret_cast<const uint8_t*>(data),
-                                    v8::NewStringType::kNormal,
-                                    length).ToLocalChecked();
-}
-
-inline v8::Local<v8::String> OneByteString(v8::Isolate* isolate,
-                                           const signed char* data,
-                                           int length) {
-  return v8::String::NewFromOneByte(isolate,
-                                    reinterpret_cast<const uint8_t*>(data),
-                                    v8::NewStringType::kNormal,
-                                    length).ToLocalChecked();
-}
-
-inline v8::Local<v8::String> OneByteString(v8::Isolate* isolate,
-                                           const unsigned char* data,
-                                           int length) {
-  return v8::String::NewFromOneByte(isolate,
-                                    reinterpret_cast<const uint8_t*>(data),
-                                    v8::NewStringType::kNormal,
-                                    length).ToLocalChecked();
-}
-
-template <typename TypeName>
-void Wrap(v8::Local<v8::Object> object, TypeName* pointer) {
-  CHECK_EQ(false, object.IsEmpty());
-  CHECK_GT(object->InternalFieldCount(), 0);
-  object->SetAlignedPointerInInternalField(0, pointer);
-}
-
-void ClearWrap(v8::Local<v8::Object> object) {
-  Wrap<void>(object, nullptr);
-}
-
-template <typename TypeName>
-TypeName* Unwrap(v8::Local<v8::Object> object) {
-  CHECK_EQ(false, object.IsEmpty());
-  CHECK_GT(object->InternalFieldCount(), 0);
-  void* pointer = object->GetAlignedPointerFromInternalField(0);
-  return static_cast<TypeName*>(pointer);
-}
-
-void SwapBytes16(char* data, size_t nbytes) {
-  CHECK_EQ(nbytes % 2, 0);
-
-#if defined(_MSC_VER)
-  int align = reinterpret_cast<uintptr_t>(data) % sizeof(uint16_t);
-  if (align == 0) {
-    // MSVC has no strict aliasing, and is able to highly optimize this case.
-    uint16_t* data16 = reinterpret_cast<uint16_t*>(data);
-    size_t len16 = nbytes / sizeof(*data16);
-    for (size_t i = 0; i < len16; i++) {
-      data16[i] = BSWAP_2(data16[i]);
-    }
-    return;
-  }
-#endif
-
-  uint16_t temp;
-  for (size_t i = 0; i < nbytes; i += sizeof(temp)) {
-    memcpy(&temp, &data[i], sizeof(temp));
-    temp = BSWAP_2(temp);
-    memcpy(&data[i], &temp, sizeof(temp));
-  }
-}
-
-void SwapBytes32(char* data, size_t nbytes) {
-  CHECK_EQ(nbytes % 4, 0);
-
-#if defined(_MSC_VER)
-  int align = reinterpret_cast<uintptr_t>(data) % sizeof(uint32_t);
-  // MSVC has no strict aliasing, and is able to highly optimize this case.
-  if (align == 0) {
-    uint32_t* data32 = reinterpret_cast<uint32_t*>(data);
-    size_t len32 = nbytes / sizeof(*data32);
-    for (size_t i = 0; i < len32; i++) {
-      data32[i] = BSWAP_4(data32[i]);
-    }
-    return;
-  }
-#endif
-
-  uint32_t temp;
-  for (size_t i = 0; i < nbytes; i += sizeof(temp)) {
-    memcpy(&temp, &data[i], sizeof(temp));
-    temp = BSWAP_4(temp);
-    memcpy(&data[i], &temp, sizeof(temp));
-  }
-}
-
-void SwapBytes64(char* data, size_t nbytes) {
-  CHECK_EQ(nbytes % 8, 0);
-
-#if defined(_MSC_VER)
-  int align = reinterpret_cast<uintptr_t>(data) % sizeof(uint64_t);
-  if (align == 0) {
-    // MSVC has no strict aliasing, and is able to highly optimize this case.
-    uint64_t* data64 = reinterpret_cast<uint64_t*>(data);
-    size_t len64 = nbytes / sizeof(*data64);
-    for (size_t i = 0; i < len64; i++) {
-      data64[i] = BSWAP_8(data64[i]);
-    }
-    return;
-  }
-#endif
-
-  uint64_t temp;
-  for (size_t i = 0; i < nbytes; i += sizeof(temp)) {
-    memcpy(&temp, &data[i], sizeof(temp));
-    temp = BSWAP_8(temp);
-    memcpy(&data[i], &temp, sizeof(temp));
-  }
-}
-
-char ToLower(char c) {
-  return c >= 'A' && c <= 'Z' ? c + ('a' - 'A') : c;
-}
-
-bool StringEqualNoCase(const char* a, const char* b) {
-  do {
-    if (*a == '\0')
-      return *b == '\0';
-    if (*b == '\0')
-      return *a == '\0';
-  } while (ToLower(*a++) == ToLower(*b++));
-  return false;
-}
-
-bool StringEqualNoCaseN(const char* a, const char* b, size_t length) {
-  for (size_t i = 0; i < length; i++) {
-    if (ToLower(a[i]) != ToLower(b[i]))
-      return false;
-    if (a[i] == '\0')
-      return true;
-  }
-  return true;
-}
-
-inline size_t MultiplyWithOverflowCheck(size_t a, size_t b) {
-  size_t ret = a * b;
-  if (a != 0)
-    CHECK_EQ(b, ret / a);
-
-  return ret;
-}
-
-// These should be used in our code as opposed to the native
-// versions as they abstract out some platform and or
-// compiler version specific functionality.
-// malloc(0) and realloc(ptr, 0) have implementation-defined behavior in
-// that the standard allows them to either return a unique pointer or a
-// nullptr for zero-sized allocation requests.  Normalize by always using
-// a nullptr.
-template <typename T>
-T* UncheckedRealloc(T* pointer, size_t n) {
-  size_t full_size = MultiplyWithOverflowCheck(sizeof(T), n);
-
-  if (full_size == 0) {
-    free(pointer);
-    return nullptr;
-  }
-
-  void* allocated = realloc(pointer, full_size);
-
-  if (UNLIKELY(allocated == nullptr)) {
-    // Tell V8 that memory is low and retry.
-    LowMemoryNotification();
-    allocated = realloc(pointer, full_size);
-  }
-
-  return static_cast<T*>(allocated);
-}
-
-// As per spec realloc behaves like malloc if passed nullptr.
-template <typename T>
-inline T* UncheckedMalloc(size_t n) {
-  if (n == 0) n = 1;
-  return UncheckedRealloc<T>(nullptr, n);
-}
-
-template <typename T>
-inline T* UncheckedCalloc(size_t n) {
-  if (n == 0) n = 1;
-  MultiplyWithOverflowCheck(sizeof(T), n);
-  return static_cast<T*>(calloc(n, sizeof(T)));
-}
-
-template <typename T>
-inline T* Realloc(T* pointer, size_t n) {
-  T* ret = UncheckedRealloc(pointer, n);
-  if (n > 0) CHECK_NE(ret, nullptr);
-  return ret;
-}
-
-template <typename T>
-inline T* Malloc(size_t n) {
-  T* ret = UncheckedMalloc<T>(n);
-  if (n > 0) CHECK_NE(ret, nullptr);
-  return ret;
-}
-
-template <typename T>
-inline T* Calloc(size_t n) {
-  T* ret = UncheckedCalloc<T>(n);
-  if (n > 0) CHECK_NE(ret, nullptr);
-  return ret;
-}
-
-// Shortcuts for char*.
-inline char* Malloc(size_t n) { return Malloc<char>(n); }
-inline char* Calloc(size_t n) { return Calloc<char>(n); }
-inline char* UncheckedMalloc(size_t n) { return UncheckedMalloc<char>(n); }
-inline char* UncheckedCalloc(size_t n) { return UncheckedCalloc<char>(n); }
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_UTIL_INL_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/util.h
+++ /dev/null
@@ -1,436 +0,0 @@
-#ifndef SRC_UTIL_H_
-#define SRC_UTIL_H_
-
-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#include "v8.h"
-
-#include <assert.h>
-#include <signal.h>
-#include <stddef.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include <type_traits>  // std::remove_reference
-
-namespace node {
-
-// These should be used in our code as opposed to the native
-// versions as they abstract out some platform and or
-// compiler version specific functionality
-// malloc(0) and realloc(ptr, 0) have implementation-defined behavior in
-// that the standard allows them to either return a unique pointer or a
-// nullptr for zero-sized allocation requests.  Normalize by always using
-// a nullptr.
-template <typename T>
-inline T* UncheckedRealloc(T* pointer, size_t n);
-template <typename T>
-inline T* UncheckedMalloc(size_t n);
-template <typename T>
-inline T* UncheckedCalloc(size_t n);
-
-// Same things, but aborts immediately instead of returning nullptr when
-// no memory is available.
-template <typename T>
-inline T* Realloc(T* pointer, size_t n);
-template <typename T>
-inline T* Malloc(size_t n);
-template <typename T>
-inline T* Calloc(size_t n);
-
-inline char* Malloc(size_t n);
-inline char* Calloc(size_t n);
-inline char* UncheckedMalloc(size_t n);
-inline char* UncheckedCalloc(size_t n);
-
-// Used by the allocation functions when allocation fails.
-// Thin wrapper around v8::Isolate::LowMemoryNotification() that checks
-// whether V8 is initialized.
-void LowMemoryNotification();
-
-#ifdef __GNUC__
-#define NO_RETURN __attribute__((noreturn))
-#else
-#define NO_RETURN
-#endif
-
-// The slightly odd function signature for Assert() is to ease
-// instruction cache pressure in calls from ASSERT and CHECK.
-NO_RETURN void Abort();
-NO_RETURN void Assert(const char* const (*args)[4]);
-void DumpBacktrace(FILE* fp);
-
-template <typename T> using remove_reference = std::remove_reference<T>;
-
-#define FIXED_ONE_BYTE_STRING(isolate, string)                                \
-  (node::OneByteString((isolate), (string), sizeof(string) - 1))
-
-#define DISALLOW_COPY_AND_ASSIGN(TypeName)                                    \
-  void operator=(const TypeName&) = delete;                                   \
-  void operator=(TypeName&&) = delete;                                        \
-  TypeName(const TypeName&) = delete;                                         \
-  TypeName(TypeName&&) = delete
-
-// Windows 8+ does not like abort() in Release mode
-#ifdef _WIN32
-#define ABORT_NO_BACKTRACE() raise(SIGABRT)
-#else
-#define ABORT_NO_BACKTRACE() abort()
-#endif
-
-#define ABORT() node::Abort()
-
-#ifdef __GNUC__
-#define LIKELY(expr) __builtin_expect(!!(expr), 1)
-#define UNLIKELY(expr) __builtin_expect(!!(expr), 0)
-#define PRETTY_FUNCTION_NAME __PRETTY_FUNCTION__
-#else
-#define LIKELY(expr) expr
-#define UNLIKELY(expr) expr
-#define PRETTY_FUNCTION_NAME ""
-#endif
-
-#define STRINGIFY_(x) #x
-#define STRINGIFY(x) STRINGIFY_(x)
-
-#define CHECK(expr)                                                           \
-  do {                                                                        \
-    if (UNLIKELY(!(expr))) {                                                  \
-      static const char* const args[] = { __FILE__, STRINGIFY(__LINE__),      \
-                                          #expr, PRETTY_FUNCTION_NAME };      \
-      node::Assert(&args);                                                    \
-    }                                                                         \
-  } while (0)
-
-// FIXME(bnoordhuis) cctests don't link in node::Abort() and node::Assert().
-#ifdef GTEST_DONT_DEFINE_ASSERT_EQ
-#undef ABORT
-#undef CHECK
-#define ABORT ABORT_NO_BACKTRACE
-#define CHECK assert
-#endif
-
-#ifdef NDEBUG
-#define ASSERT(expr)
-#else
-#define ASSERT(expr) CHECK(expr)
-#endif
-
-#define ASSERT_EQ(a, b) ASSERT((a) == (b))
-#define ASSERT_GE(a, b) ASSERT((a) >= (b))
-#define ASSERT_GT(a, b) ASSERT((a) > (b))
-#define ASSERT_LE(a, b) ASSERT((a) <= (b))
-#define ASSERT_LT(a, b) ASSERT((a) < (b))
-#define ASSERT_NE(a, b) ASSERT((a) != (b))
-
-#define CHECK_EQ(a, b) CHECK((a) == (b))
-#define CHECK_GE(a, b) CHECK((a) >= (b))
-#define CHECK_GT(a, b) CHECK((a) > (b))
-#define CHECK_LE(a, b) CHECK((a) <= (b))
-#define CHECK_LT(a, b) CHECK((a) < (b))
-#define CHECK_NE(a, b) CHECK((a) != (b))
-
-#define UNREACHABLE() ABORT()
-
-#define ASSIGN_OR_RETURN_UNWRAP(ptr, obj, ...)                                \
-  do {                                                                        \
-    *ptr =                                                                    \
-        Unwrap<typename node::remove_reference<decltype(**ptr)>::type>(obj);  \
-    if (*ptr == nullptr)                                                      \
-      return __VA_ARGS__;                                                     \
-  } while (0)
-
-// TAILQ-style intrusive list node.
-template <typename T>
-class ListNode;
-
-// TAILQ-style intrusive list head.
-template <typename T, ListNode<T> (T::*M)>
-class ListHead;
-
-template <typename T>
-class ListNode {
- public:
-  inline ListNode();
-  inline ~ListNode();
-  inline void Remove();
-  inline bool IsEmpty() const;
-
- private:
-  template <typename U, ListNode<U> (U::*M)> friend class ListHead;
-  ListNode* prev_;
-  ListNode* next_;
-  DISALLOW_COPY_AND_ASSIGN(ListNode);
-};
-
-template <typename T, ListNode<T> (T::*M)>
-class ListHead {
- public:
-  class Iterator {
-   public:
-    inline T* operator*() const;
-    inline const Iterator& operator++();
-    inline bool operator!=(const Iterator& that) const;
-
-   private:
-    friend class ListHead;
-    inline explicit Iterator(ListNode<T>* node);
-    ListNode<T>* node_;
-  };
-
-  inline ListHead() = default;
-  inline ~ListHead();
-  inline void MoveBack(ListHead* that);
-  inline void PushBack(T* element);
-  inline void PushFront(T* element);
-  inline bool IsEmpty() const;
-  inline T* PopFront();
-  inline Iterator begin() const;
-  inline Iterator end() const;
-
- private:
-  ListNode<T> head_;
-  DISALLOW_COPY_AND_ASSIGN(ListHead);
-};
-
-// The helper is for doing safe downcasts from base types to derived types.
-template <typename Inner, typename Outer>
-class ContainerOfHelper {
- public:
-  inline ContainerOfHelper(Inner Outer::*field, Inner* pointer);
-  template <typename TypeName>
-  inline operator TypeName*() const;
- private:
-  Outer* const pointer_;
-};
-
-// Calculate the address of the outer (i.e. embedding) struct from
-// the interior pointer to a data member.
-template <typename Inner, typename Outer>
-inline ContainerOfHelper<Inner, Outer> ContainerOf(Inner Outer::*field,
-                                                   Inner* pointer);
-
-// If persistent.IsWeak() == false, then do not call persistent.Reset()
-// while the returned Local<T> is still in scope, it will destroy the
-// reference to the object.
-template <class TypeName>
-inline v8::Local<TypeName> PersistentToLocal(
-    v8::Isolate* isolate,
-    const v8::Persistent<TypeName>& persistent);
-
-// Unchecked conversion from a non-weak Persistent<T> to Local<TLocal<T>,
-// use with care!
-//
-// Do not call persistent.Reset() while the returned Local<T> is still in
-// scope, it will destroy the reference to the object.
-template <class TypeName>
-inline v8::Local<TypeName> StrongPersistentToLocal(
-    const v8::Persistent<TypeName>& persistent);
-
-template <class TypeName>
-inline v8::Local<TypeName> WeakPersistentToLocal(
-    v8::Isolate* isolate,
-    const v8::Persistent<TypeName>& persistent);
-
-// Convenience wrapper around v8::String::NewFromOneByte().
-inline v8::Local<v8::String> OneByteString(v8::Isolate* isolate,
-                                           const char* data,
-                                           int length = -1);
-
-// For the people that compile with -funsigned-char.
-inline v8::Local<v8::String> OneByteString(v8::Isolate* isolate,
-                                           const signed char* data,
-                                           int length = -1);
-
-inline v8::Local<v8::String> OneByteString(v8::Isolate* isolate,
-                                           const unsigned char* data,
-                                           int length = -1);
-
-inline void Wrap(v8::Local<v8::Object> object, void* pointer);
-
-inline void ClearWrap(v8::Local<v8::Object> object);
-
-template <typename TypeName>
-inline TypeName* Unwrap(v8::Local<v8::Object> object);
-
-// Swaps bytes in place. nbytes is the number of bytes to swap and must be a
-// multiple of the word size (checked by function).
-inline void SwapBytes16(char* data, size_t nbytes);
-inline void SwapBytes32(char* data, size_t nbytes);
-inline void SwapBytes64(char* data, size_t nbytes);
-
-// tolower() is locale-sensitive.  Use ToLower() instead.
-inline char ToLower(char c);
-
-// strcasecmp() is locale-sensitive.  Use StringEqualNoCase() instead.
-inline bool StringEqualNoCase(const char* a, const char* b);
-
-// strncasecmp() is locale-sensitive.  Use StringEqualNoCaseN() instead.
-inline bool StringEqualNoCaseN(const char* a, const char* b, size_t length);
-
-// Allocates an array of member type T. For up to kStackStorageSize items,
-// the stack is used, otherwise malloc().
-template <typename T, size_t kStackStorageSize = 1024>
-class MaybeStackBuffer {
- public:
-  const T* out() const {
-    return buf_;
-  }
-
-  T* out() {
-    return buf_;
-  }
-
-  // operator* for compatibility with `v8::String::(Utf8)Value`
-  T* operator*() {
-    return buf_;
-  }
-
-  const T* operator*() const {
-    return buf_;
-  }
-
-  T& operator[](size_t index) {
-    CHECK_LT(index, length());
-    return buf_[index];
-  }
-
-  const T& operator[](size_t index) const {
-    CHECK_LT(index, length());
-    return buf_[index];
-  }
-
-  size_t length() const {
-    return length_;
-  }
-
-  // Current maximum capacity of the buffer with which SetLength() can be used
-  // without first calling AllocateSufficientStorage().
-  size_t capacity() const {
-    return IsAllocated() ? capacity_ :
-                           IsInvalidated() ? 0 : kStackStorageSize;
-  }
-
-  // Make sure enough space for `storage` entries is available.
-  // This method can be called multiple times throughout the lifetime of the
-  // buffer, but once this has been called Invalidate() cannot be used.
-  // Content of the buffer in the range [0, length()) is preserved.
-  void AllocateSufficientStorage(size_t storage) {
-    CHECK(!IsInvalidated());
-    if (storage > capacity()) {
-      bool was_allocated = IsAllocated();
-      T* allocated_ptr = was_allocated ? buf_ : nullptr;
-      buf_ = Realloc(allocated_ptr, storage);
-      capacity_ = storage;
-      if (!was_allocated && length_ > 0)
-        memcpy(buf_, buf_st_, length_ * sizeof(buf_[0]));
-    }
-
-    length_ = storage;
-  }
-
-  void SetLength(size_t length) {
-    // capacity() returns how much memory is actually available.
-    CHECK_LE(length, capacity());
-    length_ = length;
-  }
-
-  void SetLengthAndZeroTerminate(size_t length) {
-    // capacity() returns how much memory is actually available.
-    CHECK_LE(length + 1, capacity());
-    SetLength(length);
-
-    // T() is 0 for integer types, nullptr for pointers, etc.
-    buf_[length] = T();
-  }
-
-  // Make derefencing this object return nullptr.
-  // This method can be called multiple times throughout the lifetime of the
-  // buffer, but once this has been called AllocateSufficientStorage() cannot
-  // be used.
-  void Invalidate() {
-    CHECK(!IsAllocated());
-    length_ = 0;
-    buf_ = nullptr;
-  }
-
-  // If the buffer is stored in the heap rather than on the stack.
-  bool IsAllocated() const {
-    return !IsInvalidated() && buf_ != buf_st_;
-  }
-
-  // If Invalidate() has been called.
-  bool IsInvalidated() const {
-    return buf_ == nullptr;
-  }
-
-  // Release ownership of the malloc'd buffer.
-  // Note: This does not free the buffer.
-  void Release() {
-    CHECK(IsAllocated());
-    buf_ = buf_st_;
-    length_ = 0;
-    capacity_ = 0;
-  }
-
-  MaybeStackBuffer() : length_(0), capacity_(0), buf_(buf_st_) {
-    // Default to a zero-length, null-terminated buffer.
-    buf_[0] = T();
-  }
-
-  explicit MaybeStackBuffer(size_t storage) : MaybeStackBuffer() {
-    AllocateSufficientStorage(storage);
-  }
-
-  ~MaybeStackBuffer() {
-    if (IsAllocated())
-      free(buf_);
-  }
-
- private:
-  size_t length_;
-  // capacity of the malloc'ed buf_
-  size_t capacity_;
-  T* buf_;
-  T buf_st_[kStackStorageSize];
-};
-
-class Utf8Value : public MaybeStackBuffer<char> {
- public:
-  explicit Utf8Value(v8::Isolate* isolate, v8::Local<v8::Value> value);
-};
-
-class TwoByteValue : public MaybeStackBuffer<uint16_t> {
- public:
-  explicit TwoByteValue(v8::Isolate* isolate, v8::Local<v8::Value> value);
-};
-
-class BufferValue : public MaybeStackBuffer<char> {
- public:
-  explicit BufferValue(v8::Isolate* isolate, v8::Local<v8::Value> value);
-};
-
-#define THROW_AND_RETURN_UNLESS_BUFFER(env, obj)                            \
-  do {                                                                      \
-    if (!Buffer::HasInstance(obj))                                          \
-      return env->ThrowTypeError("argument should be a Buffer");            \
-  } while (0)
-
-#define SPREAD_BUFFER_ARG(val, name)                                          \
-  CHECK((val)->IsUint8Array());                                               \
-  v8::Local<v8::Uint8Array> name = (val).As<v8::Uint8Array>();                \
-  v8::ArrayBuffer::Contents name##_c = name->Buffer()->GetContents();         \
-  const size_t name##_offset = name->ByteOffset();                            \
-  const size_t name##_length = name->ByteLength();                            \
-  char* const name##_data =                                                   \
-      static_cast<char*>(name##_c.Data()) + name##_offset;                    \
-  if (name##_length > 0)                                                      \
-    CHECK_NE(name##_data, nullptr);
-
-
-}  // namespace node
-
-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
-
-#endif  // SRC_UTIL_H_
--- gbglehrerclient-0.1.orig/etc/skel/.atom/.node-gyp/.node-gyp/iojs-1.7.11/src/v8abbr.h
+++ /dev/null
@@ -1,121 +0,0 @@
-/** Copyright Joyent, Inc. and other Node contributors.
-*
-* Permission is hereby granted, free of charge, to any person obtaining a
-* copy of this software and associated documentation files (the
-* "Software"), to deal in the Software without restriction, including
-* without limitation the rights to use, copy, modify, merge, publish,
-* distribute, sublicense, and/or sell copies of the Software, and to permit
-* persons to whom the Software is furnished to do so, subject to the
-* following conditions:
-*
-* The above copyright notice and this permission notice shall be included
-* in all copies or substantial portions of the Software.
-*
-* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-* OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
-* NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
-* DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
-* OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
-* USE OR OTHER DEALINGS IN THE SOFTWARE.
-*/
-
-/*
- * This header defines short names for V8 constants for use by the ustack
- * helper.
- */
-
-#ifndef SRC_V8ABBR_H_
-#define SRC_V8ABBR_H_
-
-/* Frame pointer offsets */
-#define V8_OFF_FP_FUNC              V8DBG_OFF_FP_FUNCTION
-#define V8_OFF_FP_CONTEXT           V8DBG_OFF_FP_CONTEXT
-#define V8_OFF_FP_MARKER            V8DBG_OFF_FP_MARKER
-
-/* Stack frame types */
-#define V8_FT_ENTRY                 V8DBG_FRAMETYPE_ENTRYFRAME
-#define V8_FT_ENTRYCONSTRUCT        V8DBG_FRAMETYPE_ENTRYCONSTRUCTFRAME
-#define V8_FT_EXIT                  V8DBG_FRAMETYPE_EXITFRAME
-#define V8_FT_JAVASCRIPT            V8DBG_FRAMETYPE_JAVASCRIPTFRAME
-#define V8_FT_OPTIMIZED             V8DBG_FRAMETYPE_OPTIMIZEDFRAME
-#define V8_FT_INTERNAL              V8DBG_FRAMETYPE_INTERNALFRAME
-#define V8_FT_CONSTRUCT             V8DBG_FRAMETYPE_CONSTRUCTFRAME
-#define V8_FT_ADAPTOR               V8DBG_FRAMETYPE_ARGUMENTSADAPTORFRAME
-#define V8_FT_STUB                  V8DBG_FRAMETYPE_STUBFRAME
-
-/* Identification masks and tags */
-#define V8_SmiTagMask               (V8DBG_SMITAGMASK)
-#define V8_SmiTag                   (V8DBG_SMITAG)
-#define V8_SmiValueShift            (V8DBG_SMISHIFTSIZE + V8DBG_SMITAGMASK)
-
-#define V8_HeapObjectTagMask        V8DBG_HEAPOBJECTTAGMASK
-#define V8_HeapObjectTag            V8DBG_HEAPOBJECTTAG
-
-#define V8_IsNotStringMask          V8DBG_ISNOTSTRINGMASK
-#define V8_StringTag                V8DBG_STRINGTAG
-
-#define V8_StringEncodingMask       V8DBG_STRINGENCODINGMASK
-#define V8_AsciiStringTag           V8DBG_ONEBYTESTRINGTAG
-
-#define V8_StringRepresentationMask V8DBG_STRINGREPRESENTATIONMASK
-#define V8_SeqStringTag             V8DBG_SEQSTRINGTAG
-#define V8_ConsStringTag            V8DBG_CONSSTRINGTAG
-#define V8_ExternalStringTag        V8DBG_EXTERNALSTRINGTAG
-
-/* Instance types */
-#define V8_IT_FIXEDARRAY            V8DBG_TYPE_FIXEDARRAY__FIXED_ARRAY_TYPE
-#define V8_IT_CODE                  V8DBG_TYPE_CODE__CODE_TYPE
-#define V8_IT_SCRIPT                V8DBG_TYPE_SCRIPT__SCRIPT_TYPE
-
-/* Node-specific offsets */
-#define NODE_OFF_EXTSTR_DATA        sizeof(void*)
-
-/*
- * Not all versions of V8 have the offset for the "chars" array in the
- * SeqTwoByteString class, but it's the same as the one for SeqOneByteString.
- */
-#ifndef V8DBG_CLASS_SEQTWOBYTESTRING__CHARS__CHAR
-#define V8DBG_CLASS_SEQTWOBYTESTRING__CHARS__CHAR \
-  V8DBG_CLASS_SEQONEBYTESTRING__CHARS__CHAR
-#endif
-
-/* Heap class->field offsets */
-#define V8_OFF_HEAP(off)            ((off) - 1)
-
-#define V8_OFF_FUNC_SHARED  \
-    V8_OFF_HEAP(V8DBG_CLASS_JSFUNCTION__SHARED__SHAREDFUNCTIONINFO)
-#define V8_OFF_SHARED_NAME  \
-    V8_OFF_HEAP(V8DBG_CLASS_SHAREDFUNCTIONINFO__NAME__OBJECT)
-#define V8_OFF_SHARED_IDENT  \
-    V8_OFF_HEAP(V8DBG_CLASS_SHAREDFUNCTIONINFO__FUNCTION_IDENTIFIER__OBJECT)
-#define V8_OFF_SHARED_SCRIPT  \
-    V8_OFF_HEAP(V8DBG_CLASS_SHAREDFUNCTIONINFO__SCRIPT__OBJECT)
-#define V8_OFF_SHARED_FUNTOK  \
-    V8_OFF_HEAP(V8DBG_CLASS_SHAREDFUNCTIONINFO__FUNCTION_TOKEN_POSITION__SMI)
-#define V8_OFF_SCRIPT_NAME  \
-    V8_OFF_HEAP(V8DBG_CLASS_SCRIPT__NAME__OBJECT)
-#define V8_OFF_SCRIPT_LENDS \
-    V8_OFF_HEAP(V8DBG_CLASS_SCRIPT__LINE_ENDS__OBJECT)
-#define V8_OFF_STR_LENGTH \
-    V8_OFF_HEAP(V8DBG_CLASS_STRING__LENGTH__SMI)
-#define V8_OFF_STR_CHARS  \
-    V8_OFF_HEAP(V8DBG_CLASS_SEQONEBYTESTRING__CHARS__CHAR)
-#define V8_OFF_CONSSTR_CAR  \
-    V8_OFF_HEAP(V8DBG_CLASS_CONSSTRING__FIRST__STRING)
-#define V8_OFF_CONSSTR_CDR  \
-    V8_OFF_HEAP(V8DBG_CLASS_CONSSTRING__SECOND__STRING)
-#define V8_OFF_EXTSTR_RSRC  \
-    V8_OFF_HEAP(V8DBG_CLASS_EXTERNALSTRING__RESOURCE__OBJECT)
-#define V8_OFF_FA_SIZE    \
-    V8_OFF_HEAP(V8DBG_CLASS_FIXEDARRAYBASE__LENGTH__SMI)
-#define V8_OFF_FA_DATA    \
-    V8_OFF_HEAP(V8DBG_CLASS_FIXEDARRAY__DATA__UINTPTR_T)
-#define V8_OFF_HEAPOBJ_MAP  \
-    V8_OFF_HEAP(V8DBG_CLASS_HEAPOBJECT__MAP__MAP)
-#define V8_OFF_MAP_ATTRS  \
-    V8_OFF_HEAP(V8DBG_CLASS_MAP__INSTANCE_ATTRIBUTES__INT)
-#define V8_OFF_TWOBYTESTR_CHARS  \
-    V8_OFF_HEAP(V8DBG_CLASS_SEQTWOBYTESTRING__CHARS__CHAR)
-
-#endif  /* SRC_V8ABBR_H_ */
--- gbglehrerclient-0.1.orig/etc/skel/.atom/packages/language-nxc/.npmignore
+++ /dev/null
@@ -1 +0,0 @@
-node_modules
--- gbglehrerclient-0.1.orig/etc/skel/.atom/packages/language-nxc/.travis.yml
+++ /dev/null
@@ -1,31 +0,0 @@
-notifications:
-  email:
-    on_success: never
-    on_failure: change
-
-script: 'curl -s https://raw.githubusercontent.com/atom/ci/master/build-package.sh | sh'
-
-git:
-  depth: 10
-
-sudo: false
-
-os:
-  - linux
-  - osx
-
-env:
-  global:
-    - APM_TEST_PACKAGES=""
-
-  matrix:
-    - ATOM_CHANNEL=stable
-    - ATOM_CHANNEL=beta
-
-addons:
-  apt:
-    packages:
-    - build-essential
-    - git
-    - libgnome-keyring-dev
-    - fakeroot
--- gbglehrerclient-0.1.orig/etc/skel/.atom/packages/language-nxc/CONTRIBUTING.md
+++ /dev/null
@@ -1 +0,0 @@
-See the [Atom contributing guide](https://github.com/atom/atom/blob/master/CONTRIBUTING.md)
--- gbglehrerclient-0.1.orig/etc/skel/.atom/packages/language-nxc/LICENSE.md
+++ /dev/null
@@ -1,21 +0,0 @@
-The MIT License (MIT)
-
-Copyright (c) 2016 Noah Loomans
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
--- gbglehrerclient-0.1.orig/etc/skel/.atom/packages/language-nxc/README.md
+++ /dev/null
@@ -1,21 +0,0 @@
-# NXC language support in Atom
-
-language-nxc makes it easier to develop in NXC, which requires little to no setup (depending on your OS / distribution). Its goal is to make developing for NXC easier for everyone.
-
-## Features
-### Comping and uploading
-built-in (cross-platform) compiling and uploading, try `nxc:upload`. **This works on Linux as well!**
-
-![menu](http://i.imgur.com/92Gd8cA.png)
-![bug](http://i.imgur.com/6yuUSmT.png)
-
-### Auto completion
-auto completion for ~~built in~~ **all** functions
-- description
-- link to docs
-
-![Example Usage](http://i.imgur.com/I1v9dMs.gif)
-
-### Syntax highlighting
-
-![syntax highlighting](http://i.imgur.com/SrMTC46.png)
--- gbglehrerclient-0.1.orig/etc/skel/.atom/packages/language-nxc/docs.json
+++ /dev/null
@@ -1 +0,0 @@
-[{"leftLabel":"void","displayText":"SetSensorType","type":"function","descriptionMoreURL":"group___input_module_functions_ga1abf8d2a5ee147b22dbdd05d7cc06e3c.html#ga1abf8d2a5ee147b22dbdd05d7cc06e3c","snippet":"SetSensorType(${1:const byte &port}, ${2:byte type})","description":"Set sensor type."},{"leftLabel":"void","displayText":"SetSensorMode","type":"function","descriptionMoreURL":"group___input_module_functions_gac486b741423af7b30cf281beed74a12a.html#gac486b741423af7b30cf281beed74a12a","snippet":"SetSensorMode(${1:const byte &port}, ${2:byte mode})","description":"Set sensor mode."},{"leftLabel":"void","displayText":"ClearSensor","type":"function","descriptionMoreURL":"group___input_module_functions_gaea9f1917b39e27a9c07a8d9dd6434954.html#gaea9f1917b39e27a9c07a8d9dd6434954","snippet":"ClearSensor(${1:const byte &port})","description":"Clear a sensor value."},{"leftLabel":"void","displayText":"ResetSensor","type":"function","descriptionMoreURL":"group___input_module_functions_ga918c371b1f43e4ac11fe2696cad8fe35.html#ga918c371b1f43e4ac11fe2696cad8fe35","snippet":"ResetSensor(${1:const byte &port})","description":"Reset the sensor port."},{"leftLabel":"void","displayText":"SetSensor","type":"function","descriptionMoreURL":"group___input_module_functions_gac8a51a5406ec412735c132f4efbc028b.html#gac8a51a5406ec412735c132f4efbc028b","snippet":"SetSensor(${1:const byte &port}, ${2:const unsigned int config})","description":"Set sensor configuration."},{"leftLabel":"void","displayText":"SetSensorTouch","type":"function","descriptionMoreURL":"group___input_module_functions_ga725438cfe21ad4eb9e8e81bb3616bc03.html#ga725438cfe21ad4eb9e8e81bb3616bc03","snippet":"SetSensorTouch(${1:const byte &port})","description":"Configure a touch sensor."},{"leftLabel":"void","displayText":"SetSensorLight","type":"function","descriptionMoreURL":"group___input_module_functions_gade667ac6b2ecd679eb548f7b82d560a6.html#gade667ac6b2ecd679eb548f7b82d560a6","snippet":"SetSensorLight(${1:const byte &port}, ${2:bool bActive=true})","description":"Configure a light sensor."},{"leftLabel":"void","displayText":"SetSensorSound","type":"function","descriptionMoreURL":"group___input_module_functions_gaf55e8206edaeb0392f268787a0f06f55.html#gaf55e8206edaeb0392f268787a0f06f55","snippet":"SetSensorSound(${1:const byte &port}, ${2:bool bdBScaling=true})","description":"Configure a sound sensor."},{"leftLabel":"void","displayText":"SetSensorLowspeed","type":"function","descriptionMoreURL":"group___input_module_functions_ga218d00df36cc25f385be5eaf4972defc.html#ga218d00df36cc25f385be5eaf4972defc","snippet":"SetSensorLowspeed(${1:const byte &port}, ${2:bool bIsPowered=true})","description":"Configure an I2C sensor."},{"leftLabel":"void","displayText":"SetSensorUltrasonic","type":"function","descriptionMoreURL":"group___input_module_functions_ga3a9558c29a009be254a0f0a24d85d05f.html#ga3a9558c29a009be254a0f0a24d85d05f","snippet":"SetSensorUltrasonic(${1:const byte &port})","description":"Configure an ultrasonic sensor."},{"leftLabel":"void","displayText":"SetSensorEMeter","type":"function","descriptionMoreURL":"group___input_module_functions_gae14dba7310766017ce21ebe89ce67c97.html#gae14dba7310766017ce21ebe89ce67c97","snippet":"SetSensorEMeter(${1:const byte &port})","description":"Configure an EMeter sensor."},{"leftLabel":"void","displayText":"SetSensorTemperature","type":"function","descriptionMoreURL":"group___input_module_functions_gad704d42e22b9e5355cd5b6d7d9c1e156.html#gad704d42e22b9e5355cd5b6d7d9c1e156","snippet":"SetSensorTemperature(${1:const byte &port})","description":"Configure a temperature sensor."},{"leftLabel":"void","displayText":"SetSensorColorFull","type":"function","descriptionMoreURL":"group___input_module_functions_ga7205c67397fb4a38a33d1b89efe8131f.html#ga7205c67397fb4a38a33d1b89efe8131f","snippet":"SetSensorColorFull(${1:const byte &port})","description":"Configure an NXT 2.0 full color sensor."},{"leftLabel":"void","displayText":"SetSensorColorRed","type":"function","descriptionMoreURL":"group___input_module_functions_ga5a0f5cdab9b08650cd0b0301c8e44ee1.html#ga5a0f5cdab9b08650cd0b0301c8e44ee1","snippet":"SetSensorColorRed(${1:const byte &port})","description":"Configure an NXT 2.0 red light sensor."},{"leftLabel":"void","displayText":"SetSensorColorGreen","type":"function","descriptionMoreURL":"group___input_module_functions_gaa3bc941dc2243c55e56dbd38bb9ffa24.html#gaa3bc941dc2243c55e56dbd38bb9ffa24","snippet":"SetSensorColorGreen(${1:const byte &port})","description":"Configure an NXT 2.0 green light sensor."},{"leftLabel":"void","displayText":"SetSensorColorBlue","type":"function","descriptionMoreURL":"group___input_module_functions_ga527e2212a18144be0142c459128db5cd.html#ga527e2212a18144be0142c459128db5cd","snippet":"SetSensorColorBlue(${1:const byte &port})","description":"Configure an NXT 2.0 blue light sensor."},{"leftLabel":"void","displayText":"SetSensorColorNone","type":"function","descriptionMoreURL":"group___input_module_functions_gaa01fe205f2303fd753ed8ec71d80ce99.html#gaa01fe205f2303fd753ed8ec71d80ce99","snippet":"SetSensorColorNone(${1:const byte &port})","description":"Configure an NXT 2.0 no light sensor."},{"leftLabel":"variant","displayText":"GetInput","type":"function","descriptionMoreURL":"group___input_module_functions_ga4c5bba5cc70cd66fbab0911f30580c67.html#ga4c5bba5cc70cd66fbab0911f30580c67","snippet":"GetInput(${1:const byte &port}, ${2:const byte field})","description":"Get an input field value."},{"leftLabel":"void","displayText":"SetInput","type":"function","descriptionMoreURL":"group___input_module_functions_gade83390b69fbf2677468f7530c5f6d26.html#gade83390b69fbf2677468f7530c5f6d26","snippet":"SetInput(${1:const byte &port}, ${2:const int field}, ${3:variant value})","description":"Set an input field value."},{"leftLabel":"unsigned int","displayText":"Sensor","type":"function","descriptionMoreURL":"group___input_module_functions_gaed970c76e7d6b6ec934eacd5bd190bdd.html#gaed970c76e7d6b6ec934eacd5bd190bdd","snippet":"Sensor(${1:const byte &port})","description":"Read sensor scaled value."},{"leftLabel":"bool","displayText":"SensorBoolean","type":"function","descriptionMoreURL":"group___input_module_functions_ga6167c8eb0d0ed429223ae0500d1effef.html#ga6167c8eb0d0ed429223ae0500d1effef","snippet":"SensorBoolean(${1:const byte port})","description":"Read sensor boolean value."},{"leftLabel":"byte","displayText":"SensorDigiPinsDirection","type":"function","descriptionMoreURL":"group___input_module_functions_ga1eb10aa61a293ac6439eca27fb5b183f.html#ga1eb10aa61a293ac6439eca27fb5b183f","snippet":"SensorDigiPinsDirection(${1:const byte port})","description":"Read sensor digital pins direction."},{"leftLabel":"byte","displayText":"SensorDigiPinsOutputLevel","type":"function","descriptionMoreURL":"group___input_module_functions_ga190d47067b1fe5418ce7efa8d63b7cf0.html#ga190d47067b1fe5418ce7efa8d63b7cf0","snippet":"SensorDigiPinsOutputLevel(${1:const byte port})","description":"Read sensor digital pins output level."},{"leftLabel":"byte","displayText":"SensorDigiPinsStatus","type":"function","descriptionMoreURL":"group___input_module_functions_gaa586f98c95b2b3cb71da944476b224d2.html#gaa586f98c95b2b3cb71da944476b224d2","snippet":"SensorDigiPinsStatus(${1:const byte port})","description":"Read sensor digital pins status."},{"leftLabel":"bool","displayText":"SensorInvalid","type":"function","descriptionMoreURL":"group___input_module_functions_gad1132d096bcfa07b3d9c2635210c50aa.html#gad1132d096bcfa07b3d9c2635210c50aa","snippet":"SensorInvalid(${1:const byte &port})","description":"Read sensor invalid data flag."},{"leftLabel":"byte","displayText":"SensorMode","type":"function","descriptionMoreURL":"group___input_module_functions_gad0fd6523b72f23d085eaf0379ac8f4bf.html#gad0fd6523b72f23d085eaf0379ac8f4bf","snippet":"SensorMode(${1:const byte &port})","description":"Read sensor mode."},{"leftLabel":"unsigned int","displayText":"SensorNormalized","type":"function","descriptionMoreURL":"group___input_module_functions_gab188a488542719f43f561f14a4656cfc.html#gab188a488542719f43f561f14a4656cfc","snippet":"SensorNormalized(${1:const byte &port})","description":"Read sensor normalized value."},{"leftLabel":"unsigned int","displayText":"SensorRaw","type":"function","descriptionMoreURL":"group___input_module_functions_gadd83e72ee5c6c3079321b31c582f66cc.html#gadd83e72ee5c6c3079321b31c582f66cc","snippet":"SensorRaw(${1:const byte &port})","description":"Read sensor raw value."},{"leftLabel":"unsigned int","displayText":"SensorScaled","type":"function","descriptionMoreURL":"group___input_module_functions_ga09d82af4992d906d96b08832452f3cab.html#ga09d82af4992d906d96b08832452f3cab","snippet":"SensorScaled(${1:const byte &port})","description":"Read sensor scaled value."},{"leftLabel":"byte","displayText":"SensorType","type":"function","descriptionMoreURL":"group___input_module_functions_ga0b0f61a2a0e92e9263bff25c79f98547.html#ga0b0f61a2a0e92e9263bff25c79f98547","snippet":"SensorType(${1:const byte &port})","description":"Read sensor type."},{"leftLabel":"unsigned int","displayText":"SensorValue","type":"function","descriptionMoreURL":"group___input_module_functions_ga4c76db831f80cff3f9f341b54ccb7cf8.html#ga4c76db831f80cff3f9f341b54ccb7cf8","snippet":"SensorValue(${1:const byte &port})","description":"Read sensor scaled value."},{"leftLabel":"bool","displayText":"SensorValueBool","type":"function","descriptionMoreURL":"group___input_module_functions_ga7160e0becfca5aff7b1bcc533cd5f43a.html#ga7160e0becfca5aff7b1bcc533cd5f43a","snippet":"SensorValueBool(${1:const byte port})","description":"Read sensor boolean value."},{"leftLabel":"unsigned int","displayText":"SensorValueRaw","type":"function","descriptionMoreURL":"group___input_module_functions_gabe616109f9bc876bece67ec3b10ec285.html#gabe616109f9bc876bece67ec3b10ec285","snippet":"SensorValueRaw(${1:const byte &port})","description":"Read sensor raw value."},{"leftLabel":"byte","displayText":"CustomSensorActiveStatus","type":"function","descriptionMoreURL":"group___input_module_functions_ga7d2b8c0efad65a5205778af414a5c026.html#ga7d2b8c0efad65a5205778af414a5c026","snippet":"CustomSensorActiveStatus(${1:byte port})","description":"Get the custom sensor active status."},{"leftLabel":"byte","displayText":"CustomSensorPercentFullScale","type":"function","descriptionMoreURL":"group___input_module_functions_ga6f589a33bfaf2f7f05c08497f7512b2f.html#ga6f589a33bfaf2f7f05c08497f7512b2f","snippet":"CustomSensorPercentFullScale(${1:byte port})","description":"Get the custom sensor percent full scale."},{"leftLabel":"unsigned int","displayText":"CustomSensorZeroOffset","type":"function","descriptionMoreURL":"group___input_module_functions_ga8a0d126b2b5fc81f6f277ca77969f6dd.html#ga8a0d126b2b5fc81f6f277ca77969f6dd","snippet":"CustomSensorZeroOffset(${1:byte port})","description":"Get the custom sensor zero offset."},{"leftLabel":"void","displayText":"SetCustomSensorActiveStatus","type":"function","descriptionMoreURL":"group___input_module_functions_gabda6a5c64fd7b43d46fb8ab7d8ec5aee.html#gabda6a5c64fd7b43d46fb8ab7d8ec5aee","snippet":"SetCustomSensorActiveStatus(${1:byte port}, ${2:byte activeStatus})","description":"Set active status."},{"leftLabel":"void","displayText":"SetCustomSensorPercentFullScale","type":"function","descriptionMoreURL":"group___input_module_functions_gad49e86cd85c6cbb1b1e067a30c61fd66.html#gad49e86cd85c6cbb1b1e067a30c61fd66","snippet":"SetCustomSensorPercentFullScale(${1:byte port}, ${2:byte pctFullScale})","description":"Set percent full scale."},{"leftLabel":"void","displayText":"SetCustomSensorZeroOffset","type":"function","descriptionMoreURL":"group___input_module_functions_gacf1573ce100615dbbe37474322c0588a.html#gacf1573ce100615dbbe37474322c0588a","snippet":"SetCustomSensorZeroOffset(${1:byte port}, ${2:int zeroOffset})","description":"Set custom zero offset."},{"leftLabel":"void","displayText":"SetSensorBoolean","type":"function","descriptionMoreURL":"group___input_module_functions_ga4c5ec096dcd43dae69a62b647c476c05.html#ga4c5ec096dcd43dae69a62b647c476c05","snippet":"SetSensorBoolean(${1:byte port}, ${2:bool value})","description":"Set sensor boolean value."},{"leftLabel":"void","displayText":"SetSensorDigiPinsDirection","type":"function","descriptionMoreURL":"group___input_module_functions_gaa869f34343500ea5653ba1ab8acb8d57.html#gaa869f34343500ea5653ba1ab8acb8d57","snippet":"SetSensorDigiPinsDirection(${1:byte port}, ${2:byte direction})","description":"Set digital pins direction."},{"leftLabel":"void","displayText":"SetSensorDigiPinsOutputLevel","type":"function","descriptionMoreURL":"group___input_module_functions_ga75e3229e6cb49e5aaa205e900b99e2f5.html#ga75e3229e6cb49e5aaa205e900b99e2f5","snippet":"SetSensorDigiPinsOutputLevel(${1:byte port}, ${2:byte outputLevel})","description":"Set digital pins output level."},{"leftLabel":"void","displayText":"SetSensorDigiPinsStatus","type":"function","descriptionMoreURL":"group___input_module_functions_gad347f878eb91f22e7ec82874657a4669.html#gad347f878eb91f22e7ec82874657a4669","snippet":"SetSensorDigiPinsStatus(${1:byte port}, ${2:byte status})","description":"Set digital pins status."},{"leftLabel":"void","displayText":"SysColorSensorRead","type":"function","descriptionMoreURL":"group___input_module_functions_gab36236669ac7756bad6841157cf4450d.html#gab36236669ac7756bad6841157cf4450d","snippet":"SysColorSensorRead(${1:ColorSensorReadType &args})","description":"Read LEGO color sensor."},{"leftLabel":"int","displayText":"ReadSensorColorEx","type":"function","descriptionMoreURL":"group___input_module_functions_gaf8e01f28be7f3476baface8d4515357f.html#gaf8e01f28be7f3476baface8d4515357f","snippet":"ReadSensorColorEx(${1:const byte &port}, ${2:int &colorval}, ${3:unsigned int &raw[]}, ${4:unsigned int &norm[]}, ${5:int &scaled[]})","description":"Read LEGO color sensor extra."},{"leftLabel":"int","displayText":"ReadSensorColorRaw","type":"function","descriptionMoreURL":"group___input_module_functions_gae29b1117df46bf44aaf25843d61ccbaf.html#gae29b1117df46bf44aaf25843d61ccbaf","snippet":"ReadSensorColorRaw(${1:const byte &port}, ${2:unsigned int &rawVals[]})","description":"Read LEGO color sensor raw values."},{"leftLabel":"unsigned int","displayText":"ColorADRaw","type":"function","descriptionMoreURL":"group___input_module_functions_ga992620b670d17d41327cc49f7626ae15.html#ga992620b670d17d41327cc49f7626ae15","snippet":"ColorADRaw(${1:byte port}, ${2:byte color})","description":"Read a LEGO color sensor AD raw value."},{"leftLabel":"bool","displayText":"ColorBoolean","type":"function","descriptionMoreURL":"group___input_module_functions_gab0aa688d047eb3ab090c6b6a41dc2381.html#gab0aa688d047eb3ab090c6b6a41dc2381","snippet":"ColorBoolean(${1:byte port}, ${2:byte color})","description":"Read a LEGO color sensor boolean value."},{"leftLabel":"long","displayText":"ColorCalibration","type":"function","descriptionMoreURL":"group___input_module_functions_ga87fab8e8c67ffd2490f62da8bf12fbeb.html#ga87fab8e8c67ffd2490f62da8bf12fbeb","snippet":"ColorCalibration(${1:byte port}, ${2:byte point}, ${3:byte color})","description":"Read a LEGO color sensor calibration point value."},{"leftLabel":"byte","displayText":"ColorCalibrationState","type":"function","descriptionMoreURL":"group___input_module_functions_ga805b78d8170496cd463c8d54600b251a.html#ga805b78d8170496cd463c8d54600b251a","snippet":"ColorCalibrationState(${1:byte port})","description":"Read LEGO color sensor calibration state."},{"leftLabel":"unsigned int","displayText":"ColorCalLimits","type":"function","descriptionMoreURL":"group___input_module_functions_ga5680d47160b611c0106ad18eda7d77b6.html#ga5680d47160b611c0106ad18eda7d77b6","snippet":"ColorCalLimits(${1:byte port}, ${2:byte point})","description":"Read a LEGO color sensor calibration limit value."},{"leftLabel":"unsigned int","displayText":"ColorSensorRaw","type":"function","descriptionMoreURL":"group___input_module_functions_ga9f778b77712346ef6ad04253c1b2629d.html#ga9f778b77712346ef6ad04253c1b2629d","snippet":"ColorSensorRaw(${1:byte port}, ${2:byte color})","description":"Read a LEGO color sensor raw value."},{"leftLabel":"unsigned int","displayText":"ColorSensorValue","type":"function","descriptionMoreURL":"group___input_module_functions_ga4808680141fee797afd46be59f0c19ab.html#ga4808680141fee797afd46be59f0c19ab","snippet":"ColorSensorValue(${1:byte port}, ${2:byte color})","description":"Read a LEGO color sensor scaled value."},{"leftLabel":"void","displayText":"SysInputPinFunction","type":"function","descriptionMoreURL":"group___input_module_functions_ga001730fda3dfd1b63e568ae7320db6bb.html#ga001730fda3dfd1b63e568ae7320db6bb","snippet":"SysInputPinFunction(${1:InputPinFunctionType &args})","description":"Execute the Input module pin function."},{"leftLabel":"void","displayText":"SetMotorPwnFreq","type":"function","descriptionMoreURL":"group___output_module_functions_ga2f740b6a6b9811aab0fb10062ca3b818.html#ga2f740b6a6b9811aab0fb10062ca3b818","snippet":"SetMotorPwnFreq(${1:byte n})","description":"Set motor regulation frequency."},{"leftLabel":"void","displayText":"SetMotorRegulationTime","type":"function","descriptionMoreURL":"group___output_module_functions_ga69c796a2ece94887ca9a94d05cfafe35.html#ga69c796a2ece94887ca9a94d05cfafe35","snippet":"SetMotorRegulationTime(${1:byte n})","description":"Set regulation time."},{"leftLabel":"void","displayText":"SetMotorRegulationOptions","type":"function","descriptionMoreURL":"group___output_module_functions_ga84959a31e8b0b503c4a6b8a20236ad0e.html#ga84959a31e8b0b503c4a6b8a20236ad0e","snippet":"SetMotorRegulationOptions(${1:byte n})","description":"Set regulation options."},{"leftLabel":"void","displayText":"OnFwdSyncPID","type":"function","descriptionMoreURL":"group___output_module_functions_ga50b40af5ac2cbfa46f6f49341a683daa.html#ga50b40af5ac2cbfa46f6f49341a683daa","snippet":"OnFwdSyncPID(${1:byte outputs}, ${2:char pwr}, ${3:char turnpct}, ${4:byte p}, ${5:byte i}, ${6:byte d})","description":"Run motors forward synchronised with PID factors."},{"leftLabel":"void","displayText":"OnFwdSyncExPID","type":"function","descriptionMoreURL":"group___output_module_functions_ga171e55f3613f9bb572df4d2affe5f9ce.html#ga171e55f3613f9bb572df4d2affe5f9ce","snippet":"OnFwdSyncExPID(${1:byte outputs}, ${2:char pwr}, ${3:char turnpct}, ${4:const byte reset}, ${5:byte p}, ${6:byte i}, ${7:byte d})","description":"Run motors forward synchronised and reset counters with PID factors."},{"leftLabel":"void","displayText":"OnRevSyncPID","type":"function","descriptionMoreURL":"group___output_module_functions_gaf0274d62899ea4ed110c96fe482ad2dd.html#gaf0274d62899ea4ed110c96fe482ad2dd","snippet":"OnRevSyncPID(${1:byte outputs}, ${2:char pwr}, ${3:char turnpct}, ${4:byte p}, ${5:byte i}, ${6:byte d})","description":"Run motors backward synchronised with PID factors."},{"leftLabel":"void","displayText":"OnRevSyncExPID","type":"function","descriptionMoreURL":"group___output_module_functions_gac1c36d0a2055cf6521260f5f06cf278f.html#gac1c36d0a2055cf6521260f5f06cf278f","snippet":"OnRevSyncExPID(${1:byte outputs}, ${2:char pwr}, ${3:char turnpct}, ${4:const byte reset}, ${5:byte p}, ${6:byte i}, ${7:byte d})","description":"Run motors backward synchronised and reset counters with PID factors."},{"leftLabel":"void","displayText":"OnFwdRegPID","type":"function","descriptionMoreURL":"group___output_module_functions_gab0d1b8ef459b181193d74f73098e4341.html#gab0d1b8ef459b181193d74f73098e4341","snippet":"OnFwdRegPID(${1:byte outputs}, ${2:char pwr}, ${3:byte regmode}, ${4:byte p}, ${5:byte i}, ${6:byte d})","description":"Run motors forward regulated with PID factors."},{"leftLabel":"void","displayText":"OnFwdRegExPID","type":"function","descriptionMoreURL":"group___output_module_functions_gaa5dd57e44bbe3fd6fc78c27c3991f243.html#gaa5dd57e44bbe3fd6fc78c27c3991f243","snippet":"OnFwdRegExPID(${1:byte outputs}, ${2:char pwr}, ${3:byte regmode}, ${4:const byte reset}, ${5:byte p}, ${6:byte i}, ${7:byte d})","description":"Run motors forward regulated and reset counters with PID factors."},{"leftLabel":"void","displayText":"OnRevRegPID","type":"function","descriptionMoreURL":"group___output_module_functions_ga587bfcdf0078f041ac78a9699b3c26dd.html#ga587bfcdf0078f041ac78a9699b3c26dd","snippet":"OnRevRegPID(${1:byte outputs}, ${2:char pwr}, ${3:byte regmode}, ${4:byte p}, ${5:byte i}, ${6:byte d})","description":"Run motors reverse regulated with PID factors."},{"leftLabel":"void","displayText":"OnRevRegExPID","type":"function","descriptionMoreURL":"group___output_module_functions_ga27d687dc0a617e3b890476938d44559b.html#ga27d687dc0a617e3b890476938d44559b","snippet":"OnRevRegExPID(${1:byte outputs}, ${2:char pwr}, ${3:byte regmode}, ${4:const byte reset}, ${5:byte p}, ${6:byte i}, ${7:byte d})","description":"Run motors backward regulated and reset counters with PID factors."},{"leftLabel":"void","displayText":"Off","type":"function","descriptionMoreURL":"group___output_module_functions_ga8d19ad643f3e3a0a5d7ad08e7ea5c809.html#ga8d19ad643f3e3a0a5d7ad08e7ea5c809","snippet":"Off(${1:byte outputs})","description":"Turn motors off."},{"leftLabel":"void","displayText":"OffEx","type":"function","descriptionMoreURL":"group___output_module_functions_ga0ce1500792d60a30789cbb64f48f7d57.html#ga0ce1500792d60a30789cbb64f48f7d57","snippet":"OffEx(${1:byte outputs}, ${2:const byte reset})","description":"Turn motors off and reset counters."},{"leftLabel":"void","displayText":"Coast","type":"function","descriptionMoreURL":"group___output_module_functions_ga4e8fbbacd2579085c5d144550545a82b.html#ga4e8fbbacd2579085c5d144550545a82b","snippet":"Coast(${1:byte outputs})","description":"Coast motors."},{"leftLabel":"void","displayText":"CoastEx","type":"function","descriptionMoreURL":"group___output_module_functions_ga06700f7305ca088def48cefdedb26f94.html#ga06700f7305ca088def48cefdedb26f94","snippet":"CoastEx(${1:byte outputs}, ${2:const byte reset})","description":"Coast motors and reset counters."},{"leftLabel":"void","displayText":"Float","type":"function","descriptionMoreURL":"group___output_module_functions_ga277e6ad37dc5714db216d86d1227a450.html#ga277e6ad37dc5714db216d86d1227a450","snippet":"Float(${1:byte outputs})","description":"Float motors."},{"leftLabel":"void","displayText":"OnFwd","type":"function","descriptionMoreURL":"group___output_module_functions_gaff5b57943544cce13f2e7fcf7eb17b3c.html#gaff5b57943544cce13f2e7fcf7eb17b3c","snippet":"OnFwd(${1:byte outputs}, ${2:char pwr})","description":"Run motors forward."},{"leftLabel":"void","displayText":"OnFwdEx","type":"function","descriptionMoreURL":"group___output_module_functions_ga54d8423bdaa00d56b14b6dc4a8c4a112.html#ga54d8423bdaa00d56b14b6dc4a8c4a112","snippet":"OnFwdEx(${1:byte outputs}, ${2:char pwr}, ${3:const byte reset})","description":"Run motors forward and reset counters."},{"leftLabel":"void","displayText":"OnRev","type":"function","descriptionMoreURL":"group___output_module_functions_gaabf0c191c4e61576735f8d7087b7fc38.html#gaabf0c191c4e61576735f8d7087b7fc38","snippet":"OnRev(${1:byte outputs}, ${2:char pwr})","description":"Run motors backward."},{"leftLabel":"void","displayText":"OnRevEx","type":"function","descriptionMoreURL":"group___output_module_functions_gab6b3ba16ee0864a1eba4862602a1f550.html#gab6b3ba16ee0864a1eba4862602a1f550","snippet":"OnRevEx(${1:byte outputs}, ${2:char pwr}, ${3:const byte reset})","description":"Run motors backward and reset counters."},{"leftLabel":"void","displayText":"OnFwdReg","type":"function","descriptionMoreURL":"group___output_module_functions_gad4c4a24190aebe2e06a7a4ff41f147f5.html#gad4c4a24190aebe2e06a7a4ff41f147f5","snippet":"OnFwdReg(${1:byte outputs}, ${2:char pwr}, ${3:byte regmode})","description":"Run motors forward regulated."},{"leftLabel":"void","displayText":"OnFwdRegEx","type":"function","descriptionMoreURL":"group___output_module_functions_gafa657f3ff7256b42b9c993c24c2810a3.html#gafa657f3ff7256b42b9c993c24c2810a3","snippet":"OnFwdRegEx(${1:byte outputs}, ${2:char pwr}, ${3:byte regmode}, ${4:const byte reset})","description":"Run motors forward regulated and reset counters."},{"leftLabel":"void","displayText":"OnRevReg","type":"function","descriptionMoreURL":"group___output_module_functions_ga6f915e43f4b630775d3b84d64be04c14.html#ga6f915e43f4b630775d3b84d64be04c14","snippet":"OnRevReg(${1:byte outputs}, ${2:char pwr}, ${3:byte regmode})","description":"Run motors forward regulated."},{"leftLabel":"void","displayText":"OnRevRegEx","type":"function","descriptionMoreURL":"group___output_module_functions_ga23be8f55d95c27cc602fedd6b5a53870.html#ga23be8f55d95c27cc602fedd6b5a53870","snippet":"OnRevRegEx(${1:byte outputs}, ${2:char pwr}, ${3:byte regmode}, ${4:const byte reset})","description":"Run motors backward regulated and reset counters."},{"leftLabel":"void","displayText":"OnFwdSync","type":"function","descriptionMoreURL":"group___output_module_functions_ga470e2dac6606677d0582cb14c1d31776.html#ga470e2dac6606677d0582cb14c1d31776","snippet":"OnFwdSync(${1:byte outputs}, ${2:char pwr}, ${3:char turnpct})","description":"Run motors forward synchronised."},{"leftLabel":"void","displayText":"OnFwdSyncEx","type":"function","descriptionMoreURL":"group___output_module_functions_gae9839df67ce3ea90ef49cc9a5a99a593.html#gae9839df67ce3ea90ef49cc9a5a99a593","snippet":"OnFwdSyncEx(${1:byte outputs}, ${2:char pwr}, ${3:char turnpct}, ${4:const byte reset})","description":"Run motors forward synchronised and reset counters."},{"leftLabel":"void","displayText":"OnRevSync","type":"function","descriptionMoreURL":"group___output_module_functions_ga9b4abfa8f99355b600764a4028122e94.html#ga9b4abfa8f99355b600764a4028122e94","snippet":"OnRevSync(${1:byte outputs}, ${2:char pwr}, ${3:char turnpct})","description":"Run motors backward synchronised."},{"leftLabel":"void","displayText":"OnRevSyncEx","type":"function","descriptionMoreURL":"group___output_module_functions_ga78f2bd81279cfe3ef1c263b52ccd65cf.html#ga78f2bd81279cfe3ef1c263b52ccd65cf","snippet":"OnRevSyncEx(${1:byte outputs}, ${2:char pwr}, ${3:char turnpct}, ${4:const byte reset})","description":"Run motors backward synchronised and reset counters."},{"leftLabel":"void","displayText":"RotateMotor","type":"function","descriptionMoreURL":"group___output_module_functions_gab638baa46cfa84602c8517d9ed9b36ae.html#gab638baa46cfa84602c8517d9ed9b36ae","snippet":"RotateMotor(${1:byte outputs}, ${2:char pwr}, ${3:long angle})","description":"Rotate motor."},{"leftLabel":"void","displayText":"RotateMotorPID","type":"function","descriptionMoreURL":"group___output_module_functions_ga67b6d2a522b1c1aaa54f48440ad38846.html#ga67b6d2a522b1c1aaa54f48440ad38846","snippet":"RotateMotorPID(${1:byte outputs}, ${2:char pwr}, ${3:long angle}, ${4:byte p}, ${5:byte i}, ${6:byte d})","description":"Rotate motor with PID factors."},{"leftLabel":"void","displayText":"RotateMotorEx","type":"function","descriptionMoreURL":"group___output_module_functions_ga25995f6a1fde8c79a686aa4492568f43.html#ga25995f6a1fde8c79a686aa4492568f43","snippet":"RotateMotorEx(${1:byte outputs}, ${2:char pwr}, ${3:long angle}, ${4:char turnpct}, ${5:bool sync}, ${6:bool stop})","description":"Rotate motor Ex."},{"leftLabel":"void","displayText":"RotateMotorExPID","type":"function","descriptionMoreURL":"group___output_module_functions_ga74338c85cf59c9db5d987ebdd9388a0f.html#ga74338c85cf59c9db5d987ebdd9388a0f","snippet":"RotateMotorExPID(${1:byte outputs}, ${2:char pwr}, ${3:long angle}, ${4:char turnpct}, ${5:bool sync}, ${6:bool stop}, ${7:byte p}, ${8:byte i}, ${9:byte d})","description":"Rotate motor Ex with PID factors."},{"leftLabel":"void","displayText":"ResetTachoCount","type":"function","descriptionMoreURL":"group___output_module_functions_ga89b494fec2591253658a55cc74d7c6e7.html#ga89b494fec2591253658a55cc74d7c6e7","snippet":"ResetTachoCount(${1:byte outputs})","description":"Reset tachometer counter."},{"leftLabel":"void","displayText":"ResetBlockTachoCount","type":"function","descriptionMoreURL":"group___output_module_functions_ga0551f7dff96508c3f6707ccdd776cd3d.html#ga0551f7dff96508c3f6707ccdd776cd3d","snippet":"ResetBlockTachoCount(${1:byte outputs})","description":"Reset block-relative counter."},{"leftLabel":"void","displayText":"ResetRotationCount","type":"function","descriptionMoreURL":"group___output_module_functions_ga1f07b7f5f06116fffe738f699d0ce83f.html#ga1f07b7f5f06116fffe738f699d0ce83f","snippet":"ResetRotationCount(${1:byte outputs})","description":"Reset program-relative counter."},{"leftLabel":"void","displayText":"ResetAllTachoCounts","type":"function","descriptionMoreURL":"group___output_module_functions_ga07519ade593f829174fe25a07137d815.html#ga07519ade593f829174fe25a07137d815","snippet":"ResetAllTachoCounts(${1:byte outputs})","description":"Reset all tachometer counters."},{"leftLabel":"void","displayText":"SetOutput","type":"function","descriptionMoreURL":"group___output_module_functions_ga3a3cade87e47f20bd68d371b6896dd15.html#ga3a3cade87e47f20bd68d371b6896dd15","snippet":"SetOutput(${1:byte outputs}, ${2:byte field1}, ${3:variant val1,...}, ${4:byte fieldN}, ${5:variant valN})","description":"Set output fields."},{"leftLabel":"variant","displayText":"GetOutput","type":"function","descriptionMoreURL":"group___output_module_functions_ga956dcd8cfbd30a3b5ddcc0d7c7c810d4.html#ga956dcd8cfbd30a3b5ddcc0d7c7c810d4","snippet":"GetOutput(${1:byte output}, ${2:const byte field})","description":"Get output field value."},{"leftLabel":"byte","displayText":"MotorMode","type":"function","descriptionMoreURL":"group___output_module_functions_gaef49caa1a21a5f15fba5bc7b8c145916.html#gaef49caa1a21a5f15fba5bc7b8c145916","snippet":"MotorMode(${1:byte output})","description":"Get motor mode."},{"leftLabel":"char","displayText":"MotorPower","type":"function","descriptionMoreURL":"group___output_module_functions_ga8acbc6ac97d595b01a2dfa630f74abb2.html#ga8acbc6ac97d595b01a2dfa630f74abb2","snippet":"MotorPower(${1:byte output})","description":"Get motor power level."},{"leftLabel":"char","displayText":"MotorActualSpeed","type":"function","descriptionMoreURL":"group___output_module_functions_gaa49e8a82e84f258d4b0a9004a64d8653.html#gaa49e8a82e84f258d4b0a9004a64d8653","snippet":"MotorActualSpeed(${1:byte output})","description":"Get motor actual speed."},{"leftLabel":"long","displayText":"MotorTachoCount","type":"function","descriptionMoreURL":"group___output_module_functions_ga9607b978216f0bd22d6e093e8891c2dd.html#ga9607b978216f0bd22d6e093e8891c2dd","snippet":"MotorTachoCount(${1:byte output})","description":"Get motor tachometer counter."},{"leftLabel":"long","displayText":"MotorTachoLimit","type":"function","descriptionMoreURL":"group___output_module_functions_ga3186c712915ed01de46920d0a7a55ae0.html#ga3186c712915ed01de46920d0a7a55ae0","snippet":"MotorTachoLimit(${1:byte output})","description":"Get motor tachometer limit."},{"leftLabel":"byte","displayText":"MotorRunState","type":"function","descriptionMoreURL":"group___output_module_functions_gac583ed7c0869f05006bc8103a3fc2c10.html#gac583ed7c0869f05006bc8103a3fc2c10","snippet":"MotorRunState(${1:byte output})","description":"Get motor run state."},{"leftLabel":"char","displayText":"MotorTurnRatio","type":"function","descriptionMoreURL":"group___output_module_functions_gaede26654a3b4b05c0e210b1651c7f19b.html#gaede26654a3b4b05c0e210b1651c7f19b","snippet":"MotorTurnRatio(${1:byte output})","description":"Get motor turn ratio."},{"leftLabel":"byte","displayText":"MotorRegulation","type":"function","descriptionMoreURL":"group___output_module_functions_gadf2e4c1c12091c9f6f9dd0d920a4877c.html#gadf2e4c1c12091c9f6f9dd0d920a4877c","snippet":"MotorRegulation(${1:byte output})","description":"Get motor regulation mode."},{"leftLabel":"bool","displayText":"MotorOverload","type":"function","descriptionMoreURL":"group___output_module_functions_gafa5c117cd88f14bfb7d4d94b15ccf746.html#gafa5c117cd88f14bfb7d4d94b15ccf746","snippet":"MotorOverload(${1:byte output})","description":"Get motor overload status."},{"leftLabel":"byte","displayText":"MotorRegPValue","type":"function","descriptionMoreURL":"group___output_module_functions_ga5550ca186a91bc5ff4eeb9e6b7b60403.html#ga5550ca186a91bc5ff4eeb9e6b7b60403","snippet":"MotorRegPValue(${1:byte output})","description":"Get motor P value."},{"leftLabel":"byte","displayText":"MotorRegIValue","type":"function","descriptionMoreURL":"group___output_module_functions_ga5c95ad1958cd6613ee07274920b7c64f.html#ga5c95ad1958cd6613ee07274920b7c64f","snippet":"MotorRegIValue(${1:byte output})","description":"Get motor I value."},{"leftLabel":"byte","displayText":"MotorRegDValue","type":"function","descriptionMoreURL":"group___output_module_functions_gaf31a7aed74f6ca5175b1ccf9eb14d2fe.html#gaf31a7aed74f6ca5175b1ccf9eb14d2fe","snippet":"MotorRegDValue(${1:byte output})","description":"Get motor D value."},{"leftLabel":"long","displayText":"MotorBlockTachoCount","type":"function","descriptionMoreURL":"group___output_module_functions_ga87c16988e5c8a81e244b7331f99a4f63.html#ga87c16988e5c8a81e244b7331f99a4f63","snippet":"MotorBlockTachoCount(${1:byte output})","description":"Get motor block-relative counter."},{"leftLabel":"long","displayText":"MotorRotationCount","type":"function","descriptionMoreURL":"group___output_module_functions_ga24e7343c80ac7a9ec4eeb04e2e645131.html#ga24e7343c80ac7a9ec4eeb04e2e645131","snippet":"MotorRotationCount(${1:byte output})","description":"Get motor program-relative counter."},{"leftLabel":"byte","displayText":"MotorOutputOptions","type":"function","descriptionMoreURL":"group___output_module_functions_ga7b5826e12371bc02e4b167fa16762059.html#ga7b5826e12371bc02e4b167fa16762059","snippet":"MotorOutputOptions(${1:byte output})","description":"Get motor options."},{"leftLabel":"byte","displayText":"MotorMaxSpeed","type":"function","descriptionMoreURL":"group___output_module_functions_ga37c5079b516971de14346a93b18bbf6e.html#ga37c5079b516971de14346a93b18bbf6e","snippet":"MotorMaxSpeed(${1:byte output})","description":"Get motor max speed."},{"leftLabel":"byte","displayText":"MotorMaxAcceleration","type":"function","descriptionMoreURL":"group___output_module_functions_gad5494337cb1aede0393ab3784ee35cb6.html#gad5494337cb1aede0393ab3784ee35cb6","snippet":"MotorMaxAcceleration(${1:byte output})","description":"Get motor max acceleration."},{"leftLabel":"byte","displayText":"MotorPwnFreq","type":"function","descriptionMoreURL":"group___output_module_functions_ga3ea881cd98bd6a68ace54c31f0b3d0af.html#ga3ea881cd98bd6a68ace54c31f0b3d0af","snippet":"MotorPwnFreq(${1:})","description":"Get motor regulation frequency."},{"leftLabel":"byte","displayText":"MotorRegulationTime","type":"function","descriptionMoreURL":"group___output_module_functions_ga49ccf83ad53dc4f6eec4e0c5b2a24dcf.html#ga49ccf83ad53dc4f6eec4e0c5b2a24dcf","snippet":"MotorRegulationTime(${1:})","description":"Get motor regulation time."},{"leftLabel":"byte","displayText":"MotorRegulationOptions","type":"function","descriptionMoreURL":"group___output_module_functions_ga7938e4b863ad45a485b441e2eee628c9.html#ga7938e4b863ad45a485b441e2eee628c9","snippet":"MotorRegulationOptions(${1:})","description":"Get motor regulation options."},{"leftLabel":"void","displayText":"ResetScreen","type":"function","descriptionMoreURL":"group___display_module_functions_ga5f6047bae9bf82be7be019edf176fdba.html#ga5f6047bae9bf82be7be019edf176fdba","snippet":"ResetScreen(${1:})","description":"Reset LCD screen."},{"leftLabel":"char","displayText":"CircleOut","type":"function","descriptionMoreURL":"group___display_module_functions_ga1eb681df7693ac76693a90a5ccd402a8.html#ga1eb681df7693ac76693a90a5ccd402a8","snippet":"CircleOut(${1:int x}, ${2:int y}, ${3:byte radius}, ${4:unsigned long options=DRAW_OPT_NORMAL})","description":"Draw a circle."},{"leftLabel":"char","displayText":"LineOut","type":"function","descriptionMoreURL":"group___display_module_functions_ga36604633e8510bb5d498842ad2fac759.html#ga36604633e8510bb5d498842ad2fac759","snippet":"LineOut(${1:int x1}, ${2:int y1}, ${3:int x2}, ${4:int y2}, ${5:unsigned long options=DRAW_OPT_NORMAL})","description":"Draw a line."},{"leftLabel":"char","displayText":"PointOut","type":"function","descriptionMoreURL":"group___display_module_functions_ga032802d7467ad6b31a2db54cc374c0f5.html#ga032802d7467ad6b31a2db54cc374c0f5","snippet":"PointOut(${1:int x}, ${2:int y}, ${3:unsigned long options=DRAW_OPT_NORMAL})","description":"Draw a point."},{"leftLabel":"char","displayText":"RectOut","type":"function","descriptionMoreURL":"group___display_module_functions_gac581f66f682827f64af2551fd45e74f9.html#gac581f66f682827f64af2551fd45e74f9","snippet":"RectOut(${1:int x}, ${2:int y}, ${3:int width}, ${4:int height}, ${5:unsigned long options=DRAW_OPT_NORMAL})","description":"Draw a rectangle."},{"leftLabel":"char","displayText":"TextOut","type":"function","descriptionMoreURL":"group___display_module_functions_ga9a070f70dbe14ebfb0b6b0c0abbef64c.html#ga9a070f70dbe14ebfb0b6b0c0abbef64c","snippet":"TextOut(${1:int x}, ${2:int y}, ${3:string str}, ${4:unsigned long options=DRAW_OPT_NORMAL})","description":"Draw text."},{"leftLabel":"char","displayText":"NumOut","type":"function","descriptionMoreURL":"group___display_module_functions_ga6406022f2fd608fe87d8e11ae33b023d.html#ga6406022f2fd608fe87d8e11ae33b023d","snippet":"NumOut(${1:int x}, ${2:int y}, ${3:variant value}, ${4:unsigned long options=DRAW_OPT_NORMAL})","description":"Draw a number."},{"leftLabel":"char","displayText":"EllipseOut","type":"function","descriptionMoreURL":"group___display_module_functions_ga396352abfce5d2487a8d94940c57f798.html#ga396352abfce5d2487a8d94940c57f798","snippet":"EllipseOut(${1:int x}, ${2:int y}, ${3:byte radiusX}, ${4:byte radiusY}, ${5:unsigned long options=DRAW_OPT_NORMAL})","description":"Draw an ellipse."},{"leftLabel":"char","displayText":"PolyOut","type":"function","descriptionMoreURL":"group___display_module_functions_ga3f09eb9b7d093628c603093e4ee1ef4c.html#ga3f09eb9b7d093628c603093e4ee1ef4c","snippet":"PolyOut(${1:LocationType points[]}, ${2:unsigned long options=DRAW_OPT_NORMAL})","description":"Draw a polygon."},{"leftLabel":"char","displayText":"FontTextOut","type":"function","descriptionMoreURL":"group___display_module_functions_ga5d4df2c1e8c3951018a865013cb4f31b.html#ga5d4df2c1e8c3951018a865013cb4f31b","snippet":"FontTextOut(${1:int x}, ${2:int y}, ${3:string filename}, ${4:string str}, ${5:unsigned long options=DRAW_OPT_NORMAL})","description":"Draw text with font."},{"leftLabel":"char","displayText":"FontNumOut","type":"function","descriptionMoreURL":"group___display_module_functions_gaa860b3f8791f921c7fcce67848cee409.html#gaa860b3f8791f921c7fcce67848cee409","snippet":"FontNumOut(${1:int x}, ${2:int y}, ${3:string filename}, ${4:variant value}, ${5:unsigned long options=DRAW_OPT_NORMAL})","description":"Draw a number with font."},{"leftLabel":"char","displayText":"GraphicOut","type":"function","descriptionMoreURL":"group___display_module_functions_gaed14a2b6c5e90b0853c0e87e8efceaae.html#gaed14a2b6c5e90b0853c0e87e8efceaae","snippet":"GraphicOut(${1:int x}, ${2:int y}, ${3:string filename}, ${4:unsigned long options=DRAW_OPT_NORMAL})","description":"Draw a graphic image."},{"leftLabel":"char","displayText":"GraphicArrayOut","type":"function","descriptionMoreURL":"group___display_module_functions_gafe305347826a938cda52ce719e7fb405.html#gafe305347826a938cda52ce719e7fb405","snippet":"GraphicArrayOut(${1:int x}, ${2:int y}, ${3:byte data[]}, ${4:unsigned long options=DRAW_OPT_NORMAL})","description":"Draw a graphic image from byte array."},{"leftLabel":"char","displayText":"GraphicOutEx","type":"function","descriptionMoreURL":"group___display_module_functions_gae931ef362c7835feb3fd99c168c0c749.html#gae931ef362c7835feb3fd99c168c0c749","snippet":"GraphicOutEx(${1:int x}, ${2:int y}, ${3:string filename}, ${4:byte vars[]}, ${5:unsigned long options=DRAW_OPT_NORMAL})","description":"Draw a graphic image with parameters."},{"leftLabel":"char","displayText":"GraphicArrayOutEx","type":"function","descriptionMoreURL":"group___display_module_functions_gaa7a93062174fb1f1b16ac2ba35864dea.html#gaa7a93062174fb1f1b16ac2ba35864dea","snippet":"GraphicArrayOutEx(${1:int x}, ${2:int y}, ${3:byte data[]}, ${4:byte vars[]}, ${5:unsigned long options=DRAW_OPT_NORMAL})","description":"Draw a graphic image from byte array with parameters."},{"leftLabel":"void","displayText":"GetDisplayNormal","type":"function","descriptionMoreURL":"group___display_module_functions_gabf7c7286d01e689f07a9cf53cf9f13d2.html#gabf7c7286d01e689f07a9cf53cf9f13d2","snippet":"GetDisplayNormal(${1:const byte x}, ${2:const byte line}, ${3:unsigned int cnt}, ${4:byte &data[]})","description":"Read pixel data from the normal display buffer."},{"leftLabel":"void","displayText":"SetDisplayNormal","type":"function","descriptionMoreURL":"group___display_module_functions_ga7f7e9c41a7daa20853d2b93508df53b7.html#ga7f7e9c41a7daa20853d2b93508df53b7","snippet":"SetDisplayNormal(${1:const byte x}, ${2:const byte line}, ${3:unsigned int cnt}, ${4:byte data[]})","description":"Write pixel data to the normal display buffer."},{"leftLabel":"void","displayText":"GetDisplayPopup","type":"function","descriptionMoreURL":"group___display_module_functions_gae33a7e9c7dc09222e998b02467b35c25.html#gae33a7e9c7dc09222e998b02467b35c25","snippet":"GetDisplayPopup(${1:const byte x}, ${2:const byte line}, ${3:unsigned int cnt}, ${4:byte &data[]})","description":"Read pixel data from the popup display buffer."},{"leftLabel":"void","displayText":"SetDisplayPopup","type":"function","descriptionMoreURL":"group___display_module_functions_gaa2362b6fac5b71f2103837a7ae47c4d5.html#gaa2362b6fac5b71f2103837a7ae47c4d5","snippet":"SetDisplayPopup(${1:const byte x}, ${2:const byte line}, ${3:unsigned int cnt}, ${4:byte data[]})","description":"Write pixel data to the popup display buffer."},{"leftLabel":"unsigned long","displayText":"DisplayEraseMask","type":"function","descriptionMoreURL":"group___display_module_functions_ga5cd5a4c35f4734f699e5c9151c594c7e.html#ga5cd5a4c35f4734f699e5c9151c594c7e","snippet":"DisplayEraseMask(${1:})","description":"Read the display erase mask value."},{"leftLabel":"unsigned long","displayText":"DisplayUpdateMask","type":"function","descriptionMoreURL":"group___display_module_functions_ga4c5712d4836fe5c931f3b30e22e8c098.html#ga4c5712d4836fe5c931f3b30e22e8c098","snippet":"DisplayUpdateMask(${1:})","description":"Read the display update mask value."},{"leftLabel":"unsigned long","displayText":"DisplayFont","type":"function","descriptionMoreURL":"group___display_module_functions_ga22044f19168be6ccbff00587d3bd2b31.html#ga22044f19168be6ccbff00587d3bd2b31","snippet":"DisplayFont(${1:})","description":"Read the display font memory address."},{"leftLabel":"unsigned long","displayText":"DisplayDisplay","type":"function","descriptionMoreURL":"group___display_module_functions_ga5e3407313d9a61510407c326697ce9bc.html#ga5e3407313d9a61510407c326697ce9bc","snippet":"DisplayDisplay(${1:})","description":"Read the display memory address."},{"leftLabel":"byte","displayText":"DisplayFlags","type":"function","descriptionMoreURL":"group___display_module_functions_gacae6ac55393b741b43482247adaceaad.html#gacae6ac55393b741b43482247adaceaad","snippet":"DisplayFlags(${1:})","description":"Read the display flags."},{"leftLabel":"byte","displayText":"DisplayTextLinesCenterFlags","type":"function","descriptionMoreURL":"group___display_module_functions_gae678d17a54d15a2e6df70c6e3d4e2bb3.html#gae678d17a54d15a2e6df70c6e3d4e2bb3","snippet":"DisplayTextLinesCenterFlags(${1:})","description":"Read the display text lines center flags."},{"leftLabel":"void","displayText":"SysDrawText","type":"function","descriptionMoreURL":"group___display_module_functions_gad797e85b3de8b2cc7bdd246b2bc6841f.html#gad797e85b3de8b2cc7bdd246b2bc6841f","snippet":"SysDrawText(${1:DrawTextType &args})","description":"Draw text."},{"leftLabel":"void","displayText":"SysDrawPoint","type":"function","descriptionMoreURL":"group___display_module_functions_gac20e1745d60520cc885bee9f87e01f05.html#gac20e1745d60520cc885bee9f87e01f05","snippet":"SysDrawPoint(${1:DrawPointType &args})","description":"Draw a point."},{"leftLabel":"void","displayText":"SysDrawLine","type":"function","descriptionMoreURL":"group___display_module_functions_ga5c56e494289ba7fce319aec76d0b7dc8.html#ga5c56e494289ba7fce319aec76d0b7dc8","snippet":"SysDrawLine(${1:DrawLineType &args})","description":"Draw a line."},{"leftLabel":"void","displayText":"SysDrawCircle","type":"function","descriptionMoreURL":"group___display_module_functions_ga6165db50ebefd5f24fa9fc79ee1b3097.html#ga6165db50ebefd5f24fa9fc79ee1b3097","snippet":"SysDrawCircle(${1:DrawCircleType &args})","description":"Draw a circle."},{"leftLabel":"void","displayText":"SysDrawRect","type":"function","descriptionMoreURL":"group___display_module_functions_gaefef4f2d7bd2d25e4359636673991819.html#gaefef4f2d7bd2d25e4359636673991819","snippet":"SysDrawRect(${1:DrawRectType &args})","description":"Draw a rectangle."},{"leftLabel":"void","displayText":"SysDrawGraphic","type":"function","descriptionMoreURL":"group___display_module_functions_ga6bf37cf05ec1a8f039a957147c5e2a55.html#ga6bf37cf05ec1a8f039a957147c5e2a55","snippet":"SysDrawGraphic(${1:DrawGraphicType &args})","description":"Draw a graphic (RIC file)."},{"leftLabel":"void","displayText":"SysSetScreenMode","type":"function","descriptionMoreURL":"group___display_module_functions_gadd433d4df42c2a639b7a04a24da232c0.html#gadd433d4df42c2a639b7a04a24da232c0","snippet":"SysSetScreenMode(${1:SetScreenModeType &args})","description":"Set the screen mode."},{"leftLabel":"void","displayText":"SysDisplayExecuteFunction","type":"function","descriptionMoreURL":"group___display_module_functions_ga4d44dbbb9631f96d385adf49887ff7ae.html#ga4d44dbbb9631f96d385adf49887ff7ae","snippet":"SysDisplayExecuteFunction(${1:DisplayExecuteFunctionType &args})","description":"Execute any Display module command."},{"leftLabel":"byte","displayText":"DisplayContrast","type":"function","descriptionMoreURL":"group___display_module_functions_gaf9ea52412acbc8868d8ec9ad05c94550.html#gaf9ea52412acbc8868d8ec9ad05c94550","snippet":"DisplayContrast(${1:})","description":"Read the display contrast setting."},{"leftLabel":"void","displayText":"SysDrawGraphicArray","type":"function","descriptionMoreURL":"group___display_module_functions_gabeea40683dc91ec2d526697573525848.html#gabeea40683dc91ec2d526697573525848","snippet":"SysDrawGraphicArray(${1:DrawGraphicArrayType &args})","description":"Draw a graphic image from a byte array."},{"leftLabel":"void","displayText":"SysDrawPolygon","type":"function","descriptionMoreURL":"group___display_module_functions_gabc093201b21c198fbeb395d32a073aae.html#gabc093201b21c198fbeb395d32a073aae","snippet":"SysDrawPolygon(${1:DrawPolygonType &args})","description":"Draw a polygon."},{"leftLabel":"void","displayText":"SysDrawEllipse","type":"function","descriptionMoreURL":"group___display_module_functions_gabad9f2688ab46a5edde6da3d8e58e823.html#gabad9f2688ab46a5edde6da3d8e58e823","snippet":"SysDrawEllipse(${1:DrawEllipseType &args})","description":"Draw an ellipse."},{"leftLabel":"void","displayText":"SysDrawFont","type":"function","descriptionMoreURL":"group___display_module_functions_gaecbb6a0a341d1849bf67c9113e48e85a.html#gaecbb6a0a341d1849bf67c9113e48e85a","snippet":"SysDrawFont(${1:DrawFontType &args})","description":"Draw text using a custom font."},{"leftLabel":"void","displayText":"ClearScreen","type":"function","descriptionMoreURL":"group___display_module_functions_ga6a3ca153f0817e8ba91a023b886bb662.html#ga6a3ca153f0817e8ba91a023b886bb662","snippet":"ClearScreen(${1:})","description":"Clear LCD screen."},{"leftLabel":"void","displayText":"ClearLine","type":"function","descriptionMoreURL":"group___display_module_functions_ga615479be2064c4c7309b811ae51749bb.html#ga615479be2064c4c7309b811ae51749bb","snippet":"ClearLine(${1:byte line})","description":"Clear a line on the LCD screen."},{"leftLabel":"void","displayText":"SetDisplayFont","type":"function","descriptionMoreURL":"group___display_module_functions_ga10bd62343d1bd0495085d72b8b427270.html#ga10bd62343d1bd0495085d72b8b427270","snippet":"SetDisplayFont(${1:unsigned long fontaddr})","description":"Set the display font memory address."},{"leftLabel":"void","displayText":"SetDisplayDisplay","type":"function","descriptionMoreURL":"group___display_module_functions_gaa6704c4c9cdfc0fa38dad8a1abe90923.html#gaa6704c4c9cdfc0fa38dad8a1abe90923","snippet":"SetDisplayDisplay(${1:unsigned long dispaddr})","description":"Set the display memory address."},{"leftLabel":"void","displayText":"SetDisplayEraseMask","type":"function","descriptionMoreURL":"group___display_module_functions_gab8d994d5963b942be5484bf7e40c10f9.html#gab8d994d5963b942be5484bf7e40c10f9","snippet":"SetDisplayEraseMask(${1:unsigned long eraseMask})","description":"Set the display erase mask."},{"leftLabel":"void","displayText":"SetDisplayFlags","type":"function","descriptionMoreURL":"group___display_module_functions_ga6aaf606f8a00cb4950ffa250ba7b043b.html#ga6aaf606f8a00cb4950ffa250ba7b043b","snippet":"SetDisplayFlags(${1:byte flags})","description":"Set the display flags."},{"leftLabel":"void","displayText":"SetDisplayTextLinesCenterFlags","type":"function","descriptionMoreURL":"group___display_module_functions_gaeb18e3fd78f5e676645b5ad22303e487.html#gaeb18e3fd78f5e676645b5ad22303e487","snippet":"SetDisplayTextLinesCenterFlags(${1:byte ctrFlags})","description":"Set the display text lines center flags."},{"leftLabel":"void","displayText":"SetDisplayUpdateMask","type":"function","descriptionMoreURL":"group___display_module_functions_ga5086eabff0c3fb6dc7b9534f9186de0d.html#ga5086eabff0c3fb6dc7b9534f9186de0d","snippet":"SetDisplayUpdateMask(${1:unsigned long updateMask})","description":"Set the display update mask."},{"leftLabel":"void","displayText":"SetDisplayContrast","type":"function","descriptionMoreURL":"group___display_module_functions_gad73988805842a86affa052f9c2e9b020.html#gad73988805842a86affa052f9c2e9b020","snippet":"SetDisplayContrast(${1:byte contrast})","description":"Set the display contrast."},{"leftLabel":"char","displayText":"PlayFile","type":"function","descriptionMoreURL":"group___sound_module_functions_ga44cdcc978853d615cc6fc27703e8d0cf.html#ga44cdcc978853d615cc6fc27703e8d0cf","snippet":"PlayFile(${1:string filename})","description":"Play a file."},{"leftLabel":"char","displayText":"PlayFileEx","type":"function","descriptionMoreURL":"group___sound_module_functions_gac31e414daa8578068a8111632c554f23.html#gac31e414daa8578068a8111632c554f23","snippet":"PlayFileEx(${1:string filename}, ${2:byte volume}, ${3:bool loop}, ${4:unsigned int sr=0})","description":"Play a file with extra options."},{"leftLabel":"char","displayText":"PlayTone","type":"function","descriptionMoreURL":"group___sound_module_functions_ga2461ac0148600b1e5135c8abd8a0ad26.html#ga2461ac0148600b1e5135c8abd8a0ad26","snippet":"PlayTone(${1:unsigned int frequency}, ${2:unsigned int duration})","description":"Play a tone."},{"leftLabel":"char","displayText":"PlayToneEx","type":"function","descriptionMoreURL":"group___sound_module_functions_ga62c4748422326135566807b24be8d0ac.html#ga62c4748422326135566807b24be8d0ac","snippet":"PlayToneEx(${1:unsigned int frequency}, ${2:unsigned int duration}, ${3:byte volume}, ${4:bool loop})","description":"Play a tone with extra options."},{"leftLabel":"byte","displayText":"SoundState","type":"function","descriptionMoreURL":"group___sound_module_functions_ga77ff1ecc74c4578df36e3f780173efb2.html#ga77ff1ecc74c4578df36e3f780173efb2","snippet":"SoundState(${1:})","description":"Get sound module state."},{"leftLabel":"byte","displayText":"SoundFlags","type":"function","descriptionMoreURL":"group___sound_module_functions_gaf77be36326eb3976f6e841d3aea55479.html#gaf77be36326eb3976f6e841d3aea55479","snippet":"SoundFlags(${1:})","description":"Get sound module flags."},{"leftLabel":"byte","displayText":"StopSound","type":"function","descriptionMoreURL":"group___sound_module_functions_ga448489f2aebe99c14846335ccecfe702.html#ga448489f2aebe99c14846335ccecfe702","snippet":"StopSound(${1:})","description":"Stop sound."},{"leftLabel":"unsigned int","displayText":"SoundFrequency","type":"function","descriptionMoreURL":"group___sound_module_functions_ga8bc552d678b69460c598233001050eb7.html#ga8bc552d678b69460c598233001050eb7","snippet":"SoundFrequency(${1:})","description":"Get sound frequency."},{"leftLabel":"unsigned int","displayText":"SoundDuration","type":"function","descriptionMoreURL":"group___sound_module_functions_ga1427487643acbceadd96388932e4e0f0.html#ga1427487643acbceadd96388932e4e0f0","snippet":"SoundDuration(${1:})","description":"Get sound duration."},{"leftLabel":"unsigned int","displayText":"SoundSampleRate","type":"function","descriptionMoreURL":"group___sound_module_functions_ga131663beffe71d6eeef451345e77a146.html#ga131663beffe71d6eeef451345e77a146","snippet":"SoundSampleRate(${1:})","description":"Get sample rate."},{"leftLabel":"byte","displayText":"SoundMode","type":"function","descriptionMoreURL":"group___sound_module_functions_ga50ab059c4e57f527389f04b43e057c1b.html#ga50ab059c4e57f527389f04b43e057c1b","snippet":"SoundMode(${1:})","description":"Get sound mode."},{"leftLabel":"byte","displayText":"SoundVolume","type":"function","descriptionMoreURL":"group___sound_module_functions_ga937a3aeaadc4bbabaacee3a8b5ae9ffb.html#ga937a3aeaadc4bbabaacee3a8b5ae9ffb","snippet":"SoundVolume(${1:})","description":"Get volume."},{"leftLabel":"void","displayText":"SetSoundDuration","type":"function","descriptionMoreURL":"group___sound_module_functions_gaf4eb635bd0e0a1285590d684edb644d7.html#gaf4eb635bd0e0a1285590d684edb644d7","snippet":"SetSoundDuration(${1:unsigned int duration})","description":"Set sound duration."},{"leftLabel":"void","displayText":"SetSoundFlags","type":"function","descriptionMoreURL":"group___sound_module_functions_ga7d95bfd9fc8d97700ddab7ca03c26264.html#ga7d95bfd9fc8d97700ddab7ca03c26264","snippet":"SetSoundFlags(${1:byte flags})","description":"Set sound module flags."},{"leftLabel":"void","displayText":"SetSoundFrequency","type":"function","descriptionMoreURL":"group___sound_module_functions_ga48933159268dff45e5ff5141120373c0.html#ga48933159268dff45e5ff5141120373c0","snippet":"SetSoundFrequency(${1:unsigned int frequency})","description":"Set sound frequency."},{"leftLabel":"void","displayText":"SetSoundMode","type":"function","descriptionMoreURL":"group___sound_module_functions_ga6c5d11010baa3169939ca1f216b04ad7.html#ga6c5d11010baa3169939ca1f216b04ad7","snippet":"SetSoundMode(${1:byte mode})","description":"Set sound mode."},{"leftLabel":"void","displayText":"SetSoundModuleState","type":"function","descriptionMoreURL":"group___sound_module_functions_ga3a3c05d3adb787004b09b86948d09b46.html#ga3a3c05d3adb787004b09b86948d09b46","snippet":"SetSoundModuleState(${1:byte state})","description":"Set sound module state."},{"leftLabel":"void","displayText":"SetSoundSampleRate","type":"function","descriptionMoreURL":"group___sound_module_functions_gae032890f01e8bd2733624b85ff199dac.html#gae032890f01e8bd2733624b85ff199dac","snippet":"SetSoundSampleRate(${1:unsigned int sampleRate})","description":"Set sample rate."},{"leftLabel":"void","displayText":"SetSoundVolume","type":"function","descriptionMoreURL":"group___sound_module_functions_gacc762838bf03508c641266e17df8e243.html#gacc762838bf03508c641266e17df8e243","snippet":"SetSoundVolume(${1:byte volume})","description":"Set sound volume."},{"leftLabel":"void","displayText":"SysSoundPlayFile","type":"function","descriptionMoreURL":"group___sound_module_functions_ga589f05761cb1b466f8334499476cda09.html#ga589f05761cb1b466f8334499476cda09","snippet":"SysSoundPlayFile(${1:SoundPlayFileType &args})","description":"Play sound file."},{"leftLabel":"void","displayText":"SysSoundPlayTone","type":"function","descriptionMoreURL":"group___sound_module_functions_gab31d5acfa74843e4715e0bbabb61570a.html#gab31d5acfa74843e4715e0bbabb61570a","snippet":"SysSoundPlayTone(${1:SoundPlayToneType &args})","description":"Play tone."},{"leftLabel":"void","displayText":"SysSoundGetState","type":"function","descriptionMoreURL":"group___sound_module_functions_gaaca1de1737c855860da0e1dc01ea6cae.html#gaaca1de1737c855860da0e1dc01ea6cae","snippet":"SysSoundGetState(${1:SoundGetStateType &args})","description":"Get sound state."},{"leftLabel":"void","displayText":"SysSoundSetState","type":"function","descriptionMoreURL":"group___sound_module_functions_ga6a74d183a87b2de187805e68691722c5.html#ga6a74d183a87b2de187805e68691722c5","snippet":"SysSoundSetState(${1:SoundSetStateType &args})","description":"Set sound state."},{"leftLabel":"void","displayText":"PlaySound","type":"function","descriptionMoreURL":"group___sound_module_functions_gab633d7eec889632702c14374dab361cd.html#gab633d7eec889632702c14374dab361cd","snippet":"PlaySound(${1:const int &aCode})","description":"Play a system sound."},{"leftLabel":"void","displayText":"PlayTones","type":"function","descriptionMoreURL":"group___sound_module_functions_ga343ce8b1180f1083e6216f6d26dd1150.html#ga343ce8b1180f1083e6216f6d26dd1150","snippet":"PlayTones(${1:Tone tones[]})","description":"Play multiple tones."},{"leftLabel":"byte","displayText":"SensorUS","type":"function","descriptionMoreURL":"group___low_speed_module_functions_ga7543e9f7d63dda6389db68271134f62e.html#ga7543e9f7d63dda6389db68271134f62e","snippet":"SensorUS(${1:const byte port})","description":"Read ultrasonic sensor value."},{"leftLabel":"byte","displayText":"SensorUS0","type":"function","descriptionMoreURL":"group___low_speed_module_functions_ga4279812e5aa03473763bc7bac5f94f0d.html#ga4279812e5aa03473763bc7bac5f94f0d","snippet":"SensorUS0(${1:const byte port})","description":"Read ultrasonic sensor value without wait."},{"leftLabel":"byte","displayText":"SensorUSWait","type":"function","descriptionMoreURL":"group___low_speed_module_functions_ga5bfee063f3afc9f82dea0007efb59512.html#ga5bfee063f3afc9f82dea0007efb59512","snippet":"SensorUSWait(${1:const byte port}, ${2:const byte wait})","description":"Read ultrasonic sensor value with specified wait."},{"leftLabel":"char","displayText":"ReadSensorUSEx","type":"function","descriptionMoreURL":"group___low_speed_module_functions_ga95d443e1902408c417b392e6b829572c.html#ga95d443e1902408c417b392e6b829572c","snippet":"ReadSensorUSEx(${1:const byte port}, ${2:byte &values[]})","description":"Read multiple ultrasonic sensor values."},{"leftLabel":"char","displayText":"ReadSensorUSEx0","type":"function","descriptionMoreURL":"group___low_speed_module_functions_gacb3ce51eec44c5d2b20ca25d3abe7c26.html#gacb3ce51eec44c5d2b20ca25d3abe7c26","snippet":"ReadSensorUSEx0(${1:const byte port}, ${2:byte &values[]})","description":"Read multiple ultrasonic sensor values without wait."},{"leftLabel":"char","displayText":"ReadSensorUSExWait","type":"function","descriptionMoreURL":"group___low_speed_module_functions_ga14b25208a6c6423d281dd36a73f9262b.html#ga14b25208a6c6423d281dd36a73f9262b","snippet":"ReadSensorUSExWait(${1:const byte port}, ${2:byte &values[]}, ${3:const byte wait})","description":"Read multiple ultrasonic sensor values with specified wait."},{"leftLabel":"char","displayText":"ReadSensorEMeter","type":"function","descriptionMoreURL":"group___low_speed_module_functions_ga8d49890934bad6e9792406f36f125a0a.html#ga8d49890934bad6e9792406f36f125a0a","snippet":"ReadSensorEMeter(${1:const byte &port}, ${2:float &vIn}, ${3:float &aIn}, ${4:float &vOut}, ${5:float &aOut}, ${6:int &joules}, ${7:float &wIn}, ${8:float &wOut})","description":"Read the LEGO EMeter values."},{"leftLabel":"char","displayText":"ConfigureTemperatureSensor","type":"function","descriptionMoreURL":"group___low_speed_module_functions_ga76252d25beeca284d53ea263a4c6f3f9.html#ga76252d25beeca284d53ea263a4c6f3f9","snippet":"ConfigureTemperatureSensor(${1:const byte &port}, ${2:const byte &config})","description":"Configure LEGO Temperature sensor options."},{"leftLabel":"float","displayText":"SensorTemperature","type":"function","descriptionMoreURL":"group___low_speed_module_functions_ga1a932d6f4ac5928923b3928de0a763ec.html#ga1a932d6f4ac5928923b3928de0a763ec","snippet":"SensorTemperature(${1:const byte &port})","description":"Read the LEGO Temperature sensor value."},{"leftLabel":"long","displayText":"LowspeedStatus","type":"function","descriptionMoreURL":"group___low_speed_module_functions_gadfe700e10310199b8aefdc6a19a6be94.html#gadfe700e10310199b8aefdc6a19a6be94","snippet":"LowspeedStatus(${1:const byte port}, ${2:byte &bytesready})","description":"Get lowspeed status."},{"leftLabel":"long","displayText":"LowspeedCheckStatus","type":"function","descriptionMoreURL":"group___low_speed_module_functions_ga6459a9c5107e23f4d4437038e901e9cd.html#ga6459a9c5107e23f4d4437038e901e9cd","snippet":"LowspeedCheckStatus(${1:const byte port})","description":"Check lowspeed status."},{"leftLabel":"byte","displayText":"LowspeedBytesReady","type":"function","descriptionMoreURL":"group___low_speed_module_functions_ga325ce4e7d27dbc4a56ecc7c3feb2b509.html#ga325ce4e7d27dbc4a56ecc7c3feb2b509","snippet":"LowspeedBytesReady(${1:const byte port})","description":"Get lowspeed bytes ready."},{"leftLabel":"long","displayText":"LowspeedWrite","type":"function","descriptionMoreURL":"group___low_speed_module_functions_ga35c9dfd920448a0a791babbe3cd802f6.html#ga35c9dfd920448a0a791babbe3cd802f6","snippet":"LowspeedWrite(${1:const byte port}, ${2:byte retlen}, ${3:byte buffer[]})","description":"Write lowspeed data."},{"leftLabel":"long","displayText":"LowspeedRead","type":"function","descriptionMoreURL":"group___low_speed_module_functions_gaab95235e9af826d826b2cb679fd826b4.html#gaab95235e9af826d826b2cb679fd826b4","snippet":"LowspeedRead(${1:const byte port}, ${2:byte buflen}, ${3:byte &buffer[]})","description":"Read lowspeed data."},{"leftLabel":"long","displayText":"I2CStatus","type":"function","descriptionMoreURL":"group___low_speed_module_functions_ga46f151502b61d8d55d1255178dd3b03c.html#ga46f151502b61d8d55d1255178dd3b03c","snippet":"I2CStatus(${1:const byte port}, ${2:byte &bytesready})","description":"Get I2C status."},{"leftLabel":"long","displayText":"I2CCheckStatus","type":"function","descriptionMoreURL":"group___low_speed_module_functions_gaa9aa51f9a9c4483e8490de8f6543b2c2.html#gaa9aa51f9a9c4483e8490de8f6543b2c2","snippet":"I2CCheckStatus(${1:const byte port})","description":"Check I2C status."},{"leftLabel":"byte","displayText":"I2CBytesReady","type":"function","descriptionMoreURL":"group___low_speed_module_functions_ga7131ca5599f7bdbd7009c7c6a7c95bab.html#ga7131ca5599f7bdbd7009c7c6a7c95bab","snippet":"I2CBytesReady(${1:const byte port})","description":"Get I2C bytes ready."},{"leftLabel":"long","displayText":"I2CWrite","type":"function","descriptionMoreURL":"group___low_speed_module_functions_ga7b91cee283fe6abcf754401e4da20b58.html#ga7b91cee283fe6abcf754401e4da20b58","snippet":"I2CWrite(${1:const byte port}, ${2:byte retlen}, ${3:byte buffer[]})","description":"Write I2C data."},{"leftLabel":"long","displayText":"I2CRead","type":"function","descriptionMoreURL":"group___low_speed_module_functions_gad015f7e693d493392322cb6b5b92d77d.html#gad015f7e693d493392322cb6b5b92d77d","snippet":"I2CRead(${1:const byte port}, ${2:byte buflen}, ${3:byte &buffer[]})","description":"Read I2C data."},{"leftLabel":"long","displayText":"I2CBytes","type":"function","descriptionMoreURL":"group___low_speed_module_functions_ga085c21caa6674a6066c1cf67b7ef5374.html#ga085c21caa6674a6066c1cf67b7ef5374","snippet":"I2CBytes(${1:const byte port}, ${2:byte inbuf[]}, ${3:byte &count}, ${4:byte &outbuf[]})","description":"Perform an I2C write/read transaction."},{"leftLabel":"char","displayText":"ReadI2CRegister","type":"function","descriptionMoreURL":"group___low_speed_module_functions_ga46f8045c53edabfb3809504e7fd3d94d.html#ga46f8045c53edabfb3809504e7fd3d94d","snippet":"ReadI2CRegister(${1:byte port}, ${2:byte i2caddr}, ${3:byte reg}, ${4:byte &out})","description":"Read I2C register."},{"leftLabel":"char","displayText":"WriteI2CRegister","type":"function","descriptionMoreURL":"group___low_speed_module_functions_ga49057ab15691eb3bb4e6edbb834a98c8.html#ga49057ab15691eb3bb4e6edbb834a98c8","snippet":"WriteI2CRegister(${1:byte port}, ${2:byte i2caddr}, ${3:byte reg}, ${4:byte val})","description":"Write I2C register."},{"leftLabel":"string","displayText":"I2CDeviceInfo","type":"function","descriptionMoreURL":"group___low_speed_module_functions_ga5c21631ed09d7934da9c8ef4c4e62696.html#ga5c21631ed09d7934da9c8ef4c4e62696","snippet":"I2CDeviceInfo(${1:byte port}, ${2:byte i2caddr}, ${3:byte info})","description":"Read I2C device information."},{"leftLabel":"string","displayText":"I2CVersion","type":"function","descriptionMoreURL":"group___low_speed_module_functions_ga77ddd2b08abf930381266eff42ae97b1.html#ga77ddd2b08abf930381266eff42ae97b1","snippet":"I2CVersion(${1:byte port}, ${2:byte i2caddr})","description":"Read I2C device version."},{"leftLabel":"string","displayText":"I2CVendorId","type":"function","descriptionMoreURL":"group___low_speed_module_functions_ga72a2eb153ff0a223a16fba981250a2af.html#ga72a2eb153ff0a223a16fba981250a2af","snippet":"I2CVendorId(${1:byte port}, ${2:byte i2caddr})","description":"Read I2C device vendor."},{"leftLabel":"string","displayText":"I2CDeviceId","type":"function","descriptionMoreURL":"group___low_speed_module_functions_ga2a97aab1ee2208825d421140396f9ce7.html#ga2a97aab1ee2208825d421140396f9ce7","snippet":"I2CDeviceId(${1:byte port}, ${2:byte i2caddr})","description":"Read I2C device identifier."},{"leftLabel":"long","displayText":"I2CSendCommand","type":"function","descriptionMoreURL":"group___low_speed_module_functions_ga62e239cfe170c7d6c9b9fc5fef7b88ae.html#ga62e239cfe170c7d6c9b9fc5fef7b88ae","snippet":"I2CSendCommand(${1:byte port}, ${2:byte i2caddr}, ${3:byte cmd})","description":"Send an I2C command."},{"leftLabel":"void","displayText":"GetLSInputBuffer","type":"function","descriptionMoreURL":"group___low_level_low_speed_module_functions_ga7ccaba5effb0f8cf4a47612a1d3be054.html#ga7ccaba5effb0f8cf4a47612a1d3be054","snippet":"GetLSInputBuffer(${1:const byte port}, ${2:const byte offset}, ${3:byte cnt}, ${4:byte &data[]})","description":"Get I2C input buffer data."},{"leftLabel":"void","displayText":"GetLSOutputBuffer","type":"function","descriptionMoreURL":"group___low_level_low_speed_module_functions_ga5a1b2de511d8cf1ab4f1c57990997386.html#ga5a1b2de511d8cf1ab4f1c57990997386","snippet":"GetLSOutputBuffer(${1:const byte port}, ${2:const byte offset}, ${3:byte cnt}, ${4:byte &data[]})","description":"Get I2C output buffer data."},{"leftLabel":"byte","displayText":"LSInputBufferInPtr","type":"function","descriptionMoreURL":"group___low_level_low_speed_module_functions_ga3bb658aad04156aff8ae214a95df856a.html#ga3bb658aad04156aff8ae214a95df856a","snippet":"LSInputBufferInPtr(${1:const byte port})","description":"Get I2C input buffer in-pointer."},{"leftLabel":"byte","displayText":"LSInputBufferOutPtr","type":"function","descriptionMoreURL":"group___low_level_low_speed_module_functions_gaf3af9052d470460d0eb133e3b08bee9b.html#gaf3af9052d470460d0eb133e3b08bee9b","snippet":"LSInputBufferOutPtr(${1:const byte port})","description":"Get I2C input buffer out-pointer."},{"leftLabel":"byte","displayText":"LSInputBufferBytesToRx","type":"function","descriptionMoreURL":"group___low_level_low_speed_module_functions_ga8c638292f2bf4b9d3a48dd4b821a892b.html#ga8c638292f2bf4b9d3a48dd4b821a892b","snippet":"LSInputBufferBytesToRx(${1:const byte port})","description":"Get I2C input buffer bytes to rx."},{"leftLabel":"byte","displayText":"LSOutputBufferInPtr","type":"function","descriptionMoreURL":"group___low_level_low_speed_module_functions_ga0165b0c1357ae347071fc6f86e663e34.html#ga0165b0c1357ae347071fc6f86e663e34","snippet":"LSOutputBufferInPtr(${1:const byte port})","description":"Get I2C output buffer in-pointer."},{"leftLabel":"byte","displayText":"LSOutputBufferOutPtr","type":"function","descriptionMoreURL":"group___low_level_low_speed_module_functions_gae4020fa1496877506e4a06b1dccfcd9b.html#gae4020fa1496877506e4a06b1dccfcd9b","snippet":"LSOutputBufferOutPtr(${1:const byte port})","description":"Get I2C output buffer out-pointer."},{"leftLabel":"byte","displayText":"LSOutputBufferBytesToRx","type":"function","descriptionMoreURL":"group___low_level_low_speed_module_functions_ga506267af6d58d64c2b2f052b150c373e.html#ga506267af6d58d64c2b2f052b150c373e","snippet":"LSOutputBufferBytesToRx(${1:const byte port})","description":"Get I2C output buffer bytes to rx."},{"leftLabel":"byte","displayText":"LSMode","type":"function","descriptionMoreURL":"group___low_level_low_speed_module_functions_ga7adb79527b2dee332045af04d8a63563.html#ga7adb79527b2dee332045af04d8a63563","snippet":"LSMode(${1:const byte port})","description":"Get I2C mode."},{"leftLabel":"byte","displayText":"LSChannelState","type":"function","descriptionMoreURL":"group___low_level_low_speed_module_functions_gaf4ff129c02ce2962087595e7cc7e4bb1.html#gaf4ff129c02ce2962087595e7cc7e4bb1","snippet":"LSChannelState(${1:const byte port})","description":"Get I2C channel state."},{"leftLabel":"byte","displayText":"LSErrorType","type":"function","descriptionMoreURL":"group___low_level_low_speed_module_functions_ga5c9ca57b24b436ca47b5c3891e6f61fc.html#ga5c9ca57b24b436ca47b5c3891e6f61fc","snippet":"LSErrorType(${1:const byte port})","description":"Get I2C error type."},{"leftLabel":"byte","displayText":"LSState","type":"function","descriptionMoreURL":"group___low_level_low_speed_module_functions_ga258190a1dc2f828071cb183321840b7c.html#ga258190a1dc2f828071cb183321840b7c","snippet":"LSState(${1:})","description":"Get I2C state."},{"leftLabel":"byte","displayText":"LSSpeed","type":"function","descriptionMoreURL":"group___low_level_low_speed_module_functions_ga09f88efa5bcf677e3fb36a912a848127.html#ga09f88efa5bcf677e3fb36a912a848127","snippet":"LSSpeed(${1:})","description":"Get I2C speed."},{"leftLabel":"byte","displayText":"LSNoRestartOnRead","type":"function","descriptionMoreURL":"group___low_level_low_speed_module_functions_ga17beb1068a9cbe8cc270c50d7c0e8851.html#ga17beb1068a9cbe8cc270c50d7c0e8851","snippet":"LSNoRestartOnRead(${1:})","description":"Get I2C no restart on read setting."},{"leftLabel":"void","displayText":"SetI2COptions","type":"function","descriptionMoreURL":"group___low_level_low_speed_module_functions_gae9b765c80489e5104bcfa9c116c5523b.html#gae9b765c80489e5104bcfa9c116c5523b","snippet":"SetI2COptions(${1:byte port}, ${2:byte options})","description":"Set I2C options."},{"leftLabel":"void","displayText":"SysCommLSWrite","type":"function","descriptionMoreURL":"group___low_speed_module_system_call_functions_ga50a27e152ee9c627091c4046b19fc4ba.html#ga50a27e152ee9c627091c4046b19fc4ba","snippet":"SysCommLSWrite(${1:CommLSWriteType &args})","description":"Write to a Lowspeed sensor."},{"leftLabel":"void","displayText":"SysCommLSRead","type":"function","descriptionMoreURL":"group___low_speed_module_system_call_functions_ga59da4f6f1e8e85b1172e7d565efd08eb.html#ga59da4f6f1e8e85b1172e7d565efd08eb","snippet":"SysCommLSRead(${1:CommLSReadType &args})","description":"Read from a Lowspeed sensor."},{"leftLabel":"void","displayText":"SysCommLSCheckStatus","type":"function","descriptionMoreURL":"group___low_speed_module_system_call_functions_ga1008b4278d6ac6744711f43b42977400.html#ga1008b4278d6ac6744711f43b42977400","snippet":"SysCommLSCheckStatus(${1:CommLSCheckStatusType &args})","description":"Check Lowspeed sensor status."},{"leftLabel":"void","displayText":"SysCommLSWriteEx","type":"function","descriptionMoreURL":"group___low_speed_module_system_call_functions_ga24d58a9c2c21af890efad13984defc26.html#ga24d58a9c2c21af890efad13984defc26","snippet":"SysCommLSWriteEx(${1:CommLSWriteExType &args})","description":"Write to a Lowspeed sensor (extra)."},{"leftLabel":"unsigned long","displayText":"CurrentTick","type":"function","descriptionMoreURL":"group___command_module_functions_ga792aeb4749e2b045d0c896df9a0ef21a.html#ga792aeb4749e2b045d0c896df9a0ef21a","snippet":"CurrentTick(${1:})","description":"Read the current system tick."},{"leftLabel":"unsigned long","displayText":"FirstTick","type":"function","descriptionMoreURL":"group___command_module_functions_ga8455ea60ae45289b3e82cc619d4b538a.html#ga8455ea60ae45289b3e82cc619d4b538a","snippet":"FirstTick(${1:})","description":"Get the first tick."},{"leftLabel":"long","displayText":"ResetSleepTimer","type":"function","descriptionMoreURL":"group___command_module_functions_ga5f828be1c6d60dd34554bc7062d87338.html#ga5f828be1c6d60dd34554bc7062d87338","snippet":"ResetSleepTimer(${1:})","description":"Reset the sleep timer."},{"leftLabel":"void","displayText":"SysCall","type":"function","descriptionMoreURL":"group___command_module_functions_ga48452295fbdcabea34c033eed3615e9a.html#ga48452295fbdcabea34c033eed3615e9a","snippet":"SysCall(${1:byte funcID}, ${2:variant &args})","description":"Call any system function."},{"leftLabel":"void","displayText":"SysGetStartTick","type":"function","descriptionMoreURL":"group___command_module_functions_ga6816a338ad72dce892d3ba0bf9f1eeeb.html#ga6816a338ad72dce892d3ba0bf9f1eeeb","snippet":"SysGetStartTick(${1:GetStartTickType &args})","description":"Get start tick."},{"leftLabel":"void","displayText":"SysKeepAlive","type":"function","descriptionMoreURL":"group___command_module_functions_ga3deab51bdfe0021ec67ac696b7e8bb26.html#ga3deab51bdfe0021ec67ac696b7e8bb26","snippet":"SysKeepAlive(${1:KeepAliveType &args})","description":"Keep alive."},{"leftLabel":"void","displayText":"SysIOMapRead","type":"function","descriptionMoreURL":"group___command_module_functions_ga0c918e541158d300dec3c7bc58c09e7e.html#ga0c918e541158d300dec3c7bc58c09e7e","snippet":"SysIOMapRead(${1:IOMapReadType &args})","description":"Read from IOMap by name."},{"leftLabel":"void","displayText":"SysIOMapWrite","type":"function","descriptionMoreURL":"group___command_module_functions_gac7c0e73bd76ee3679304a9dd0b35f3c2.html#gac7c0e73bd76ee3679304a9dd0b35f3c2","snippet":"SysIOMapWrite(${1:IOMapWriteType &args})","description":"Write to IOMap by name."},{"leftLabel":"void","displayText":"SysIOMapReadByID","type":"function","descriptionMoreURL":"group___command_module_functions_gaf5669e344371371e7987caf0daaf0cd8.html#gaf5669e344371371e7987caf0daaf0cd8","snippet":"SysIOMapReadByID(${1:IOMapReadByIDType &args})","description":"Read from IOMap by identifier."},{"leftLabel":"void","displayText":"SysIOMapWriteByID","type":"function","descriptionMoreURL":"group___command_module_functions_ga652abebd3b0f4f536fb22274a25aa116.html#ga652abebd3b0f4f536fb22274a25aa116","snippet":"SysIOMapWriteByID(${1:IOMapWriteByIDType &args})","description":"Write to IOMap by identifier."},{"leftLabel":"void","displayText":"SysDatalogWrite","type":"function","descriptionMoreURL":"group___command_module_functions_ga02e9cfaf1e241b58ae2eccbab8cb59a3.html#ga02e9cfaf1e241b58ae2eccbab8cb59a3","snippet":"SysDatalogWrite(${1:DatalogWriteType &args})","description":"Write to the datalog."},{"leftLabel":"void","displayText":"SysDatalogGetTimes","type":"function","descriptionMoreURL":"group___command_module_functions_ga31b62e8fda9b22305930b709826b2204.html#ga31b62e8fda9b22305930b709826b2204","snippet":"SysDatalogGetTimes(${1:DatalogGetTimesType &args})","description":"Get datalog times."},{"leftLabel":"void","displayText":"SysReadSemData","type":"function","descriptionMoreURL":"group___command_module_functions_ga87a686a4f82f9fb97df1e2e95c4cb05e.html#ga87a686a4f82f9fb97df1e2e95c4cb05e","snippet":"SysReadSemData(${1:ReadSemDataType &args})","description":"Read semaphore data."},{"leftLabel":"void","displayText":"SysWriteSemData","type":"function","descriptionMoreURL":"group___command_module_functions_ga3f12d1860a8512bb04584e458b43adfe.html#ga3f12d1860a8512bb04584e458b43adfe","snippet":"SysWriteSemData(${1:WriteSemDataType &args})","description":"Write semaphore data."},{"leftLabel":"void","displayText":"SysUpdateCalibCacheInfo","type":"function","descriptionMoreURL":"group___command_module_functions_gace596bec3583d3f625ee7f7c15a517a3.html#gace596bec3583d3f625ee7f7c15a517a3","snippet":"SysUpdateCalibCacheInfo(${1:UpdateCalibCacheInfoType &args})","description":"Update calibration cache information."},{"leftLabel":"void","displayText":"SysComputeCalibValue","type":"function","descriptionMoreURL":"group___command_module_functions_ga1d3daa068d5bb97a74bd00737219da3d.html#ga1d3daa068d5bb97a74bd00737219da3d","snippet":"SysComputeCalibValue(${1:ComputeCalibValueType &args})","description":"Compute calibration values."},{"leftLabel":"char","displayText":"GetMemoryInfo","type":"function","descriptionMoreURL":"group___command_module_functions_ga5a2a2017a422b66d7419af9eafb75ac7.html#ga5a2a2017a422b66d7419af9eafb75ac7","snippet":"GetMemoryInfo(${1:bool Compact}, ${2:unsigned int &PoolSize}, ${3:unsigned int &DataspaceSize})","description":"Read memory information."},{"leftLabel":"void","displayText":"SysMemoryManager","type":"function","descriptionMoreURL":"group___command_module_functions_ga3d17a2c0f41de37508087b016a821433.html#ga3d17a2c0f41de37508087b016a821433","snippet":"SysMemoryManager(${1:MemoryManagerType &args})","description":"Read memory information."},{"leftLabel":"char","displayText":"GetLastResponseInfo","type":"function","descriptionMoreURL":"group___command_module_functions_gaa3e2d0e181d9c606b051ea7191fc3221.html#gaa3e2d0e181d9c606b051ea7191fc3221","snippet":"GetLastResponseInfo(${1:bool Clear}, ${2:byte &Length}, ${3:byte &Command}, ${4:byte &Buffer[]})","description":"Read last response information."},{"leftLabel":"void","displayText":"SysReadLastResponse","type":"function","descriptionMoreURL":"group___command_module_functions_gac9f8743e4ae263e0762d820141f7cb0f.html#gac9f8743e4ae263e0762d820141f7cb0f","snippet":"SysReadLastResponse(${1:ReadLastResponseType &args})","description":"Read last response information."},{"leftLabel":"void","displayText":"Wait","type":"function","descriptionMoreURL":"group___command_module_functions_ga01e64d2250db0e5b41486e316228983f.html#ga01e64d2250db0e5b41486e316228983f","snippet":"Wait(${1:unsigned long ms})","description":"Wait some milliseconds."},{"leftLabel":"void","displayText":"Yield","type":"function","descriptionMoreURL":"group___command_module_functions_gaf1c0e21e0767ef32cb1a785ed610e839.html#gaf1c0e21e0767ef32cb1a785ed610e839","snippet":"Yield(${1:})","description":"Yield to another task."},{"leftLabel":"void","displayText":"StopAllTasks","type":"function","descriptionMoreURL":"group___command_module_functions_gaccc90f57482de569cccfad5ae0f81161.html#gaccc90f57482de569cccfad5ae0f81161","snippet":"StopAllTasks(${1:})","description":"Stop all tasks."},{"leftLabel":"void","displayText":"Stop","type":"function","descriptionMoreURL":"group___command_module_functions_gae0b7b4cbddeeaa97c008626c305b0b13.html#gae0b7b4cbddeeaa97c008626c305b0b13","snippet":"Stop(${1:bool bvalue})","description":"Stop the running program."},{"leftLabel":"void","displayText":"ExitTo","type":"function","descriptionMoreURL":"group___command_module_functions_gabfaff59fc3febef6a33807ba51d38bb4.html#gabfaff59fc3febef6a33807ba51d38bb4","snippet":"ExitTo(${1:task newTask})","description":"Exit to another task."},{"leftLabel":"void","displayText":"Precedes","type":"function","descriptionMoreURL":"group___command_module_functions_ga59bc18d456217192cffcfb1d0bef3863.html#ga59bc18d456217192cffcfb1d0bef3863","snippet":"Precedes(${1:task task1}, ${2:task task2,...}, ${3:task taskN})","description":"Declare tasks that this task precedes."},{"leftLabel":"void","displayText":"Follows","type":"function","descriptionMoreURL":"group___command_module_functions_gacfb98e808819952fc1fc8edcf4e1faf3.html#gacfb98e808819952fc1fc8edcf4e1faf3","snippet":"Follows(${1:task task1}, ${2:task task2,...}, ${3:task taskN})","description":"Declare tasks that this task follows."},{"leftLabel":"void","displayText":"Acquire","type":"function","descriptionMoreURL":"group___command_module_functions_gae2dc7a23d31e7874ae3b6929e4a29300.html#gae2dc7a23d31e7874ae3b6929e4a29300","snippet":"Acquire(${1:mutex m})","description":"Acquire a mutex."},{"leftLabel":"void","displayText":"Release","type":"function","descriptionMoreURL":"group___command_module_functions_ga1dff3d84967a491413b2331501653cb6.html#ga1dff3d84967a491413b2331501653cb6","snippet":"Release(${1:mutex m})","description":"Acquire a mutex."},{"leftLabel":"void","displayText":"StartTask","type":"function","descriptionMoreURL":"group___command_module_functions_ga7ecb5d6444d6b2283730af5ddd145b75.html#ga7ecb5d6444d6b2283730af5ddd145b75","snippet":"StartTask(${1:task t})","description":"Start a task."},{"leftLabel":"void","displayText":"StopTask","type":"function","descriptionMoreURL":"group___command_module_functions_ga3e86a933a9c4bc0e4bb7587a493ab9a7.html#ga3e86a933a9c4bc0e4bb7587a493ab9a7","snippet":"StopTask(${1:task t})","description":"Stop a task."},{"leftLabel":"void","displayText":"BranchTest","type":"function","descriptionMoreURL":"group___command_module_functions_ga53b3a5e50ed558c9afdbe601df787e68.html#ga53b3a5e50ed558c9afdbe601df787e68","snippet":"BranchTest(${1:const byte cmp}, ${2:constant void lbl}, ${3:variant value})","description":"Branch if test is true."},{"leftLabel":"void","displayText":"BranchComp","type":"function","descriptionMoreURL":"group___command_module_functions_gaf9cada4a12c26e741aba67a036fb641a.html#gaf9cada4a12c26e741aba67a036fb641a","snippet":"BranchComp(${1:const byte cmp}, ${2:constant void lbl}, ${3:variant v1}, ${4:variant v2})","description":"Branch if compare is true."},{"leftLabel":"void","displayText":"ArrayBuild","type":"function","descriptionMoreURL":"group___array_functions_gae8d75e08c670f09f01200a897d7ed2ba.html#gae8d75e08c670f09f01200a897d7ed2ba","snippet":"ArrayBuild(${1:variant &aout[]}, ${2:variant src1}, ${3:variant src2,...}, ${4:variant srcN})","description":"Build an array."},{"leftLabel":"unsigned int","displayText":"ArrayLen","type":"function","descriptionMoreURL":"group___array_functions_ga976ecd49f48279bebe51a946d96037c7.html#ga976ecd49f48279bebe51a946d96037c7","snippet":"ArrayLen(${1:variant data[]})","description":"Get array length."},{"leftLabel":"void","displayText":"ArrayInit","type":"function","descriptionMoreURL":"group___array_functions_ga49d48de55d817e96ed132eadc21260eb.html#ga49d48de55d817e96ed132eadc21260eb","snippet":"ArrayInit(${1:variant &aout[]}, ${2:variant value}, ${3:unsigned int count})","description":"Initialize an array."},{"leftLabel":"void","displayText":"ArraySubset","type":"function","descriptionMoreURL":"group___array_functions_ga007959abef61d9e7ca36c588d5a99fc8.html#ga007959abef61d9e7ca36c588d5a99fc8","snippet":"ArraySubset(${1:variant &aout[]}, ${2:variant asrc[]}, ${3:unsigned int idx}, ${4:unsigned int len})","description":"Copy an array subset."},{"leftLabel":"void","displayText":"ArrayIndex","type":"function","descriptionMoreURL":"group___array_functions_ga38666bafad667cf22d45ee8c29f01f66.html#ga38666bafad667cf22d45ee8c29f01f66","snippet":"ArrayIndex(${1:variant &out}, ${2:variant asrc[]}, ${3:unsigned int idx})","description":"Extract item from an array."},{"leftLabel":"void","displayText":"ArrayReplace","type":"function","descriptionMoreURL":"group___array_functions_ga9c1799dc277afa1c4e7da7f5829e4846.html#ga9c1799dc277afa1c4e7da7f5829e4846","snippet":"ArrayReplace(${1:variant &asrc[]}, ${2:unsigned int idx}, ${3:variant value})","description":"Replace items in an array."},{"leftLabel":"variant","displayText":"ArraySum","type":"function","descriptionMoreURL":"group___array_functions_ga8165950fda279c2f016ef7b4c0c29b41.html#ga8165950fda279c2f016ef7b4c0c29b41","snippet":"ArraySum(${1:const variant &src[]}, ${2:unsigned int idx}, ${3:unsigned int len})","description":"Calculate the sum of the elements in a numeric array."},{"leftLabel":"variant","displayText":"ArrayMean","type":"function","descriptionMoreURL":"group___array_functions_gafb8c16c1b180a56c716a505894bfa0e3.html#gafb8c16c1b180a56c716a505894bfa0e3","snippet":"ArrayMean(${1:const variant &src[]}, ${2:unsigned int idx}, ${3:unsigned int len})","description":"Calculate the mean of the elements in a numeric array."},{"leftLabel":"variant","displayText":"ArraySumSqr","type":"function","descriptionMoreURL":"group___array_functions_gaae74c963c3985bd942067a6b5a8088d2.html#gaae74c963c3985bd942067a6b5a8088d2","snippet":"ArraySumSqr(${1:const variant &src[]}, ${2:unsigned int idx}, ${3:unsigned int len})","description":"Calculate the sum of the squares of the elements in a numeric array."},{"leftLabel":"variant","displayText":"ArrayStd","type":"function","descriptionMoreURL":"group___array_functions_ga15248ed3afee3d6ae9d43b3d17a06514.html#ga15248ed3afee3d6ae9d43b3d17a06514","snippet":"ArrayStd(${1:const variant &src[]}, ${2:unsigned int idx}, ${3:unsigned int len})","description":"Calculate the standard deviation of the elements in a numeric array."},{"leftLabel":"variant","displayText":"ArrayMin","type":"function","descriptionMoreURL":"group___array_functions_ga4ed5da57255795a6e43f6c089d09a990.html#ga4ed5da57255795a6e43f6c089d09a990","snippet":"ArrayMin(${1:const variant &src[]}, ${2:unsigned int idx}, ${3:unsigned int len})","description":"Calculate the minimum of the elements in a numeric array."},{"leftLabel":"variant","displayText":"ArrayMax","type":"function","descriptionMoreURL":"group___array_functions_gaa2b3f28dc6937b9e2d117fdd186bef13.html#gaa2b3f28dc6937b9e2d117fdd186bef13","snippet":"ArrayMax(${1:const variant &src[]}, ${2:unsigned int idx}, ${3:unsigned int len})","description":"Calculate the maximum of the elements in a numeric array."},{"leftLabel":"void","displayText":"ArraySort","type":"function","descriptionMoreURL":"group___array_functions_gaac7aaacb79484c7af81ba0bf35a181d2.html#gaac7aaacb79484c7af81ba0bf35a181d2","snippet":"ArraySort(${1:variant &dest[]}, ${2:const variant &src[]}, ${3:unsigned int idx}, ${4:unsigned int len})","description":"Sort the elements in a numeric array."},{"leftLabel":"string","displayText":"UpperCase","type":"function","descriptionMoreURL":"group___array_functions_ga4a8d4f791f8dba04a6cc9a222937cdeb.html#ga4a8d4f791f8dba04a6cc9a222937cdeb","snippet":"UpperCase(${1:string src})","description":"Uppercase the characters in a string."},{"leftLabel":"string","displayText":"LowerCase","type":"function","descriptionMoreURL":"group___array_functions_gaab84ca4f64004a41a0523b9524a46b22.html#gaab84ca4f64004a41a0523b9524a46b22","snippet":"LowerCase(${1:string src})","description":"Lowercase the characters in a string."},{"leftLabel":"string","displayText":"UpperCaseEx","type":"function","descriptionMoreURL":"group___array_functions_ga8ddc5c9e6e8f10499ffc5243cf846c53.html#ga8ddc5c9e6e8f10499ffc5243cf846c53","snippet":"UpperCaseEx(${1:string src}, ${2:unsigned int idx}, ${3:unsigned int len})","description":"Uppercase some of the characters in a string."},{"leftLabel":"string","displayText":"LowerCaseEx","type":"function","descriptionMoreURL":"group___array_functions_ga38b118b438bd19a10fc417719f81db92.html#ga38b118b438bd19a10fc417719f81db92","snippet":"LowerCaseEx(${1:string src}, ${2:unsigned int idx}, ${3:unsigned int len})","description":"Lowercase some of the characters in a string."},{"leftLabel":"void","displayText":"ArrayOp","type":"function","descriptionMoreURL":"group___array_functions_ga000a314fd93cd84a5c46b1e5e22c3a71.html#ga000a314fd93cd84a5c46b1e5e22c3a71","snippet":"ArrayOp(${1:const byte op}, ${2:variant &dest}, ${3:const variant &src[]}, ${4:unsigned int idx}, ${5:unsigned int len})","description":"Operate on numeric arrays."},{"leftLabel":"void","displayText":"SetIOMapBytes","type":"function","descriptionMoreURL":"group___command_module_functions_ga05fcc7e2bd55d7de8d59cc64b877b14e.html#ga05fcc7e2bd55d7de8d59cc64b877b14e","snippet":"SetIOMapBytes(${1:string moduleName}, ${2:unsigned int offset}, ${3:unsigned int count}, ${4:byte data[]})","description":"Set IOMap bytes by name."},{"leftLabel":"void","displayText":"SetIOMapValue","type":"function","descriptionMoreURL":"group___command_module_functions_ga53cf48a293a44885b820c7159f5600bb.html#ga53cf48a293a44885b820c7159f5600bb","snippet":"SetIOMapValue(${1:string moduleName}, ${2:unsigned int offset}, ${3:variant value})","description":"Set IOMap value by name."},{"leftLabel":"void","displayText":"GetIOMapBytes","type":"function","descriptionMoreURL":"group___command_module_functions_ga083b3b7e37bfeca001d63ee9e5f82330.html#ga083b3b7e37bfeca001d63ee9e5f82330","snippet":"GetIOMapBytes(${1:string moduleName}, ${2:unsigned int offset}, ${3:unsigned int count}, ${4:byte &data[]})","description":"Get IOMap bytes by name."},{"leftLabel":"void","displayText":"GetIOMapValue","type":"function","descriptionMoreURL":"group___command_module_functions_ga61c0f2c77fabbfe0c58e1cbc0944fe03.html#ga61c0f2c77fabbfe0c58e1cbc0944fe03","snippet":"GetIOMapValue(${1:string moduleName}, ${2:unsigned int offset}, ${3:variant &value})","description":"Get IOMap value by name."},{"leftLabel":"void","displayText":"GetLowSpeedModuleBytes","type":"function","descriptionMoreURL":"group___command_module_functions_ga18a57bbf17db5ff67b40962bbe4b0b71.html#ga18a57bbf17db5ff67b40962bbe4b0b71","snippet":"GetLowSpeedModuleBytes(${1:unsigned int offset}, ${2:unsigned int count}, ${3:byte &data[]})","description":"Get Lowspeed module IOMap bytes."},{"leftLabel":"void","displayText":"GetDisplayModuleBytes","type":"function","descriptionMoreURL":"group___command_module_functions_ga73ad5813431ba39b18e3464a94530eb6.html#ga73ad5813431ba39b18e3464a94530eb6","snippet":"GetDisplayModuleBytes(${1:unsigned int offset}, ${2:unsigned int count}, ${3:byte &data[]})","description":"Get Display module IOMap bytes."},{"leftLabel":"void","displayText":"GetCommModuleBytes","type":"function","descriptionMoreURL":"group___command_module_functions_ga0760dd1fbb6d97987f16d12f2ec6432f.html#ga0760dd1fbb6d97987f16d12f2ec6432f","snippet":"GetCommModuleBytes(${1:unsigned int offset}, ${2:unsigned int count}, ${3:byte &data[]})","description":"Get Comm module IOMap bytes."},{"leftLabel":"void","displayText":"GetCommandModuleBytes","type":"function","descriptionMoreURL":"group___command_module_functions_ga184cdd6dd985ca9b063c680d8d1611aa.html#ga184cdd6dd985ca9b063c680d8d1611aa","snippet":"GetCommandModuleBytes(${1:unsigned int offset}, ${2:unsigned int count}, ${3:byte &data[]})","description":"Get Command module IOMap bytes."},{"leftLabel":"void","displayText":"SetCommandModuleBytes","type":"function","descriptionMoreURL":"group___command_module_functions_ga9c757b0bcba51b7630bc6e01d7f9d587.html#ga9c757b0bcba51b7630bc6e01d7f9d587","snippet":"SetCommandModuleBytes(${1:unsigned int offset}, ${2:unsigned int count}, ${3:byte data[]})","description":"Set Command module IOMap bytes."},{"leftLabel":"void","displayText":"SetLowSpeedModuleBytes","type":"function","descriptionMoreURL":"group___command_module_functions_ga04288b37733d3d3567696b5905f5a0a3.html#ga04288b37733d3d3567696b5905f5a0a3","snippet":"SetLowSpeedModuleBytes(${1:unsigned int offset}, ${2:unsigned int count}, ${3:byte data[]})","description":"Set Lowspeed module IOMap bytes."},{"leftLabel":"void","displayText":"SetDisplayModuleBytes","type":"function","descriptionMoreURL":"group___command_module_functions_gadecce842539280744b836969002b1c61.html#gadecce842539280744b836969002b1c61","snippet":"SetDisplayModuleBytes(${1:unsigned int offset}, ${2:unsigned int count}, ${3:byte data[]})","description":"Set Display module IOMap bytes."},{"leftLabel":"void","displayText":"SetCommModuleBytes","type":"function","descriptionMoreURL":"group___command_module_functions_gafbd862595d0fb114160defd510e03216.html#gafbd862595d0fb114160defd510e03216","snippet":"SetCommModuleBytes(${1:unsigned int offset}, ${2:unsigned int count}, ${3:byte data[]})","description":"Set Comm module IOMap bytes."},{"leftLabel":"void","displayText":"SetSoundModuleBytes","type":"function","descriptionMoreURL":"group___command_module_functions_ga60b01c541bd3a932bcedb732f7c93d47.html#ga60b01c541bd3a932bcedb732f7c93d47","snippet":"SetSoundModuleBytes(${1:unsigned int offset}, ${2:unsigned int count}, ${3:byte data[]})","description":"Set Sound module IOMap bytes."},{"leftLabel":"void","displayText":"SetIOMapBytesByID","type":"function","descriptionMoreURL":"group___command_module_functions_ga149960623e37f7386f6d85938b42127d.html#ga149960623e37f7386f6d85938b42127d","snippet":"SetIOMapBytesByID(${1:unsigned long moduleId}, ${2:unsigned int offset}, ${3:unsigned int count}, ${4:byte data[]})","description":"Set IOMap bytes by ID."},{"leftLabel":"void","displayText":"SetIOMapValueByID","type":"function","descriptionMoreURL":"group___command_module_functions_gab569a7e17343c370b592e0286e010cbf.html#gab569a7e17343c370b592e0286e010cbf","snippet":"SetIOMapValueByID(${1:unsigned long moduleId}, ${2:unsigned int offset}, ${3:variant value})","description":"Set IOMap value by ID."},{"leftLabel":"void","displayText":"GetIOMapBytesByID","type":"function","descriptionMoreURL":"group___command_module_functions_ga2f883beb21431a0ddbc1baaf96165d6a.html#ga2f883beb21431a0ddbc1baaf96165d6a","snippet":"GetIOMapBytesByID(${1:unsigned long moduleId}, ${2:unsigned int offset}, ${3:unsigned int count}, ${4:byte &data[]})","description":"Get IOMap bytes by ID."},{"leftLabel":"void","displayText":"GetIOMapValueByID","type":"function","descriptionMoreURL":"group___command_module_functions_ga2aeaef50ea9116c7f9856b529cb36871.html#ga2aeaef50ea9116c7f9856b529cb36871","snippet":"GetIOMapValueByID(${1:unsigned long moduleId}, ${2:unsigned int offset}, ${3:variant &value})","description":"Get IOMap value by ID."},{"leftLabel":"void","displayText":"SetCommandModuleValue","type":"function","descriptionMoreURL":"group___command_module_functions_ga085fd22193f490cddd8346bb4a4ee398.html#ga085fd22193f490cddd8346bb4a4ee398","snippet":"SetCommandModuleValue(${1:unsigned int offset}, ${2:variant value})","description":"Set Command module IOMap value."},{"leftLabel":"void","displayText":"SetIOCtrlModuleValue","type":"function","descriptionMoreURL":"group___command_module_functions_ga2f2e48753c3f22c190a756030b61d264.html#ga2f2e48753c3f22c190a756030b61d264","snippet":"SetIOCtrlModuleValue(${1:unsigned int offset}, ${2:variant value})","description":"Set IOCtrl module IOMap value."},{"leftLabel":"void","displayText":"SetLoaderModuleValue","type":"function","descriptionMoreURL":"group___command_module_functions_gad9f53125941638e294b5202af3c1006b.html#gad9f53125941638e294b5202af3c1006b","snippet":"SetLoaderModuleValue(${1:unsigned int offset}, ${2:variant value})","description":"Set Loader module IOMap value."},{"leftLabel":"void","displayText":"SetUIModuleValue","type":"function","descriptionMoreURL":"group___command_module_functions_ga015bc5e58737b3cf3bfd2319ad150d7d.html#ga015bc5e58737b3cf3bfd2319ad150d7d","snippet":"SetUIModuleValue(${1:unsigned int offset}, ${2:variant value})","description":"Set Ui module IOMap value."},{"leftLabel":"void","displayText":"SetSoundModuleValue","type":"function","descriptionMoreURL":"group___command_module_functions_ga2821698fca45fe8ea07bf757a46fd055.html#ga2821698fca45fe8ea07bf757a46fd055","snippet":"SetSoundModuleValue(${1:unsigned int offset}, ${2:variant value})","description":"Set Sound module IOMap value."},{"leftLabel":"void","displayText":"SetButtonModuleValue","type":"function","descriptionMoreURL":"group___command_module_functions_ga88a61dbe49d3438471b54192ed064ee3.html#ga88a61dbe49d3438471b54192ed064ee3","snippet":"SetButtonModuleValue(${1:unsigned int offset}, ${2:variant value})","description":"Set Button module IOMap value."},{"leftLabel":"void","displayText":"SetInputModuleValue","type":"function","descriptionMoreURL":"group___command_module_functions_ga6b12c44090001fdebdd26f6fd808492c.html#ga6b12c44090001fdebdd26f6fd808492c","snippet":"SetInputModuleValue(${1:unsigned int offset}, ${2:variant value})","description":"Set Input module IOMap value."},{"leftLabel":"void","displayText":"SetOutputModuleValue","type":"function","descriptionMoreURL":"group___command_module_functions_ga684ce19906c5c5514fefa5bae41b9bb0.html#ga684ce19906c5c5514fefa5bae41b9bb0","snippet":"SetOutputModuleValue(${1:unsigned int offset}, ${2:variant value})","description":"Set Output module IOMap value."},{"leftLabel":"void","displayText":"SetLowSpeedModuleValue","type":"function","descriptionMoreURL":"group___command_module_functions_ga9c7d2af4bb4831dc7cf198329c0e772b.html#ga9c7d2af4bb4831dc7cf198329c0e772b","snippet":"SetLowSpeedModuleValue(${1:unsigned int offset}, ${2:variant value})","description":"Set Lowspeed module IOMap value."},{"leftLabel":"void","displayText":"SetDisplayModuleValue","type":"function","descriptionMoreURL":"group___command_module_functions_ga0e7f4325c94cb4a679cbcd459223ac52.html#ga0e7f4325c94cb4a679cbcd459223ac52","snippet":"SetDisplayModuleValue(${1:unsigned int offset}, ${2:variant value})","description":"Set Display module IOMap value."},{"leftLabel":"void","displayText":"SetCommModuleValue","type":"function","descriptionMoreURL":"group___command_module_functions_ga32d542510dcaeb23ab38e53ec150cbea.html#ga32d542510dcaeb23ab38e53ec150cbea","snippet":"SetCommModuleValue(${1:unsigned int offset}, ${2:variant value})","description":"Set Comm module IOMap value."},{"leftLabel":"void","displayText":"GetCommandModuleValue","type":"function","descriptionMoreURL":"group___command_module_functions_ga17e7f3db881d2815dbf4b5751c33fb45.html#ga17e7f3db881d2815dbf4b5751c33fb45","snippet":"GetCommandModuleValue(${1:unsigned int offset}, ${2:variant &value})","description":"Get Command module IOMap value."},{"leftLabel":"void","displayText":"GetLoaderModuleValue","type":"function","descriptionMoreURL":"group___command_module_functions_ga4254a491680a4e774330788388d50d61.html#ga4254a491680a4e774330788388d50d61","snippet":"GetLoaderModuleValue(${1:unsigned int offset}, ${2:variant &value})","description":"Get Loader module IOMap value."},{"leftLabel":"void","displayText":"GetSoundModuleValue","type":"function","descriptionMoreURL":"group___command_module_functions_ga04647ce2052a5d576164642b156db511.html#ga04647ce2052a5d576164642b156db511","snippet":"GetSoundModuleValue(${1:unsigned int offset}, ${2:variant &value})","description":"Get Sound module IOMap value."},{"leftLabel":"void","displayText":"GetButtonModuleValue","type":"function","descriptionMoreURL":"group___command_module_functions_ga46daccc6afc2f3dc6c158440bade4b36.html#ga46daccc6afc2f3dc6c158440bade4b36","snippet":"GetButtonModuleValue(${1:unsigned int offset}, ${2:variant &value})","description":"Get Button module IOMap value."},{"leftLabel":"void","displayText":"GetUIModuleValue","type":"function","descriptionMoreURL":"group___command_module_functions_gabdc537c3ae31eeb857d5e956921bdb81.html#gabdc537c3ae31eeb857d5e956921bdb81","snippet":"GetUIModuleValue(${1:unsigned int offset}, ${2:variant &value})","description":"Get Ui module IOMap value."},{"leftLabel":"void","displayText":"GetInputModuleValue","type":"function","descriptionMoreURL":"group___command_module_functions_ga3751d4aa53567e7b5fe3d0d966753959.html#ga3751d4aa53567e7b5fe3d0d966753959","snippet":"GetInputModuleValue(${1:unsigned int offset}, ${2:variant &value})","description":"Get Input module IOMap value."},{"leftLabel":"void","displayText":"GetOutputModuleValue","type":"function","descriptionMoreURL":"group___command_module_functions_ga5eda5c73f74b606a7fef7451524bad03.html#ga5eda5c73f74b606a7fef7451524bad03","snippet":"GetOutputModuleValue(${1:unsigned int offset}, ${2:variant &value})","description":"Get Output module IOMap value."},{"leftLabel":"void","displayText":"GetLowSpeedModuleValue","type":"function","descriptionMoreURL":"group___command_module_functions_ga9d3a79082188f0632ecfa67b251b1362.html#ga9d3a79082188f0632ecfa67b251b1362","snippet":"GetLowSpeedModuleValue(${1:unsigned int offset}, ${2:variant &value})","description":"Get LowSpeed module IOMap value."},{"leftLabel":"void","displayText":"GetDisplayModuleValue","type":"function","descriptionMoreURL":"group___command_module_functions_gaea8a97d919808edecb989d84e55b5bd2.html#gaea8a97d919808edecb989d84e55b5bd2","snippet":"GetDisplayModuleValue(${1:unsigned int offset}, ${2:variant &value})","description":"Get Display module IOMap value."},{"leftLabel":"void","displayText":"GetCommModuleValue","type":"function","descriptionMoreURL":"group___command_module_functions_ga0721e7f889fc06d5ae44a552c03a472f.html#ga0721e7f889fc06d5ae44a552c03a472f","snippet":"GetCommModuleValue(${1:unsigned int offset}, ${2:variant &value})","description":"Get Comm module IOMap value."},{"leftLabel":"void","displayText":"PowerDown","type":"function","descriptionMoreURL":"group___i_o_ctrl_module_functions_gad250149295f663a8d474fd25086fd376.html#gad250149295f663a8d474fd25086fd376","snippet":"PowerDown(${1:})","description":"Power down the NXT."},{"leftLabel":"void","displayText":"SleepNow","type":"function","descriptionMoreURL":"group___i_o_ctrl_module_functions_gadecafd9ae6d682ee5a26fdfe68d8cf85.html#gadecafd9ae6d682ee5a26fdfe68d8cf85","snippet":"SleepNow(${1:})","description":"Put the brick to sleep immediately."},{"leftLabel":"void","displayText":"RebootInFirmwareMode","type":"function","descriptionMoreURL":"group___i_o_ctrl_module_functions_ga64deba6187c8a5c061fcfed88b668566.html#ga64deba6187c8a5c061fcfed88b668566","snippet":"RebootInFirmwareMode(${1:})","description":"Reboot the NXT in firmware download mode."},{"leftLabel":"char","displayText":"JoystickMessageRead","type":"function","descriptionMoreURL":"group___comm_module_functions_ga7db28ed8b4ea16fd20208837bd711ed1.html#ga7db28ed8b4ea16fd20208837bd711ed1","snippet":"JoystickMessageRead(${1:byte queue}, ${2:JoystickMessageType &msg})","description":"Read a joystick message from a queue/mailbox."},{"leftLabel":"char","displayText":"JoystickExMessageRead","type":"function","descriptionMoreURL":"group___comm_module_functions_ga0a9463fe4061061aee60c8f6acd98db7.html#ga0a9463fe4061061aee60c8f6acd98db7","snippet":"JoystickExMessageRead(${1:byte queue}, ${2:JoystickExMessageType &msg})","description":"Read an extended joystick message from a queue/mailbox."},{"leftLabel":"char","displayText":"SendMessage","type":"function","descriptionMoreURL":"group___comm_module_functions_gaa0dcf38898e9b509650a456d1393e9c7.html#gaa0dcf38898e9b509650a456d1393e9c7","snippet":"SendMessage(${1:byte queue}, ${2:string msg})","description":"Send a message to a queue/mailbox."},{"leftLabel":"char","displayText":"ReceiveMessage","type":"function","descriptionMoreURL":"group___comm_module_functions_ga2d0f44fe54ee34627d4423de5a08539e.html#ga2d0f44fe54ee34627d4423de5a08539e","snippet":"ReceiveMessage(${1:byte queue}, ${2:bool clear}, ${3:string &msg})","description":"Read a message from a queue/mailbox."},{"leftLabel":"char","displayText":"BluetoothStatus","type":"function","descriptionMoreURL":"group___comm_module_functions_ga8bf586cf5f8a0e890c5413cce7e35f39.html#ga8bf586cf5f8a0e890c5413cce7e35f39","snippet":"BluetoothStatus(${1:byte conn})","description":"Check bluetooth status."},{"leftLabel":"char","displayText":"BluetoothWrite","type":"function","descriptionMoreURL":"group___comm_module_functions_ga9a937eb89f6f1f688388d2708ce3982f.html#ga9a937eb89f6f1f688388d2708ce3982f","snippet":"BluetoothWrite(${1:byte conn}, ${2:byte buffer[]})","description":"Write to a bluetooth connection."},{"leftLabel":"char","displayText":"RemoteConnectionWrite","type":"function","descriptionMoreURL":"group___comm_module_functions_gab3740a85298030954e0dae61179dd2af.html#gab3740a85298030954e0dae61179dd2af","snippet":"RemoteConnectionWrite(${1:byte conn}, ${2:byte buffer[]})","description":"Write to a remote connection."},{"leftLabel":"bool","displayText":"RemoteConnectionIdle","type":"function","descriptionMoreURL":"group___comm_module_functions_gaf4a3f74c4302a1a1c4749cf49966bd2f.html#gaf4a3f74c4302a1a1c4749cf49966bd2f","snippet":"RemoteConnectionIdle(${1:byte conn})","description":"Check if remote connection is idle."},{"leftLabel":"char","displayText":"SendRemoteBool","type":"function","descriptionMoreURL":"group___comm_module_functions_ga932a8bf1221cb52b1ce54e8392a2a785.html#ga932a8bf1221cb52b1ce54e8392a2a785","snippet":"SendRemoteBool(${1:byte conn}, ${2:byte queue}, ${3:bool bval})","description":"Send a boolean value to a remote mailbox."},{"leftLabel":"char","displayText":"SendRemoteNumber","type":"function","descriptionMoreURL":"group___comm_module_functions_ga30beab417cafc0c414eaea0cf58ada14.html#ga30beab417cafc0c414eaea0cf58ada14","snippet":"SendRemoteNumber(${1:byte conn}, ${2:byte queue}, ${3:long val})","description":"Send a numeric value to a remote mailbox."},{"leftLabel":"char","displayText":"SendRemoteString","type":"function","descriptionMoreURL":"group___comm_module_functions_gab0fbb5bd16ba155fe3a7a3ac541b4952.html#gab0fbb5bd16ba155fe3a7a3ac541b4952","snippet":"SendRemoteString(${1:byte conn}, ${2:byte queue}, ${3:string str})","description":"Send a string value to a remote mailbox."},{"leftLabel":"char","displayText":"SendResponseBool","type":"function","descriptionMoreURL":"group___comm_module_functions_gad9d1b72ebef21d78dc659465a6040874.html#gad9d1b72ebef21d78dc659465a6040874","snippet":"SendResponseBool(${1:byte queue}, ${2:bool bval})","description":"Write a boolean value to a local response mailbox."},{"leftLabel":"char","displayText":"SendResponseNumber","type":"function","descriptionMoreURL":"group___comm_module_functions_ga91ff51f864ad53c03403177dbc5b73d0.html#ga91ff51f864ad53c03403177dbc5b73d0","snippet":"SendResponseNumber(${1:byte queue}, ${2:long val})","description":"Write a numeric value to a local response mailbox."},{"leftLabel":"char","displayText":"SendResponseString","type":"function","descriptionMoreURL":"group___comm_module_functions_gae966a0a293b3e5e3b4ca41919bd3fc98.html#gae966a0a293b3e5e3b4ca41919bd3fc98","snippet":"SendResponseString(${1:byte queue}, ${2:string str})","description":"Write a string value to a local response mailbox."},{"leftLabel":"char","displayText":"ReceiveRemoteBool","type":"function","descriptionMoreURL":"group___comm_module_functions_ga512177a39ea1e88e3a63a895abed2d82.html#ga512177a39ea1e88e3a63a895abed2d82","snippet":"ReceiveRemoteBool(${1:byte queue}, ${2:bool clear}, ${3:bool &bval})","description":"Read a boolean value from a queue/mailbox."},{"leftLabel":"char","displayText":"ReceiveRemoteMessageEx","type":"function","descriptionMoreURL":"group___comm_module_functions_gaf2ae51daedc5449f0553ebc47ce9446e.html#gaf2ae51daedc5449f0553ebc47ce9446e","snippet":"ReceiveRemoteMessageEx(${1:byte queue}, ${2:bool clear}, ${3:string &str}, ${4:long &val}, ${5:bool &bval})","description":"Read a value from a queue/mailbox."},{"leftLabel":"char","displayText":"ReceiveRemoteNumber","type":"function","descriptionMoreURL":"group___comm_module_functions_ga6c1a6c444a5a91e662b218ea37dc0bae.html#ga6c1a6c444a5a91e662b218ea37dc0bae","snippet":"ReceiveRemoteNumber(${1:byte queue}, ${2:bool clear}, ${3:long &val})","description":"Read a numeric value from a queue/mailbox."},{"leftLabel":"char","displayText":"ReceiveRemoteString","type":"function","descriptionMoreURL":"group___comm_module_functions_gad6d57411062a96381d31f0b83c686b21.html#gad6d57411062a96381d31f0b83c686b21","snippet":"ReceiveRemoteString(${1:byte queue}, ${2:bool clear}, ${3:string &str})","description":"Read a string value from a queue/mailbox."},{"leftLabel":"char","displayText":"RemoteKeepAlive","type":"function","descriptionMoreURL":"group___comm_module_d_c_functions_ga077787b4e8e698a283aff23c529c6338.html#ga077787b4e8e698a283aff23c529c6338","snippet":"RemoteKeepAlive(${1:byte conn})","description":"Send a KeepAlive message."},{"leftLabel":"char","displayText":"RemoteMessageRead","type":"function","descriptionMoreURL":"group___comm_module_d_c_functions_ga9a6108ddeefefc5ff5a1893b16fce45a.html#ga9a6108ddeefefc5ff5a1893b16fce45a","snippet":"RemoteMessageRead(${1:byte conn}, ${2:byte queue})","description":"Send a MessageRead message."},{"leftLabel":"char","displayText":"RemoteMessageWrite","type":"function","descriptionMoreURL":"group___comm_module_d_c_functions_gaeb58ee321ceb422aa6096e53392d25de.html#gaeb58ee321ceb422aa6096e53392d25de","snippet":"RemoteMessageWrite(${1:byte conn}, ${2:byte queue}, ${3:string msg})","description":"Send a MessageWrite message."},{"leftLabel":"char","displayText":"RemotePlaySoundFile","type":"function","descriptionMoreURL":"group___comm_module_d_c_functions_ga07c4a4214471ac4a594c7b3c19a7333e.html#ga07c4a4214471ac4a594c7b3c19a7333e","snippet":"RemotePlaySoundFile(${1:byte conn}, ${2:string filename}, ${3:bool bloop})","description":"Send a PlaySoundFile message."},{"leftLabel":"char","displayText":"RemotePlayTone","type":"function","descriptionMoreURL":"group___comm_module_d_c_functions_ga4ee2a9d0917362d14a7045fda979e0fe.html#ga4ee2a9d0917362d14a7045fda979e0fe","snippet":"RemotePlayTone(${1:byte conn}, ${2:unsigned int frequency}, ${3:unsigned int duration})","description":"Send a PlayTone message."},{"leftLabel":"char","displayText":"RemoteResetMotorPosition","type":"function","descriptionMoreURL":"group___comm_module_d_c_functions_gac67efce61704d809226ae014ed0fd188.html#gac67efce61704d809226ae014ed0fd188","snippet":"RemoteResetMotorPosition(${1:byte conn}, ${2:byte port}, ${3:bool brelative})","description":"Send a ResetMotorPosition message."},{"leftLabel":"char","displayText":"RemoteResetScaledValue","type":"function","descriptionMoreURL":"group___comm_module_d_c_functions_ga367136db44b6a133988b1142ddaec1b6.html#ga367136db44b6a133988b1142ddaec1b6","snippet":"RemoteResetScaledValue(${1:byte conn}, ${2:byte port})","description":"Send a ResetScaledValue message."},{"leftLabel":"char","displayText":"RemoteSetInputMode","type":"function","descriptionMoreURL":"group___comm_module_d_c_functions_ga3c92f90fd5ffa0d6d8ee45c676c97249.html#ga3c92f90fd5ffa0d6d8ee45c676c97249","snippet":"RemoteSetInputMode(${1:byte conn}, ${2:byte port}, ${3:byte type}, ${4:byte mode})","description":"Send a SetInputMode message."},{"leftLabel":"char","displayText":"RemoteSetOutputState","type":"function","descriptionMoreURL":"group___comm_module_d_c_functions_ga9b80406ca9bd35fbc6d1ff38bb9a5a3f.html#ga9b80406ca9bd35fbc6d1ff38bb9a5a3f","snippet":"RemoteSetOutputState(${1:byte conn}, ${2:byte port}, ${3:char speed}, ${4:byte mode}, ${5:byte regmode}, ${6:char turnpct}, ${7:byte runstate}, ${8:unsigned long tacholimit})","description":"Send a SetOutputMode message."},{"leftLabel":"char","displayText":"RemoteStartProgram","type":"function","descriptionMoreURL":"group___comm_module_d_c_functions_gaa323856be7980bd6f82f8f87b74fb387.html#gaa323856be7980bd6f82f8f87b74fb387","snippet":"RemoteStartProgram(${1:byte conn}, ${2:string filename})","description":"Send a StartProgram message."},{"leftLabel":"char","displayText":"RemoteStopProgram","type":"function","descriptionMoreURL":"group___comm_module_d_c_functions_gadb8ddf6b9e434b053aac96a304a18f98.html#gadb8ddf6b9e434b053aac96a304a18f98","snippet":"RemoteStopProgram(${1:byte conn})","description":"Send a StopProgram message."},{"leftLabel":"char","displayText":"RemoteStopSound","type":"function","descriptionMoreURL":"group___comm_module_d_c_functions_ga7783a50c02443a19e76b0e5b86505c8e.html#ga7783a50c02443a19e76b0e5b86505c8e","snippet":"RemoteStopSound(${1:byte conn})","description":"Send a StopSound message."},{"leftLabel":"char","displayText":"RemoteGetOutputState","type":"function","descriptionMoreURL":"group___comm_module_d_c_functions_ga169521f86c6f66d01f8feffbd71d7331.html#ga169521f86c6f66d01f8feffbd71d7331","snippet":"RemoteGetOutputState(${1:byte conn}, ${2:OutputStateType &params})","description":"Send a GetOutputState message."},{"leftLabel":"char","displayText":"RemoteGetInputValues","type":"function","descriptionMoreURL":"group___comm_module_d_c_functions_ga3a6c4174d619d8eb79adb2fe2604ba01.html#ga3a6c4174d619d8eb79adb2fe2604ba01","snippet":"RemoteGetInputValues(${1:byte conn}, ${2:InputValuesType &params})","description":"Send a GetInputValues message."},{"leftLabel":"char","displayText":"RemoteGetBatteryLevel","type":"function","descriptionMoreURL":"group___comm_module_d_c_functions_ga6862d6ed8173f895052c1352b0635cfd.html#ga6862d6ed8173f895052c1352b0635cfd","snippet":"RemoteGetBatteryLevel(${1:byte conn}, ${2:int &value})","description":"Send a GetBatteryLevel message."},{"leftLabel":"char","displayText":"RemoteLowspeedGetStatus","type":"function","descriptionMoreURL":"group___comm_module_d_c_functions_ga77fac5e6923d913b5bca9644fca60b96.html#ga77fac5e6923d913b5bca9644fca60b96","snippet":"RemoteLowspeedGetStatus(${1:byte conn}, ${2:byte &value})","description":"Send a LowspeedGetStatus message."},{"leftLabel":"char","displayText":"RemoteLowspeedRead","type":"function","descriptionMoreURL":"group___comm_module_d_c_functions_ga60e4f54487492f881ff7d9187fe11c57.html#ga60e4f54487492f881ff7d9187fe11c57","snippet":"RemoteLowspeedRead(${1:byte conn}, ${2:byte port}, ${3:byte &bread}, ${4:byte &data[]})","description":"Send a LowspeedRead message."},{"leftLabel":"char","displayText":"RemoteGetCurrentProgramName","type":"function","descriptionMoreURL":"group___comm_module_d_c_functions_ga66605f295758b6f80c68e952af2410d3.html#ga66605f295758b6f80c68e952af2410d3","snippet":"RemoteGetCurrentProgramName(${1:byte conn}, ${2:string &name})","description":"Send a GetCurrentProgramName message."},{"leftLabel":"char","displayText":"RemoteDatalogRead","type":"function","descriptionMoreURL":"group___comm_module_d_c_functions_ga03de5da465c4187ce05f25d5b10e23da.html#ga03de5da465c4187ce05f25d5b10e23da","snippet":"RemoteDatalogRead(${1:byte conn}, ${2:bool remove}, ${3:byte &cnt}, ${4:byte &log[]})","description":"Send a DatalogRead message."},{"leftLabel":"char","displayText":"RemoteGetContactCount","type":"function","descriptionMoreURL":"group___comm_module_d_c_functions_gaa907266f6d94359ce5ab261c4e5b62c1.html#gaa907266f6d94359ce5ab261c4e5b62c1","snippet":"RemoteGetContactCount(${1:byte conn}, ${2:byte &cnt})","description":"Send a GetContactCount message."},{"leftLabel":"char","displayText":"RemoteGetContactName","type":"function","descriptionMoreURL":"group___comm_module_d_c_functions_gae85bc6e6ba61e957012a265779391aae.html#gae85bc6e6ba61e957012a265779391aae","snippet":"RemoteGetContactName(${1:byte conn}, ${2:byte idx}, ${3:string &name})","description":"Send a GetContactName message."},{"leftLabel":"char","displayText":"RemoteGetConnectionCount","type":"function","descriptionMoreURL":"group___comm_module_d_c_functions_ga0eb45ed37674e26b11c41d069476375b.html#ga0eb45ed37674e26b11c41d069476375b","snippet":"RemoteGetConnectionCount(${1:byte conn}, ${2:byte &cnt})","description":"Send a GetConnectionCount message."},{"leftLabel":"char","displayText":"RemoteGetConnectionName","type":"function","descriptionMoreURL":"group___comm_module_d_c_functions_ga12c97246832f0995b1f1d8723f5d6ce9.html#ga12c97246832f0995b1f1d8723f5d6ce9","snippet":"RemoteGetConnectionName(${1:byte conn}, ${2:byte idx}, ${3:string &name})","description":"Send a GetConnectionName message."},{"leftLabel":"char","displayText":"RemoteGetProperty","type":"function","descriptionMoreURL":"group___comm_module_d_c_functions_ga6febfa3d065ffb98427ff36b67b888d2.html#ga6febfa3d065ffb98427ff36b67b888d2","snippet":"RemoteGetProperty(${1:byte conn}, ${2:byte property}, ${3:variant &value})","description":"Send a GetProperty message."},{"leftLabel":"char","displayText":"RemoteResetTachoCount","type":"function","descriptionMoreURL":"group___comm_module_d_c_functions_ga5ba7f1e04cb196015267ba1054715112.html#ga5ba7f1e04cb196015267ba1054715112","snippet":"RemoteResetTachoCount(${1:byte conn}, ${2:byte port})","description":"Send a ResetTachoCount message."},{"leftLabel":"char","displayText":"RemoteDatalogSetTimes","type":"function","descriptionMoreURL":"group___comm_module_d_c_functions_ga2308cf81f12ecaa6f19d982797151a6a.html#ga2308cf81f12ecaa6f19d982797151a6a","snippet":"RemoteDatalogSetTimes(${1:byte conn}, ${2:long synctime})","description":"Send a DatalogSetTimes message."},{"leftLabel":"char","displayText":"RemoteSetProperty","type":"function","descriptionMoreURL":"group___comm_module_d_c_functions_gaaa3818ca57ce0177668ab74b092ae4ba.html#gaaa3818ca57ce0177668ab74b092ae4ba","snippet":"RemoteSetProperty(${1:byte conn}, ${2:byte prop}, ${3:variant value})","description":"Send a SetProperty message."},{"leftLabel":"char","displayText":"RemoteLowspeedWrite","type":"function","descriptionMoreURL":"group___comm_module_d_c_functions_ga8c4817f0e668c5794a3cb92bf28a28c2.html#ga8c4817f0e668c5794a3cb92bf28a28c2","snippet":"RemoteLowspeedWrite(${1:byte conn}, ${2:byte port}, ${3:byte txlen}, ${4:byte rxlen}, ${5:byte data[]})","description":"Send a LowspeedWrite message."},{"leftLabel":"char","displayText":"RemoteOpenRead","type":"function","descriptionMoreURL":"group___comm_module_s_c_functions_ga4aa703b4dabb872e8055a78ef63d174f.html#ga4aa703b4dabb872e8055a78ef63d174f","snippet":"RemoteOpenRead(${1:byte conn}, ${2:string filename}, ${3:byte &handle}, ${4:long &size})","description":"Send an OpenRead message."},{"leftLabel":"char","displayText":"RemoteOpenAppendData","type":"function","descriptionMoreURL":"group___comm_module_s_c_functions_ga6e37e5e663178e0b1601f4b819598c7b.html#ga6e37e5e663178e0b1601f4b819598c7b","snippet":"RemoteOpenAppendData(${1:byte conn}, ${2:string filename}, ${3:byte &handle}, ${4:long &size})","description":"Send an OpenAppendData message."},{"leftLabel":"char","displayText":"RemoteDeleteFile","type":"function","descriptionMoreURL":"group___comm_module_s_c_functions_gae5a4cb4a4f5ffd1864004bdc1ff0f8d3.html#gae5a4cb4a4f5ffd1864004bdc1ff0f8d3","snippet":"RemoteDeleteFile(${1:byte conn}, ${2:string filename})","description":"Send a DeleteFile message."},{"leftLabel":"char","displayText":"RemoteFindFirstFile","type":"function","descriptionMoreURL":"group___comm_module_s_c_functions_ga89303219ff446513963d4a1a74911d1a.html#ga89303219ff446513963d4a1a74911d1a","snippet":"RemoteFindFirstFile(${1:byte conn}, ${2:string mask}, ${3:byte &handle}, ${4:string &name}, ${5:long &size})","description":"Send a FindFirstFile message."},{"leftLabel":"char","displayText":"RemoteGetFirmwareVersion","type":"function","descriptionMoreURL":"group___comm_module_s_c_functions_ga3ee6090fa9666fc51f4f2f39ba50abd1.html#ga3ee6090fa9666fc51f4f2f39ba50abd1","snippet":"RemoteGetFirmwareVersion(${1:byte conn}, ${2:byte &pmin}, ${3:byte &pmaj}, ${4:byte &fmin}, ${5:byte &fmaj})","description":"Send a GetFirmwareVersion message."},{"leftLabel":"char","displayText":"RemoteGetBluetoothAddress","type":"function","descriptionMoreURL":"group___comm_module_s_c_functions_ga711973b883010404e1dae802c01d012e.html#ga711973b883010404e1dae802c01d012e","snippet":"RemoteGetBluetoothAddress(${1:byte conn}, ${2:byte &btaddr[]})","description":"Send a GetBluetoothAddress message."},{"leftLabel":"char","displayText":"RemoteGetDeviceInfo","type":"function","descriptionMoreURL":"group___comm_module_s_c_functions_gad0b4f023ebcf3e66ec9aa8451b584851.html#gad0b4f023ebcf3e66ec9aa8451b584851","snippet":"RemoteGetDeviceInfo(${1:byte conn}, ${2:string &name}, ${3:byte &btaddr[]}, ${4:byte &btsignal[]}, ${5:long &freemem})","description":"Send a GetDeviceInfo message."},{"leftLabel":"char","displayText":"RemoteDeleteUserFlash","type":"function","descriptionMoreURL":"group___comm_module_s_c_functions_gad6a9c659646130ff73a94cd0c4a22227.html#gad6a9c659646130ff73a94cd0c4a22227","snippet":"RemoteDeleteUserFlash(${1:byte conn})","description":"Send a DeleteUserFlash message."},{"leftLabel":"char","displayText":"RemoteOpenWrite","type":"function","descriptionMoreURL":"group___comm_module_s_c_functions_ga72d62f363254c03da7c15f73bec26445.html#ga72d62f363254c03da7c15f73bec26445","snippet":"RemoteOpenWrite(${1:byte conn}, ${2:string filename}, ${3:long size}, ${4:byte &handle})","description":"Send an OpenWrite message."},{"leftLabel":"char","displayText":"RemoteOpenWriteLinear","type":"function","descriptionMoreURL":"group___comm_module_s_c_functions_gabd43c2a337ccf5ad92a7669909a5c12b.html#gabd43c2a337ccf5ad92a7669909a5c12b","snippet":"RemoteOpenWriteLinear(${1:byte conn}, ${2:string filename}, ${3:long size}, ${4:byte &handle})","description":"Send an OpenWriteLinear message."},{"leftLabel":"char","displayText":"RemoteOpenWriteData","type":"function","descriptionMoreURL":"group___comm_module_s_c_functions_ga85d595ef46112bbbf037d6631ce28ba8.html#ga85d595ef46112bbbf037d6631ce28ba8","snippet":"RemoteOpenWriteData(${1:byte conn}, ${2:string filename}, ${3:long size}, ${4:byte &handle})","description":"Send an OpenWriteData message."},{"leftLabel":"char","displayText":"RemoteCloseFile","type":"function","descriptionMoreURL":"group___comm_module_s_c_functions_gaf92a466e53fc6cdd513e7f4275a38589.html#gaf92a466e53fc6cdd513e7f4275a38589","snippet":"RemoteCloseFile(${1:byte conn}, ${2:byte handle})","description":"Send a CloseFile message."},{"leftLabel":"char","displayText":"RemoteFindNextFile","type":"function","descriptionMoreURL":"group___comm_module_s_c_functions_gacda7a84736eb12a97c784f142d2b65c3.html#gacda7a84736eb12a97c784f142d2b65c3","snippet":"RemoteFindNextFile(${1:byte conn}, ${2:byte &handle}, ${3:string &name}, ${4:long &size})","description":"Send a FindNextFile message."},{"leftLabel":"char","displayText":"RemotePollCommandLength","type":"function","descriptionMoreURL":"group___comm_module_s_c_functions_gaf8c6ca705777ee91e4f9b9dd4434dd85.html#gaf8c6ca705777ee91e4f9b9dd4434dd85","snippet":"RemotePollCommandLength(${1:byte conn}, ${2:byte bufnum}, ${3:byte &length})","description":"Send a PollCommandLength message."},{"leftLabel":"char","displayText":"RemoteWrite","type":"function","descriptionMoreURL":"group___comm_module_s_c_functions_ga0a475f6342fbd11f4793d60f44491c82.html#ga0a475f6342fbd11f4793d60f44491c82","snippet":"RemoteWrite(${1:byte conn}, ${2:byte &handle}, ${3:int &numbytes}, ${4:byte data[]})","description":"Send a Write message."},{"leftLabel":"char","displayText":"RemoteRead","type":"function","descriptionMoreURL":"group___comm_module_s_c_functions_gae2fa838455fc2736a4be80f5e1ff20cc.html#gae2fa838455fc2736a4be80f5e1ff20cc","snippet":"RemoteRead(${1:byte conn}, ${2:byte &handle}, ${3:int &numbytes}, ${4:byte &data[]})","description":"Send a Read message."},{"leftLabel":"char","displayText":"RemoteIOMapRead","type":"function","descriptionMoreURL":"group___comm_module_s_c_functions_ga0d01f3b93faf8f05c2e5c9626eb82ef9.html#ga0d01f3b93faf8f05c2e5c9626eb82ef9","snippet":"RemoteIOMapRead(${1:byte conn}, ${2:long id}, ${3:int offset}, ${4:int &numbytes}, ${5:byte &data[]})","description":"Send an IOMapRead message."},{"leftLabel":"char","displayText":"RemotePollCommand","type":"function","descriptionMoreURL":"group___comm_module_s_c_functions_ga137479ad4fd2d741e8c13e50fe07adcd.html#ga137479ad4fd2d741e8c13e50fe07adcd","snippet":"RemotePollCommand(${1:byte conn}, ${2:byte bufnum}, ${3:byte &len}, ${4:byte &data[]})","description":"Send a PollCommand message."},{"leftLabel":"char","displayText":"RemoteRenameFile","type":"function","descriptionMoreURL":"group___comm_module_s_c_functions_ga44e0ffd40f5db562e232d38b15d84890.html#ga44e0ffd40f5db562e232d38b15d84890","snippet":"RemoteRenameFile(${1:byte conn}, ${2:string oldname}, ${3:string newname})","description":"Send a RenameFile message."},{"leftLabel":"char","displayText":"RemoteBluetoothFactoryReset","type":"function","descriptionMoreURL":"group___comm_module_s_c_functions_ga14e60e2d403bf5c3d3777e51a5a3ccc0.html#ga14e60e2d403bf5c3d3777e51a5a3ccc0","snippet":"RemoteBluetoothFactoryReset(${1:byte conn})","description":"Send a BluetoothFactoryReset message."},{"leftLabel":"char","displayText":"RemoteIOMapWriteValue","type":"function","descriptionMoreURL":"group___comm_module_s_c_functions_gaab1b02896f4c501a8fdaa6dcb5526e19.html#gaab1b02896f4c501a8fdaa6dcb5526e19","snippet":"RemoteIOMapWriteValue(${1:byte conn}, ${2:long id}, ${3:int offset}, ${4:variant value})","description":"Send an IOMapWrite value message."},{"leftLabel":"char","displayText":"RemoteIOMapWriteBytes","type":"function","descriptionMoreURL":"group___comm_module_s_c_functions_ga908adfd93089d4314a9e92488b9b24eb.html#ga908adfd93089d4314a9e92488b9b24eb","snippet":"RemoteIOMapWriteBytes(${1:byte conn}, ${2:long id}, ${3:int offset}, ${4:byte data[]})","description":"Send an IOMapWrite bytes message."},{"leftLabel":"char","displayText":"RemoteSetBrickName","type":"function","descriptionMoreURL":"group___comm_module_s_c_functions_ga15a9e643b85cd8f8dff094711824e57e.html#ga15a9e643b85cd8f8dff094711824e57e","snippet":"RemoteSetBrickName(${1:byte conn}, ${2:string name})","description":"Send a SetBrickName message."},{"leftLabel":"void","displayText":"UseRS485","type":"function","descriptionMoreURL":"group___comm_module_functions_ga1715615d9c3c95830b2bf720dab73d7a.html#ga1715615d9c3c95830b2bf720dab73d7a","snippet":"UseRS485(${1:void})","description":"Use the RS485 port."},{"leftLabel":"char","displayText":"RS485Control","type":"function","descriptionMoreURL":"group___comm_module_functions_ga2602cfd3ec9185597a98e1e66714030e.html#ga2602cfd3ec9185597a98e1e66714030e","snippet":"RS485Control(${1:byte cmd}, ${2:byte baud}, ${3:unsigned int mode})","description":"Control the RS485 port."},{"leftLabel":"byte","displayText":"RS485DataAvailable","type":"function","descriptionMoreURL":"group___comm_module_functions_ga481910c60e5fc16e9fbd07c6e26e3561.html#ga481910c60e5fc16e9fbd07c6e26e3561","snippet":"RS485DataAvailable(${1:void})","description":"Check for RS485 available data."},{"leftLabel":"char","displayText":"RS485Initialize","type":"function","descriptionMoreURL":"group___comm_module_functions_gaacdf99e14d9bda7be7c8d1eabbaf49db.html#gaacdf99e14d9bda7be7c8d1eabbaf49db","snippet":"RS485Initialize(${1:void})","description":"Initialize RS485 port."},{"leftLabel":"char","displayText":"RS485Disable","type":"function","descriptionMoreURL":"group___comm_module_functions_ga840a318618b81405a3ad2fedacf8aa13.html#ga840a318618b81405a3ad2fedacf8aa13","snippet":"RS485Disable(${1:void})","description":"Disable RS485."},{"leftLabel":"char","displayText":"RS485Enable","type":"function","descriptionMoreURL":"group___comm_module_functions_ga8e96c959c2356edff50aebc93923eca4.html#ga8e96c959c2356edff50aebc93923eca4","snippet":"RS485Enable(${1:void})","description":"Enable RS485."},{"leftLabel":"char","displayText":"RS485Read","type":"function","descriptionMoreURL":"group___comm_module_functions_ga9cd4f3e460395836bb72ebb60741a7b3.html#ga9cd4f3e460395836bb72ebb60741a7b3","snippet":"RS485Read(${1:byte &buffer[]})","description":"Read RS485 data."},{"leftLabel":"char","displayText":"RS485ReadEx","type":"function","descriptionMoreURL":"group___comm_module_functions_ga263394cc24582665fe10d69c90c32a71.html#ga263394cc24582665fe10d69c90c32a71","snippet":"RS485ReadEx(${1:byte &buffer[]}, ${2:byte buflen})","description":"Read limited RS485 data."},{"leftLabel":"byte","displayText":"RS485SendingData","type":"function","descriptionMoreURL":"group___comm_module_functions_ga546e38880720cf6296a69af77e607de0.html#ga546e38880720cf6296a69af77e607de0","snippet":"RS485SendingData(${1:void})","description":"Is RS485 sending data."},{"leftLabel":"void","displayText":"RS485Status","type":"function","descriptionMoreURL":"group___comm_module_functions_gabcf800d305515226ac764bf97bd4c3d4.html#gabcf800d305515226ac764bf97bd4c3d4","snippet":"RS485Status(${1:byte &sendingData}, ${2:byte &dataAvail})","description":"Check RS485 status."},{"leftLabel":"char","displayText":"RS485Uart","type":"function","descriptionMoreURL":"group___comm_module_functions_gaf9941cbe12019af71e6176cbe431c9bb.html#gaf9941cbe12019af71e6176cbe431c9bb","snippet":"RS485Uart(${1:byte baud}, ${2:unsigned int mode})","description":"Configure RS485 UART."},{"leftLabel":"char","displayText":"RS485Write","type":"function","descriptionMoreURL":"group___comm_module_functions_ga29d48221788b707299a4d76ebb6cf127.html#ga29d48221788b707299a4d76ebb6cf127","snippet":"RS485Write(${1:byte buffer[]})","description":"Write RS485 data."},{"leftLabel":"char","displayText":"SendRS485Bool","type":"function","descriptionMoreURL":"group___comm_module_functions_gac9e90050f945ba33437e5ee15ae9da3e.html#gac9e90050f945ba33437e5ee15ae9da3e","snippet":"SendRS485Bool(${1:bool bval})","description":"Write RS485 boolean."},{"leftLabel":"char","displayText":"SendRS485Number","type":"function","descriptionMoreURL":"group___comm_module_functions_ga9a060947b611a17c6d326c8937c783c2.html#ga9a060947b611a17c6d326c8937c783c2","snippet":"SendRS485Number(${1:long val})","description":"Write RS485 numeric."},{"leftLabel":"char","displayText":"SendRS485String","type":"function","descriptionMoreURL":"group___comm_module_functions_gae0749c3912f69b803ad5d30fee650af3.html#gae0749c3912f69b803ad5d30fee650af3","snippet":"SendRS485String(${1:string str})","description":"Write RS485 string."},{"leftLabel":"void","displayText":"GetBTInputBuffer","type":"function","descriptionMoreURL":"group___comm_module_functions_gad6db7e1fdbf367e934284736c53cf9b8.html#gad6db7e1fdbf367e934284736c53cf9b8","snippet":"GetBTInputBuffer(${1:const byte offset}, ${2:byte cnt}, ${3:byte &data[]})","description":"Get bluetooth input buffer data."},{"leftLabel":"void","displayText":"GetBTOutputBuffer","type":"function","descriptionMoreURL":"group___comm_module_functions_ga5302c6b28eb5167027d0669bf47e1cbe.html#ga5302c6b28eb5167027d0669bf47e1cbe","snippet":"GetBTOutputBuffer(${1:const byte offset}, ${2:byte cnt}, ${3:byte &data[]})","description":"Get bluetooth output buffer data."},{"leftLabel":"void","displayText":"GetHSInputBuffer","type":"function","descriptionMoreURL":"group___comm_module_functions_gafc2ef00546b9a9d1909dbfc4be248086.html#gafc2ef00546b9a9d1909dbfc4be248086","snippet":"GetHSInputBuffer(${1:const byte offset}, ${2:byte cnt}, ${3:byte &data[]})","description":"Get hi-speed port input buffer data."},{"leftLabel":"void","displayText":"GetHSOutputBuffer","type":"function","descriptionMoreURL":"group___comm_module_functions_gaf8ef4b0c79e96f5564c7ef5fa57a4864.html#gaf8ef4b0c79e96f5564c7ef5fa57a4864","snippet":"GetHSOutputBuffer(${1:const byte offset}, ${2:byte cnt}, ${3:byte &data[]})","description":"Get hi-speed port output buffer data."},{"leftLabel":"void","displayText":"GetUSBInputBuffer","type":"function","descriptionMoreURL":"group___comm_module_functions_gaa59e9b3272ab47d6c8df390e416825ba.html#gaa59e9b3272ab47d6c8df390e416825ba","snippet":"GetUSBInputBuffer(${1:const byte offset}, ${2:byte cnt}, ${3:byte &data[]})","description":"Get usb input buffer data."},{"leftLabel":"void","displayText":"GetUSBOutputBuffer","type":"function","descriptionMoreURL":"group___comm_module_functions_ga7347a4bc00f35558b267ec6c9ddf9c52.html#ga7347a4bc00f35558b267ec6c9ddf9c52","snippet":"GetUSBOutputBuffer(${1:const byte offset}, ${2:byte cnt}, ${3:byte &data[]})","description":"Get usb output buffer data."},{"leftLabel":"void","displayText":"GetUSBPollBuffer","type":"function","descriptionMoreURL":"group___comm_module_functions_ga197af024a3921861b671bada294a1100.html#ga197af024a3921861b671bada294a1100","snippet":"GetUSBPollBuffer(${1:const byte offset}, ${2:byte cnt}, ${3:byte &data[]})","description":"Get usb poll buffer data."},{"leftLabel":"string","displayText":"BTDeviceName","type":"function","descriptionMoreURL":"group___comm_module_functions_ga464576a706a7c09b8afb212806d610d7.html#ga464576a706a7c09b8afb212806d610d7","snippet":"BTDeviceName(${1:const byte devidx})","description":"Get bluetooth device name."},{"leftLabel":"string","displayText":"BTConnectionName","type":"function","descriptionMoreURL":"group___comm_module_functions_ga24b328638653be852965d36f1c2a4a3f.html#ga24b328638653be852965d36f1c2a4a3f","snippet":"BTConnectionName(${1:const byte conn})","description":"Get bluetooth device name."},{"leftLabel":"string","displayText":"BTConnectionPinCode","type":"function","descriptionMoreURL":"group___comm_module_functions_ga3fb32167160f1738ad152141a0de0218.html#ga3fb32167160f1738ad152141a0de0218","snippet":"BTConnectionPinCode(${1:const byte conn})","description":"Get bluetooth device pin code."},{"leftLabel":"string","displayText":"BrickDataName","type":"function","descriptionMoreURL":"group___comm_module_functions_gafc78b73002bf89829b36f51f5831bbf6.html#gafc78b73002bf89829b36f51f5831bbf6","snippet":"BrickDataName(${1:void})","description":"Get NXT name."},{"leftLabel":"void","displayText":"GetBTDeviceAddress","type":"function","descriptionMoreURL":"group___comm_module_functions_ga64e935a2d94d0ab4bd2511a1dcf3f24f.html#ga64e935a2d94d0ab4bd2511a1dcf3f24f","snippet":"GetBTDeviceAddress(${1:const byte devidx}, ${2:byte &data[]})","description":"Get bluetooth device address."},{"leftLabel":"void","displayText":"GetBTConnectionAddress","type":"function","descriptionMoreURL":"group___comm_module_functions_ga78c493e4889af7d4d08a6ddb2a2ac339.html#ga78c493e4889af7d4d08a6ddb2a2ac339","snippet":"GetBTConnectionAddress(${1:const byte conn}, ${2:byte &data[]})","description":"Get bluetooth device address."},{"leftLabel":"void","displayText":"GetBrickDataAddress","type":"function","descriptionMoreURL":"group___comm_module_functions_gad14f5765f2f0fc72ec89bb1e853e0094.html#gad14f5765f2f0fc72ec89bb1e853e0094","snippet":"GetBrickDataAddress(${1:byte &data[]})","description":"Get NXT address."},{"leftLabel":"long","displayText":"BTDeviceClass","type":"function","descriptionMoreURL":"group___comm_module_functions_ga17d9fc1ff643f609ace6e1d3a2be2258.html#ga17d9fc1ff643f609ace6e1d3a2be2258","snippet":"BTDeviceClass(${1:const byte devidx})","description":"Get bluetooth device class."},{"leftLabel":"byte","displayText":"BTDeviceStatus","type":"function","descriptionMoreURL":"group___comm_module_functions_ga592bac36f3d06325078d6b22d01865af.html#ga592bac36f3d06325078d6b22d01865af","snippet":"BTDeviceStatus(${1:const byte devidx})","description":"Get bluetooth device status."},{"leftLabel":"long","displayText":"BTConnectionClass","type":"function","descriptionMoreURL":"group___comm_module_functions_ga157e3f7b381b32b40c43aa7c8aa4994d.html#ga157e3f7b381b32b40c43aa7c8aa4994d","snippet":"BTConnectionClass(${1:const byte conn})","description":"Get bluetooth device class."},{"leftLabel":"byte","displayText":"BTConnectionHandleNum","type":"function","descriptionMoreURL":"group___comm_module_functions_ga0ed86d44c42b9a41482c9aa974b0fc69.html#ga0ed86d44c42b9a41482c9aa974b0fc69","snippet":"BTConnectionHandleNum(${1:const byte conn})","description":"Get bluetooth device handle number."},{"leftLabel":"byte","displayText":"BTConnectionStreamStatus","type":"function","descriptionMoreURL":"group___comm_module_functions_ga7f884202b0a8f47d0384ec0a7c3e3bbf.html#ga7f884202b0a8f47d0384ec0a7c3e3bbf","snippet":"BTConnectionStreamStatus(${1:const byte conn})","description":"Get bluetooth device stream status."},{"leftLabel":"byte","displayText":"BTConnectionLinkQuality","type":"function","descriptionMoreURL":"group___comm_module_functions_ga071a9a24c6ae17797f41a5ba85e0b542.html#ga071a9a24c6ae17797f41a5ba85e0b542","snippet":"BTConnectionLinkQuality(${1:const byte conn})","description":"Get bluetooth device link quality."},{"leftLabel":"int","displayText":"BrickDataBluecoreVersion","type":"function","descriptionMoreURL":"group___comm_module_functions_ga964c5e7ad4e902a12a46add60ed0f0a0.html#ga964c5e7ad4e902a12a46add60ed0f0a0","snippet":"BrickDataBluecoreVersion(${1:void})","description":"Get NXT bluecore version."},{"leftLabel":"byte","displayText":"BrickDataBtStateStatus","type":"function","descriptionMoreURL":"group___comm_module_functions_ga770a417df78614fc859773a1b4a37ad4.html#ga770a417df78614fc859773a1b4a37ad4","snippet":"BrickDataBtStateStatus(${1:void})","description":"Get NXT bluetooth state status."},{"leftLabel":"byte","displayText":"BrickDataBtHardwareStatus","type":"function","descriptionMoreURL":"group___comm_module_functions_ga9a612a88771a4cf6b06fd78cddfc7fbf.html#ga9a612a88771a4cf6b06fd78cddfc7fbf","snippet":"BrickDataBtHardwareStatus(${1:void})","description":"Get NXT bluetooth hardware status."},{"leftLabel":"byte","displayText":"BrickDataTimeoutValue","type":"function","descriptionMoreURL":"group___comm_module_functions_ga26b7c183b4b20e2d857ec3c8007084d1.html#ga26b7c183b4b20e2d857ec3c8007084d1","snippet":"BrickDataTimeoutValue(${1:void})","description":"Get NXT bluetooth timeout value."},{"leftLabel":"byte","displayText":"BTInputBufferInPtr","type":"function","descriptionMoreURL":"group___comm_module_functions_ga86965453f6c57355ce2ef2ff8efb8fa6.html#ga86965453f6c57355ce2ef2ff8efb8fa6","snippet":"BTInputBufferInPtr(${1:void})","description":"Get bluetooth input buffer in-pointer."},{"leftLabel":"byte","displayText":"BTInputBufferOutPtr","type":"function","descriptionMoreURL":"group___comm_module_functions_gad28481b8554af8edbf807ced44742760.html#gad28481b8554af8edbf807ced44742760","snippet":"BTInputBufferOutPtr(${1:void})","description":"Get bluetooth input buffer out-pointer."},{"leftLabel":"byte","displayText":"BTOutputBufferInPtr","type":"function","descriptionMoreURL":"group___comm_module_functions_gad4bd4955a793acc69d8347dcf14c4478.html#gad4bd4955a793acc69d8347dcf14c4478","snippet":"BTOutputBufferInPtr(${1:void})","description":"Get bluetooth output buffer in-pointer."},{"leftLabel":"byte","displayText":"BTOutputBufferOutPtr","type":"function","descriptionMoreURL":"group___comm_module_functions_ga2090ab579db1eb65b8c4e0b7a0322389.html#ga2090ab579db1eb65b8c4e0b7a0322389","snippet":"BTOutputBufferOutPtr(${1:void})","description":"Get bluetooth output buffer out-pointer."},{"leftLabel":"byte","displayText":"HSInputBufferInPtr","type":"function","descriptionMoreURL":"group___comm_module_functions_ga31416415da33867d12070d2eb7ab684b.html#ga31416415da33867d12070d2eb7ab684b","snippet":"HSInputBufferInPtr(${1:void})","description":"Get hi-speed port input buffer in-pointer."},{"leftLabel":"byte","displayText":"HSInputBufferOutPtr","type":"function","descriptionMoreURL":"group___comm_module_functions_ga47eaa9a3a1346a84cb3181a6a8dc1e5c.html#ga47eaa9a3a1346a84cb3181a6a8dc1e5c","snippet":"HSInputBufferOutPtr(${1:void})","description":"Get hi-speed port input buffer out-pointer."},{"leftLabel":"byte","displayText":"HSOutputBufferInPtr","type":"function","descriptionMoreURL":"group___comm_module_functions_gac069cf44817633ba823cdaaf0fbb9279.html#gac069cf44817633ba823cdaaf0fbb9279","snippet":"HSOutputBufferInPtr(${1:void})","description":"Get hi-speed port output buffer in-pointer."},{"leftLabel":"byte","displayText":"HSOutputBufferOutPtr","type":"function","descriptionMoreURL":"group___comm_module_functions_gaaf62d2ac0f41bde9fd908a2e51ea82a9.html#gaaf62d2ac0f41bde9fd908a2e51ea82a9","snippet":"HSOutputBufferOutPtr(${1:void})","description":"Get hi-speed port output buffer out-pointer."},{"leftLabel":"byte","displayText":"USBInputBufferInPtr","type":"function","descriptionMoreURL":"group___comm_module_functions_gaeea7436f6eccd3dfb1744fbb95d043c1.html#gaeea7436f6eccd3dfb1744fbb95d043c1","snippet":"USBInputBufferInPtr(${1:void})","description":"Get usb port input buffer in-pointer."},{"leftLabel":"byte","displayText":"USBInputBufferOutPtr","type":"function","descriptionMoreURL":"group___comm_module_functions_ga07ae3065564a6dc8ce8668d61b7b49f0.html#ga07ae3065564a6dc8ce8668d61b7b49f0","snippet":"USBInputBufferOutPtr(${1:void})","description":"Get usb port input buffer out-pointer."},{"leftLabel":"byte","displayText":"USBOutputBufferInPtr","type":"function","descriptionMoreURL":"group___comm_module_functions_gab8e5fcc3c3a0ff60ea3dfccaa5dd8665.html#gab8e5fcc3c3a0ff60ea3dfccaa5dd8665","snippet":"USBOutputBufferInPtr(${1:void})","description":"Get usb port output buffer in-pointer."},{"leftLabel":"byte","displayText":"USBOutputBufferOutPtr","type":"function","descriptionMoreURL":"group___comm_module_functions_ga68fbaae4d1fa7112311ad270286dbb6f.html#ga68fbaae4d1fa7112311ad270286dbb6f","snippet":"USBOutputBufferOutPtr(${1:void})","description":"Get usb port output buffer out-pointer."},{"leftLabel":"byte","displayText":"USBPollBufferInPtr","type":"function","descriptionMoreURL":"group___comm_module_functions_ga7165df1cfc5955382c91c2cb30a8cada.html#ga7165df1cfc5955382c91c2cb30a8cada","snippet":"USBPollBufferInPtr(${1:void})","description":"Get usb port poll buffer in-pointer."},{"leftLabel":"byte","displayText":"USBPollBufferOutPtr","type":"function","descriptionMoreURL":"group___comm_module_functions_gafdee731cd61f12e278523a7fba45b4c7.html#gafdee731cd61f12e278523a7fba45b4c7","snippet":"USBPollBufferOutPtr(${1:void})","description":"Get usb port poll buffer out-pointer."},{"leftLabel":"byte","displayText":"BTDeviceCount","type":"function","descriptionMoreURL":"group___comm_module_functions_gac15f8dd562f2563f7ba0a4c08a182913.html#gac15f8dd562f2563f7ba0a4c08a182913","snippet":"BTDeviceCount(${1:void})","description":"Get bluetooth device count."},{"leftLabel":"byte","displayText":"BTDeviceNameCount","type":"function","descriptionMoreURL":"group___comm_module_functions_ga7421bfab9a3527c129805c75a4e50b78.html#ga7421bfab9a3527c129805c75a4e50b78","snippet":"BTDeviceNameCount(${1:void})","description":"Get bluetooth device name count."},{"leftLabel":"byte","displayText":"HSFlags","type":"function","descriptionMoreURL":"group___comm_module_functions_ga2dfd219872dde743cc5dfa24c142cad3.html#ga2dfd219872dde743cc5dfa24c142cad3","snippet":"HSFlags(${1:void})","description":"Get hi-speed port flags."},{"leftLabel":"byte","displayText":"HSSpeed","type":"function","descriptionMoreURL":"group___comm_module_functions_ga11ee13540fc96d6ce2864d0e1ff75c37.html#ga11ee13540fc96d6ce2864d0e1ff75c37","snippet":"HSSpeed(${1:void})","description":"Get hi-speed port speed."},{"leftLabel":"byte","displayText":"HSState","type":"function","descriptionMoreURL":"group___comm_module_functions_ga9d03b106378bf478570240daf77d1679.html#ga9d03b106378bf478570240daf77d1679","snippet":"HSState(${1:void})","description":"Get hi-speed port state."},{"leftLabel":"byte","displayText":"HSAddress","type":"function","descriptionMoreURL":"group___comm_module_functions_ga641ac463478008371d91eb5d000ed6b0.html#ga641ac463478008371d91eb5d000ed6b0","snippet":"HSAddress(${1:void})","description":"Get hi-speed port address."},{"leftLabel":"int","displayText":"HSMode","type":"function","descriptionMoreURL":"group___comm_module_functions_ga1225d66a464ad788be40f93d8d526b66.html#ga1225d66a464ad788be40f93d8d526b66","snippet":"HSMode(${1:void})","description":"Get hi-speed port mode."},{"leftLabel":"int","displayText":"BTDataMode","type":"function","descriptionMoreURL":"group___comm_module_functions_gaa10c8e649787c11d9430c0e9b868f1c3.html#gaa10c8e649787c11d9430c0e9b868f1c3","snippet":"BTDataMode(${1:void})","description":"Get Bluetooth data mode."},{"leftLabel":"int","displayText":"HSDataMode","type":"function","descriptionMoreURL":"group___comm_module_functions_ga7f935b92a9ce9b322c7d3d34453609d7.html#ga7f935b92a9ce9b322c7d3d34453609d7","snippet":"HSDataMode(${1:void})","description":"Get hi-speed port datamode."},{"leftLabel":"byte","displayText":"USBState","type":"function","descriptionMoreURL":"group___comm_module_functions_gae7579412c21a9ae26b4f36e86929fd11.html#gae7579412c21a9ae26b4f36e86929fd11","snippet":"USBState(${1:void})","description":"Get USB state."},{"leftLabel":"void","displayText":"SetBTInputBuffer","type":"function","descriptionMoreURL":"group___comm_module_functions_ga3f4ee10cce5cd2674ee42de23a8eab90.html#ga3f4ee10cce5cd2674ee42de23a8eab90","snippet":"SetBTInputBuffer(${1:const byte offset}, ${2:byte cnt}, ${3:byte data[]})","description":"Set bluetooth input buffer data."},{"leftLabel":"void","displayText":"SetBTInputBufferInPtr","type":"function","descriptionMoreURL":"group___comm_module_functions_gaa626037ee52b034c148edc1303831b85.html#gaa626037ee52b034c148edc1303831b85","snippet":"SetBTInputBufferInPtr(${1:byte n})","description":"Set bluetooth input buffer in-pointer."},{"leftLabel":"void","displayText":"SetBTInputBufferOutPtr","type":"function","descriptionMoreURL":"group___comm_module_functions_gabc245701277d31a6db96ab1a4a8c1211.html#gabc245701277d31a6db96ab1a4a8c1211","snippet":"SetBTInputBufferOutPtr(${1:byte n})","description":"Set bluetooth input buffer out-pointer."},{"leftLabel":"void","displayText":"SetBTOutputBuffer","type":"function","descriptionMoreURL":"group___comm_module_functions_gaf9b2e853c469fd5d2d0513b3f4dcead2.html#gaf9b2e853c469fd5d2d0513b3f4dcead2","snippet":"SetBTOutputBuffer(${1:const byte offset}, ${2:byte cnt}, ${3:byte data[]})","description":"Set bluetooth output buffer data."},{"leftLabel":"void","displayText":"SetBTOutputBufferInPtr","type":"function","descriptionMoreURL":"group___comm_module_functions_ga969b6502c2b374e81bfb4496187f25f3.html#ga969b6502c2b374e81bfb4496187f25f3","snippet":"SetBTOutputBufferInPtr(${1:byte n})","description":"Set bluetooth output buffer in-pointer."},{"leftLabel":"void","displayText":"SetBTOutputBufferOutPtr","type":"function","descriptionMoreURL":"group___comm_module_functions_gac83101aacd930dd23df9c8bb8637a1a4.html#gac83101aacd930dd23df9c8bb8637a1a4","snippet":"SetBTOutputBufferOutPtr(${1:byte n})","description":"Set bluetooth output buffer out-pointer."},{"leftLabel":"void","displayText":"SetHSInputBuffer","type":"function","descriptionMoreURL":"group___comm_module_functions_gaf45b20c235220dc134d6368b7a78581c.html#gaf45b20c235220dc134d6368b7a78581c","snippet":"SetHSInputBuffer(${1:const byte offset}, ${2:byte cnt}, ${3:byte data[]})","description":"Set hi-speed port input buffer data."},{"leftLabel":"void","displayText":"SetHSInputBufferInPtr","type":"function","descriptionMoreURL":"group___comm_module_functions_ga3eec6963d2dcd43b698fd84ebc0ff77a.html#ga3eec6963d2dcd43b698fd84ebc0ff77a","snippet":"SetHSInputBufferInPtr(${1:byte n})","description":"Set hi-speed port input buffer in-pointer."},{"leftLabel":"void","displayText":"SetHSInputBufferOutPtr","type":"function","descriptionMoreURL":"group___comm_module_functions_gacc4dc3f793b19e3bdaa3e20ce95d665a.html#gacc4dc3f793b19e3bdaa3e20ce95d665a","snippet":"SetHSInputBufferOutPtr(${1:byte n})","description":"Set hi-speed port input buffer out-pointer."},{"leftLabel":"void","displayText":"SetHSOutputBuffer","type":"function","descriptionMoreURL":"group___comm_module_functions_ga5eb11223416ae5250c46bdbc7671243e.html#ga5eb11223416ae5250c46bdbc7671243e","snippet":"SetHSOutputBuffer(${1:const byte offset}, ${2:byte cnt}, ${3:byte data[]})","description":"Set hi-speed port output buffer data."},{"leftLabel":"void","displayText":"SetHSOutputBufferInPtr","type":"function","descriptionMoreURL":"group___comm_module_functions_ga626bdf50223e86d90be0230584d431bb.html#ga626bdf50223e86d90be0230584d431bb","snippet":"SetHSOutputBufferInPtr(${1:byte n})","description":"Set hi-speed port output buffer in-pointer."},{"leftLabel":"void","displayText":"SetHSOutputBufferOutPtr","type":"function","descriptionMoreURL":"group___comm_module_functions_gabf4b574c6e9266c86bf1940ec401b273.html#gabf4b574c6e9266c86bf1940ec401b273","snippet":"SetHSOutputBufferOutPtr(${1:byte n})","description":"Set hi-speed port output buffer out-pointer."},{"leftLabel":"void","displayText":"SetUSBInputBuffer","type":"function","descriptionMoreURL":"group___comm_module_functions_gaa66ef1f5ee9f204db63bcb8aa7dbcc7d.html#gaa66ef1f5ee9f204db63bcb8aa7dbcc7d","snippet":"SetUSBInputBuffer(${1:const byte offset}, ${2:byte cnt}, ${3:byte data[]})","description":"Set USB input buffer data."},{"leftLabel":"void","displayText":"SetUSBInputBufferInPtr","type":"function","descriptionMoreURL":"group___comm_module_functions_ga42bf6a0ed3d3dddd1a277f5a508f746a.html#ga42bf6a0ed3d3dddd1a277f5a508f746a","snippet":"SetUSBInputBufferInPtr(${1:byte n})","description":"Set USB input buffer in-pointer."},{"leftLabel":"void","displayText":"SetUSBInputBufferOutPtr","type":"function","descriptionMoreURL":"group___comm_module_functions_ga0d7e3c01cb5a6902e42625a9332b3c3e.html#ga0d7e3c01cb5a6902e42625a9332b3c3e","snippet":"SetUSBInputBufferOutPtr(${1:byte n})","description":"Set USB input buffer out-pointer."},{"leftLabel":"void","displayText":"SetUSBOutputBuffer","type":"function","descriptionMoreURL":"group___comm_module_functions_gaa46d2f90746d9b7b671be834535cceb6.html#gaa46d2f90746d9b7b671be834535cceb6","snippet":"SetUSBOutputBuffer(${1:const byte offset}, ${2:byte cnt}, ${3:byte data[]})","description":"Set USB output buffer data."},{"leftLabel":"void","displayText":"SetUSBOutputBufferInPtr","type":"function","descriptionMoreURL":"group___comm_module_functions_ga6f12e7cf94122bf099f01475a9e15c06.html#ga6f12e7cf94122bf099f01475a9e15c06","snippet":"SetUSBOutputBufferInPtr(${1:byte n})","description":"Set USB output buffer in-pointer."},{"leftLabel":"void","displayText":"SetUSBOutputBufferOutPtr","type":"function","descriptionMoreURL":"group___comm_module_functions_gaa5170d82878f407f4bbf4ab0496d690e.html#gaa5170d82878f407f4bbf4ab0496d690e","snippet":"SetUSBOutputBufferOutPtr(${1:byte n})","description":"Set USB output buffer out-pointer."},{"leftLabel":"void","displayText":"SetUSBPollBuffer","type":"function","descriptionMoreURL":"group___comm_module_functions_gac6d28aadf0d4ced671acf12a0493cf1e.html#gac6d28aadf0d4ced671acf12a0493cf1e","snippet":"SetUSBPollBuffer(${1:const byte offset}, ${2:byte cnt}, ${3:byte data[]})","description":"Set USB poll buffer data."},{"leftLabel":"void","displayText":"SetUSBPollBufferInPtr","type":"function","descriptionMoreURL":"group___comm_module_functions_ga39a77df9db88ee531be0f5a21f707da8.html#ga39a77df9db88ee531be0f5a21f707da8","snippet":"SetUSBPollBufferInPtr(${1:byte n})","description":"Set USB poll buffer in-pointer."},{"leftLabel":"void","displayText":"SetUSBPollBufferOutPtr","type":"function","descriptionMoreURL":"group___comm_module_functions_ga535db96af7ea8b162d07c410027e6937.html#ga535db96af7ea8b162d07c410027e6937","snippet":"SetUSBPollBufferOutPtr(${1:byte n})","description":"Set USB poll buffer out-pointer."},{"leftLabel":"void","displayText":"SetHSFlags","type":"function","descriptionMoreURL":"group___comm_module_functions_ga9ea9826f1c9531b5b70943ad1bf2efe6.html#ga9ea9826f1c9531b5b70943ad1bf2efe6","snippet":"SetHSFlags(${1:byte hsFlags})","description":"Set hi-speed port flags."},{"leftLabel":"void","displayText":"SetHSSpeed","type":"function","descriptionMoreURL":"group___comm_module_functions_ga5d938e8e05d31cbfbe32124cd0e04ad4.html#ga5d938e8e05d31cbfbe32124cd0e04ad4","snippet":"SetHSSpeed(${1:byte hsSpeed})","description":"Set hi-speed port speed."},{"leftLabel":"void","displayText":"SetHSState","type":"function","descriptionMoreURL":"group___comm_module_functions_ga5e4d33cc0688fd92451ec2d89442b75a.html#ga5e4d33cc0688fd92451ec2d89442b75a","snippet":"SetHSState(${1:byte hsState})","description":"Set hi-speed port state."},{"leftLabel":"void","displayText":"SetHSAddress","type":"function","descriptionMoreURL":"group___comm_module_functions_ga3f77fdcae336a213fb464b456c6516b0.html#ga3f77fdcae336a213fb464b456c6516b0","snippet":"SetHSAddress(${1:byte hsAddress})","description":"Set hi-speed port address."},{"leftLabel":"void","displayText":"SetHSMode","type":"function","descriptionMoreURL":"group___comm_module_functions_gae723872c42fc652026601da891c4fdb2.html#gae723872c42fc652026601da891c4fdb2","snippet":"SetHSMode(${1:unsigned int hsMode})","description":"Set hi-speed port mode."},{"leftLabel":"void","displayText":"SetBTDataMode","type":"function","descriptionMoreURL":"group___comm_module_functions_ga2ca1be634f8b0ddd70995700a43abdea.html#ga2ca1be634f8b0ddd70995700a43abdea","snippet":"SetBTDataMode(${1:const byte dataMode})","description":"Set Bluetooth data mode."},{"leftLabel":"void","displayText":"SetHSDataMode","type":"function","descriptionMoreURL":"group___comm_module_functions_gac5bbcbb8cf05419b7800cee328bbb769.html#gac5bbcbb8cf05419b7800cee328bbb769","snippet":"SetHSDataMode(${1:const byte dataMode})","description":"Set hi-speed port data mode."},{"leftLabel":"void","displayText":"SetUSBState","type":"function","descriptionMoreURL":"group___comm_module_functions_ga03e112e961e0ed18986a928d3fcacb1c.html#ga03e112e961e0ed18986a928d3fcacb1c","snippet":"SetUSBState(${1:byte usbState})","description":"Set USB state."},{"leftLabel":"void","displayText":"SysMessageWrite","type":"function","descriptionMoreURL":"group___comm_module_functions_ga16f2cf513d5154574d34d6bc7e6db71e.html#ga16f2cf513d5154574d34d6bc7e6db71e","snippet":"SysMessageWrite(${1:MessageWriteType &args})","description":"Write message."},{"leftLabel":"void","displayText":"SysMessageRead","type":"function","descriptionMoreURL":"group___comm_module_functions_gafec3a4b5ac2472c2ca1de14e64bd5677.html#gafec3a4b5ac2472c2ca1de14e64bd5677","snippet":"SysMessageRead(${1:MessageReadType &args})","description":"Read message."},{"leftLabel":"void","displayText":"SysCommBTWrite","type":"function","descriptionMoreURL":"group___comm_module_functions_ga8e08a8615ac16f56c2b87477075d97ad.html#ga8e08a8615ac16f56c2b87477075d97ad","snippet":"SysCommBTWrite(${1:CommBTWriteType &args})","description":"Write data to a Bluetooth connection."},{"leftLabel":"void","displayText":"SysCommBTCheckStatus","type":"function","descriptionMoreURL":"group___comm_module_functions_ga7be5601c8966e17bdfcec4fde05a5443.html#ga7be5601c8966e17bdfcec4fde05a5443","snippet":"SysCommBTCheckStatus(${1:CommBTCheckStatusType &args})","description":"Check Bluetooth connection status."},{"leftLabel":"void","displayText":"SysCommExecuteFunction","type":"function","descriptionMoreURL":"group___comm_module_functions_gaa59d4f6aadf74c248d7f17df8f110fc5.html#gaa59d4f6aadf74c248d7f17df8f110fc5","snippet":"SysCommExecuteFunction(${1:CommExecuteFunctionType &args})","description":"Execute any Comm module command."},{"leftLabel":"void","displayText":"SysCommHSControl","type":"function","descriptionMoreURL":"group___comm_module_functions_ga2fa9add72f670246e804168073e038d4.html#ga2fa9add72f670246e804168073e038d4","snippet":"SysCommHSControl(${1:CommHSControlType &args})","description":"Control the hi-speed port."},{"leftLabel":"void","displayText":"SysCommHSCheckStatus","type":"function","descriptionMoreURL":"group___comm_module_functions_gac8763c4089daf6ab088116f949eaaf04.html#gac8763c4089daf6ab088116f949eaaf04","snippet":"SysCommHSCheckStatus(${1:CommHSCheckStatusType &args})","description":"Check the hi-speed port status."},{"leftLabel":"void","displayText":"SysCommHSRead","type":"function","descriptionMoreURL":"group___comm_module_functions_ga9dd0450eeabaaad8cab92d3bfc6c4f72.html#ga9dd0450eeabaaad8cab92d3bfc6c4f72","snippet":"SysCommHSRead(${1:CommHSReadWriteType &args})","description":"Read from the hi-speed port."},{"leftLabel":"void","displayText":"SysCommHSWrite","type":"function","descriptionMoreURL":"group___comm_module_functions_ga472319548e57b0208e511a35aaee7ebe.html#ga472319548e57b0208e511a35aaee7ebe","snippet":"SysCommHSWrite(${1:CommHSReadWriteType &args})","description":"Write to the hi-speed port."},{"leftLabel":"void","displayText":"SysCommBTOnOff","type":"function","descriptionMoreURL":"group___comm_module_functions_gafd9ff0aebd6d15312a48512e1d7abd91.html#gafd9ff0aebd6d15312a48512e1d7abd91","snippet":"SysCommBTOnOff(${1:CommBTOnOffType &args})","description":"Turn on or off the bluetooth subsystem."},{"leftLabel":"void","displayText":"SysCommBTConnection","type":"function","descriptionMoreURL":"group___comm_module_functions_ga842ce6b10457e9dbb1bc8c91f6d0d3ae.html#ga842ce6b10457e9dbb1bc8c91f6d0d3ae","snippet":"SysCommBTConnection(${1:CommBTConnectionType &args})","description":"Connect or disconnect a bluetooth device."},{"leftLabel":"bool","displayText":"ButtonPressed","type":"function","descriptionMoreURL":"group___button_module_functions_ga422820a7aa44d2899f2cdde2375e15e5.html#ga422820a7aa44d2899f2cdde2375e15e5","snippet":"ButtonPressed(${1:const byte btn}, ${2:bool resetCount=false})","description":"Check for button press."},{"leftLabel":"byte","displayText":"ButtonCount","type":"function","descriptionMoreURL":"group___button_module_functions_ga2ecb6d9c50071e4f2f385087162cc07f.html#ga2ecb6d9c50071e4f2f385087162cc07f","snippet":"ButtonCount(${1:const byte btn}, ${2:bool resetCount=false})","description":"Get button press count."},{"leftLabel":"char","displayText":"ReadButtonEx","type":"function","descriptionMoreURL":"group___button_module_functions_ga962aa3bd34dcf435b36d30f73bebb3e3.html#ga962aa3bd34dcf435b36d30f73bebb3e3","snippet":"ReadButtonEx(${1:const byte btn}, ${2:bool reset}, ${3:bool &pressed}, ${4:unsigned int &count})","description":"Read button information."},{"leftLabel":"byte","displayText":"ButtonPressCount","type":"function","descriptionMoreURL":"group___button_module_functions_ga6302b443c0500eaea6a2164b81580fb7.html#ga6302b443c0500eaea6a2164b81580fb7","snippet":"ButtonPressCount(${1:const byte btn})","description":"Get button press count."},{"leftLabel":"byte","displayText":"ButtonLongPressCount","type":"function","descriptionMoreURL":"group___button_module_functions_gad3da3e95404bb16224e474452c3a5915.html#gad3da3e95404bb16224e474452c3a5915","snippet":"ButtonLongPressCount(${1:const byte btn})","description":"Get button long press count."},{"leftLabel":"byte","displayText":"ButtonShortReleaseCount","type":"function","descriptionMoreURL":"group___button_module_functions_ga34cc70463a3c870d0bf56aa6f5faa920.html#ga34cc70463a3c870d0bf56aa6f5faa920","snippet":"ButtonShortReleaseCount(${1:const byte btn})","description":"Get button short release count."},{"leftLabel":"byte","displayText":"ButtonLongReleaseCount","type":"function","descriptionMoreURL":"group___button_module_functions_gaf3fa640aedef16d0815cca41a8b44714.html#gaf3fa640aedef16d0815cca41a8b44714","snippet":"ButtonLongReleaseCount(${1:const byte btn})","description":"Get button long release count."},{"leftLabel":"byte","displayText":"ButtonReleaseCount","type":"function","descriptionMoreURL":"group___button_module_functions_gaff5146bcfb5fc8a27ca92c44bf45818e.html#gaff5146bcfb5fc8a27ca92c44bf45818e","snippet":"ButtonReleaseCount(${1:const byte btn})","description":"Get button release count."},{"leftLabel":"byte","displayText":"ButtonState","type":"function","descriptionMoreURL":"group___button_module_functions_gab2806b509572d576e9a2f30e7d6c007f.html#gab2806b509572d576e9a2f30e7d6c007f","snippet":"ButtonState(${1:const byte btn})","description":"Get button state."},{"leftLabel":"void","displayText":"SetButtonLongPressCount","type":"function","descriptionMoreURL":"group___button_module_functions_ga5f16bb46382f9b33374221e9a671dda6.html#ga5f16bb46382f9b33374221e9a671dda6","snippet":"SetButtonLongPressCount(${1:const byte btn}, ${2:const byte n})","description":"Set button long press count."},{"leftLabel":"void","displayText":"SetButtonLongReleaseCount","type":"function","descriptionMoreURL":"group___button_module_functions_ga9f1c9e5ac2dd8646ec65b6f5c4d7155d.html#ga9f1c9e5ac2dd8646ec65b6f5c4d7155d","snippet":"SetButtonLongReleaseCount(${1:const byte btn}, ${2:const byte n})","description":"Set button long release count."},{"leftLabel":"void","displayText":"SetButtonPressCount","type":"function","descriptionMoreURL":"group___button_module_functions_ga0a7e5b7f0dadf90bf2662f33708797e2.html#ga0a7e5b7f0dadf90bf2662f33708797e2","snippet":"SetButtonPressCount(${1:const byte btn}, ${2:const byte n})","description":"Set button press count."},{"leftLabel":"void","displayText":"SetButtonReleaseCount","type":"function","descriptionMoreURL":"group___button_module_functions_ga4f54e86054e1ef02ef9cd892eb4ece30.html#ga4f54e86054e1ef02ef9cd892eb4ece30","snippet":"SetButtonReleaseCount(${1:const byte btn}, ${2:const byte n})","description":"Set button release count."},{"leftLabel":"void","displayText":"SetButtonShortReleaseCount","type":"function","descriptionMoreURL":"group___button_module_functions_ga57f72fe52c7aa582733dae20c97975d1.html#ga57f72fe52c7aa582733dae20c97975d1","snippet":"SetButtonShortReleaseCount(${1:const byte btn}, ${2:const byte n})","description":"Set button short release count."},{"leftLabel":"void","displayText":"SetButtonState","type":"function","descriptionMoreURL":"group___button_module_functions_ga9431c7b1178be40933a5e3b57309caa2.html#ga9431c7b1178be40933a5e3b57309caa2","snippet":"SetButtonState(${1:const byte btn}, ${2:const byte state})","description":"Set button state."},{"leftLabel":"void","displayText":"SysReadButton","type":"function","descriptionMoreURL":"group___button_module_functions_ga7539adb3705b0d59f359d4688bc8794b.html#ga7539adb3705b0d59f359d4688bc8794b","snippet":"SysReadButton(${1:ReadButtonType &args})","description":"Read button."},{"leftLabel":"byte","displayText":"CommandFlags","type":"function","descriptionMoreURL":"group___ui_module_functions_gad76bcd625b0a895f98d0853051a64dff.html#gad76bcd625b0a895f98d0853051a64dff","snippet":"CommandFlags(${1:void})","description":"Get command flags."},{"leftLabel":"byte","displayText":"UIState","type":"function","descriptionMoreURL":"group___ui_module_functions_ga92ee0a50219dd8dc2805a3db56b24b71.html#ga92ee0a50219dd8dc2805a3db56b24b71","snippet":"UIState(${1:void})","description":"Get UI module state."},{"leftLabel":"byte","displayText":"UIButton","type":"function","descriptionMoreURL":"group___ui_module_functions_ga36e4f12b572614b134690095b6df4bc1.html#ga36e4f12b572614b134690095b6df4bc1","snippet":"UIButton(${1:void})","description":"Read UI button."},{"leftLabel":"byte","displayText":"VMRunState","type":"function","descriptionMoreURL":"group___ui_module_functions_gaa1dd27bc00fd2c2152759c3164d176d1.html#gaa1dd27bc00fd2c2152759c3164d176d1","snippet":"VMRunState(${1:void})","description":"Read VM run state."},{"leftLabel":"byte","displayText":"BatteryState","type":"function","descriptionMoreURL":"group___ui_module_functions_ga7aa4b5743574a50cf553544308367b55.html#ga7aa4b5743574a50cf553544308367b55","snippet":"BatteryState(${1:void})","description":"Get battery state."},{"leftLabel":"byte","displayText":"BluetoothState","type":"function","descriptionMoreURL":"group___ui_module_functions_gad5b54611981b0354a333a1bf40f0bea4.html#gad5b54611981b0354a333a1bf40f0bea4","snippet":"BluetoothState(${1:void})","description":"Get bluetooth state."},{"leftLabel":"byte","displayText":"UsbState","type":"function","descriptionMoreURL":"group___ui_module_functions_ga2860ce53b476b94f36d30092c0665e73.html#ga2860ce53b476b94f36d30092c0665e73","snippet":"UsbState(${1:void})","description":"Get UI module USB state."},{"leftLabel":"byte","displayText":"SleepTimeout","type":"function","descriptionMoreURL":"group___ui_module_functions_ga49891078cc0c032480ad5746056662ec.html#ga49891078cc0c032480ad5746056662ec","snippet":"SleepTimeout(${1:void})","description":"Read sleep timeout."},{"leftLabel":"byte","displayText":"SleepTime","type":"function","descriptionMoreURL":"group___ui_module_functions_gad9b343d4a6f887901eaf8cae7cd223e0.html#gad9b343d4a6f887901eaf8cae7cd223e0","snippet":"SleepTime(${1:void})","description":"Read sleep time."},{"leftLabel":"byte","displayText":"SleepTimer","type":"function","descriptionMoreURL":"group___ui_module_functions_ga98e982ca521453ef8d9f2ca8896990bf.html#ga98e982ca521453ef8d9f2ca8896990bf","snippet":"SleepTimer(${1:void})","description":"Read sleep timer."},{"leftLabel":"bool","displayText":"RechargeableBattery","type":"function","descriptionMoreURL":"group___ui_module_functions_gac23cb2126f516f7ecfc57b2c5bec6a79.html#gac23cb2126f516f7ecfc57b2c5bec6a79","snippet":"RechargeableBattery(${1:void})","description":"Read battery type."},{"leftLabel":"byte","displayText":"Volume","type":"function","descriptionMoreURL":"group___ui_module_functions_gab3783fa8eb4714a8fd8bb39337ef6550.html#gab3783fa8eb4714a8fd8bb39337ef6550","snippet":"Volume(${1:void})","description":"Read volume."},{"leftLabel":"byte","displayText":"OnBrickProgramPointer","type":"function","descriptionMoreURL":"group___ui_module_functions_gafed08926132cf674fac6b5e5f411b8de.html#gafed08926132cf674fac6b5e5f411b8de","snippet":"OnBrickProgramPointer(${1:void})","description":"Read the on brick program pointer value."},{"leftLabel":"byte","displayText":"AbortFlag","type":"function","descriptionMoreURL":"group___ui_module_functions_ga4bf657e61435af801f0078a4d040cf7f.html#ga4bf657e61435af801f0078a4d040cf7f","snippet":"AbortFlag(${1:void})","description":"Read abort flag."},{"leftLabel":"byte","displayText":"LongAbort","type":"function","descriptionMoreURL":"group___ui_module_functions_ga82271e1630251483f49b40e29c857549.html#ga82271e1630251483f49b40e29c857549","snippet":"LongAbort(${1:void})","description":"Read long abort setting."},{"leftLabel":"unsigned int","displayText":"BatteryLevel","type":"function","descriptionMoreURL":"group___ui_module_functions_gadab48c54d5ff7333fe086152a4c634d1.html#gadab48c54d5ff7333fe086152a4c634d1","snippet":"BatteryLevel(${1:void})","description":"Get battery Level."},{"leftLabel":"void","displayText":"SetCommandFlags","type":"function","descriptionMoreURL":"group___ui_module_functions_ga4b592f77ead243054358a65ec62cc65e.html#ga4b592f77ead243054358a65ec62cc65e","snippet":"SetCommandFlags(${1:const byte cmdFlags})","description":"Set command flags."},{"leftLabel":"void","displayText":"SetUIButton","type":"function","descriptionMoreURL":"group___ui_module_functions_ga379edbffdfe6d4488b13a347cbd29ac0.html#ga379edbffdfe6d4488b13a347cbd29ac0","snippet":"SetUIButton(${1:byte btn})","description":"Set UI button."},{"leftLabel":"void","displayText":"SetUIState","type":"function","descriptionMoreURL":"group___ui_module_functions_ga86c39b71bfa7b244995745c932379f82.html#ga86c39b71bfa7b244995745c932379f82","snippet":"SetUIState(${1:byte state})","description":"Set UI state."},{"leftLabel":"void","displayText":"SetVMRunState","type":"function","descriptionMoreURL":"group___ui_module_functions_gab9ba4b4e50de6e899e083aab3463a597.html#gab9ba4b4e50de6e899e083aab3463a597","snippet":"SetVMRunState(${1:const byte vmRunState})","description":"Set VM run state."},{"leftLabel":"void","displayText":"SetBatteryState","type":"function","descriptionMoreURL":"group___ui_module_functions_ga838303b8fce965ce00e2e585aed604be.html#ga838303b8fce965ce00e2e585aed604be","snippet":"SetBatteryState(${1:byte state})","description":"Set battery state."},{"leftLabel":"void","displayText":"SetBluetoothState","type":"function","descriptionMoreURL":"group___ui_module_functions_ga3e1d02098d0ed4ec09b2412cb45bddb0.html#ga3e1d02098d0ed4ec09b2412cb45bddb0","snippet":"SetBluetoothState(${1:byte state})","description":"Set bluetooth state."},{"leftLabel":"void","displayText":"SetSleepTimeout","type":"function","descriptionMoreURL":"group___ui_module_functions_ga9a424a8728947cd102922d60f316822c.html#ga9a424a8728947cd102922d60f316822c","snippet":"SetSleepTimeout(${1:const byte n})","description":"Set sleep timeout."},{"leftLabel":"void","displayText":"SetSleepTime","type":"function","descriptionMoreURL":"group___ui_module_functions_ga3ad5f62315d1b295901872cec3ebe060.html#ga3ad5f62315d1b295901872cec3ebe060","snippet":"SetSleepTime(${1:const byte n})","description":"Set sleep time."},{"leftLabel":"void","displayText":"SetSleepTimer","type":"function","descriptionMoreURL":"group___ui_module_functions_ga4253652d829836f9da9ad6608a567afb.html#ga4253652d829836f9da9ad6608a567afb","snippet":"SetSleepTimer(${1:const byte n})","description":"Set the sleep timer."},{"leftLabel":"void","displayText":"SetVolume","type":"function","descriptionMoreURL":"group___ui_module_functions_ga998e2678b97428b98796548bd7a8f164.html#ga998e2678b97428b98796548bd7a8f164","snippet":"SetVolume(${1:byte volume})","description":"Set volume."},{"leftLabel":"void","displayText":"SetOnBrickProgramPointer","type":"function","descriptionMoreURL":"group___ui_module_functions_ga17831ae8357457e9ddc2d98d81d1ef86.html#ga17831ae8357457e9ddc2d98d81d1ef86","snippet":"SetOnBrickProgramPointer(${1:byte obpStep})","description":"Set on-brick program pointer."},{"leftLabel":"void","displayText":"ForceOff","type":"function","descriptionMoreURL":"group___ui_module_functions_ga2845348c8d35c782af66b21af45b7933.html#ga2845348c8d35c782af66b21af45b7933","snippet":"ForceOff(${1:byte num})","description":"Turn off NXT."},{"leftLabel":"void","displayText":"SetAbortFlag","type":"function","descriptionMoreURL":"group___ui_module_functions_ga588ec1132940b08cc706bb843422d494.html#ga588ec1132940b08cc706bb843422d494","snippet":"SetAbortFlag(${1:byte abortFlag})","description":"Set abort flag."},{"leftLabel":"void","displayText":"SetLongAbort","type":"function","descriptionMoreURL":"group___ui_module_functions_gace23a1d08934fde2c2cc7c5d65280604.html#gace23a1d08934fde2c2cc7c5d65280604","snippet":"SetLongAbort(${1:bool longAbort})","description":"Set long abort."},{"leftLabel":"void","displayText":"SysSetSleepTimeout","type":"function","descriptionMoreURL":"group___ui_module_functions_gacc06664b2b2aa8221b1e9d98a58f016a.html#gacc06664b2b2aa8221b1e9d98a58f016a","snippet":"SysSetSleepTimeout(${1:SetSleepTimeoutType &args})","description":"Set system sleep timeout."},{"leftLabel":"unsigned int","displayText":"FreeMemory","type":"function","descriptionMoreURL":"group___loader_module_functions_gaa54c9305e497a2d06942d78e0e02218f.html#gaa54c9305e497a2d06942d78e0e02218f","snippet":"FreeMemory(${1:void})","description":"Get free flash memory."},{"leftLabel":"unsigned int","displayText":"CreateFile","type":"function","descriptionMoreURL":"group___loader_module_functions_gada63da95141ff19ffa6ee15c5ccba1e8.html#gada63da95141ff19ffa6ee15c5ccba1e8","snippet":"CreateFile(${1:string fname}, ${2:unsigned int fsize}, ${3:byte &handle})","description":"Create a file."},{"leftLabel":"unsigned int","displayText":"OpenFileAppend","type":"function","descriptionMoreURL":"group___loader_module_functions_gad726b331d30cbecdbcb1707dd72fb0bb.html#gad726b331d30cbecdbcb1707dd72fb0bb","snippet":"OpenFileAppend(${1:string fname}, ${2:unsigned int &fsize}, ${3:byte &handle})","description":"Open a file for appending."},{"leftLabel":"unsigned int","displayText":"OpenFileRead","type":"function","descriptionMoreURL":"group___loader_module_functions_ga3061ab47184fd4a90cd1d8ed04d9f6a3.html#ga3061ab47184fd4a90cd1d8ed04d9f6a3","snippet":"OpenFileRead(${1:string fname}, ${2:unsigned int &fsize}, ${3:byte &handle})","description":"Open a file for reading."},{"leftLabel":"unsigned int","displayText":"CloseFile","type":"function","descriptionMoreURL":"group___loader_module_functions_ga17ac87a3d0fcb018de6a4e75d5570528.html#ga17ac87a3d0fcb018de6a4e75d5570528","snippet":"CloseFile(${1:byte handle})","description":"Close a file."},{"leftLabel":"unsigned int","displayText":"ResolveHandle","type":"function","descriptionMoreURL":"group___loader_module_functions_ga116eab089d2a616d3e1a2f39fa484f0f.html#ga116eab089d2a616d3e1a2f39fa484f0f","snippet":"ResolveHandle(${1:string filename}, ${2:byte &handle}, ${3:bool &writable})","description":"Resolve a handle."},{"leftLabel":"unsigned int","displayText":"RenameFile","type":"function","descriptionMoreURL":"group___loader_module_functions_gaf61ab8be7811c3d71d7223dd4e218ab7.html#gaf61ab8be7811c3d71d7223dd4e218ab7","snippet":"RenameFile(${1:string oldname}, ${2:string newname})","description":"Rename a file."},{"leftLabel":"unsigned int","displayText":"DeleteFile","type":"function","descriptionMoreURL":"group___loader_module_functions_gaa89e91e96e56f2a8ea643c6250dcd68d.html#gaa89e91e96e56f2a8ea643c6250dcd68d","snippet":"DeleteFile(${1:string fname})","description":"Delete a file."},{"leftLabel":"unsigned int","displayText":"ResizeFile","type":"function","descriptionMoreURL":"group___loader_module_functions_ga2eab4efcde5a3ced5ecf3e472c0fc0bd.html#ga2eab4efcde5a3ced5ecf3e472c0fc0bd","snippet":"ResizeFile(${1:string fname}, ${2:const unsigned int newsize})","description":"Resize a file."},{"leftLabel":"unsigned int","displayText":"CreateFileLinear","type":"function","descriptionMoreURL":"group___loader_module_functions_ga82743413eccdd38076ff1ba266a225f4.html#ga82743413eccdd38076ff1ba266a225f4","snippet":"CreateFileLinear(${1:string fname}, ${2:unsigned int fsize}, ${3:byte &handle})","description":"Create a linear file."},{"leftLabel":"unsigned int","displayText":"CreateFileNonLinear","type":"function","descriptionMoreURL":"group___loader_module_functions_ga2c562ef29f14c285e8ac696a73847491.html#ga2c562ef29f14c285e8ac696a73847491","snippet":"CreateFileNonLinear(${1:string fname}, ${2:unsigned int fsize}, ${3:byte &handle})","description":"Create a non-linear file."},{"leftLabel":"unsigned int","displayText":"OpenFileReadLinear","type":"function","descriptionMoreURL":"group___loader_module_functions_gae0a0e291a865ccb8b4678ddc59160b99.html#gae0a0e291a865ccb8b4678ddc59160b99","snippet":"OpenFileReadLinear(${1:string fname}, ${2:unsigned int &fsize}, ${3:byte &handle})","description":"Open a linear file for reading."},{"leftLabel":"unsigned int","displayText":"FindFirstFile","type":"function","descriptionMoreURL":"group___loader_module_functions_ga3d737b6a801bf167a97cf0427a02ad83.html#ga3d737b6a801bf167a97cf0427a02ad83","snippet":"FindFirstFile(${1:string &fname}, ${2:byte &handle})","description":"Start searching for files."},{"leftLabel":"unsigned int","displayText":"FindNextFile","type":"function","descriptionMoreURL":"group___loader_module_functions_gaa5264f1649b74c1e0d8c0ef92cc2121d.html#gaa5264f1649b74c1e0d8c0ef92cc2121d","snippet":"FindNextFile(${1:string &fname}, ${2:byte &handle})","description":"Continue searching for files."},{"leftLabel":"unsigned int","displayText":"SizeOf","type":"function","descriptionMoreURL":"group___loader_module_functions_gadbf1c0fed1e8e1a406e212895f253a43.html#gadbf1c0fed1e8e1a406e212895f253a43","snippet":"SizeOf(${1:variant &value})","description":"Calculate the size of a variable."},{"leftLabel":"unsigned int","displayText":"TypeOf","type":"function","descriptionMoreURL":"group___loader_module_functions_gac1fbf8ea683150a0848a415d81969495.html#gac1fbf8ea683150a0848a415d81969495","snippet":"TypeOf(${1:variant &value})","description":"Return the type of a variable."},{"leftLabel":"unsigned int","displayText":"Read","type":"function","descriptionMoreURL":"group___loader_module_functions_gaac1ea059f7224207b51573784c344537.html#gaac1ea059f7224207b51573784c344537","snippet":"Read(${1:byte handle}, ${2:variant &value})","description":"Read a value from a file."},{"leftLabel":"unsigned int","displayText":"ReadLn","type":"function","descriptionMoreURL":"group___loader_module_functions_gab29d31beaf0fa0e2272e765f1b874045.html#gab29d31beaf0fa0e2272e765f1b874045","snippet":"ReadLn(${1:byte handle}, ${2:variant &value})","description":"Read a value from a file plus line ending."},{"leftLabel":"unsigned int","displayText":"ReadBytes","type":"function","descriptionMoreURL":"group___loader_module_functions_gae8ae82f26e206da40c3bde47a4dd652b.html#gae8ae82f26e206da40c3bde47a4dd652b","snippet":"ReadBytes(${1:byte handle}, ${2:unsigned int &length}, ${3:byte &buf[]})","description":"Read bytes from a file."},{"leftLabel":"unsigned int","displayText":"ReadLnString","type":"function","descriptionMoreURL":"group___loader_module_functions_ga0378bbf5561771317961d8b11b8e0157.html#ga0378bbf5561771317961d8b11b8e0157","snippet":"ReadLnString(${1:byte handle}, ${2:string &output})","description":"Read a string from a file plus line ending."},{"leftLabel":"unsigned int","displayText":"Write","type":"function","descriptionMoreURL":"group___loader_module_functions_ga4db689546a8284ed46aa5838bd6e7dcf.html#ga4db689546a8284ed46aa5838bd6e7dcf","snippet":"Write(${1:byte handle}, ${2:const variant &value})","description":"Write value to file."},{"leftLabel":"unsigned int","displayText":"WriteBytes","type":"function","descriptionMoreURL":"group___loader_module_functions_ga1422e2caa5778b269a54c5f1e4bdda61.html#ga1422e2caa5778b269a54c5f1e4bdda61","snippet":"WriteBytes(${1:byte handle}, ${2:const byte &buf[]}, ${3:unsigned int &cnt})","description":"Write bytes to file."},{"leftLabel":"unsigned int","displayText":"WriteBytesEx","type":"function","descriptionMoreURL":"group___loader_module_functions_ga49d752bc44503859ee78cc6ad92a3aa0.html#ga49d752bc44503859ee78cc6ad92a3aa0","snippet":"WriteBytesEx(${1:byte handle}, ${2:unsigned int &len}, ${3:const byte &buf[]})","description":"Write bytes to a file with limit."},{"leftLabel":"unsigned int","displayText":"WriteLn","type":"function","descriptionMoreURL":"group___loader_module_functions_ga4e0c625c81653096752094ddaef0cf6c.html#ga4e0c625c81653096752094ddaef0cf6c","snippet":"WriteLn(${1:byte handle}, ${2:const variant &value})","description":"Write a value and new line to a file."},{"leftLabel":"unsigned int","displayText":"WriteLnString","type":"function","descriptionMoreURL":"group___loader_module_functions_ga4a8644eec9e0b19af7a20911eb520037.html#ga4a8644eec9e0b19af7a20911eb520037","snippet":"WriteLnString(${1:byte handle}, ${2:const string &str}, ${3:unsigned int &cnt})","description":"Write string and new line to a file."},{"leftLabel":"unsigned int","displayText":"WriteString","type":"function","descriptionMoreURL":"group___loader_module_functions_ga4b6afe0059527e6079e5c99e1e0ffadf.html#ga4b6afe0059527e6079e5c99e1e0ffadf","snippet":"WriteString(${1:byte handle}, ${2:const string &str}, ${3:unsigned int &cnt})","description":"Write string to a file."},{"leftLabel":"void","displayText":"SysFileOpenRead","type":"function","descriptionMoreURL":"group___loader_module_functions_ga994e013f5399ccd37118fecb006e70ae.html#ga994e013f5399ccd37118fecb006e70ae","snippet":"SysFileOpenRead(${1:FileOpenType &args})","description":"Open file for reading."},{"leftLabel":"void","displayText":"SysFileOpenWrite","type":"function","descriptionMoreURL":"group___loader_module_functions_ga42ad132448cce615481020d882e9edd0.html#ga42ad132448cce615481020d882e9edd0","snippet":"SysFileOpenWrite(${1:FileOpenType &args})","description":"Open and create file for writing."},{"leftLabel":"void","displayText":"SysFileOpenAppend","type":"function","descriptionMoreURL":"group___loader_module_functions_ga5cb21014646e567ccfab6050baaddee1.html#ga5cb21014646e567ccfab6050baaddee1","snippet":"SysFileOpenAppend(${1:FileOpenType &args})","description":"Open file for writing at end of file."},{"leftLabel":"void","displayText":"SysFileRead","type":"function","descriptionMoreURL":"group___loader_module_functions_gad28a222a8f18cebec60a32d04b2c8769.html#gad28a222a8f18cebec60a32d04b2c8769","snippet":"SysFileRead(${1:FileReadWriteType &args})","description":"Read from file."},{"leftLabel":"void","displayText":"SysFileWrite","type":"function","descriptionMoreURL":"group___loader_module_functions_ga15b4a20a82cceecad74db98ff0fc6f55.html#ga15b4a20a82cceecad74db98ff0fc6f55","snippet":"SysFileWrite(${1:FileReadWriteType &args})","description":"File write."},{"leftLabel":"void","displayText":"SysFileClose","type":"function","descriptionMoreURL":"group___loader_module_functions_ga8dff293c4eb561e104781939f2332fd8.html#ga8dff293c4eb561e104781939f2332fd8","snippet":"SysFileClose(${1:FileCloseType &args})","description":"Close file handle."},{"leftLabel":"void","displayText":"SysFileResolveHandle","type":"function","descriptionMoreURL":"group___loader_module_functions_ga572083efeb02103742756441d951ef29.html#ga572083efeb02103742756441d951ef29","snippet":"SysFileResolveHandle(${1:FileResolveHandleType &args})","description":"File resolve handle."},{"leftLabel":"void","displayText":"SysFileRename","type":"function","descriptionMoreURL":"group___loader_module_functions_ga0c74d5bd705c2ce4a1ce1c82ef8b584e.html#ga0c74d5bd705c2ce4a1ce1c82ef8b584e","snippet":"SysFileRename(${1:FileRenameType &args})","description":"Rename file."},{"leftLabel":"void","displayText":"SysFileDelete","type":"function","descriptionMoreURL":"group___loader_module_functions_gad128f8a1b756239ac0901f2545467bf7.html#gad128f8a1b756239ac0901f2545467bf7","snippet":"SysFileDelete(${1:FileDeleteType &args})","description":"Delete file."},{"leftLabel":"void","displayText":"SysLoaderExecuteFunction","type":"function","descriptionMoreURL":"group___loader_module_functions_gaea838edff2cf5f31f2c138f6f7407924.html#gaea838edff2cf5f31f2c138f6f7407924","snippet":"SysLoaderExecuteFunction(${1:LoaderExecuteFunctionType &args})","description":"Execute any Loader module command."},{"leftLabel":"void","displayText":"SysFileFindFirst","type":"function","descriptionMoreURL":"group___loader_module_functions_ga866544072133f01b9b4948a5dafcc7d8.html#ga866544072133f01b9b4948a5dafcc7d8","snippet":"SysFileFindFirst(${1:FileFindType &args})","description":"Start finding files."},{"leftLabel":"void","displayText":"SysFileFindNext","type":"function","descriptionMoreURL":"group___loader_module_functions_ga317950015b0f9c6bd01e9156c19d4954.html#ga317950015b0f9c6bd01e9156c19d4954","snippet":"SysFileFindNext(${1:FileFindType &args})","description":"Continue finding files."},{"leftLabel":"void","displayText":"SysFileOpenWriteLinear","type":"function","descriptionMoreURL":"group___loader_module_functions_ga5ef8bec4fb31522683c8cd4c27bb7eb8.html#ga5ef8bec4fb31522683c8cd4c27bb7eb8","snippet":"SysFileOpenWriteLinear(${1:FileOpenType &args})","description":"Open and create linear file for writing."},{"leftLabel":"void","displayText":"SysFileOpenWriteNonLinear","type":"function","descriptionMoreURL":"group___loader_module_functions_ga20be5b18be66f1efe068c880ecb3d3d9.html#ga20be5b18be66f1efe068c880ecb3d3d9","snippet":"SysFileOpenWriteNonLinear(${1:FileOpenType &args})","description":"Open and create non-linear file for writing."},{"leftLabel":"void","displayText":"SysFileOpenReadLinear","type":"function","descriptionMoreURL":"group___loader_module_functions_gab2cc70710eae4879bae0879ff4d372a0.html#gab2cc70710eae4879bae0879ff4d372a0","snippet":"SysFileOpenReadLinear(${1:FileOpenType &args})","description":"Open linear file for reading."},{"leftLabel":"void","displayText":"SysFileSeek","type":"function","descriptionMoreURL":"group___loader_module_functions_gaca9c80455432d977ba6e4c1c4d3f2153.html#gaca9c80455432d977ba6e4c1c4d3f2153","snippet":"SysFileSeek(${1:FileSeekType &args})","description":"Seek to file position."},{"leftLabel":"void","displayText":"SysFileResize","type":"function","descriptionMoreURL":"group___loader_module_functions_ga99a07eba34cccd730476e3e3a0b42c80.html#ga99a07eba34cccd730476e3e3a0b42c80","snippet":"SysFileResize(${1:FileResizeType &args})","description":"Resize a file."},{"leftLabel":"void","displayText":"SysFileTell","type":"function","descriptionMoreURL":"group___loader_module_functions_ga8c37cbc30ee5808247c04c1a976c4030.html#ga8c37cbc30ee5808247c04c1a976c4030","snippet":"SysFileTell(${1:FileTellType &args})","description":"Return the file position."},{"leftLabel":"void","displayText":"SysListFiles","type":"function","descriptionMoreURL":"group___loader_module_functions_ga5dddeb542d9427bb16d997f61427f3f7.html#ga5dddeb542d9427bb16d997f61427f3f7","snippet":"SysListFiles(${1:ListFilesType &args})","description":"List files."},{"leftLabel":"void","displayText":"SetSensorHTGyro","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gaea028b5e636bef58d384fe0f7f064027.html#gaea028b5e636bef58d384fe0f7f064027","snippet":"SetSensorHTGyro(${1:const byte &port})","description":"Set sensor as HiTechnic Gyro."},{"leftLabel":"void","displayText":"SetSensorHTMagnet","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gac80c0b01120f05c7ee8c5282710e6ca2.html#gac80c0b01120f05c7ee8c5282710e6ca2","snippet":"SetSensorHTMagnet(${1:const byte &port})","description":"Set sensor as HiTechnic Magnet."},{"leftLabel":"void","displayText":"SetSensorHTEOPD","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga2304b03b500ada516a2e5980835dec69.html#ga2304b03b500ada516a2e5980835dec69","snippet":"SetSensorHTEOPD(${1:const byte &port}, ${2:bool bStandard=true})","description":"Set sensor as HiTechnic EOPD."},{"leftLabel":"void","displayText":"SetSensorHTForce","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga65cf659b9e7ff9f8c37cf64cb47a86db.html#ga65cf659b9e7ff9f8c37cf64cb47a86db","snippet":"SetSensorHTForce(${1:const byte &port})","description":"Set sensor as HiTechnic Force."},{"leftLabel":"int","displayText":"SensorHTGyro","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gabdb455bf56fa8e2d0c834eccf0e5b532.html#gabdb455bf56fa8e2d0c834eccf0e5b532","snippet":"SensorHTGyro(${1:const byte &port}, ${2:int offset=0})","description":"Read HiTechnic Gyro sensor."},{"leftLabel":"int","displayText":"SensorHTMagnet","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga0c7d81910084157f24be6f5a485e9401.html#ga0c7d81910084157f24be6f5a485e9401","snippet":"SensorHTMagnet(${1:const byte &port}, ${2:int offset=0})","description":"Read HiTechnic Magnet sensor."},{"leftLabel":"int","displayText":"SensorHTEOPD","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga666fbc3dea3a90268ddd4be401bd32d3.html#ga666fbc3dea3a90268ddd4be401bd32d3","snippet":"SensorHTEOPD(${1:const byte &port})","description":"Read HiTechnic EOPD sensor."},{"leftLabel":"int","displayText":"SensorHTForce","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga48edd558272a2467f373dc411a888c78.html#ga48edd558272a2467f373dc411a888c78","snippet":"SensorHTForce(${1:const byte &port})","description":"Read HiTechnic Force sensor."},{"leftLabel":"int","displayText":"SensorHTColorNum","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gae1fd199476d619089558f7d2df50ef15.html#gae1fd199476d619089558f7d2df50ef15","snippet":"SensorHTColorNum(${1:const byte &port})","description":"Read HiTechnic color sensor color number."},{"leftLabel":"int","displayText":"SensorHTCompass","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga6acad43b9093e56fd45d2a76d21a6782.html#ga6acad43b9093e56fd45d2a76d21a6782","snippet":"SensorHTCompass(${1:const byte &port})","description":"Read HiTechnic compass."},{"leftLabel":"int","displayText":"SensorHTIRSeekerDir","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga1dfe105eb38114e456873671b4e42e0b.html#ga1dfe105eb38114e456873671b4e42e0b","snippet":"SensorHTIRSeekerDir(${1:const byte &port})","description":"Read HiTechnic IRSeeker direction."},{"leftLabel":"int","displayText":"SensorHTIRSeeker2Addr","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga4915fb775c45886368f588d22c2b8818.html#ga4915fb775c45886368f588d22c2b8818","snippet":"SensorHTIRSeeker2Addr(${1:const byte &port}, ${2:const byte reg})","description":"Read HiTechnic IRSeeker2 register."},{"leftLabel":"int","displayText":"SensorHTIRSeeker2DCDir","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga244b0f1f29854492503f230513a8e48c.html#ga244b0f1f29854492503f230513a8e48c","snippet":"SensorHTIRSeeker2DCDir(${1:const byte &port})","description":"Read HiTechnic IRSeeker2 DC direction."},{"leftLabel":"int","displayText":"SensorHTIRSeeker2ACDir","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga24c5a45da67b4f64a50918396e49451e.html#ga24c5a45da67b4f64a50918396e49451e","snippet":"SensorHTIRSeeker2ACDir(${1:const byte &port})","description":"Read HiTechnic IRSeeker2 AC direction."},{"leftLabel":"char","displayText":"SetHTColor2Mode","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga4bf5798b8c0bcd427da26f47983ea04e.html#ga4bf5798b8c0bcd427da26f47983ea04e","snippet":"SetHTColor2Mode(${1:const byte &port}, ${2:byte mode})","description":"Set HiTechnic Color2 mode."},{"leftLabel":"char","displayText":"SetHTIRSeeker2Mode","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga483f98611d3441ced552e7bf3e5b6c26.html#ga483f98611d3441ced552e7bf3e5b6c26","snippet":"SetHTIRSeeker2Mode(${1:const byte &port}, ${2:const byte mode})","description":"Set HiTechnic IRSeeker2 mode."},{"leftLabel":"bool","displayText":"ReadSensorHTAccel","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gaccb90829f8390c6731dfdf1af1dcf2b0.html#gaccb90829f8390c6731dfdf1af1dcf2b0","snippet":"ReadSensorHTAccel(${1:const byte port}, ${2:int &x}, ${3:int &y}, ${4:int &z})","description":"Read HiTechnic acceleration values."},{"leftLabel":"bool","displayText":"ReadSensorHTColor","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gafe4c0ed777c2bc436c109d68eb232b2c.html#gafe4c0ed777c2bc436c109d68eb232b2c","snippet":"ReadSensorHTColor(${1:const byte port}, ${2:byte &ColorNum}, ${3:byte &Red}, ${4:byte &Green}, ${5:byte &Blue})","description":"Read HiTechnic Color values."},{"leftLabel":"bool","displayText":"ReadSensorHTIRSeeker","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gafbba4be00b16a4cb83127ab5575e7908.html#gafbba4be00b16a4cb83127ab5575e7908","snippet":"ReadSensorHTIRSeeker(${1:const byte port}, ${2:byte &dir}, ${3:byte &s1}, ${4:byte &s3}, ${5:byte &s5}, ${6:byte &s7}, ${7:byte &s9})","description":"Read HiTechnic IRSeeker values."},{"leftLabel":"bool","displayText":"ReadSensorHTNormalizedColor","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga0706d3a06e1981a0a2c2da4deed539d0.html#ga0706d3a06e1981a0a2c2da4deed539d0","snippet":"ReadSensorHTNormalizedColor(${1:const byte port}, ${2:byte &ColorIdx}, ${3:byte &Red}, ${4:byte &Green}, ${5:byte &Blue})","description":"Read HiTechnic Color normalized values."},{"leftLabel":"bool","displayText":"ReadSensorHTRawColor","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gac1a3d66c3697160f4804bf3f6d012c22.html#gac1a3d66c3697160f4804bf3f6d012c22","snippet":"ReadSensorHTRawColor(${1:const byte port}, ${2:unsigned int &Red}, ${3:unsigned int &Green}, ${4:unsigned int &Blue})","description":"Read HiTechnic Color raw values."},{"leftLabel":"bool","displayText":"ReadSensorHTColor2Active","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gad745c4078b81d8888dba87a7524ce210.html#gad745c4078b81d8888dba87a7524ce210","snippet":"ReadSensorHTColor2Active(${1:byte port}, ${2:byte &ColorNum}, ${3:byte &Red}, ${4:byte &Green}, ${5:byte &Blue}, ${6:byte &White})","description":"Read HiTechnic Color2 active values."},{"leftLabel":"bool","displayText":"ReadSensorHTNormalizedColor2Active","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga422531aab0399d53c90337d24cccef9b.html#ga422531aab0399d53c90337d24cccef9b","snippet":"ReadSensorHTNormalizedColor2Active(${1:const byte port}, ${2:byte &ColorIdx}, ${3:byte &Red}, ${4:byte &Green}, ${5:byte &Blue})","description":"Read HiTechnic Color2 normalized active values."},{"leftLabel":"bool","displayText":"ReadSensorHTRawColor2","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga69edf42e1328eed4db665f78e76b2dc8.html#ga69edf42e1328eed4db665f78e76b2dc8","snippet":"ReadSensorHTRawColor2(${1:const byte port}, ${2:unsigned int &Red}, ${3:unsigned int &Green}, ${4:unsigned int &Blue}, ${5:unsigned int &White})","description":"Read HiTechnic Color2 raw values."},{"leftLabel":"bool","displayText":"ReadSensorHTIRReceiver","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga4dcecec08c61f9d79439f3dad42d2ecd.html#ga4dcecec08c61f9d79439f3dad42d2ecd","snippet":"ReadSensorHTIRReceiver(${1:const byte port}, ${2:char &pfdata[]})","description":"Read HiTechnic IRReceiver Power Function bytes."},{"leftLabel":"bool","displayText":"ReadSensorHTIRReceiverEx","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gacd083ef3c92ae43bad66cd07f28dca5d.html#gacd083ef3c92ae43bad66cd07f28dca5d","snippet":"ReadSensorHTIRReceiverEx(${1:const byte port}, ${2:const byte offset}, ${3:char &pfchar})","description":"Read HiTechnic IRReceiver Power Function value."},{"leftLabel":"bool","displayText":"ReadSensorHTIRSeeker2AC","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga05430b9dc24cba9a82ebdf62c11efa24.html#ga05430b9dc24cba9a82ebdf62c11efa24","snippet":"ReadSensorHTIRSeeker2AC(${1:const byte port}, ${2:byte &dir}, ${3:byte &s1}, ${4:byte &s3}, ${5:byte &s5}, ${6:byte &s7}, ${7:byte &s9})","description":"Read HiTechnic IRSeeker2 AC values."},{"leftLabel":"bool","displayText":"ReadSensorHTIRSeeker2DC","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga7aefe1c5216e6aab272eb4ba8b8ed0da.html#ga7aefe1c5216e6aab272eb4ba8b8ed0da","snippet":"ReadSensorHTIRSeeker2DC(${1:const byte port}, ${2:byte &dir}, ${3:byte &s1}, ${4:byte &s3}, ${5:byte &s5}, ${6:byte &s7}, ${7:byte &s9}, ${8:byte &avg})","description":"Read HiTechnic IRSeeker2 DC values."},{"leftLabel":"char","displayText":"ResetSensorHTAngle","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga6a4098c16a92e7915e51f6c8616d8c4d.html#ga6a4098c16a92e7915e51f6c8616d8c4d","snippet":"ResetSensorHTAngle(${1:const byte port}, ${2:const byte mode})","description":"Reset HiTechnic Angle sensor."},{"leftLabel":"bool","displayText":"ReadSensorHTAngle","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gafd97b81a5dc7ab5ac7a9a986b9aafdea.html#gafd97b81a5dc7ab5ac7a9a986b9aafdea","snippet":"ReadSensorHTAngle(${1:const byte port}, ${2:int &Angle}, ${3:long &AccAngle}, ${4:int &RPM})","description":"Read HiTechnic Angle sensor values."},{"leftLabel":"bool","displayText":"ResetHTBarometricCalibration","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga11cf20eaefc1a117771d1b62a41f89d1.html#ga11cf20eaefc1a117771d1b62a41f89d1","snippet":"ResetHTBarometricCalibration(${1:byte port})","description":"Reset HiTechnic Barometric sensor calibration."},{"leftLabel":"bool","displayText":"SetHTBarometricCalibration","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gad9dc084db8068cf72ba38c4a64223bde.html#gad9dc084db8068cf72ba38c4a64223bde","snippet":"SetHTBarometricCalibration(${1:byte port}, ${2:unsigned int cal})","description":"Set HiTechnic Barometric sensor calibration."},{"leftLabel":"bool","displayText":"ReadSensorHTBarometric","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga0b1ec3775f73ffa701014ae5c2e3641b.html#ga0b1ec3775f73ffa701014ae5c2e3641b","snippet":"ReadSensorHTBarometric(${1:const byte port}, ${2:int &temp}, ${3:unsigned int &press})","description":"Read HiTechnic Barometric sensor values."},{"leftLabel":"int","displayText":"SensorHTProtoAnalog","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gae845bbc11df1bd6f3f816001a00e41c0.html#gae845bbc11df1bd6f3f816001a00e41c0","snippet":"SensorHTProtoAnalog(${1:const byte port}, ${2:const byte input})","description":"Read HiTechnic Prototype board analog input value."},{"leftLabel":"bool","displayText":"ReadSensorHTProtoAllAnalog","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga9201ef16dbfbb2f6d3c11f2d4c26631d.html#ga9201ef16dbfbb2f6d3c11f2d4c26631d","snippet":"ReadSensorHTProtoAllAnalog(${1:const byte port}, ${2:int &a0}, ${3:int &a1}, ${4:int &a2}, ${5:int &a3}, ${6:int &a4})","description":"Read all HiTechnic Prototype board analog input values."},{"leftLabel":"bool","displayText":"SetSensorHTProtoDigitalControl","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gaa02c2c0e562b4d6edf417b6d5b208263.html#gaa02c2c0e562b4d6edf417b6d5b208263","snippet":"SetSensorHTProtoDigitalControl(${1:const byte port}, ${2:byte value})","description":"Control HiTechnic Prototype board digital pin direction."},{"leftLabel":"byte","displayText":"SensorHTProtoDigitalControl","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gac879282bb367dc0c01975b43c0b13913.html#gac879282bb367dc0c01975b43c0b13913","snippet":"SensorHTProtoDigitalControl(${1:const byte port})","description":"Read HiTechnic Prototype board digital control values."},{"leftLabel":"bool","displayText":"SetSensorHTProtoDigital","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga2eb828b76ee0cf2f9f9ba76229caea89.html#ga2eb828b76ee0cf2f9f9ba76229caea89","snippet":"SetSensorHTProtoDigital(${1:const byte port}, ${2:byte value})","description":"Set HiTechnic Prototype board digital output values."},{"leftLabel":"byte","displayText":"SensorHTProtoDigital","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga38fd6a5d3e801c903bc5442dfd1a00c8.html#ga38fd6a5d3e801c903bc5442dfd1a00c8","snippet":"SensorHTProtoDigital(${1:const byte port})","description":"Read HiTechnic Prototype board digital input values."},{"leftLabel":"int","displayText":"SensorHTSuperProAnalog","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga327989bd4612a1513602ab2181ec39f0.html#ga327989bd4612a1513602ab2181ec39f0","snippet":"SensorHTSuperProAnalog(${1:const byte port}, ${2:const byte input})","description":"Read HiTechnic SuperPro board analog input value."},{"leftLabel":"bool","displayText":"ReadSensorHTSuperProAllAnalog","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga52c7160dc4e7f8c37d4ab359e3a4981e.html#ga52c7160dc4e7f8c37d4ab359e3a4981e","snippet":"ReadSensorHTSuperProAllAnalog(${1:const byte port}, ${2:int &a0}, ${3:int &a1}, ${4:int &a2}, ${5:int &a3})","description":"Read all HiTechnic SuperPro board analog input values."},{"leftLabel":"bool","displayText":"SetSensorHTSuperProDigitalControl","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gac7716dee07a11f5f9adbe14718c836f6.html#gac7716dee07a11f5f9adbe14718c836f6","snippet":"SetSensorHTSuperProDigitalControl(${1:const byte port}, ${2:byte value})","description":"Control HiTechnic SuperPro board digital pin direction."},{"leftLabel":"byte","displayText":"SensorHTSuperProDigitalControl","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga87f76ff1617a89838f0c67f967959d66.html#ga87f76ff1617a89838f0c67f967959d66","snippet":"SensorHTSuperProDigitalControl(${1:const byte port})","description":"Read HiTechnic SuperPro board digital control values."},{"leftLabel":"bool","displayText":"SetSensorHTSuperProDigital","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gafe518d2ad62793f383f7bdf655a366b3.html#gafe518d2ad62793f383f7bdf655a366b3","snippet":"SetSensorHTSuperProDigital(${1:const byte port}, ${2:byte value})","description":"Set HiTechnic SuperPro board digital output values."},{"leftLabel":"byte","displayText":"SensorHTSuperProDigital","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga4b1448977407a550b3677d9f95042a44.html#ga4b1448977407a550b3677d9f95042a44","snippet":"SensorHTSuperProDigital(${1:const byte port})","description":"Read HiTechnic SuperPro board digital input values."},{"leftLabel":"bool","displayText":"SetSensorHTSuperProLED","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gadbdf80d56a1bccfe247582cdfdbc46ff.html#gadbdf80d56a1bccfe247582cdfdbc46ff","snippet":"SetSensorHTSuperProLED(${1:const byte port}, ${2:byte value})","description":"Set HiTechnic SuperPro LED value."},{"leftLabel":"byte","displayText":"SensorHTSuperProLED","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gab19bfa8c74d8644320e65dc4ebeb73c5.html#gab19bfa8c74d8644320e65dc4ebeb73c5","snippet":"SensorHTSuperProLED(${1:const byte port})","description":"Read HiTechnic SuperPro LED value."},{"leftLabel":"bool","displayText":"SetSensorHTSuperProStrobe","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga2872307f123c66c399f72fb5b8a736fa.html#ga2872307f123c66c399f72fb5b8a736fa","snippet":"SetSensorHTSuperProStrobe(${1:const byte port}, ${2:byte value})","description":"Set HiTechnic SuperPro strobe value."},{"leftLabel":"byte","displayText":"SensorHTSuperProStrobe","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gaa065afc40dd93c443da38c2cfff05795.html#gaa065afc40dd93c443da38c2cfff05795","snippet":"SensorHTSuperProStrobe(${1:const byte port})","description":"Read HiTechnic SuperPro strobe value."},{"leftLabel":"bool","displayText":"SetSensorHTSuperProProgramControl","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga8297884609b8d85ea3cdc9116c25854b.html#ga8297884609b8d85ea3cdc9116c25854b","snippet":"SetSensorHTSuperProProgramControl(${1:const byte port}, ${2:byte value})","description":"Set HiTechnic SuperPro program control value."},{"leftLabel":"byte","displayText":"SensorHTSuperProProgramControl","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga57b520c32847d2f52783293604bfdf53.html#ga57b520c32847d2f52783293604bfdf53","snippet":"SensorHTSuperProProgramControl(${1:const byte port})","description":"Read HiTechnic SuperPro program control value."},{"leftLabel":"bool","displayText":"SetSensorHTSuperProAnalogOut","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga677d411926b1d85bf7649966c41de706.html#ga677d411926b1d85bf7649966c41de706","snippet":"SetSensorHTSuperProAnalogOut(${1:const byte port}, ${2:const byte dac}, ${3:byte mode}, ${4:int freq}, ${5:int volt})","description":"Set HiTechnic SuperPro board analog output parameters."},{"leftLabel":"bool","displayText":"ReadSensorHTSuperProAnalogOut","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga7d383c512b146799b31c722b0b5526fc.html#ga7d383c512b146799b31c722b0b5526fc","snippet":"ReadSensorHTSuperProAnalogOut(${1:const byte port}, ${2:const byte dac}, ${3:byte &mode}, ${4:int &freq}, ${5:int &volt})","description":"Read HiTechnic SuperPro board analog output parameters."},{"leftLabel":"bool","displayText":"SetSensorHTPIRDeadband","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga2f5a68a0168e531288ffef86e2e14c34.html#ga2f5a68a0168e531288ffef86e2e14c34","snippet":"SetSensorHTPIRDeadband(${1:const byte port}, ${2:byte value})","description":"Set HiTechnic PIR deadband value."},{"leftLabel":"char","displayText":"SensorHTPIR","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga7f3332068f43c9f36768ae26d3efce67.html#ga7f3332068f43c9f36768ae26d3efce67","snippet":"SensorHTPIR(${1:const byte port})","description":"Read HiTechnic PIR measurement value."},{"leftLabel":"void","displayText":"ReadSensorHTTouchMultiplexer","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gafb017f21259eb60929865969ae9f4c14.html#gafb017f21259eb60929865969ae9f4c14","snippet":"ReadSensorHTTouchMultiplexer(${1:const byte port}, ${2:byte &t1}, ${3:byte &t2}, ${4:byte &t3}, ${5:byte &t4})","description":"Read HiTechnic touch multiplexer."},{"leftLabel":"char","displayText":"HTIRTrain","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga485e215d22518a7ecd3d50339b1bb254.html#ga485e215d22518a7ecd3d50339b1bb254","snippet":"HTIRTrain(${1:const byte port}, ${2:const byte channel}, ${3:const byte func})","description":"HTIRTrain function."},{"leftLabel":"char","displayText":"HTPFComboDirect","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga02028bf0002796ada5b44675ebfed512.html#ga02028bf0002796ada5b44675ebfed512","snippet":"HTPFComboDirect(${1:const byte port}, ${2:const byte channel}, ${3:const byte outa}, ${4:const byte outb})","description":"HTPFComboDirect function."},{"leftLabel":"char","displayText":"HTPFComboPWM","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga3303f0705e9e43e66700f0fd209f9dfc.html#ga3303f0705e9e43e66700f0fd209f9dfc","snippet":"HTPFComboPWM(${1:const byte port}, ${2:const byte channel}, ${3:const byte outa}, ${4:const byte outb})","description":"HTPFComboPWM function."},{"leftLabel":"char","displayText":"HTPFRawOutput","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gaad83cc30f999b73df7c774df4cc5f44e.html#gaad83cc30f999b73df7c774df4cc5f44e","snippet":"HTPFRawOutput(${1:const byte port}, ${2:const byte nibble0}, ${3:const byte nibble1}, ${4:const byte nibble2})","description":"HTPFRawOutput function."},{"leftLabel":"char","displayText":"HTPFRepeat","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga07792729bbb4fbfeb9c83e6bf5c28894.html#ga07792729bbb4fbfeb9c83e6bf5c28894","snippet":"HTPFRepeat(${1:const byte port}, ${2:const byte count}, ${3:const unsigned int delay})","description":"HTPFRepeat function."},{"leftLabel":"char","displayText":"HTPFSingleOutputCST","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gae80fb6b909862f02b1a26ae5d3da5c5d.html#gae80fb6b909862f02b1a26ae5d3da5c5d","snippet":"HTPFSingleOutputCST(${1:const byte port}, ${2:const byte channel}, ${3:const byte out}, ${4:const byte func})","description":"HTPFSingleOutputCST function."},{"leftLabel":"char","displayText":"HTPFSingleOutputPWM","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gab8b043b3aa4f11237b136492b61c226a.html#gab8b043b3aa4f11237b136492b61c226a","snippet":"HTPFSingleOutputPWM(${1:const byte port}, ${2:const byte channel}, ${3:const byte out}, ${4:const byte func})","description":"HTPFSingleOutputPWM function."},{"leftLabel":"char","displayText":"HTPFSinglePin","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga23d405c2946a4a9a600cacd4a66e2aa7.html#ga23d405c2946a4a9a600cacd4a66e2aa7","snippet":"HTPFSinglePin(${1:const byte port}, ${2:const byte channel}, ${3:const byte out}, ${4:const byte pin}, ${5:const byte func}, ${6:bool cont})","description":"HTPFSinglePin function."},{"leftLabel":"char","displayText":"HTPFTrain","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gaf5d9306cea9fa13dbadf7865dd6e0055.html#gaf5d9306cea9fa13dbadf7865dd6e0055","snippet":"HTPFTrain(${1:const byte port}, ${2:const byte channel}, ${3:const byte func})","description":"HTPFTrain function."},{"leftLabel":"void","displayText":"HTRCXSetIRLinkPort","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga25f3722b44d50daf7934765193e40a72.html#ga25f3722b44d50daf7934765193e40a72","snippet":"HTRCXSetIRLinkPort(${1:const byte port})","description":"HTRCXSetIRLinkPort function."},{"leftLabel":"int","displayText":"HTRCXBatteryLevel","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gad063c346adccbd193217ebb07e9aef56.html#gad063c346adccbd193217ebb07e9aef56","snippet":"HTRCXBatteryLevel(${1:void})","description":"HTRCXBatteryLevel function."},{"leftLabel":"int","displayText":"HTRCXPoll","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga6ba49b5fd87b3ad379a07b5ef5247559.html#ga6ba49b5fd87b3ad379a07b5ef5247559","snippet":"HTRCXPoll(${1:const byte src}, ${2:const byte value})","description":"HTRCXPoll function Send the Poll command to an RCX to read a signed 2-byte value at the specified source and value combination."},{"leftLabel":"int","displayText":"HTRCXPollMemory","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga5b0bae03ec48ac98eb558aa43bca3878.html#ga5b0bae03ec48ac98eb558aa43bca3878","snippet":"HTRCXPollMemory(${1:const unsigned int address})","description":"HTRCXPollMemory function."},{"leftLabel":"void","displayText":"HTRCXAddToDatalog","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga9241c690bbb54e3a644736797d775fb3.html#ga9241c690bbb54e3a644736797d775fb3","snippet":"HTRCXAddToDatalog(${1:const byte src}, ${2:const unsigned int value})","description":"HTRCXAddToDatalog function."},{"leftLabel":"void","displayText":"HTRCXClearAllEvents","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga614a59f9ad8a24a5372efb05948c0e19.html#ga614a59f9ad8a24a5372efb05948c0e19","snippet":"HTRCXClearAllEvents(${1:void})","description":"HTRCXClearAllEvents function."},{"leftLabel":"void","displayText":"HTRCXClearCounter","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga3f1f7d3d7a3efbc418ec2efa817f2212.html#ga3f1f7d3d7a3efbc418ec2efa817f2212","snippet":"HTRCXClearCounter(${1:const byte counter})","description":"HTRCXClearCounter function."},{"leftLabel":"void","displayText":"HTRCXClearMsg","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gafcd51c98b19996d62e85545d4db5a39c.html#gafcd51c98b19996d62e85545d4db5a39c","snippet":"HTRCXClearMsg(${1:void})","description":"HTRCXClearMsg function."},{"leftLabel":"void","displayText":"HTRCXClearSensor","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga0379b553190489ba697e2b869a445117.html#ga0379b553190489ba697e2b869a445117","snippet":"HTRCXClearSensor(${1:const byte port})","description":"HTRCXClearSensor function."},{"leftLabel":"void","displayText":"HTRCXClearSound","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga7f6ef0a21624d81794c608b7e8a4e3d7.html#ga7f6ef0a21624d81794c608b7e8a4e3d7","snippet":"HTRCXClearSound(${1:void})","description":"HTRCXClearSound function."},{"leftLabel":"void","displayText":"HTRCXClearTimer","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga48b35c851355f40074d7e437a5cfa1ab.html#ga48b35c851355f40074d7e437a5cfa1ab","snippet":"HTRCXClearTimer(${1:const byte timer})","description":"HTRCXClearTimer function."},{"leftLabel":"void","displayText":"HTRCXCreateDatalog","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga58a422b4a7a6ccefca133c520aeb02fe.html#ga58a422b4a7a6ccefca133c520aeb02fe","snippet":"HTRCXCreateDatalog(${1:const unsigned int size})","description":"HTRCXCreateDatalog function."},{"leftLabel":"void","displayText":"HTRCXDecCounter","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga5bd634623b8d61df23e7b36204f86d1f.html#ga5bd634623b8d61df23e7b36204f86d1f","snippet":"HTRCXDecCounter(${1:const byte counter})","description":"HTRCXDecCounter function."},{"leftLabel":"void","displayText":"HTRCXDeleteSub","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gadc0aa5bcbd9a12482f8a1caf30537e19.html#gadc0aa5bcbd9a12482f8a1caf30537e19","snippet":"HTRCXDeleteSub(${1:const byte s})","description":"HTRCXDeleteSub function."},{"leftLabel":"void","displayText":"HTRCXDeleteSubs","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gad7a89b17a4daa1b6a3750b6dcf7b51fe.html#gad7a89b17a4daa1b6a3750b6dcf7b51fe","snippet":"HTRCXDeleteSubs(${1:void})","description":"HTRCXDeleteSubs function."},{"leftLabel":"void","displayText":"HTRCXDeleteTask","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga55036804fb7e8d2ae29b6b1a17acf516.html#ga55036804fb7e8d2ae29b6b1a17acf516","snippet":"HTRCXDeleteTask(${1:const byte t})","description":"HTRCXDeleteTask function."},{"leftLabel":"void","displayText":"HTRCXDeleteTasks","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga9e4c91b906082bf598bc35a09ebe4a84.html#ga9e4c91b906082bf598bc35a09ebe4a84","snippet":"HTRCXDeleteTasks(${1:void})","description":"HTRCXDeleteTasks function."},{"leftLabel":"void","displayText":"HTRCXDisableOutput","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gae0182d5825f9f5e44e94068488a36b8d.html#gae0182d5825f9f5e44e94068488a36b8d","snippet":"HTRCXDisableOutput(${1:const byte outputs})","description":"HTRCXDisableOutput function."},{"leftLabel":"void","displayText":"HTRCXEnableOutput","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gaa5dd1efce577756a55ae01c2a7b9f7e0.html#gaa5dd1efce577756a55ae01c2a7b9f7e0","snippet":"HTRCXEnableOutput(${1:const byte outputs})","description":"HTRCXEnableOutput function."},{"leftLabel":"void","displayText":"HTRCXEvent","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gabf9152ac52e9e1aa8cac53a595c4e442.html#gabf9152ac52e9e1aa8cac53a595c4e442","snippet":"HTRCXEvent(${1:const byte src}, ${2:const unsigned int value})","description":"HTRCXEvent function."},{"leftLabel":"void","displayText":"HTRCXFloat","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga2d8fdd30a569c5748d1048867ddc62f5.html#ga2d8fdd30a569c5748d1048867ddc62f5","snippet":"HTRCXFloat(${1:const byte outputs})","description":"HTRCXFloat function."},{"leftLabel":"void","displayText":"HTRCXFwd","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gaa5dae3c88923b3185910e3923c3acd94.html#gaa5dae3c88923b3185910e3923c3acd94","snippet":"HTRCXFwd(${1:const byte outputs})","description":"HTRCXFwd function."},{"leftLabel":"void","displayText":"HTRCXIncCounter","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga4c858cb028de33510febed2345aec524.html#ga4c858cb028de33510febed2345aec524","snippet":"HTRCXIncCounter(${1:const byte counter})","description":"HTRCXIncCounter function."},{"leftLabel":"void","displayText":"HTRCXInvertOutput","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga6b5be24801d17b54d620df15b50fe64f.html#ga6b5be24801d17b54d620df15b50fe64f","snippet":"HTRCXInvertOutput(${1:const byte outputs})","description":"HTRCXInvertOutput function."},{"leftLabel":"void","displayText":"HTRCXMuteSound","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga33cbed46c71d555681eab90ff5ae4003.html#ga33cbed46c71d555681eab90ff5ae4003","snippet":"HTRCXMuteSound(${1:void})","description":"HTRCXMuteSound function."},{"leftLabel":"void","displayText":"HTRCXObvertOutput","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gaf415f468f2e19331036f9e852b5ffc01.html#gaf415f468f2e19331036f9e852b5ffc01","snippet":"HTRCXObvertOutput(${1:const byte outputs})","description":"HTRCXObvertOutput function."},{"leftLabel":"void","displayText":"HTRCXOff","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga3e6e4aca22289c390dff7d2e78d6c5ac.html#ga3e6e4aca22289c390dff7d2e78d6c5ac","snippet":"HTRCXOff(${1:const byte outputs})","description":"HTRCXOff function."},{"leftLabel":"void","displayText":"HTRCXOn","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gabd80a1331ceb42689e90f189c03a2294.html#gabd80a1331ceb42689e90f189c03a2294","snippet":"HTRCXOn(${1:const byte outputs})","description":"HTRCXOn function."},{"leftLabel":"void","displayText":"HTRCXOnFor","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga8ee6a144e8a74e4bdbcd7e79d1223cac.html#ga8ee6a144e8a74e4bdbcd7e79d1223cac","snippet":"HTRCXOnFor(${1:const byte outputs}, ${2:const unsigned int ms})","description":"HTRCXOnFor function."},{"leftLabel":"void","displayText":"HTRCXOnFwd","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga70a0e0677f2c00315a2e496e9dbe078b.html#ga70a0e0677f2c00315a2e496e9dbe078b","snippet":"HTRCXOnFwd(${1:const byte outputs})","description":"HTRCXOnFwd function."},{"leftLabel":"void","displayText":"HTRCXOnRev","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gaec772182d2d4d22f3879e094f441105d.html#gaec772182d2d4d22f3879e094f441105d","snippet":"HTRCXOnRev(${1:const byte outputs})","description":"HTRCXOnRev function."},{"leftLabel":"void","displayText":"HTRCXPBTurnOff","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga9b9a68e34ba3946cb6bdf6599145c743.html#ga9b9a68e34ba3946cb6bdf6599145c743","snippet":"HTRCXPBTurnOff(${1:void})","description":"HTRCXPBTurnOff function."},{"leftLabel":"void","displayText":"HTRCXPing","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gabb4ce89fbcc51b1de00a67bf82352fc4.html#gabb4ce89fbcc51b1de00a67bf82352fc4","snippet":"HTRCXPing(${1:void})","description":"HTRCXPing function."},{"leftLabel":"void","displayText":"HTRCXPlaySound","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gadfdc8bd92b118bc223764d850d7575e8.html#gadfdc8bd92b118bc223764d850d7575e8","snippet":"HTRCXPlaySound(${1:const byte snd})","description":"HTRCXPlaySound function."},{"leftLabel":"void","displayText":"HTRCXPlayTone","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gadb67a71d8322dd355d11ffb4c73e1dd1.html#gadb67a71d8322dd355d11ffb4c73e1dd1","snippet":"HTRCXPlayTone(${1:const unsigned int freq}, ${2:const byte duration})","description":"HTRCXPlayTone function."},{"leftLabel":"void","displayText":"HTRCXPlayToneVar","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga6fb550de94af3b8196c0590e6b54a744.html#ga6fb550de94af3b8196c0590e6b54a744","snippet":"HTRCXPlayToneVar(${1:const byte varnum}, ${2:const byte duration})","description":"HTRCXPlayToneVar function."},{"leftLabel":"void","displayText":"HTRCXRemote","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga971a1eebb17d6baf276578dea47bcc33.html#ga971a1eebb17d6baf276578dea47bcc33","snippet":"HTRCXRemote(${1:unsigned int cmd})","description":"HTRCXRemote function."},{"leftLabel":"void","displayText":"HTRCXRev","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga2fdb47e423b5d837a0f03e21453ae5d5.html#ga2fdb47e423b5d837a0f03e21453ae5d5","snippet":"HTRCXRev(${1:const byte outputs})","description":"HTRCXRev function."},{"leftLabel":"void","displayText":"HTRCXSelectDisplay","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gac7c3e04bfceb8216eb844cb490bf4a6c.html#gac7c3e04bfceb8216eb844cb490bf4a6c","snippet":"HTRCXSelectDisplay(${1:const byte src}, ${2:const unsigned int value})","description":"HTRCXSelectDisplay function."},{"leftLabel":"void","displayText":"HTRCXSelectProgram","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gaf73993366ac8d1dcabc368b723a8124b.html#gaf73993366ac8d1dcabc368b723a8124b","snippet":"HTRCXSelectProgram(${1:const byte prog})","description":"HTRCXSelectProgram function."},{"leftLabel":"void","displayText":"HTRCXSendSerial","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gaa648159aa86487b4925d2e773b5077dc.html#gaa648159aa86487b4925d2e773b5077dc","snippet":"HTRCXSendSerial(${1:const byte first}, ${2:const byte count})","description":"HTRCXSendSerial function."},{"leftLabel":"void","displayText":"HTRCXSetDirection","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga17f12d14dca7773525ac4da0f02e5809.html#ga17f12d14dca7773525ac4da0f02e5809","snippet":"HTRCXSetDirection(${1:const byte outputs}, ${2:const byte dir})","description":"HTRCXSetDirection function."},{"leftLabel":"void","displayText":"HTRCXSetEvent","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gafaa975491b06b944ba3da2fc4de35113.html#gafaa975491b06b944ba3da2fc4de35113","snippet":"HTRCXSetEvent(${1:const byte evt}, ${2:const byte src}, ${3:const byte type})","description":"HTRCXSetEvent function."},{"leftLabel":"void","displayText":"HTRCXSetGlobalDirection","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga489eec8156c8b0e7494abd142f84d33e.html#ga489eec8156c8b0e7494abd142f84d33e","snippet":"HTRCXSetGlobalDirection(${1:const byte outputs}, ${2:const byte dir})","description":"HTRCXSetGlobalDirection function."},{"leftLabel":"void","displayText":"HTRCXSetGlobalOutput","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga109c4f1c17b5727a1c0dc4810ce4428e.html#ga109c4f1c17b5727a1c0dc4810ce4428e","snippet":"HTRCXSetGlobalOutput(${1:const byte outputs}, ${2:const byte mode})","description":"HTRCXSetGlobalOutput function."},{"leftLabel":"void","displayText":"HTRCXSetMaxPower","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga2bce3654037a08e9ef3918922e9c5109.html#ga2bce3654037a08e9ef3918922e9c5109","snippet":"HTRCXSetMaxPower(${1:const byte outputs}, ${2:const byte pwrsrc}, ${3:const byte pwrval})","description":"HTRCXSetMaxPower function."},{"leftLabel":"void","displayText":"HTRCXSetMessage","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga5d0e6689a9aae6a7826c1e451e255944.html#ga5d0e6689a9aae6a7826c1e451e255944","snippet":"HTRCXSetMessage(${1:const byte msg})","description":"HTRCXSetMessage function."},{"leftLabel":"void","displayText":"HTRCXSetOutput","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga18769c6dd7ced62d755ac732502ec981.html#ga18769c6dd7ced62d755ac732502ec981","snippet":"HTRCXSetOutput(${1:const byte outputs}, ${2:const byte mode})","description":"HTRCXSetOutput function."},{"leftLabel":"void","displayText":"HTRCXSetPower","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga44575c8a4439e6042e565b47571e78b9.html#ga44575c8a4439e6042e565b47571e78b9","snippet":"HTRCXSetPower(${1:const byte outputs}, ${2:const byte pwrsrc}, ${3:const byte pwrval})","description":"HTRCXSetPower function."},{"leftLabel":"void","displayText":"HTRCXSetPriority","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gaca40ea74d558dae8184fc5faf99ebf46.html#gaca40ea74d558dae8184fc5faf99ebf46","snippet":"HTRCXSetPriority(${1:const byte p})","description":"HTRCXSetPriority function."},{"leftLabel":"void","displayText":"HTRCXSetSensorMode","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga5e1feed4991e77abf0e5b962360b484d.html#ga5e1feed4991e77abf0e5b962360b484d","snippet":"HTRCXSetSensorMode(${1:const byte port}, ${2:const byte mode})","description":"HTRCXSetSensorMode function."},{"leftLabel":"void","displayText":"HTRCXSetSensorType","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gacb0d99b1d0250d6809054d9dc54f714b.html#gacb0d99b1d0250d6809054d9dc54f714b","snippet":"HTRCXSetSensorType(${1:const byte port}, ${2:const byte type})","description":"HTRCXSetSensorType function."},{"leftLabel":"void","displayText":"HTRCXSetSleepTime","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gabca7914b1d31026f1093d33dc493c80c.html#gabca7914b1d31026f1093d33dc493c80c","snippet":"HTRCXSetSleepTime(${1:const byte t})","description":"HTRCXSetSleepTime function."},{"leftLabel":"void","displayText":"HTRCXSetTxPower","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gad23894a1f6aedea0603ec60bd82b1dac.html#gad23894a1f6aedea0603ec60bd82b1dac","snippet":"HTRCXSetTxPower(${1:const byte pwr})","description":"HTRCXSetTxPower function."},{"leftLabel":"void","displayText":"HTRCXSetWatch","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga05b8869ad910118771d054c7d68cf12d.html#ga05b8869ad910118771d054c7d68cf12d","snippet":"HTRCXSetWatch(${1:const byte hours}, ${2:const byte minutes})","description":"HTRCXSetWatch function."},{"leftLabel":"void","displayText":"HTRCXStartTask","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga728dfb37aac27cff402b52d2469db384.html#ga728dfb37aac27cff402b52d2469db384","snippet":"HTRCXStartTask(${1:const byte t})","description":"HTRCXStartTask function."},{"leftLabel":"void","displayText":"HTRCXStopAllTasks","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga8005885831ee18b09b1d568f486b6b5b.html#ga8005885831ee18b09b1d568f486b6b5b","snippet":"HTRCXStopAllTasks(${1:void})","description":"HTRCXStopAllTasks function."},{"leftLabel":"void","displayText":"HTRCXStopTask","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga95da9f3db99b8b677d8e55fad4b0ece0.html#ga95da9f3db99b8b677d8e55fad4b0ece0","snippet":"HTRCXStopTask(${1:const byte t})","description":"HTRCXStopTask function."},{"leftLabel":"void","displayText":"HTRCXToggle","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gadd71f25e94dc99e8cad6ea2270720cdf.html#gadd71f25e94dc99e8cad6ea2270720cdf","snippet":"HTRCXToggle(${1:const byte outputs})","description":"HTRCXToggle function."},{"leftLabel":"void","displayText":"HTRCXUnmuteSound","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gaf126862e9e7eb07d8ebf25d98031837c.html#gaf126862e9e7eb07d8ebf25d98031837c","snippet":"HTRCXUnmuteSound(${1:void})","description":"HTRCXUnmuteSound function."},{"leftLabel":"void","displayText":"HTScoutCalibrateSensor","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga3075adb9a5b64370fa67431c606fce48.html#ga3075adb9a5b64370fa67431c606fce48","snippet":"HTScoutCalibrateSensor(${1:void})","description":"HTScoutCalibrateSensor function."},{"leftLabel":"void","displayText":"HTScoutMuteSound","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gacefe2c441127804f9d5d3c2d902cece4.html#gacefe2c441127804f9d5d3c2d902cece4","snippet":"HTScoutMuteSound(${1:void})","description":"HTScoutMuteSound function."},{"leftLabel":"void","displayText":"HTScoutSelectSounds","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gaa2310c74fdb59923969297bb1ba8941d.html#gaa2310c74fdb59923969297bb1ba8941d","snippet":"HTScoutSelectSounds(${1:const byte grp})","description":"HTScoutSelectSounds function."},{"leftLabel":"void","displayText":"HTScoutSendVLL","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga7aaad513325f7aafe05a4d67408c6bd3.html#ga7aaad513325f7aafe05a4d67408c6bd3","snippet":"HTScoutSendVLL(${1:const byte src}, ${2:const unsigned int value})","description":"HTScoutSendVLL function."},{"leftLabel":"void","displayText":"HTScoutSetEventFeedback","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga2c5dac0f4ca6e536df3d830f52b4a75a.html#ga2c5dac0f4ca6e536df3d830f52b4a75a","snippet":"HTScoutSetEventFeedback(${1:const byte src}, ${2:const unsigned int value})","description":"HTScoutSetEventFeedback function."},{"leftLabel":"void","displayText":"HTScoutSetLight","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga94f81a2f6690ec81fd653b3f33906393.html#ga94f81a2f6690ec81fd653b3f33906393","snippet":"HTScoutSetLight(${1:const byte x})","description":"HTScoutSetLight function."},{"leftLabel":"void","displayText":"HTScoutSetScoutMode","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gafa06b5762c944c7f5e9d64a126ef0cfe.html#gafa06b5762c944c7f5e9d64a126ef0cfe","snippet":"HTScoutSetScoutMode(${1:const byte mode})","description":"HTScoutSetScoutMode function."},{"leftLabel":"void","displayText":"HTScoutSetSensorClickTime","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga9f24e2abb821bd6bb6cf465c682d76ad.html#ga9f24e2abb821bd6bb6cf465c682d76ad","snippet":"HTScoutSetSensorClickTime(${1:const byte src}, ${2:const unsigned int value})","description":"HTScoutSetSensorClickTime function."},{"leftLabel":"void","displayText":"HTScoutSetSensorHysteresis","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gad6841b46176fdd709c2b44ded1cee76f.html#gad6841b46176fdd709c2b44ded1cee76f","snippet":"HTScoutSetSensorHysteresis(${1:const byte src}, ${2:const unsigned int value})","description":"HTScoutSetSensorHysteresis function."},{"leftLabel":"void","displayText":"HTScoutSetSensorLowerLimit","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gab6f651aed501517fd41306f18cef8c7a.html#gab6f651aed501517fd41306f18cef8c7a","snippet":"HTScoutSetSensorLowerLimit(${1:const byte src}, ${2:const unsigned int value})","description":"HTScoutSetSensorLowerLimit function."},{"leftLabel":"void","displayText":"HTScoutSetSensorUpperLimit","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_ga91438bbc6e2f46eebe3ca8fd4b080e6e.html#ga91438bbc6e2f46eebe3ca8fd4b080e6e","snippet":"HTScoutSetSensorUpperLimit(${1:const byte src}, ${2:const unsigned int value})","description":"HTScoutSetSensorUpperLimit function."},{"leftLabel":"void","displayText":"HTScoutUnmuteSound","type":"function","descriptionMoreURL":"group___hi_technic_a_p_i_gaab487282e32d152c8e57e2774f6ba1de.html#gaab487282e32d152c8e57e2774f6ba1de","snippet":"HTScoutUnmuteSound(${1:void})","description":"HTScoutUnmuteSound function."},{"leftLabel":"void","displayText":"SetSensorMSPressure","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga303fc25c8e11965796bd06f553d8f1ae.html#ga303fc25c8e11965796bd06f553d8f1ae","snippet":"SetSensorMSPressure(${1:const byte &port})","description":"Configure a mindsensors pressure sensor."},{"leftLabel":"void","displayText":"SetSensorMSDROD","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga993ab384a7353851c077d81191c34581.html#ga993ab384a7353851c077d81191c34581","snippet":"SetSensorMSDROD(${1:const byte &port}, ${2:bool bActive})","description":"Configure a mindsensors DROD sensor."},{"leftLabel":"void","displayText":"SetSensorNXTSumoEyes","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga1d642480e31a4f0ca74ab73c22db81db.html#ga1d642480e31a4f0ca74ab73c22db81db","snippet":"SetSensorNXTSumoEyes(${1:const byte &port}, ${2:bool bLong})","description":"Configure a mindsensors SumoEyes sensor."},{"leftLabel":"int","displayText":"SensorMSPressure","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga6b50d16038277c477abac03df8a17983.html#ga6b50d16038277c477abac03df8a17983","snippet":"SensorMSPressure(${1:const byte &port})","description":"Read mindsensors pressure sensor."},{"leftLabel":"char","displayText":"SensorNXTSumoEyes","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga91eab754daed00c1455527924f185516.html#ga91eab754daed00c1455527924f185516","snippet":"SensorNXTSumoEyes(${1:const byte &port})","description":"Read mindsensors NXTSumoEyes obstacle zone."},{"leftLabel":"int","displayText":"SensorMSCompass","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga8c368c86a8474352df4955493a293e8a.html#ga8c368c86a8474352df4955493a293e8a","snippet":"SensorMSCompass(${1:const byte &port}, ${2:const byte i2caddr})","description":"Read mindsensors compass value."},{"leftLabel":"int","displayText":"SensorMSDROD","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gacb172fcc9e6707d7ee159760212dff59.html#gacb172fcc9e6707d7ee159760212dff59","snippet":"SensorMSDROD(${1:const byte &port})","description":"Read mindsensors DROD value."},{"leftLabel":"int","displayText":"SensorNXTSumoEyesRaw","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga43b01ad9143d954b44f14cdd820ecf3f.html#ga43b01ad9143d954b44f14cdd820ecf3f","snippet":"SensorNXTSumoEyesRaw(${1:const byte &port})","description":"Read mindsensors NXTSumoEyes raw value."},{"leftLabel":"int","displayText":"SensorMSPressureRaw","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga2af490eb0d3319e6970e47737f0c39c9.html#ga2af490eb0d3319e6970e47737f0c39c9","snippet":"SensorMSPressureRaw(${1:const byte &port})","description":"Read mindsensors raw pressure value."},{"leftLabel":"bool","displayText":"ReadSensorMSAccel","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gacf3ee6a0493ee564316e4b42f3feb517.html#gacf3ee6a0493ee564316e4b42f3feb517","snippet":"ReadSensorMSAccel(${1:const byte port}, ${2:const byte i2caddr}, ${3:int &x}, ${4:int &y}, ${5:int &z})","description":"Read mindsensors acceleration values."},{"leftLabel":"bool","displayText":"ReadSensorMSPlayStation","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga121c0873665a939f3534c5e3e8b8d2fa.html#ga121c0873665a939f3534c5e3e8b8d2fa","snippet":"ReadSensorMSPlayStation(${1:const byte port}, ${2:const byte i2caddr}, ${3:byte &btnset1}, ${4:byte &btnset2}, ${5:byte &xleft}, ${6:byte &yleft}, ${7:byte &xright}, ${8:byte &yright})","description":"Read mindsensors playstation controller values."},{"leftLabel":"bool","displayText":"ReadSensorMSRTClock","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga624aefb799d7f5d3184347179f14f0e4.html#ga624aefb799d7f5d3184347179f14f0e4","snippet":"ReadSensorMSRTClock(${1:const byte port}, ${2:byte &sec}, ${3:byte &min}, ${4:byte &hrs}, ${5:byte &dow}, ${6:byte &date}, ${7:byte &month}, ${8:byte &year})","description":"Read mindsensors RTClock values."},{"leftLabel":"bool","displayText":"ReadSensorMSTilt","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gaf3ba4928f305c19e58c6183986df7a38.html#gaf3ba4928f305c19e58c6183986df7a38","snippet":"ReadSensorMSTilt(${1:const byte &port}, ${2:const byte &i2caddr}, ${3:byte &x}, ${4:byte &y}, ${5:byte &z})","description":"Read mindsensors tilt values."},{"leftLabel":"bool","displayText":"PFMateSend","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gab55a9de36288285f8376f08736fd3ffc.html#gab55a9de36288285f8376f08736fd3ffc","snippet":"PFMateSend(${1:const byte &port}, ${2:const byte &i2caddr}, ${3:const byte &channel}, ${4:const byte &motors}, ${5:const byte &cmdA}, ${6:const byte &spdA}, ${7:const byte &cmdB}, ${8:const byte &spdB})","description":"Send PFMate command."},{"leftLabel":"bool","displayText":"PFMateSendRaw","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga737ceb463f15f7a0cc6b59061b697a18.html#ga737ceb463f15f7a0cc6b59061b697a18","snippet":"PFMateSendRaw(${1:const byte &port}, ${2:const byte &i2caddr}, ${3:const byte &channel}, ${4:const byte &b1}, ${5:const byte &b2})","description":"Send raw PFMate command."},{"leftLabel":"int","displayText":"MSReadValue","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gaa170823d0d410b75264115aaee29b182.html#gaa170823d0d410b75264115aaee29b182","snippet":"MSReadValue(${1:const byte port}, ${2:const byte i2caddr}, ${3:const byte reg}, ${4:const byte numbytes})","description":"Read a mindsensors device value."},{"leftLabel":"char","displayText":"MSEnergize","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga0014508e8fc2333c93c8fda832b2cf77.html#ga0014508e8fc2333c93c8fda832b2cf77","snippet":"MSEnergize(${1:const byte port}, ${2:const byte i2caddr})","description":"Turn on power to device."},{"leftLabel":"char","displayText":"MSDeenergize","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga294d6e216c3d474cbacf1f01f52d9ebd.html#ga294d6e216c3d474cbacf1f01f52d9ebd","snippet":"MSDeenergize(${1:const byte port}, ${2:const byte i2caddr})","description":"Turn off power to device."},{"leftLabel":"char","displayText":"MSADPAOn","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gaf690d1ab8a9533b67b96a78c6e870c54.html#gaf690d1ab8a9533b67b96a78c6e870c54","snippet":"MSADPAOn(${1:const byte port}, ${2:const byte i2caddr})","description":"Turn on mindsensors ADPA mode."},{"leftLabel":"char","displayText":"MSADPAOff","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga6b9e97e1219c2200661ee360091af396.html#ga6b9e97e1219c2200661ee360091af396","snippet":"MSADPAOff(${1:const byte port}, ${2:const byte i2caddr})","description":"Turn off mindsensors ADPA mode."},{"leftLabel":"char","displayText":"DISTNxGP2D12","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gacf3f145bb18b10a9db6d71fbf65503fa.html#gacf3f145bb18b10a9db6d71fbf65503fa","snippet":"DISTNxGP2D12(${1:const byte port}, ${2:const byte i2caddr})","description":"Configure DISTNx as GP2D12."},{"leftLabel":"char","displayText":"DISTNxGP2D120","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gafd0fe12d7b44df814bdb6659794eea94.html#gafd0fe12d7b44df814bdb6659794eea94","snippet":"DISTNxGP2D120(${1:const byte port}, ${2:const byte i2caddr})","description":"Configure DISTNx as GP2D120."},{"leftLabel":"char","displayText":"DISTNxGP2YA02","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga1fe2bf6b13ee75b00ccf1b671453283f.html#ga1fe2bf6b13ee75b00ccf1b671453283f","snippet":"DISTNxGP2YA02(${1:const byte port}, ${2:const byte i2caddr})","description":"Configure DISTNx as GP2YA02."},{"leftLabel":"char","displayText":"DISTNxGP2YA21","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga03fac0b9e99303faf427cf0f7e07bbfb.html#ga03fac0b9e99303faf427cf0f7e07bbfb","snippet":"DISTNxGP2YA21(${1:const byte port}, ${2:const byte i2caddr})","description":"Configure DISTNx as GP2YA21."},{"leftLabel":"int","displayText":"DISTNxDistance","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gaa362d3858a715aa1fd18227b7b80dd94.html#gaa362d3858a715aa1fd18227b7b80dd94","snippet":"DISTNxDistance(${1:const byte port}, ${2:const byte i2caddr})","description":"Read DISTNx distance value."},{"leftLabel":"int","displayText":"DISTNxMaxDistance","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga58f75c0d7346a36d45d18f1bbc4bd440.html#ga58f75c0d7346a36d45d18f1bbc4bd440","snippet":"DISTNxMaxDistance(${1:const byte port}, ${2:const byte i2caddr})","description":"Read DISTNx maximum distance value."},{"leftLabel":"int","displayText":"DISTNxMinDistance","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gac940030e97c3ab329dbe5d72dce2fc21.html#gac940030e97c3ab329dbe5d72dce2fc21","snippet":"DISTNxMinDistance(${1:const byte port}, ${2:const byte i2caddr})","description":"Read DISTNx minimum distance value."},{"leftLabel":"byte","displayText":"DISTNxModuleType","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gab208bbcdea430b159644e85211b308eb.html#gab208bbcdea430b159644e85211b308eb","snippet":"DISTNxModuleType(${1:const byte port}, ${2:const byte i2caddr})","description":"Read DISTNx module type value."},{"leftLabel":"byte","displayText":"DISTNxNumPoints","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gaeb8adf737b52b8962b06fb354f9619b1.html#gaeb8adf737b52b8962b06fb354f9619b1","snippet":"DISTNxNumPoints(${1:const byte port}, ${2:const byte i2caddr})","description":"Read DISTNx num points value."},{"leftLabel":"int","displayText":"DISTNxVoltage","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga97c0bc4bc8a331d2c0607dfd914f1fd2.html#ga97c0bc4bc8a331d2c0607dfd914f1fd2","snippet":"DISTNxVoltage(${1:const byte port}, ${2:const byte i2caddr})","description":"Read DISTNx voltage value."},{"leftLabel":"char","displayText":"ACCLNxCalibrateX","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga25b1d2399081348fca72594b3b66cc7b.html#ga25b1d2399081348fca72594b3b66cc7b","snippet":"ACCLNxCalibrateX(${1:const byte port}, ${2:const byte i2caddr})","description":"Calibrate ACCL-Nx X-axis."},{"leftLabel":"char","displayText":"ACCLNxCalibrateXEnd","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga261f32c08c80f93b3af6a7aab66f05f3.html#ga261f32c08c80f93b3af6a7aab66f05f3","snippet":"ACCLNxCalibrateXEnd(${1:const byte port}, ${2:const byte i2caddr})","description":"Stop calibrating ACCL-Nx X-axis."},{"leftLabel":"char","displayText":"ACCLNxCalibrateY","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gaa258e57599d577d03785f2fcf120d213.html#gaa258e57599d577d03785f2fcf120d213","snippet":"ACCLNxCalibrateY(${1:const byte port}, ${2:const byte i2caddr})","description":"Calibrate ACCL-Nx Y-axis."},{"leftLabel":"char","displayText":"ACCLNxCalibrateYEnd","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga66701253178b3154986a5664a1138d3f.html#ga66701253178b3154986a5664a1138d3f","snippet":"ACCLNxCalibrateYEnd(${1:const byte port}, ${2:const byte i2caddr})","description":"Stop calibrating ACCL-Nx Y-axis."},{"leftLabel":"char","displayText":"ACCLNxCalibrateZ","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gab9eb8f6f755ebd7787587dc909b5ba61.html#gab9eb8f6f755ebd7787587dc909b5ba61","snippet":"ACCLNxCalibrateZ(${1:const byte port}, ${2:const byte i2caddr})","description":"Calibrate ACCL-Nx Z-axis."},{"leftLabel":"char","displayText":"ACCLNxCalibrateZEnd","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga60a7ce6d8ab39e211a8a065128c401dc.html#ga60a7ce6d8ab39e211a8a065128c401dc","snippet":"ACCLNxCalibrateZEnd(${1:const byte port}, ${2:const byte i2caddr})","description":"Stop calibrating ACCL-Nx Z-axis."},{"leftLabel":"char","displayText":"ACCLNxResetCalibration","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gad4f93a786fe7af9770c24f09ecff4bac.html#gad4f93a786fe7af9770c24f09ecff4bac","snippet":"ACCLNxResetCalibration(${1:const byte port}, ${2:const byte i2caddr})","description":"Reset ACCL-Nx calibration."},{"leftLabel":"char","displayText":"SetACCLNxSensitivity","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga21ba98a18bd1be9c125eed31da9bb6f4.html#ga21ba98a18bd1be9c125eed31da9bb6f4","snippet":"SetACCLNxSensitivity(${1:const byte port}, ${2:const byte i2caddr}, ${3:byte slevel})","description":"Set ACCL-Nx sensitivity."},{"leftLabel":"byte","displayText":"ACCLNxSensitivity","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gabacec0b4845031c11c83cb886f6f1506.html#gabacec0b4845031c11c83cb886f6f1506","snippet":"ACCLNxSensitivity(${1:const byte port}, ${2:const byte i2caddr})","description":"Read ACCL-Nx sensitivity value."},{"leftLabel":"int","displayText":"ACCLNxXOffset","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gaa623e78eebfc2b8218d21161d6fe3df1.html#gaa623e78eebfc2b8218d21161d6fe3df1","snippet":"ACCLNxXOffset(${1:const byte port}, ${2:const byte i2caddr})","description":"Read ACCL-Nx X offset value."},{"leftLabel":"int","displayText":"ACCLNxXRange","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gac42d2302fba28248a2d63236ffa9f2c0.html#gac42d2302fba28248a2d63236ffa9f2c0","snippet":"ACCLNxXRange(${1:const byte port}, ${2:const byte i2caddr})","description":"Read ACCL-Nx X range value."},{"leftLabel":"int","displayText":"ACCLNxYOffset","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gadff4c22de8b27e9af26b9b1171da75d1.html#gadff4c22de8b27e9af26b9b1171da75d1","snippet":"ACCLNxYOffset(${1:const byte port}, ${2:const byte i2caddr})","description":"Read ACCL-Nx Y offset value."},{"leftLabel":"int","displayText":"ACCLNxYRange","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga4e8cd076710d5ad9570b7c20107715ef.html#ga4e8cd076710d5ad9570b7c20107715ef","snippet":"ACCLNxYRange(${1:const byte port}, ${2:const byte i2caddr})","description":"Read ACCL-Nx Y range value."},{"leftLabel":"int","displayText":"ACCLNxZOffset","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga5e671b7b7ca728f1a6d3bede9b5f0333.html#ga5e671b7b7ca728f1a6d3bede9b5f0333","snippet":"ACCLNxZOffset(${1:const byte port}, ${2:const byte i2caddr})","description":"Read ACCL-Nx Z offset value."},{"leftLabel":"int","displayText":"ACCLNxZRange","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gaaaaca61e17582ebc14b23064b3703090.html#gaaaaca61e17582ebc14b23064b3703090","snippet":"ACCLNxZRange(${1:const byte port}, ${2:const byte i2caddr})","description":"Read ACCL-Nx Z range value."},{"leftLabel":"char","displayText":"PSPNxDigital","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gacb27c4393915249c7a4286f37a3b0043.html#gacb27c4393915249c7a4286f37a3b0043","snippet":"PSPNxDigital(${1:const byte &port}, ${2:const byte &i2caddr})","description":"Configure PSPNx in digital mode."},{"leftLabel":"char","displayText":"PSPNxAnalog","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga5b3b1c572eb60382dae6c9178a76c8c6.html#ga5b3b1c572eb60382dae6c9178a76c8c6","snippet":"PSPNxAnalog(${1:const byte &port}, ${2:const byte &i2caddr})","description":"Configure PSPNx in analog mode."},{"leftLabel":"unsigned int","displayText":"NXTServoPosition","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga6ed5f76c165421dce3c338d90c44b90f.html#ga6ed5f76c165421dce3c338d90c44b90f","snippet":"NXTServoPosition(${1:const byte &port}, ${2:const byte &i2caddr}, ${3:const byte servo})","description":"Read NXTServo servo position value."},{"leftLabel":"byte","displayText":"NXTServoSpeed","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga372fcb08f46bf1bcff01e9182b8be2e6.html#ga372fcb08f46bf1bcff01e9182b8be2e6","snippet":"NXTServoSpeed(${1:const byte &port}, ${2:const byte &i2caddr}, ${3:const byte servo})","description":"Read NXTServo servo speed value."},{"leftLabel":"byte","displayText":"NXTServoBatteryVoltage","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga05a5a0396a45a8159168da061a2b4040.html#ga05a5a0396a45a8159168da061a2b4040","snippet":"NXTServoBatteryVoltage(${1:const byte &port}, ${2:const byte &i2caddr})","description":"Read NXTServo battery voltage value."},{"leftLabel":"char","displayText":"SetNXTServoSpeed","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga56bbe9a41513bea3dc7b26643b39beba.html#ga56bbe9a41513bea3dc7b26643b39beba","snippet":"SetNXTServoSpeed(${1:const byte &port}, ${2:const byte &i2caddr}, ${3:const byte servo}, ${4:const byte &speed})","description":"Set NXTServo servo motor speed."},{"leftLabel":"char","displayText":"SetNXTServoQuickPosition","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga47e7943546faa67c9f6fe76d76871b4b.html#ga47e7943546faa67c9f6fe76d76871b4b","snippet":"SetNXTServoQuickPosition(${1:const byte &port}, ${2:const byte &i2caddr}, ${3:const byte servo}, ${4:const byte &qpos})","description":"Set NXTServo servo motor quick position."},{"leftLabel":"char","displayText":"SetNXTServoPosition","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga580f1b8e3d606976fd74639b8ae7fb7e.html#ga580f1b8e3d606976fd74639b8ae7fb7e","snippet":"SetNXTServoPosition(${1:const byte &port}, ${2:const byte &i2caddr}, ${3:const byte servo}, ${4:const byte &pos})","description":"Set NXTServo servo motor position."},{"leftLabel":"char","displayText":"NXTServoReset","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gabe8d459b7ece54e5d97229f95a227822.html#gabe8d459b7ece54e5d97229f95a227822","snippet":"NXTServoReset(${1:const byte &port}, ${2:const byte &i2caddr})","description":"Reset NXTServo properties."},{"leftLabel":"char","displayText":"NXTServoHaltMacro","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gad197062f168033c8dad5bc7aa7927388.html#gad197062f168033c8dad5bc7aa7927388","snippet":"NXTServoHaltMacro(${1:const byte &port}, ${2:const byte &i2caddr})","description":"Halt NXTServo macro."},{"leftLabel":"char","displayText":"NXTServoResumeMacro","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gad98e618feef42b79e46fb881b18f0128.html#gad98e618feef42b79e46fb881b18f0128","snippet":"NXTServoResumeMacro(${1:const byte &port}, ${2:const byte &i2caddr})","description":"Resume NXTServo macro."},{"leftLabel":"char","displayText":"NXTServoPauseMacro","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga06e2a94ccc82c1e16bbd4e2cdea0acff.html#ga06e2a94ccc82c1e16bbd4e2cdea0acff","snippet":"NXTServoPauseMacro(${1:const byte &port}, ${2:const byte &i2caddr})","description":"Pause NXTServo macro."},{"leftLabel":"char","displayText":"NXTServoInit","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga0da05e5fa1be1c0d29e0144f3bb97205.html#ga0da05e5fa1be1c0d29e0144f3bb97205","snippet":"NXTServoInit(${1:const byte &port}, ${2:const byte &i2caddr}, ${3:const byte servo})","description":"Initialize NXTServo servo properties."},{"leftLabel":"char","displayText":"NXTServoGotoMacroAddress","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga81c55dff0778b7dd6f11f25d68a8dd81.html#ga81c55dff0778b7dd6f11f25d68a8dd81","snippet":"NXTServoGotoMacroAddress(${1:const byte &port}, ${2:const byte &i2caddr}, ${3:const byte &macro})","description":"Goto NXTServo macro address."},{"leftLabel":"char","displayText":"NXTServoEditMacro","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga90290bc4f5c3928a42812625ab84f450.html#ga90290bc4f5c3928a42812625ab84f450","snippet":"NXTServoEditMacro(${1:const byte &port}, ${2:const byte &i2caddr})","description":"Edit NXTServo macro."},{"leftLabel":"char","displayText":"NXTServoQuitEdit","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga09487a1fcbf80d0684c1020ec47a1794.html#ga09487a1fcbf80d0684c1020ec47a1794","snippet":"NXTServoQuitEdit(${1:const byte &port})","description":"Quit NXTServo macro edit mode."},{"leftLabel":"char","displayText":"NXTHIDAsciiMode","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga2b3d16b76dd669df0dee735ef72595ce.html#ga2b3d16b76dd669df0dee735ef72595ce","snippet":"NXTHIDAsciiMode(${1:const byte &port}, ${2:const byte &i2caddr})","description":"Set NXTHID into ASCII data mode."},{"leftLabel":"char","displayText":"NXTHIDDirectMode","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga6e99a95197287d9e774ee8fa1688e0e3.html#ga6e99a95197287d9e774ee8fa1688e0e3","snippet":"NXTHIDDirectMode(${1:const byte &port}, ${2:const byte &i2caddr})","description":"Set NXTHID into direct data mode."},{"leftLabel":"char","displayText":"NXTHIDTransmit","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga8eeb3d157131734b3e12b5f004244ce8.html#ga8eeb3d157131734b3e12b5f004244ce8","snippet":"NXTHIDTransmit(${1:const byte &port}, ${2:const byte &i2caddr})","description":"Transmit NXTHID character."},{"leftLabel":"char","displayText":"NXTHIDLoadCharacter","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga251d11a1e716805b9aa6be9e06b2e8d2.html#ga251d11a1e716805b9aa6be9e06b2e8d2","snippet":"NXTHIDLoadCharacter(${1:const byte &port}, ${2:const byte &i2caddr}, ${3:const byte &modifier}, ${4:const byte &character})","description":"Load NXTHID character."},{"leftLabel":"char","displayText":"NXTPowerMeterResetCounters","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga997a8ad061e78d6519edee472a7797f6.html#ga997a8ad061e78d6519edee472a7797f6","snippet":"NXTPowerMeterResetCounters(${1:const byte &port}, ${2:const byte &i2caddr})","description":"Reset NXTPowerMeter counters."},{"leftLabel":"int","displayText":"NXTPowerMeterPresentCurrent","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga020cdd3c22c825b7e0e9ef05540df4cc.html#ga020cdd3c22c825b7e0e9ef05540df4cc","snippet":"NXTPowerMeterPresentCurrent(${1:const byte &port}, ${2:const byte &i2caddr})","description":"Read NXTPowerMeter present current."},{"leftLabel":"int","displayText":"NXTPowerMeterPresentVoltage","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gafb18d33bc35011baef361ff4aa3aeaaf.html#gafb18d33bc35011baef361ff4aa3aeaaf","snippet":"NXTPowerMeterPresentVoltage(${1:const byte &port}, ${2:const byte &i2caddr})","description":"Read NXTPowerMeter present voltage."},{"leftLabel":"int","displayText":"NXTPowerMeterCapacityUsed","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga65343ee215381ec0e2975c22b86ed38f.html#ga65343ee215381ec0e2975c22b86ed38f","snippet":"NXTPowerMeterCapacityUsed(${1:const byte &port}, ${2:const byte &i2caddr})","description":"Read NXTPowerMeter capacity used."},{"leftLabel":"int","displayText":"NXTPowerMeterPresentPower","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gaf0941dc49c8f131e495f025236534209.html#gaf0941dc49c8f131e495f025236534209","snippet":"NXTPowerMeterPresentPower(${1:const byte &port}, ${2:const byte &i2caddr})","description":"Read NXTPowerMeter present power."},{"leftLabel":"long","displayText":"NXTPowerMeterTotalPowerConsumed","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga1f64adae71faed68aa2648789c13934a.html#ga1f64adae71faed68aa2648789c13934a","snippet":"NXTPowerMeterTotalPowerConsumed(${1:const byte &port}, ${2:const byte &i2caddr})","description":"Read NXTPowerMeter total power consumed."},{"leftLabel":"int","displayText":"NXTPowerMeterMaxCurrent","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga69cbe8e4589bdf8ae66211d3c6941adb.html#ga69cbe8e4589bdf8ae66211d3c6941adb","snippet":"NXTPowerMeterMaxCurrent(${1:const byte &port}, ${2:const byte &i2caddr})","description":"Read NXTPowerMeter maximum current."},{"leftLabel":"int","displayText":"NXTPowerMeterMinCurrent","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga1d047c1703b53bf64acb60c67069a37a.html#ga1d047c1703b53bf64acb60c67069a37a","snippet":"NXTPowerMeterMinCurrent(${1:const byte &port}, ${2:const byte &i2caddr})","description":"Read NXTPowerMeter minimum current."},{"leftLabel":"int","displayText":"NXTPowerMeterMaxVoltage","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga265391878adbb6458c7aeec7c4f46a05.html#ga265391878adbb6458c7aeec7c4f46a05","snippet":"NXTPowerMeterMaxVoltage(${1:const byte &port}, ${2:const byte &i2caddr})","description":"Read NXTPowerMeter maximum voltage."},{"leftLabel":"int","displayText":"NXTPowerMeterMinVoltage","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga8a7c01195c040139d6f350c55fc2c9e3.html#ga8a7c01195c040139d6f350c55fc2c9e3","snippet":"NXTPowerMeterMinVoltage(${1:const byte &port}, ${2:const byte &i2caddr})","description":"Read NXTPowerMeter minimum voltage."},{"leftLabel":"long","displayText":"NXTPowerMeterElapsedTime","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga1d41fe6baa48f7e4603613252072ad61.html#ga1d41fe6baa48f7e4603613252072ad61","snippet":"NXTPowerMeterElapsedTime(${1:const byte &port}, ${2:const byte &i2caddr})","description":"Read NXTPowerMeter elapsed time."},{"leftLabel":"int","displayText":"NXTPowerMeterErrorCount","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga34e38f013383371acf6a8d2d2567539e.html#ga34e38f013383371acf6a8d2d2567539e","snippet":"NXTPowerMeterErrorCount(${1:const byte &port}, ${2:const byte &i2caddr})","description":"Read NXTPowerMeter error count."},{"leftLabel":"char","displayText":"NXTLineLeaderPowerDown","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga9d3f4c054dbb5c3ddea23b425669b474.html#ga9d3f4c054dbb5c3ddea23b425669b474","snippet":"NXTLineLeaderPowerDown(${1:const byte &port}, ${2:const byte &i2caddr})","description":"Powerdown NXTLineLeader device."},{"leftLabel":"char","displayText":"NXTLineLeaderPowerUp","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga6db36414bf38a9abcb8f7b441586dc77.html#ga6db36414bf38a9abcb8f7b441586dc77","snippet":"NXTLineLeaderPowerUp(${1:const byte &port}, ${2:const byte &i2caddr})","description":"Powerup NXTLineLeader device."},{"leftLabel":"char","displayText":"NXTLineLeaderInvert","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gaf4e1753f179a1afa9845bb89b7b2e19e.html#gaf4e1753f179a1afa9845bb89b7b2e19e","snippet":"NXTLineLeaderInvert(${1:const byte &port}, ${2:const byte &i2caddr})","description":"Invert NXTLineLeader colors."},{"leftLabel":"char","displayText":"NXTLineLeaderReset","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga5956afe257fda5892f217ea86abbaa00.html#ga5956afe257fda5892f217ea86abbaa00","snippet":"NXTLineLeaderReset(${1:const byte &port}, ${2:const byte &i2caddr})","description":"Reset NXTLineLeader color inversion."},{"leftLabel":"char","displayText":"NXTLineLeaderSnapshot","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga9e6849bc6af2c37cb61c643e6d04eb57.html#ga9e6849bc6af2c37cb61c643e6d04eb57","snippet":"NXTLineLeaderSnapshot(${1:const byte &port}, ${2:const byte &i2caddr})","description":"Take NXTLineLeader line snapshot."},{"leftLabel":"char","displayText":"NXTLineLeaderCalibrateWhite","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga27917c0c4dd9aa7a2ed3c00b3e147201.html#ga27917c0c4dd9aa7a2ed3c00b3e147201","snippet":"NXTLineLeaderCalibrateWhite(${1:const byte &port}, ${2:const byte &i2caddr})","description":"Calibrate NXTLineLeader white color."},{"leftLabel":"char","displayText":"NXTLineLeaderCalibrateBlack","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga1fc953e4eb1803afa996639ff586fc2a.html#ga1fc953e4eb1803afa996639ff586fc2a","snippet":"NXTLineLeaderCalibrateBlack(${1:const byte &port}, ${2:const byte &i2caddr})","description":"Calibrate NXTLineLeader black color."},{"leftLabel":"char","displayText":"NXTLineLeaderSteering","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga19e2190acd94e51909ca3ff7e1371b32.html#ga19e2190acd94e51909ca3ff7e1371b32","snippet":"NXTLineLeaderSteering(${1:const byte &port}, ${2:const byte &i2caddr})","description":"Read NXTLineLeader steering."},{"leftLabel":"char","displayText":"NXTLineLeaderAverage","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gae6465863ab6db7fe02c13f04919df177.html#gae6465863ab6db7fe02c13f04919df177","snippet":"NXTLineLeaderAverage(${1:const byte &port}, ${2:const byte &i2caddr})","description":"Read NXTLineLeader average."},{"leftLabel":"byte","displayText":"NXTLineLeaderResult","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga1dcdfd1f52ea66fdcadaa709251d91e0.html#ga1dcdfd1f52ea66fdcadaa709251d91e0","snippet":"NXTLineLeaderResult(${1:const byte &port}, ${2:const byte &i2caddr})","description":"Read NXTLineLeader result."},{"leftLabel":"char","displayText":"SetNXTLineLeaderSetpoint","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga7c449f01adcb63ead4689407fdfa0142.html#ga7c449f01adcb63ead4689407fdfa0142","snippet":"SetNXTLineLeaderSetpoint(${1:const byte &port}, ${2:const byte &i2caddr}, ${3:const byte &value})","description":"Write NXTLineLeader setpoint."},{"leftLabel":"char","displayText":"SetNXTLineLeaderKpValue","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gabe6f5ccb37714b17e20b302e356a2491.html#gabe6f5ccb37714b17e20b302e356a2491","snippet":"SetNXTLineLeaderKpValue(${1:const byte &port}, ${2:const byte &i2caddr}, ${3:const byte &value})","description":"Write NXTLineLeader Kp value."},{"leftLabel":"char","displayText":"SetNXTLineLeaderKiValue","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga1b392245b70856e55d747d7f968d1ce7.html#ga1b392245b70856e55d747d7f968d1ce7","snippet":"SetNXTLineLeaderKiValue(${1:const byte &port}, ${2:const byte &i2caddr}, ${3:const byte &value})","description":"Write NXTLineLeader Ki value."},{"leftLabel":"char","displayText":"SetNXTLineLeaderKdValue","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga16f5dbc670beb167d7a5e2faa195c754.html#ga16f5dbc670beb167d7a5e2faa195c754","snippet":"SetNXTLineLeaderKdValue(${1:const byte &port}, ${2:const byte &i2caddr}, ${3:const byte &value})","description":"Write NXTLineLeader Kd value."},{"leftLabel":"char","displayText":"SetNXTLineLeaderKpFactor","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga60e975ecf422d68c3d1a36e62a21867b.html#ga60e975ecf422d68c3d1a36e62a21867b","snippet":"SetNXTLineLeaderKpFactor(${1:const byte &port}, ${2:const byte &i2caddr}, ${3:const byte &value})","description":"Write NXTLineLeader Kp factor."},{"leftLabel":"char","displayText":"SetNXTLineLeaderKiFactor","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gae97171cb45e5e52c215e5f2187183268.html#gae97171cb45e5e52c215e5f2187183268","snippet":"SetNXTLineLeaderKiFactor(${1:const byte &port}, ${2:const byte &i2caddr}, ${3:const byte &value})","description":"Write NXTLineLeader Ki factor."},{"leftLabel":"char","displayText":"SetNXTLineLeaderKdFactor","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gab7237837fe66c26f379e2ae54082cb83.html#gab7237837fe66c26f379e2ae54082cb83","snippet":"SetNXTLineLeaderKdFactor(${1:const byte &port}, ${2:const byte &i2caddr}, ${3:const byte &value})","description":"Write NXTLineLeader Kd factor."},{"leftLabel":"char","displayText":"NRLink2400","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gad20b47dee83421271a4f0edff77ac767.html#gad20b47dee83421271a4f0edff77ac767","snippet":"NRLink2400(${1:const byte port}, ${2:const byte i2caddr})","description":"Configure NRLink in 2400 baud mode."},{"leftLabel":"char","displayText":"NRLink4800","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gacaf171f6855f3fb0e941a65064143e5c.html#gacaf171f6855f3fb0e941a65064143e5c","snippet":"NRLink4800(${1:const byte port}, ${2:const byte i2caddr})","description":"Configure NRLink in 4800 baud mode."},{"leftLabel":"char","displayText":"NRLinkFlush","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gac2a4f5323a941775632b8917d268bbe5.html#gac2a4f5323a941775632b8917d268bbe5","snippet":"NRLinkFlush(${1:const byte port}, ${2:const byte i2caddr})","description":"Flush NRLink buffers."},{"leftLabel":"char","displayText":"NRLinkIRLong","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga311d99d400580dec788aee698319935c.html#ga311d99d400580dec788aee698319935c","snippet":"NRLinkIRLong(${1:const byte port}, ${2:const byte i2caddr})","description":"Configure NRLink in IR long mode."},{"leftLabel":"char","displayText":"NRLinkIRShort","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gaf3e230bed5c8872c91f754bf0521b598.html#gaf3e230bed5c8872c91f754bf0521b598","snippet":"NRLinkIRShort(${1:const byte port}, ${2:const byte i2caddr})","description":"Configure NRLink in IR short mode."},{"leftLabel":"char","displayText":"NRLinkSetPF","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga43dd7daf154d8267887f1b089f58eacf.html#ga43dd7daf154d8267887f1b089f58eacf","snippet":"NRLinkSetPF(${1:const byte port}, ${2:const byte i2caddr})","description":"Configure NRLink in power function mode."},{"leftLabel":"char","displayText":"NRLinkSetRCX","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gac00191339fcc01480cacad30cf26ecc0.html#gac00191339fcc01480cacad30cf26ecc0","snippet":"NRLinkSetRCX(${1:const byte port}, ${2:const byte i2caddr})","description":"Configure NRLink in RCX mode."},{"leftLabel":"char","displayText":"NRLinkSetTrain","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga331cc01cb3ffabd7b64f668c96de9938.html#ga331cc01cb3ffabd7b64f668c96de9938","snippet":"NRLinkSetTrain(${1:const byte port}, ${2:const byte i2caddr})","description":"Configure NRLink in IR train mode."},{"leftLabel":"char","displayText":"NRLinkTxRaw","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga58e7a65733e8e040fa71169e044fb558.html#ga58e7a65733e8e040fa71169e044fb558","snippet":"NRLinkTxRaw(${1:const byte port}, ${2:const byte i2caddr})","description":"Configure NRLink in raw IR transmit mode."},{"leftLabel":"byte","displayText":"NRLinkStatus","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gaa26b9472338fb131abd1fd90cd9173ca.html#gaa26b9472338fb131abd1fd90cd9173ca","snippet":"NRLinkStatus(${1:const byte port}, ${2:const byte i2caddr})","description":"Read NRLink status."},{"leftLabel":"char","displayText":"RunNRLinkMacro","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gadc62f13d02633855c903bc5a49f8ff72.html#gadc62f13d02633855c903bc5a49f8ff72","snippet":"RunNRLinkMacro(${1:const byte port}, ${2:const byte i2caddr}, ${3:const byte macro})","description":"Run NRLink macro."},{"leftLabel":"char","displayText":"WriteNRLinkBytes","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gabbb22e4e52cb19702802956350018f3c.html#gabbb22e4e52cb19702802956350018f3c","snippet":"WriteNRLinkBytes(${1:const byte port}, ${2:const byte i2caddr}, ${3:const byte data[]})","description":"Write data to NRLink."},{"leftLabel":"bool","displayText":"ReadNRLinkBytes","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gab6f0003ea2a56e87c8f8553db1d89cfb.html#gab6f0003ea2a56e87c8f8553db1d89cfb","snippet":"ReadNRLinkBytes(${1:const byte port}, ${2:const byte i2caddr}, ${3:byte &data[]})","description":"Read data from NRLink."},{"leftLabel":"char","displayText":"MSIRTrain","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga78e99b9d5000ddbbf9666cf8305a4ca2.html#ga78e99b9d5000ddbbf9666cf8305a4ca2","snippet":"MSIRTrain(${1:const byte port}, ${2:const byte i2caddr}, ${3:const byte channel}, ${4:const byte func})","description":"MSIRTrain function."},{"leftLabel":"char","displayText":"MSPFComboDirect","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga08e0757e4cb713ef287dd001e8fcf110.html#ga08e0757e4cb713ef287dd001e8fcf110","snippet":"MSPFComboDirect(${1:const byte port}, ${2:const byte i2caddr}, ${3:const byte channel}, ${4:const byte outa}, ${5:const byte outb})","description":"MSPFComboDirect function."},{"leftLabel":"char","displayText":"MSPFComboPWM","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gae33dab6c3fa4ee05c3f4a162a8437eb6.html#gae33dab6c3fa4ee05c3f4a162a8437eb6","snippet":"MSPFComboPWM(${1:const byte port}, ${2:const byte i2caddr}, ${3:const byte channel}, ${4:const byte outa}, ${5:const byte outb})","description":"MSPFComboPWM function."},{"leftLabel":"char","displayText":"MSPFRawOutput","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga5e27b735a12ecb09d5dca0442f8d8f33.html#ga5e27b735a12ecb09d5dca0442f8d8f33","snippet":"MSPFRawOutput(${1:const byte port}, ${2:const byte i2caddr}, ${3:const byte nibble0}, ${4:const byte nibble1}, ${5:const byte nibble2})","description":"MSPFRawOutput function."},{"leftLabel":"char","displayText":"MSPFRepeat","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga8716f435f3de969276577e30e4500663.html#ga8716f435f3de969276577e30e4500663","snippet":"MSPFRepeat(${1:const byte port}, ${2:const byte i2caddr}, ${3:const byte count}, ${4:const unsigned int delay})","description":"MSPFRepeat function."},{"leftLabel":"char","displayText":"MSPFSingleOutputCST","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gae3d406cc00a01201b5f89218f912afa6.html#gae3d406cc00a01201b5f89218f912afa6","snippet":"MSPFSingleOutputCST(${1:const byte port}, ${2:const byte i2caddr}, ${3:const byte channel}, ${4:const byte out}, ${5:const byte func})","description":"MSPFSingleOutputCST function."},{"leftLabel":"char","displayText":"MSPFSingleOutputPWM","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga2e891ead3ba94d1738e7b01ba6766ea6.html#ga2e891ead3ba94d1738e7b01ba6766ea6","snippet":"MSPFSingleOutputPWM(${1:const byte port}, ${2:const byte i2caddr}, ${3:const byte channel}, ${4:const byte out}, ${5:const byte func})","description":"MSPFSingleOutputPWM function."},{"leftLabel":"char","displayText":"MSPFSinglePin","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gae2b6192847bcc0f7ecaef9f2fe6fe323.html#gae2b6192847bcc0f7ecaef9f2fe6fe323","snippet":"MSPFSinglePin(${1:const byte port}, ${2:const byte i2caddr}, ${3:const byte channel}, ${4:const byte out}, ${5:const byte pin}, ${6:const byte func}, ${7:bool cont})","description":"MSPFSinglePin function."},{"leftLabel":"char","displayText":"MSPFTrain","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga0cc2087b18e92a0e5b92c3bf17232e65.html#ga0cc2087b18e92a0e5b92c3bf17232e65","snippet":"MSPFTrain(${1:const byte port}, ${2:const byte i2caddr}, ${3:const byte channel}, ${4:const byte func})","description":"MSPFTrain function."},{"leftLabel":"void","displayText":"MSRCXSetNRLinkPort","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gac04ad8f352eaf70cc1f80beed7e5c79e.html#gac04ad8f352eaf70cc1f80beed7e5c79e","snippet":"MSRCXSetNRLinkPort(${1:const byte port}, ${2:const byte i2caddr})","description":"MSRCXSetIRLinkPort function."},{"leftLabel":"int","displayText":"MSRCXBatteryLevel","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gac7ef075de7088d57a20166b97a256b45.html#gac7ef075de7088d57a20166b97a256b45","snippet":"MSRCXBatteryLevel(${1:void})","description":"MSRCXBatteryLevel function."},{"leftLabel":"int","displayText":"MSRCXPoll","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga6d32f3ddc922a04e19af8c4c216f9920.html#ga6d32f3ddc922a04e19af8c4c216f9920","snippet":"MSRCXPoll(${1:const byte src}, ${2:const byte value})","description":"MSRCXPoll function."},{"leftLabel":"int","displayText":"MSRCXPollMemory","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga26e9d7180d55ce82d45399006d862c94.html#ga26e9d7180d55ce82d45399006d862c94","snippet":"MSRCXPollMemory(${1:const unsigned int address})","description":"MSRCXPollMemory function."},{"leftLabel":"void","displayText":"MSRCXAbsVar","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gab49065ea7ce33aa85f1c854d1fdf890b.html#gab49065ea7ce33aa85f1c854d1fdf890b","snippet":"MSRCXAbsVar(${1:const byte varnum}, ${2:const byte byte src}, ${3:const unsigned int value})","description":"MSRCXAbsVar function."},{"leftLabel":"void","displayText":"MSRCXAddToDatalog","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gad84aee809f84172d7669c7d8ce327e59.html#gad84aee809f84172d7669c7d8ce327e59","snippet":"MSRCXAddToDatalog(${1:const byte src}, ${2:const unsigned int value})","description":"MSRCXAddToDatalog function."},{"leftLabel":"void","displayText":"MSRCXAndVar","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gac2db8ef54ad2067f7610f2f40e137678.html#gac2db8ef54ad2067f7610f2f40e137678","snippet":"MSRCXAndVar(${1:const byte varnum}, ${2:const byte src}, ${3:const unsigned int value})","description":"MSRCXAndVar function."},{"leftLabel":"void","displayText":"MSRCXBoot","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga411ed1a834f14384d5b68a0f27fb2854.html#ga411ed1a834f14384d5b68a0f27fb2854","snippet":"MSRCXBoot(${1:void})","description":"MSRCXBoot function."},{"leftLabel":"void","displayText":"MSRCXCalibrateEvent","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga087024d5d8581212cb62470b75e2b8c5.html#ga087024d5d8581212cb62470b75e2b8c5","snippet":"MSRCXCalibrateEvent(${1:const byte evt}, ${2:const byte low}, ${3:const byte hi}, ${4:const byte hyst})","description":"MSRCXCalibrateEvent function."},{"leftLabel":"void","displayText":"MSRCXClearAllEvents","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gafec52d22f643469e67b941ba86afb1bc.html#gafec52d22f643469e67b941ba86afb1bc","snippet":"MSRCXClearAllEvents(${1:void})","description":"MSRCXClearAllEvents function."},{"leftLabel":"void","displayText":"MSRCXClearCounter","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga15d75034d7fd58846e1b811118687622.html#ga15d75034d7fd58846e1b811118687622","snippet":"MSRCXClearCounter(${1:const byte counter})","description":"MSRCXClearCounter function."},{"leftLabel":"void","displayText":"MSRCXClearMsg","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gaf64070ed7e6b8a7495f520f4d9d0afe0.html#gaf64070ed7e6b8a7495f520f4d9d0afe0","snippet":"MSRCXClearMsg(${1:void})","description":"MSRCXClearMsg function."},{"leftLabel":"void","displayText":"MSRCXClearSensor","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga75c93c7201ef07b976db11996210cf9c.html#ga75c93c7201ef07b976db11996210cf9c","snippet":"MSRCXClearSensor(${1:const byte port})","description":"MSRCXClearSensor function."},{"leftLabel":"void","displayText":"MSRCXClearSound","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga94790d6dd64362e3eb3a11fcf964920a.html#ga94790d6dd64362e3eb3a11fcf964920a","snippet":"MSRCXClearSound(${1:void})","description":"MSRCXClearSound function."},{"leftLabel":"void","displayText":"MSRCXClearTimer","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga1a6f2dfa36cf4d3a2a23de472d032f28.html#ga1a6f2dfa36cf4d3a2a23de472d032f28","snippet":"MSRCXClearTimer(${1:const byte timer})","description":"MSRCXClearTimer function."},{"leftLabel":"void","displayText":"MSRCXCreateDatalog","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga7394ae627171f3c3813e2a9c32272123.html#ga7394ae627171f3c3813e2a9c32272123","snippet":"MSRCXCreateDatalog(${1:const unsigned int size})","description":"MSRCXCreateDatalog function."},{"leftLabel":"void","displayText":"MSRCXDecCounter","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga8411df188eaf9e688c77165610da27ba.html#ga8411df188eaf9e688c77165610da27ba","snippet":"MSRCXDecCounter(${1:const byte counter})","description":"MSRCXDecCounter function."},{"leftLabel":"void","displayText":"MSRCXDeleteSub","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gaaa4590fda6b5f1f6561ca782930625d0.html#gaaa4590fda6b5f1f6561ca782930625d0","snippet":"MSRCXDeleteSub(${1:const byte s})","description":"MSRCXDeleteSub function."},{"leftLabel":"void","displayText":"MSRCXDeleteSubs","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gaf1dc8f8b056912a9caa869fec0cb97da.html#gaf1dc8f8b056912a9caa869fec0cb97da","snippet":"MSRCXDeleteSubs(${1:void})","description":"MSRCXDeleteSubs function."},{"leftLabel":"void","displayText":"MSRCXDeleteTask","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga6b4f0cadf988ae365dd4293ec3b66a02.html#ga6b4f0cadf988ae365dd4293ec3b66a02","snippet":"MSRCXDeleteTask(${1:const byte t})","description":"MSRCXDeleteTask function."},{"leftLabel":"void","displayText":"MSRCXDeleteTasks","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga1ecd20ff9a8929f66cf70a6696fc762f.html#ga1ecd20ff9a8929f66cf70a6696fc762f","snippet":"MSRCXDeleteTasks(${1:void})","description":"MSRCXDeleteTasks function."},{"leftLabel":"void","displayText":"MSRCXDisableOutput","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gab8dcb76fd804493632bad8b7e19a8a3d.html#gab8dcb76fd804493632bad8b7e19a8a3d","snippet":"MSRCXDisableOutput(${1:const byte outputs})","description":"MSRCXDisableOutput function."},{"leftLabel":"void","displayText":"MSRCXDivVar","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga1796258df9d64b83c1f7b27f8bb9e5dd.html#ga1796258df9d64b83c1f7b27f8bb9e5dd","snippet":"MSRCXDivVar(${1:const byte varnum}, ${2:const byte src}, ${3:const unsigned int value})","description":"MSRCXDivVar function."},{"leftLabel":"void","displayText":"MSRCXEnableOutput","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gab662147fcf332c0a9960cd7ae925def1.html#gab662147fcf332c0a9960cd7ae925def1","snippet":"MSRCXEnableOutput(${1:const byte outputs})","description":"MSRCXEnableOutput function."},{"leftLabel":"void","displayText":"MSRCXEvent","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga567751ce237a9b1a0c62bef226af5c89.html#ga567751ce237a9b1a0c62bef226af5c89","snippet":"MSRCXEvent(${1:const byte src}, ${2:const unsigned int value})","description":"MSRCXEvent function."},{"leftLabel":"void","displayText":"MSRCXFloat","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga62c73c9e955bde83d274ad72f4452df7.html#ga62c73c9e955bde83d274ad72f4452df7","snippet":"MSRCXFloat(${1:const byte outputs})","description":"MSRCXFloat function."},{"leftLabel":"void","displayText":"MSRCXFwd","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga729c738a954632b8b24b4d6156fd0007.html#ga729c738a954632b8b24b4d6156fd0007","snippet":"MSRCXFwd(${1:const byte outputs})","description":"MSRCXFwd function."},{"leftLabel":"void","displayText":"MSRCXIncCounter","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gab0b283636d0511430623f3ab7491b1be.html#gab0b283636d0511430623f3ab7491b1be","snippet":"MSRCXIncCounter(${1:const byte counter})","description":"MSRCXIncCounter function."},{"leftLabel":"void","displayText":"MSRCXInvertOutput","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga64ac6e384141716df78a39f74d2e159f.html#ga64ac6e384141716df78a39f74d2e159f","snippet":"MSRCXInvertOutput(${1:const byte outputs})","description":"MSRCXInvertOutput function."},{"leftLabel":"void","displayText":"MSRCXMulVar","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gafb98e7bb2295042d025914e0ecbede66.html#gafb98e7bb2295042d025914e0ecbede66","snippet":"MSRCXMulVar(${1:const byte varnum}, ${2:const byte src}, ${3:unsigned int value})","description":"MSRCXMulVar function."},{"leftLabel":"void","displayText":"MSRCXMuteSound","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga72dcc2e9c88061b0e6bfb0d3811d5b3c.html#ga72dcc2e9c88061b0e6bfb0d3811d5b3c","snippet":"MSRCXMuteSound(${1:void})","description":"MSRCXMuteSound function."},{"leftLabel":"void","displayText":"MSRCXObvertOutput","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga4fe504dfc2523b6ab157c2653c653974.html#ga4fe504dfc2523b6ab157c2653c653974","snippet":"MSRCXObvertOutput(${1:const byte outputs})","description":"MSRCXObvertOutput function."},{"leftLabel":"void","displayText":"MSRCXOff","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga4b7c2549c5e12aaa32661938279b740f.html#ga4b7c2549c5e12aaa32661938279b740f","snippet":"MSRCXOff(${1:const byte outputs})","description":"MSRCXOff function."},{"leftLabel":"void","displayText":"MSRCXOn","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gaa71f682b946ad2e9472f5cee496b4016.html#gaa71f682b946ad2e9472f5cee496b4016","snippet":"MSRCXOn(${1:const byte outputs})","description":"MSRCXOn function."},{"leftLabel":"void","displayText":"MSRCXOnFor","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga02a2511f8b6c0e6e88749140e6fbce1d.html#ga02a2511f8b6c0e6e88749140e6fbce1d","snippet":"MSRCXOnFor(${1:const byte outputs}, ${2:const unsigned int ms})","description":"MSRCXOnFor function."},{"leftLabel":"void","displayText":"MSRCXOnFwd","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga0dc6207aeddd42da225f1a65ea2202b3.html#ga0dc6207aeddd42da225f1a65ea2202b3","snippet":"MSRCXOnFwd(${1:const byte outputs})","description":"MSRCXOnFwd function."},{"leftLabel":"void","displayText":"MSRCXOnRev","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gac67b55f0a1d117e478ae72ea7d8d1f68.html#gac67b55f0a1d117e478ae72ea7d8d1f68","snippet":"MSRCXOnRev(${1:const byte outputs})","description":"MSRCXOnRev function."},{"leftLabel":"void","displayText":"MSRCXOrVar","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga6fcc33477afda64e12514c95a53f362f.html#ga6fcc33477afda64e12514c95a53f362f","snippet":"MSRCXOrVar(${1:const byte varnum}, ${2:const byte src}, ${3:const unsigned int value})","description":"MSRCXOrVar function."},{"leftLabel":"void","displayText":"MSRCXPBTurnOff","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga2f7cbf2d093546825199e71be297d811.html#ga2f7cbf2d093546825199e71be297d811","snippet":"MSRCXPBTurnOff(${1:void})","description":"MSRCXPBTurnOff function."},{"leftLabel":"void","displayText":"MSRCXPing","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gad2566941e3eef6fe5087b0e10ef5bc24.html#gad2566941e3eef6fe5087b0e10ef5bc24","snippet":"MSRCXPing(${1:void})","description":"MSRCXPing function."},{"leftLabel":"void","displayText":"MSRCXPlaySound","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gade49a0c8179c959083650ab23b857421.html#gade49a0c8179c959083650ab23b857421","snippet":"MSRCXPlaySound(${1:const byte snd})","description":"MSRCXPlaySound function."},{"leftLabel":"void","displayText":"MSRCXPlayTone","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga647d78b972a2d3f68fefbe97c217fff1.html#ga647d78b972a2d3f68fefbe97c217fff1","snippet":"MSRCXPlayTone(${1:const unsigned int freq}, ${2:const byte duration})","description":"MSRCXPlayTone function."},{"leftLabel":"void","displayText":"MSRCXPlayToneVar","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gaa0c7a89281b28a67b3cee8ca6ff68545.html#gaa0c7a89281b28a67b3cee8ca6ff68545","snippet":"MSRCXPlayToneVar(${1:const byte varnum}, ${2:const byte duration})","description":"MSRCXPlayToneVar function."},{"leftLabel":"void","displayText":"MSRCXRemote","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga23ebdc5a76579cb785efa0080a3f7c25.html#ga23ebdc5a76579cb785efa0080a3f7c25","snippet":"MSRCXRemote(${1:unsigned int cmd})","description":"MSRCXRemote function."},{"leftLabel":"void","displayText":"MSRCXReset","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga65e48d6c125b9ecf46f4e8df7ae598b2.html#ga65e48d6c125b9ecf46f4e8df7ae598b2","snippet":"MSRCXReset(${1:void})","description":"MSRCXReset function."},{"leftLabel":"void","displayText":"MSRCXRev","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga5ab1ac1f92d0b3ffdc5406f8d8dae538.html#ga5ab1ac1f92d0b3ffdc5406f8d8dae538","snippet":"MSRCXRev(${1:const byte outputs})","description":"MSRCXRev function."},{"leftLabel":"void","displayText":"MSRCXSelectDisplay","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga316c048f2c7e17de489e22ccf4c7933e.html#ga316c048f2c7e17de489e22ccf4c7933e","snippet":"MSRCXSelectDisplay(${1:const byte src}, ${2:const unsigned int value})","description":"MSRCXSelectDisplay function."},{"leftLabel":"void","displayText":"MSRCXSelectProgram","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga604c88ec4e6ec5fc1f4543f2f4803850.html#ga604c88ec4e6ec5fc1f4543f2f4803850","snippet":"MSRCXSelectProgram(${1:const byte prog})","description":"MSRCXSelectProgram function."},{"leftLabel":"void","displayText":"MSRCXSendSerial","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gab48ec237399a9281181321ce289d13b7.html#gab48ec237399a9281181321ce289d13b7","snippet":"MSRCXSendSerial(${1:const byte first}, ${2:const byte count})","description":"MSRCXSendSerial function."},{"leftLabel":"void","displayText":"MSRCXSet","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gaa294dbd95240cd862f80984298fd12a4.html#gaa294dbd95240cd862f80984298fd12a4","snippet":"MSRCXSet(${1:const byte dstsrc}, ${2:const byte dstval}, ${3:const byte src}, ${4:unsigned int value})","description":"MSRCXSet function."},{"leftLabel":"void","displayText":"MSRCXSetDirection","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga75e8165e32650497a3aaa1d4610fce04.html#ga75e8165e32650497a3aaa1d4610fce04","snippet":"MSRCXSetDirection(${1:const byte outputs}, ${2:const byte dir})","description":"MSRCXSetDirection function."},{"leftLabel":"void","displayText":"MSRCXSetEvent","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga9c12502e42609b41cda4fefd88938d06.html#ga9c12502e42609b41cda4fefd88938d06","snippet":"MSRCXSetEvent(${1:const byte evt}, ${2:const byte src}, ${3:const byte type})","description":"MSRCXSetEvent function."},{"leftLabel":"void","displayText":"MSRCXSetGlobalDirection","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga9284855db34bfc5defcf40e47b2cf735.html#ga9284855db34bfc5defcf40e47b2cf735","snippet":"MSRCXSetGlobalDirection(${1:const byte outputs}, ${2:const byte dir})","description":"MSRCXSetGlobalDirection function."},{"leftLabel":"void","displayText":"MSRCXSetGlobalOutput","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gabd3e7ebc42eb222e18b9cac288619f9d.html#gabd3e7ebc42eb222e18b9cac288619f9d","snippet":"MSRCXSetGlobalOutput(${1:const byte outputs}, ${2:const byte mode})","description":"MSRCXSetGlobalOutput function."},{"leftLabel":"void","displayText":"MSRCXSetMaxPower","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga295f3c95eaeac31d63f06b8e28d1fde7.html#ga295f3c95eaeac31d63f06b8e28d1fde7","snippet":"MSRCXSetMaxPower(${1:const byte outputs}, ${2:const byte pwrsrc}, ${3:const byte pwrval})","description":"MSRCXSetMaxPower function."},{"leftLabel":"void","displayText":"MSRCXSetMessage","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gac788a01ad1fa75e2714061f4cded6ea7.html#gac788a01ad1fa75e2714061f4cded6ea7","snippet":"MSRCXSetMessage(${1:const byte msg})","description":"MSRCXSetMessage function."},{"leftLabel":"void","displayText":"MSRCXSetOutput","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga2914f93567a03e6347b51e8f4179b252.html#ga2914f93567a03e6347b51e8f4179b252","snippet":"MSRCXSetOutput(${1:const byte outputs}, ${2:const byte mode})","description":"MSRCXSetOutput function."},{"leftLabel":"void","displayText":"MSRCXSetPower","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga94ad2b282df96eddf6cb59c5f9515035.html#ga94ad2b282df96eddf6cb59c5f9515035","snippet":"MSRCXSetPower(${1:const byte outputs}, ${2:const byte pwrsrc}, ${3:const byte pwrval})","description":"MSRCXSetPower function."},{"leftLabel":"void","displayText":"MSRCXSetPriority","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga406b08ba3f3ffaef6a47006fa6721e85.html#ga406b08ba3f3ffaef6a47006fa6721e85","snippet":"MSRCXSetPriority(${1:const byte p})","description":"MSRCXSetPriority function."},{"leftLabel":"void","displayText":"MSRCXSetSensorMode","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga77cd94791881ae1e0b762301fd1d1f93.html#ga77cd94791881ae1e0b762301fd1d1f93","snippet":"MSRCXSetSensorMode(${1:const byte port}, ${2:const byte mode})","description":"MSRCXSetSensorMode function."},{"leftLabel":"void","displayText":"MSRCXSetSensorType","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gad83563ce5eecefb5ccff466d1ff93e0a.html#gad83563ce5eecefb5ccff466d1ff93e0a","snippet":"MSRCXSetSensorType(${1:const byte port}, ${2:const byte type})","description":"MSRCXSetSensorType function."},{"leftLabel":"void","displayText":"MSRCXSetSleepTime","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gaa267840a804a659a043616a9d07c064e.html#gaa267840a804a659a043616a9d07c064e","snippet":"MSRCXSetSleepTime(${1:const byte t})","description":"MSRCXSetSleepTime function."},{"leftLabel":"void","displayText":"MSRCXSetTxPower","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gaa206c0f567d673f3f2789fc19c2b9c89.html#gaa206c0f567d673f3f2789fc19c2b9c89","snippet":"MSRCXSetTxPower(${1:const byte pwr})","description":"MSRCXSetTxPower function."},{"leftLabel":"void","displayText":"MSRCXSetUserDisplay","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gad96a072e66cfd5f26b465093deaacc24.html#gad96a072e66cfd5f26b465093deaacc24","snippet":"MSRCXSetUserDisplay(${1:const byte src}, ${2:const unsigned int value}, ${3:const byte precision})","description":"MSRCXSetUserDisplay function."},{"leftLabel":"void","displayText":"MSRCXSetVar","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gaf8ee7e8a8027f82611560f3770883d3c.html#gaf8ee7e8a8027f82611560f3770883d3c","snippet":"MSRCXSetVar(${1:const byte varnum}, ${2:const byte src}, ${3:const unsigned int value})","description":"MSRCXSetVar function."},{"leftLabel":"void","displayText":"MSRCXSetWatch","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga58b10a5143cc20f79667732232c8a9c6.html#ga58b10a5143cc20f79667732232c8a9c6","snippet":"MSRCXSetWatch(${1:const byte hours}, ${2:const byte minutes})","description":"MSRCXSetWatch function."},{"leftLabel":"void","displayText":"MSRCXSgnVar","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gac57c43f712247b60861cbaa9910492c5.html#gac57c43f712247b60861cbaa9910492c5","snippet":"MSRCXSgnVar(${1:const byte varnum}, ${2:const byte src}, ${3:const unsigned int value})","description":"MSRCXSgnVar function."},{"leftLabel":"void","displayText":"MSRCXStartTask","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga742a5847f758468765a34cc20adfafc3.html#ga742a5847f758468765a34cc20adfafc3","snippet":"MSRCXStartTask(${1:const byte t})","description":"MSRCXStartTask function."},{"leftLabel":"void","displayText":"MSRCXStopAllTasks","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga2454e2883eb53b8b1c6a60eefc138717.html#ga2454e2883eb53b8b1c6a60eefc138717","snippet":"MSRCXStopAllTasks(${1:void})","description":"MSRCXStopAllTasks function."},{"leftLabel":"void","displayText":"MSRCXStopTask","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga5d86ff25985d1d1f16cd3e4512e2e52d.html#ga5d86ff25985d1d1f16cd3e4512e2e52d","snippet":"MSRCXStopTask(${1:const byte t})","description":"MSRCXStopTask function."},{"leftLabel":"void","displayText":"MSRCXSubVar","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga255644bcb5ba408a2e2ebb74eb36dcd5.html#ga255644bcb5ba408a2e2ebb74eb36dcd5","snippet":"MSRCXSubVar(${1:const byte varnum}, ${2:const byte src}, ${3:const unsigned int value})","description":"MSRCXSubVar function."},{"leftLabel":"void","displayText":"MSRCXSumVar","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga5d2f4d0f68e5d9b7fd0f12b41df7cb92.html#ga5d2f4d0f68e5d9b7fd0f12b41df7cb92","snippet":"MSRCXSumVar(${1:const byte varnum}, ${2:const byte src}, ${3:const unsigned int value})","description":"MSRCXSumVar function."},{"leftLabel":"void","displayText":"MSRCXToggle","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gaccdd2732975ce6ca25b33056627492e3.html#gaccdd2732975ce6ca25b33056627492e3","snippet":"MSRCXToggle(${1:const byte outputs})","description":"MSRCXToggle function."},{"leftLabel":"void","displayText":"MSRCXUnlock","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gaba416a52acb9c2e11d1207d2f8a3b735.html#gaba416a52acb9c2e11d1207d2f8a3b735","snippet":"MSRCXUnlock(${1:void})","description":"MSRCXUnlock function."},{"leftLabel":"void","displayText":"MSRCXUnmuteSound","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga25a302da0335827083572eb5e64f7ab0.html#ga25a302da0335827083572eb5e64f7ab0","snippet":"MSRCXUnmuteSound(${1:void})","description":"MSRCXUnmuteSound function."},{"leftLabel":"void","displayText":"MSScoutCalibrateSensor","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gaa556176760f1ae8149c5afc46f0c4333.html#gaa556176760f1ae8149c5afc46f0c4333","snippet":"MSScoutCalibrateSensor(${1:void})","description":"MSScoutCalibrateSensor function."},{"leftLabel":"void","displayText":"MSScoutMuteSound","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gafce155997b0255253db4d90c99fab9b5.html#gafce155997b0255253db4d90c99fab9b5","snippet":"MSScoutMuteSound(${1:void})","description":"MSScoutMuteSound function."},{"leftLabel":"void","displayText":"MSScoutSelectSounds","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga27d981cf9e67733785889b68140e404f.html#ga27d981cf9e67733785889b68140e404f","snippet":"MSScoutSelectSounds(${1:const byte grp})","description":"MSScoutSelectSounds function."},{"leftLabel":"void","displayText":"MSScoutSendVLL","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga26ff6a651be0d56222f8b8c20e068e2d.html#ga26ff6a651be0d56222f8b8c20e068e2d","snippet":"MSScoutSendVLL(${1:const byte src}, ${2:const unsigned int value})","description":"MSScoutSendVLL function."},{"leftLabel":"void","displayText":"MSScoutSetCounterLimit","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gaf5b373b0dd0ada6e2751cc484340ca52.html#gaf5b373b0dd0ada6e2751cc484340ca52","snippet":"MSScoutSetCounterLimit(${1:const byte ctr}, ${2:const byte src}, ${3:const unsigned int value})","description":"MSScoutSetCounterLimit function."},{"leftLabel":"void","displayText":"MSScoutSetEventFeedback","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga3b209a691631d897dd049c94be1586e3.html#ga3b209a691631d897dd049c94be1586e3","snippet":"MSScoutSetEventFeedback(${1:const byte src}, ${2:const unsigned int value})","description":"MSScoutSetEventFeedback function."},{"leftLabel":"void","displayText":"MSScoutSetLight","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga221b1f1c782d72e03a6d5bdd8db849d3.html#ga221b1f1c782d72e03a6d5bdd8db849d3","snippet":"MSScoutSetLight(${1:const byte x})","description":"MSScoutSetLight function."},{"leftLabel":"void","displayText":"MSScoutSetScoutMode","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga23a42585d8d12425924dae5d5cedd7bb.html#ga23a42585d8d12425924dae5d5cedd7bb","snippet":"MSScoutSetScoutMode(${1:const byte mode})","description":"MSScoutSetScoutMode function."},{"leftLabel":"void","displayText":"MSScoutSetScoutRules","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga802967ec515e105dd3692892f8ae0aa7.html#ga802967ec515e105dd3692892f8ae0aa7","snippet":"MSScoutSetScoutRules(${1:const byte m}, ${2:const byte t}, ${3:const byte l}, ${4:const byte tm}, ${5:const byte fx})","description":"MSScoutSetScoutRules function."},{"leftLabel":"void","displayText":"MSScoutSetSensorClickTime","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga08889fffc2605b478ff3c9779feb7b42.html#ga08889fffc2605b478ff3c9779feb7b42","snippet":"MSScoutSetSensorClickTime(${1:const byte src}, ${2:const unsigned int value})","description":"MSScoutSetSensorClickTime function."},{"leftLabel":"void","displayText":"MSScoutSetSensorHysteresis","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga1288377f9a825dec60c963400664b7e8.html#ga1288377f9a825dec60c963400664b7e8","snippet":"MSScoutSetSensorHysteresis(${1:const byte src}, ${2:const unsigned int value})","description":"MSScoutSetSensorHysteresis function."},{"leftLabel":"void","displayText":"MSScoutSetSensorLowerLimit","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga303ddcf09957eb8ac35f956a1cf23174.html#ga303ddcf09957eb8ac35f956a1cf23174","snippet":"MSScoutSetSensorLowerLimit(${1:const byte src}, ${2:const unsigned int value})","description":"MSScoutSetSensorLowerLimit function."},{"leftLabel":"void","displayText":"MSScoutSetSensorUpperLimit","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga8f6e7407524df88e8d9f6ee24a0183e3.html#ga8f6e7407524df88e8d9f6ee24a0183e3","snippet":"MSScoutSetSensorUpperLimit(${1:const byte src}, ${2:const unsigned int value})","description":"MSScoutSetSensorUpperLimit function."},{"leftLabel":"void","displayText":"MSScoutSetTimerLimit","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_ga52f3e695d9ca51242c0051021b528d36.html#ga52f3e695d9ca51242c0051021b528d36","snippet":"MSScoutSetTimerLimit(${1:const byte tmr}, ${2:const byte src}, ${3:const unsigned int value})","description":"MSScoutSetTimerLimit function."},{"leftLabel":"void","displayText":"MSScoutUnmuteSound","type":"function","descriptionMoreURL":"group___mind_sensors_a_p_i_gaffa127a4a3e3c555fb43f4b2fc9a3e3d.html#gaffa127a4a3e3c555fb43f4b2fc9a3e3d","snippet":"MSScoutUnmuteSound(${1:void})","description":"MSScoutUnmuteSound function."},{"leftLabel":"bool","displayText":"RFIDInit","type":"function","descriptionMoreURL":"group___codatex_a_p_i_ga2a962f09e5423123f8dd6568b07db227.html#ga2a962f09e5423123f8dd6568b07db227","snippet":"RFIDInit(${1:const byte &port})","description":"RFIDInit function."},{"leftLabel":"bool","displayText":"RFIDMode","type":"function","descriptionMoreURL":"group___codatex_a_p_i_gaf09f5b8b421ee015141a69370558b669.html#gaf09f5b8b421ee015141a69370558b669","snippet":"RFIDMode(${1:const byte &port}, ${2:const byte &mode})","description":"RFIDMode function."},{"leftLabel":"byte","displayText":"RFIDStatus","type":"function","descriptionMoreURL":"group___codatex_a_p_i_gafdc4a3023dfcde2d0a967c761c023201.html#gafdc4a3023dfcde2d0a967c761c023201","snippet":"RFIDStatus(${1:const byte &port})","description":"RFIDStatus function."},{"leftLabel":"bool","displayText":"RFIDRead","type":"function","descriptionMoreURL":"group___codatex_a_p_i_ga8280fa6387acdbe597ce0befea14761d.html#ga8280fa6387acdbe597ce0befea14761d","snippet":"RFIDRead(${1:const byte &port}, ${2:byte &output[]})","description":"RFIDRead function."},{"leftLabel":"bool","displayText":"RFIDStop","type":"function","descriptionMoreURL":"group___codatex_a_p_i_ga5d44d1b5b775bc04467ff26aad5ba444.html#ga5d44d1b5b775bc04467ff26aad5ba444","snippet":"RFIDStop(${1:const byte &port})","description":"RFIDStop function."},{"leftLabel":"bool","displayText":"RFIDReadSingle","type":"function","descriptionMoreURL":"group___codatex_a_p_i_gad43ea2fb600dc403b25bb57df066cd75.html#gad43ea2fb600dc403b25bb57df066cd75","snippet":"RFIDReadSingle(${1:const byte &port}, ${2:byte &output[]})","description":"RFIDReadSingle function."},{"leftLabel":"bool","displayText":"RFIDReadContinuous","type":"function","descriptionMoreURL":"group___codatex_a_p_i_ga70e88437b71bbbb4b0fa8c5b0a994663.html#ga70e88437b71bbbb4b0fa8c5b0a994663","snippet":"RFIDReadContinuous(${1:const byte &port}, ${2:byte &output[]})","description":"RFIDReadContinuous function."},{"leftLabel":"bool","displayText":"SensorDIGPSStatus","type":"function","descriptionMoreURL":"group___dexter_industries_a_p_i_gad2e0fcdd6229a71304c9c993850caa51.html#gad2e0fcdd6229a71304c9c993850caa51","snippet":"SensorDIGPSStatus(${1:byte port})","description":"SensorDIGPSStatus function."},{"leftLabel":"long","displayText":"SensorDIGPSTime","type":"function","descriptionMoreURL":"group___dexter_industries_a_p_i_ga0541738770e1e6fcc64c793c0f06b582.html#ga0541738770e1e6fcc64c793c0f06b582","snippet":"SensorDIGPSTime(${1:byte port})","description":"SensorDIGPSTime function."},{"leftLabel":"long","displayText":"SensorDIGPSLatitude","type":"function","descriptionMoreURL":"group___dexter_industries_a_p_i_ga34d0a5c6c6fb9c2cf2efd2197bb991ba.html#ga34d0a5c6c6fb9c2cf2efd2197bb991ba","snippet":"SensorDIGPSLatitude(${1:byte port})","description":"SensorDIGPSLatitude function."},{"leftLabel":"long","displayText":"SensorDIGPSLongitude","type":"function","descriptionMoreURL":"group___dexter_industries_a_p_i_gae02716b5f046cbc44f53aaebf90205ed.html#gae02716b5f046cbc44f53aaebf90205ed","snippet":"SensorDIGPSLongitude(${1:byte port})","description":"SensorDIGPSLongitude function."},{"leftLabel":"long","displayText":"SensorDIGPSVelocity","type":"function","descriptionMoreURL":"group___dexter_industries_a_p_i_gab9d2ca8f188adf408dbac9fd1f2af0eb.html#gab9d2ca8f188adf408dbac9fd1f2af0eb","snippet":"SensorDIGPSVelocity(${1:byte port})","description":"SensorDIGPSVelocity function."},{"leftLabel":"int","displayText":"SensorDIGPSHeading","type":"function","descriptionMoreURL":"group___dexter_industries_a_p_i_ga592bc33c7e7a29e32afaf7f6fd0f7a33.html#ga592bc33c7e7a29e32afaf7f6fd0f7a33","snippet":"SensorDIGPSHeading(${1:byte port})","description":"SensorDIGPSHeading function."},{"leftLabel":"long","displayText":"SensorDIGPSDistanceToWaypoint","type":"function","descriptionMoreURL":"group___dexter_industries_a_p_i_gac5af5dccd71ba029dd61b4430cf7f027.html#gac5af5dccd71ba029dd61b4430cf7f027","snippet":"SensorDIGPSDistanceToWaypoint(${1:byte port})","description":"SensorDIGPSDistanceToWaypoint function."},{"leftLabel":"int","displayText":"SensorDIGPSHeadingToWaypoint","type":"function","descriptionMoreURL":"group___dexter_industries_a_p_i_gaaf8dc5d4385e7b748ccaf6f0b94800b0.html#gaaf8dc5d4385e7b748ccaf6f0b94800b0","snippet":"SensorDIGPSHeadingToWaypoint(${1:byte port})","description":"SensorDIGPSHeadingToWaypoint function."},{"leftLabel":"int","displayText":"SensorDIGPSRelativeHeading","type":"function","descriptionMoreURL":"group___dexter_industries_a_p_i_ga107917af32062a29236dcfb6b13018fc.html#ga107917af32062a29236dcfb6b13018fc","snippet":"SensorDIGPSRelativeHeading(${1:byte port})","description":"SensorDIGPSRelativeHeading function."},{"leftLabel":"bool","displayText":"SetSensorDIGPSWaypoint","type":"function","descriptionMoreURL":"group___dexter_industries_a_p_i_ga9d23c5f3dffc1d9be12cd4c97c34c474.html#ga9d23c5f3dffc1d9be12cd4c97c34c474","snippet":"SetSensorDIGPSWaypoint(${1:byte port}, ${2:long latitude}, ${3:long longitude})","description":"SetSensorDIGPSWaypoint function."},{"leftLabel":"bool","displayText":"SetSensorDIGyroEx","type":"function","descriptionMoreURL":"group___dexter_industries_a_p_i_ga4bafb3475fddf2b227bb4ac55d1966e6.html#ga4bafb3475fddf2b227bb4ac55d1966e6","snippet":"SetSensorDIGyroEx(${1:const byte port}, ${2:byte scale}, ${3:byte odr}, ${4:byte bw})","description":"SetSensorDIGyroEx function."},{"leftLabel":"bool","displayText":"SetSensorDIGyro","type":"function","descriptionMoreURL":"group___dexter_industries_a_p_i_gaddcd2f57c5baf462b0b983b3b182c7ac.html#gaddcd2f57c5baf462b0b983b3b182c7ac","snippet":"SetSensorDIGyro(${1:const byte port})","description":"SetSensorDIGyro function."},{"leftLabel":"bool","displayText":"ReadSensorDIGyroRaw","type":"function","descriptionMoreURL":"group___dexter_industries_a_p_i_ga2cf76edf44f713d7b33cc77b0f1c5e27.html#ga2cf76edf44f713d7b33cc77b0f1c5e27","snippet":"ReadSensorDIGyroRaw(${1:const byte port}, ${2:VectorType &vector})","description":"ReadSensorDIGyroRaw function."},{"leftLabel":"bool","displayText":"ReadSensorDIGyro","type":"function","descriptionMoreURL":"group___dexter_industries_a_p_i_ga4439e589bd1c64cb6759dc5ac606c663.html#ga4439e589bd1c64cb6759dc5ac606c663","snippet":"ReadSensorDIGyro(${1:const byte port}, ${2:VectorType &vector})","description":"ReadSensorDIGyro function."},{"leftLabel":"int","displayText":"SensorDIGyroTemperature","type":"function","descriptionMoreURL":"group___dexter_industries_a_p_i_ga1fb8e550434af0eae68d8393e50dd153.html#ga1fb8e550434af0eae68d8393e50dd153","snippet":"SensorDIGyroTemperature(${1:const byte port})","description":"SensorDIGyroTemperature function."},{"leftLabel":"byte","displayText":"SensorDIGyroStatus","type":"function","descriptionMoreURL":"group___dexter_industries_a_p_i_ga5d665cf1b5fb42cdb9e40bf85cc8544d.html#ga5d665cf1b5fb42cdb9e40bf85cc8544d","snippet":"SensorDIGyroStatus(${1:const byte port})","description":"SensorDIGyroStatus function."},{"leftLabel":"bool","displayText":"SetSensorDIAcclEx","type":"function","descriptionMoreURL":"group___dexter_industries_a_p_i_gaef913fee0af867ae0fb39b900a8e97db.html#gaef913fee0af867ae0fb39b900a8e97db","snippet":"SetSensorDIAcclEx(${1:const byte port}, ${2:byte mode})","description":"SetSensorDIAcclEx function."},{"leftLabel":"bool","displayText":"SetSensorDIAccl","type":"function","descriptionMoreURL":"group___dexter_industries_a_p_i_gab59344abf16c3465c1f44ce863933652.html#gab59344abf16c3465c1f44ce863933652","snippet":"SetSensorDIAccl(${1:const byte port})","description":"SetSensorDIAccl function."},{"leftLabel":"bool","displayText":"ReadSensorDIAcclRaw","type":"function","descriptionMoreURL":"group___dexter_industries_a_p_i_gafac914b3701e64186e9f986a795142c0.html#gafac914b3701e64186e9f986a795142c0","snippet":"ReadSensorDIAcclRaw(${1:const byte port}, ${2:VectorType &vector})","description":"ReadSensorDIAcclRaw function."},{"leftLabel":"bool","displayText":"ReadSensorDIAccl","type":"function","descriptionMoreURL":"group___dexter_industries_a_p_i_ga37471c46069394a62e881f4b007a1176.html#ga37471c46069394a62e881f4b007a1176","snippet":"ReadSensorDIAccl(${1:const byte port}, ${2:VectorType &vector})","description":"ReadSensorDIAccl function."},{"leftLabel":"bool","displayText":"ReadSensorDIAccl8Raw","type":"function","descriptionMoreURL":"group___dexter_industries_a_p_i_ga4049939b6df07ce5719540fd6cf31f9f.html#ga4049939b6df07ce5719540fd6cf31f9f","snippet":"ReadSensorDIAccl8Raw(${1:const byte port}, ${2:VectorType &vector})","description":"ReadSensorDIAccl8Raw function."},{"leftLabel":"bool","displayText":"ReadSensorDIAccl8","type":"function","descriptionMoreURL":"group___dexter_industries_a_p_i_gad48819f8a0f9e967475d24174362f48d.html#gad48819f8a0f9e967475d24174362f48d","snippet":"ReadSensorDIAccl8(${1:const byte port}, ${2:VectorType &vector})","description":"ReadSensorDIAccl8 function."},{"leftLabel":"byte","displayText":"SensorDIAcclStatus","type":"function","descriptionMoreURL":"group___dexter_industries_a_p_i_gad14fd7b86c38cbbe4c76d1c6433d21af.html#gad14fd7b86c38cbbe4c76d1c6433d21af","snippet":"SensorDIAcclStatus(${1:const byte port})","description":"SensorDIAcclStatus function."},{"leftLabel":"bool","displayText":"ReadSensorDIAcclDrift","type":"function","descriptionMoreURL":"group___dexter_industries_a_p_i_ga0a4b53ec7ef5eea29f51d28d75e8ff99.html#ga0a4b53ec7ef5eea29f51d28d75e8ff99","snippet":"ReadSensorDIAcclDrift(${1:const byte port}, ${2:int &x}, ${3:int &y}, ${4:int &z})","description":"ReadSensorDIAcclDrift function."},{"leftLabel":"bool","displayText":"SetSensorDIAcclDrift","type":"function","descriptionMoreURL":"group___dexter_industries_a_p_i_ga3833b0ca3c9d9c342212f5a3dc0ab918.html#ga3833b0ca3c9d9c342212f5a3dc0ab918","snippet":"SetSensorDIAcclDrift(${1:const byte port}, ${2:int x}, ${3:int y}, ${4:int z})","description":"SetSensorDIAcclDrift function."},{"leftLabel":"bool","displayText":"ResetMIXG1300L","type":"function","descriptionMoreURL":"group___microinfinity_functions_ga0accd98c6ac906249c54480be1f87ea1.html#ga0accd98c6ac906249c54480be1f87ea1","snippet":"ResetMIXG1300L(${1:byte port})","description":"ResetMIXG1300L function."},{"leftLabel":"int","displayText":"SensorMIXG1300LScale","type":"function","descriptionMoreURL":"group___microinfinity_functions_ga85c5f881294fb5c5e1f0b598ed4f92b1.html#ga85c5f881294fb5c5e1f0b598ed4f92b1","snippet":"SensorMIXG1300LScale(${1:byte port})","description":"SensorMIXG1300LScale function."},{"leftLabel":"bool","displayText":"SetSensorMIXG1300LScale","type":"function","descriptionMoreURL":"group___microinfinity_functions_gad064a782ce6f3a2ed5947c69528ca057.html#gad064a782ce6f3a2ed5947c69528ca057","snippet":"SetSensorMIXG1300LScale(${1:byte port}, ${2:const byte scale})","description":"SetSensorMIXG1300LScale function."},{"leftLabel":"bool","displayText":"ReadSensorMIXG1300L","type":"function","descriptionMoreURL":"group___microinfinity_functions_ga3b601937924d3c6c82e5a4a2ba2a118a.html#ga3b601937924d3c6c82e5a4a2ba2a118a","snippet":"ReadSensorMIXG1300L(${1:byte port}, ${2:XGPacketType &packet})","description":"ReadSensorMIXG1300L function."},{"leftLabel":"float","displayText":"sqrt","type":"function","descriptionMoreURL":"group__cmath_a_p_i_ga592e5b536e9e1b69f4520e9566521a17.html#ga592e5b536e9e1b69f4520e9566521a17","snippet":"sqrt(${1:float x})","description":"Compute square root."},{"leftLabel":"float","displayText":"cos","type":"function","descriptionMoreURL":"group__cmath_a_p_i_ga5e88e48c21b60ac9b58a322cf8a8bb67.html#ga5e88e48c21b60ac9b58a322cf8a8bb67","snippet":"cos(${1:float x})","description":"Compute cosine."},{"leftLabel":"float","displayText":"sin","type":"function","descriptionMoreURL":"group__cmath_a_p_i_ga15876915492b5aff219d1dd03ad66def.html#ga15876915492b5aff219d1dd03ad66def","snippet":"sin(${1:float x})","description":"Compute sine."},{"leftLabel":"float","displayText":"tan","type":"function","descriptionMoreURL":"group__cmath_a_p_i_ga26971409112830841bd7c7a0d7681b8a.html#ga26971409112830841bd7c7a0d7681b8a","snippet":"tan(${1:float x})","description":"Compute tangent."},{"leftLabel":"float","displayText":"acos","type":"function","descriptionMoreURL":"group__cmath_a_p_i_gad3746d6ae34f39dc1929395d6af1ecb1.html#gad3746d6ae34f39dc1929395d6af1ecb1","snippet":"acos(${1:float x})","description":"Compute arc cosine."},{"leftLabel":"float","displayText":"asin","type":"function","descriptionMoreURL":"group__cmath_a_p_i_gaf7a153258c174c284724467debb9458c.html#gaf7a153258c174c284724467debb9458c","snippet":"asin(${1:float x})","description":"Compute arc sine."},{"leftLabel":"float","displayText":"atan","type":"function","descriptionMoreURL":"group__cmath_a_p_i_gaa1707595eec76a358520359b4f20267e.html#gaa1707595eec76a358520359b4f20267e","snippet":"atan(${1:float x})","description":"Compute arc tangent."},{"leftLabel":"float","displayText":"atan2","type":"function","descriptionMoreURL":"group__cmath_a_p_i_gaaf4b636b09041878e1542054c73d81e9.html#gaaf4b636b09041878e1542054c73d81e9","snippet":"atan2(${1:float y}, ${2:float x})","description":"Compute arc tangent with 2 parameters."},{"leftLabel":"float","displayText":"cosh","type":"function","descriptionMoreURL":"group__cmath_a_p_i_ga2ebcd12a3f554326958712eb4e298eec.html#ga2ebcd12a3f554326958712eb4e298eec","snippet":"cosh(${1:float x})","description":"Compute hyperbolic cosine."},{"leftLabel":"float","displayText":"sinh","type":"function","descriptionMoreURL":"group__cmath_a_p_i_ga2b779d5089ff8362eb9b3d362083de19.html#ga2b779d5089ff8362eb9b3d362083de19","snippet":"sinh(${1:float x})","description":"Compute hyperbolic sine."},{"leftLabel":"float","displayText":"tanh","type":"function","descriptionMoreURL":"group__cmath_a_p_i_gafde1d7d92227ce384c236b80161e11c8.html#gafde1d7d92227ce384c236b80161e11c8","snippet":"tanh(${1:float x})","description":"Compute hyperbolic tangent."},{"leftLabel":"float","displayText":"exp","type":"function","descriptionMoreURL":"group__cmath_a_p_i_ga9b5b75b78eff58c7f376e3ce51e9fdfd.html#ga9b5b75b78eff58c7f376e3ce51e9fdfd","snippet":"exp(${1:float x})","description":"Compute exponential function."},{"leftLabel":"float","displayText":"log","type":"function","descriptionMoreURL":"group__cmath_a_p_i_gad04ff2fafc7559725e22b969af498b7d.html#gad04ff2fafc7559725e22b969af498b7d","snippet":"log(${1:float x})","description":"Compute natural logarithm."},{"leftLabel":"float","displayText":"log10","type":"function","descriptionMoreURL":"group__cmath_a_p_i_ga9072957ddf2d504ecc13b926c225ab59.html#ga9072957ddf2d504ecc13b926c225ab59","snippet":"log10(${1:float x})","description":"Compute common logarithm."},{"leftLabel":"long","displayText":"trunc","type":"function","descriptionMoreURL":"group__cmath_a_p_i_ga7f1b134a8a05d4c24030dd5f61ab895e.html#ga7f1b134a8a05d4c24030dd5f61ab895e","snippet":"trunc(${1:float x})","description":"Compute integral part."},{"leftLabel":"float","displayText":"frac","type":"function","descriptionMoreURL":"group__cmath_a_p_i_ga39b5c388cab149413887f1bdbd8b008f.html#ga39b5c388cab149413887f1bdbd8b008f","snippet":"frac(${1:float x})","description":"Compute fractional part."},{"leftLabel":"float","displayText":"pow","type":"function","descriptionMoreURL":"group__cmath_a_p_i_ga0cb1b3000989378ad48b37b358adecf2.html#ga0cb1b3000989378ad48b37b358adecf2","snippet":"pow(${1:float base}, ${2:float exponent})","description":"Raise to power."},{"leftLabel":"float","displayText":"ceil","type":"function","descriptionMoreURL":"group__cmath_a_p_i_ga65b86cc953409a678d94f6db9653fd98.html#ga65b86cc953409a678d94f6db9653fd98","snippet":"ceil(${1:float x})","description":"Round up value."},{"leftLabel":"float","displayText":"floor","type":"function","descriptionMoreURL":"group__cmath_a_p_i_gada8a2be1464302cc6dda3b2ab19e15ad.html#gada8a2be1464302cc6dda3b2ab19e15ad","snippet":"floor(${1:float x})","description":"Round down value."},{"leftLabel":"long","displayText":"muldiv32","type":"function","descriptionMoreURL":"group__cmath_a_p_i_gab8e6dd993a0e6a1a57dcbee511665c45.html#gab8e6dd993a0e6a1a57dcbee511665c45","snippet":"muldiv32(${1:long a}, ${2:long b}, ${3:long c})","description":"Multiply and divide."},{"leftLabel":"float","displayText":"cosd","type":"function","descriptionMoreURL":"group__cmath_a_p_i_ga502f5a841d8d1fcba289e167a1177bda.html#ga502f5a841d8d1fcba289e167a1177bda","snippet":"cosd(${1:float x})","description":"Compute cosine (degrees)."},{"leftLabel":"float","displayText":"sind","type":"function","descriptionMoreURL":"group__cmath_a_p_i_gaf191247f966a40ecf3ee0fe9a717c0f3.html#gaf191247f966a40ecf3ee0fe9a717c0f3","snippet":"sind(${1:float x})","description":"Compute sine (degrees)."},{"leftLabel":"float","displayText":"tand","type":"function","descriptionMoreURL":"group__cmath_a_p_i_ga17594ace979a55af690e03333370535c.html#ga17594ace979a55af690e03333370535c","snippet":"tand(${1:float x})","description":"Compute tangent (degrees)."},{"leftLabel":"float","displayText":"acosd","type":"function","descriptionMoreURL":"group__cmath_a_p_i_ga890e7b1e04fc333ebacc7adcc9305f02.html#ga890e7b1e04fc333ebacc7adcc9305f02","snippet":"acosd(${1:float x})","description":"Compute arc cosine (degrees)."},{"leftLabel":"float","displayText":"asind","type":"function","descriptionMoreURL":"group__cmath_a_p_i_ga010688f3321fe4059cca19b5be0c0fe3.html#ga010688f3321fe4059cca19b5be0c0fe3","snippet":"asind(${1:float x})","description":"Compute arc sine (degrees)."},{"leftLabel":"float","displayText":"atand","type":"function","descriptionMoreURL":"group__cmath_a_p_i_ga99a6dae1b6a0cf075d57c37cff04e907.html#ga99a6dae1b6a0cf075d57c37cff04e907","snippet":"atand(${1:float x})","description":"Compute arc tangent (degrees)."},{"leftLabel":"float","displayText":"atan2d","type":"function","descriptionMoreURL":"group__cmath_a_p_i_ga14462153d28b0ed79cfa18931abf3df6.html#ga14462153d28b0ed79cfa18931abf3df6","snippet":"atan2d(${1:float y}, ${2:float x})","description":"Compute arc tangent with 2 parameters (degrees)."},{"leftLabel":"float","displayText":"coshd","type":"function","descriptionMoreURL":"group__cmath_a_p_i_ga38e161a1ff5f924830acd1ac695fb055.html#ga38e161a1ff5f924830acd1ac695fb055","snippet":"coshd(${1:float x})","description":"Compute hyperbolic cosine (degrees)."},{"leftLabel":"float","displayText":"sinhd","type":"function","descriptionMoreURL":"group__cmath_a_p_i_gab280b957071558d83b8ae9e4ba239417.html#gab280b957071558d83b8ae9e4ba239417","snippet":"sinhd(${1:float x})","description":"Compute hyperbolic sine (degrees)."},{"leftLabel":"float","displayText":"tanhd","type":"function","descriptionMoreURL":"group__cmath_a_p_i_gad86c97f3120b2d6d33a193121d74e8d0.html#gad86c97f3120b2d6d33a193121d74e8d0","snippet":"tanhd(${1:float x})","description":"Compute hyperbolic tangent (degrees)."},{"leftLabel":"byte","displayText":"bcd2dec","type":"function","descriptionMoreURL":"group__cmath_a_p_i_ga370ecedca3418d42ec3f2a5e38f08411.html#ga370ecedca3418d42ec3f2a5e38f08411","snippet":"bcd2dec(${1:byte bcd})","description":"Convert from BCD to decimal Return the decimal equivalent of the binary coded decimal value provided."},{"leftLabel":"bool","displayText":"isNAN","type":"function","descriptionMoreURL":"group__cmath_a_p_i_ga0034068ee46f42530598c39757b22038.html#ga0034068ee46f42530598c39757b22038","snippet":"isNAN(${1:float value})","description":"Is the value NaN."},{"leftLabel":"char","displayText":"sign","type":"function","descriptionMoreURL":"group__cmath_a_p_i_ga90f77c8b3df60383861c2bf620063c74.html#ga90f77c8b3df60383861c2bf620063c74","snippet":"sign(${1:variant num})","description":"Sign value."},{"leftLabel":"void","displayText":"VectorCross","type":"function","descriptionMoreURL":"group__cmath_a_p_i_ga853b29946507f78b14948808e40ed7ee.html#ga853b29946507f78b14948808e40ed7ee","snippet":"VectorCross(${1:VectorType a}, ${2:VectorType b}, ${3:VectorType &out})","description":"VectorCross function."},{"leftLabel":"float","displayText":"VectorDot","type":"function","descriptionMoreURL":"group__cmath_a_p_i_ga29a30e6f2a24e0b27457b26245e464de.html#ga29a30e6f2a24e0b27457b26245e464de","snippet":"VectorDot(${1:VectorType a}, ${2:VectorType b})","description":"VectorDot function."},{"leftLabel":"void","displayText":"VectorNormalize","type":"function","descriptionMoreURL":"group__cmath_a_p_i_ga02faf234ce9cca757f98a5156221d243.html#ga02faf234ce9cca757f98a5156221d243","snippet":"VectorNormalize(${1:VectorType &a})","description":"VectorNormalize function."},{"leftLabel":"int","displayText":"fclose","type":"function","descriptionMoreURL":"group__cstdio_a_p_i_ga78341155278a926a518130763ae9887b.html#ga78341155278a926a518130763ae9887b","snippet":"fclose(${1:byte handle})","description":"Close file."},{"leftLabel":"int","displayText":"remove","type":"function","descriptionMoreURL":"group__cstdio_a_p_i_ga058834d925e086875a6b873e1d0ba5fa.html#ga058834d925e086875a6b873e1d0ba5fa","snippet":"remove(${1:string filename})","description":"Remove file."},{"leftLabel":"int","displayText":"rename","type":"function","descriptionMoreURL":"group__cstdio_a_p_i_ga0ced44d6a8f9acbf1ca0f349b3da3db0.html#ga0ced44d6a8f9acbf1ca0f349b3da3db0","snippet":"rename(${1:string old}, ${2:string new})","description":"Rename file."},{"leftLabel":"char","displayText":"fgetc","type":"function","descriptionMoreURL":"group__cstdio_a_p_i_gafd54f6047719371cc7a9d9ee1ef96d27.html#gafd54f6047719371cc7a9d9ee1ef96d27","snippet":"fgetc(${1:byte handle})","description":"Get character from file."},{"leftLabel":"string","displayText":"fgets","type":"function","descriptionMoreURL":"group__cstdio_a_p_i_ga66a374bc9be9c7172e77d7fb314aa5c2.html#ga66a374bc9be9c7172e77d7fb314aa5c2","snippet":"fgets(${1:string &str}, ${2:int num}, ${3:byte handle})","description":"Get string from file."},{"leftLabel":"int","displayText":"feof","type":"function","descriptionMoreURL":"group__cstdio_a_p_i_gaf3017f823c03bbc16dd3c66e99f68b52.html#gaf3017f823c03bbc16dd3c66e99f68b52","snippet":"feof(${1:byte handle})","description":"Check End-of-file indicator."},{"leftLabel":"void","displayText":"set_fopen_size","type":"function","descriptionMoreURL":"group__cstdio_a_p_i_gaa2ebe730b700188db9ab78b15b231609.html#gaa2ebe730b700188db9ab78b15b231609","snippet":"set_fopen_size(${1:unsigned long fsize})","description":"Set the default fopen file size."},{"leftLabel":"byte","displayText":"fopen","type":"function","descriptionMoreURL":"group__cstdio_a_p_i_ga5d172e1b352898e1a13a836656d70a03.html#ga5d172e1b352898e1a13a836656d70a03","snippet":"fopen(${1:string filename}, ${2:const string mode})","description":"Open file."},{"leftLabel":"int","displayText":"fflush","type":"function","descriptionMoreURL":"group__cstdio_a_p_i_ga764d9bc83a9e3e8dfef824a646ff59c1.html#ga764d9bc83a9e3e8dfef824a646ff59c1","snippet":"fflush(${1:byte handle})","description":"Flush file."},{"leftLabel":"unsigned long","displayText":"ftell","type":"function","descriptionMoreURL":"group__cstdio_a_p_i_ga9bd28c8309873723bc1360b1fafc0bdb.html#ga9bd28c8309873723bc1360b1fafc0bdb","snippet":"ftell(${1:byte handle})","description":"Get current position in file."},{"leftLabel":"char","displayText":"fputc","type":"function","descriptionMoreURL":"group__cstdio_a_p_i_ga7184413c7de347cb51fcce534af60170.html#ga7184413c7de347cb51fcce534af60170","snippet":"fputc(${1:char ch}, ${2:byte handle})","description":"Write character to file."},{"leftLabel":"int","displayText":"fputs","type":"function","descriptionMoreURL":"group__cstdio_a_p_i_gaf85c7002f5d8d9ff2c9663d726f28e6d.html#gaf85c7002f5d8d9ff2c9663d726f28e6d","snippet":"fputs(${1:string str}, ${2:byte handle})","description":"Write string to file."},{"leftLabel":"int","displayText":"getchar","type":"function","descriptionMoreURL":"group__cstdio_a_p_i_gac45fdeab51c3197c1e7c4ec7beabaca9.html#gac45fdeab51c3197c1e7c4ec7beabaca9","snippet":"getchar(${1:})","description":"Get character from stdin."},{"leftLabel":"void","displayText":"printf","type":"function","descriptionMoreURL":"group__cstdio_a_p_i_ga8e7f8b03b05f9affe2dbbbdc3fd0985a.html#ga8e7f8b03b05f9affe2dbbbdc3fd0985a","snippet":"printf(${1:string format}, ${2:variant value})","description":"Print formatted data to stdout."},{"leftLabel":"void","displayText":"fprintf","type":"function","descriptionMoreURL":"group__cstdio_a_p_i_ga9c9fc2c8e79988b9bd66aaf71c3344ff.html#ga9c9fc2c8e79988b9bd66aaf71c3344ff","snippet":"fprintf(${1:byte handle}, ${2:string format}, ${3:variant value})","description":"Write formatted data to file."},{"leftLabel":"void","displayText":"sprintf","type":"function","descriptionMoreURL":"group__cstdio_a_p_i_ga371602cef541e81b14dc2ffdb0f13539.html#ga371602cef541e81b14dc2ffdb0f13539","snippet":"sprintf(${1:string &str}, ${2:string format}, ${3:variant value})","description":"Write formatted data to string."},{"leftLabel":"int","displayText":"fseek","type":"function","descriptionMoreURL":"group__cstdio_a_p_i_gabea819317fe740c7376ca24eaf1225c6.html#gabea819317fe740c7376ca24eaf1225c6","snippet":"fseek(${1:byte handle}, ${2:long offset}, ${3:int origin})","description":"Reposition file position indicator."},{"leftLabel":"void","displayText":"rewind","type":"function","descriptionMoreURL":"group__cstdio_a_p_i_ga1628898dfcdc94ac664c7a7cafb773b5.html#ga1628898dfcdc94ac664c7a7cafb773b5","snippet":"rewind(${1:byte handle})","description":"Set position indicator to the beginning."},{"leftLabel":"void","displayText":"abort","type":"function","descriptionMoreURL":"group__cstdlib_a_p_i_gac54f53dc342019e8db34f4aa581a5792.html#gac54f53dc342019e8db34f4aa581a5792","snippet":"abort(${1:})","description":"Abort current process."},{"leftLabel":"variant","displayText":"abs","type":"function","descriptionMoreURL":"group__cstdlib_a_p_i_gafa60b7b723d42d4d0823518b011d2876.html#gafa60b7b723d42d4d0823518b011d2876","snippet":"abs(${1:variant num})","description":"Absolute value."},{"leftLabel":"long","displayText":"srand","type":"function","descriptionMoreURL":"group__cstdlib_a_p_i_ga1b3a34ea993e2f01600fc09687b3b9a1.html#ga1b3a34ea993e2f01600fc09687b3b9a1","snippet":"srand(${1:long seed})","description":"Seed the random number generator."},{"leftLabel":"unsigned long","displayText":"rand","type":"function","descriptionMoreURL":"group__cstdlib_a_p_i_ga12372a1ed425b34e4503a5f4c2bb5f53.html#ga12372a1ed425b34e4503a5f4c2bb5f53","snippet":"rand(${1:})","description":"Generate random number."},{"leftLabel":"int","displayText":"Random","type":"function","descriptionMoreURL":"group__cstdlib_a_p_i_ga7a0e69b48d53c5647f09ab8b80c148b6.html#ga7a0e69b48d53c5647f09ab8b80c148b6","snippet":"Random(${1:unsigned int n=0})","description":"Generate random number."},{"leftLabel":"void","displayText":"SysRandomNumber","type":"function","descriptionMoreURL":"group__cstdlib_a_p_i_gab485d2bc34b70873158cae0500683681.html#gab485d2bc34b70873158cae0500683681","snippet":"SysRandomNumber(${1:RandomNumberType &args})","description":"Draw a random number."},{"leftLabel":"void","displayText":"SysRandomEx","type":"function","descriptionMoreURL":"group__cstdlib_a_p_i_ga6d7aa40a0ebdf471f0cd08f7906029a7.html#ga6d7aa40a0ebdf471f0cd08f7906029a7","snippet":"SysRandomEx(${1:RandomExType &args})","description":"Call the enhanced random number function."},{"leftLabel":"int","displayText":"atoi","type":"function","descriptionMoreURL":"group__cstdlib_a_p_i_ga85e54114113967a00dfb8c3caf16627a.html#ga85e54114113967a00dfb8c3caf16627a","snippet":"atoi(${1:const string &str})","description":"Convert string to integer."},{"leftLabel":"long","displayText":"atol","type":"function","descriptionMoreURL":"group__cstdlib_a_p_i_gad7992156968cab995ddc15880dbfda70.html#gad7992156968cab995ddc15880dbfda70","snippet":"atol(${1:const string &str})","description":"Convert string to long integer."},{"leftLabel":"long","displayText":"labs","type":"function","descriptionMoreURL":"group__cstdlib_a_p_i_ga3b270e0b7f5c47e2511ecf21dab24b5b.html#ga3b270e0b7f5c47e2511ecf21dab24b5b","snippet":"labs(${1:long n})","description":"Absolute value."},{"leftLabel":"float","displayText":"atof","type":"function","descriptionMoreURL":"group__cstdlib_a_p_i_ga3115cd14bd7c409bb213020c414a1779.html#ga3115cd14bd7c409bb213020c414a1779","snippet":"atof(${1:const string &str})","description":"Convert string to float."},{"leftLabel":"float","displayText":"strtod","type":"function","descriptionMoreURL":"group__cstdlib_a_p_i_gac1db1816f8e8ece593c7a5329636b3c3.html#gac1db1816f8e8ece593c7a5329636b3c3","snippet":"strtod(${1:const string &str}, ${2:string &endptr})","description":"Convert string to float."},{"leftLabel":"long","displayText":"strtol","type":"function","descriptionMoreURL":"group__cstdlib_a_p_i_ga946b010fb3c8e6440d6d18f14d704734.html#ga946b010fb3c8e6440d6d18f14d704734","snippet":"strtol(${1:const string &str}, ${2:string &endptr}, ${3:int base=10})","description":"Convert string to long integer."},{"leftLabel":"long","displayText":"strtoul","type":"function","descriptionMoreURL":"group__cstdlib_a_p_i_gadff1d9998bc9d54d98c3f7545e3eba37.html#gadff1d9998bc9d54d98c3f7545e3eba37","snippet":"strtoul(${1:const string &str}, ${2:string &endptr}, ${3:int base=10})","description":"Convert string to unsigned long integer."},{"leftLabel":"div_t","displayText":"div","type":"function","descriptionMoreURL":"group__cstdlib_a_p_i_ga4476a5dc418924ee3ad18ce699581dfd.html#ga4476a5dc418924ee3ad18ce699581dfd","snippet":"div(${1:int numer}, ${2:int denom})","description":"Integral division."},{"leftLabel":"ldiv_t","displayText":"ldiv","type":"function","descriptionMoreURL":"group__cstdlib_a_p_i_ga66fb11dc4734db57fdda6f32f3977935.html#ga66fb11dc4734db57fdda6f32f3977935","snippet":"ldiv(${1:long numer}, ${2:long denom})","description":"Integral division."},{"leftLabel":"variant","displayText":"StrToNum","type":"function","descriptionMoreURL":"group__cstring_a_p_i_ga66139f3a7d68d84bf7527dee102666aa.html#ga66139f3a7d68d84bf7527dee102666aa","snippet":"StrToNum(${1:string str})","description":"Convert string to number."},{"leftLabel":"unsigned int","displayText":"StrLen","type":"function","descriptionMoreURL":"group__cstring_a_p_i_ga13b226120fec7be8bcc5dcc477c2776c.html#ga13b226120fec7be8bcc5dcc477c2776c","snippet":"StrLen(${1:string str})","description":"Get string length."},{"leftLabel":"byte","displayText":"StrIndex","type":"function","descriptionMoreURL":"group__cstring_a_p_i_ga47434e9d95f28a810744cef52622fec0.html#ga47434e9d95f28a810744cef52622fec0","snippet":"StrIndex(${1:string str}, ${2:unsigned int idx})","description":"Extract a character from a string."},{"leftLabel":"string","displayText":"NumToStr","type":"function","descriptionMoreURL":"group__cstring_a_p_i_ga4cf4c03b015a26cec27eb7f4baeaaef3.html#ga4cf4c03b015a26cec27eb7f4baeaaef3","snippet":"NumToStr(${1:variant num})","description":"Convert number to string."},{"leftLabel":"string","displayText":"StrCat","type":"function","descriptionMoreURL":"group__cstring_a_p_i_ga2b29257801af5e2fe7ee06528f9d6b40.html#ga2b29257801af5e2fe7ee06528f9d6b40","snippet":"StrCat(${1:string str1}, ${2:string str2}, ${3:string strN})","description":"Concatenate strings."},{"leftLabel":"string","displayText":"SubStr","type":"function","descriptionMoreURL":"group__cstring_a_p_i_ga35d32335d12e1f453977797ad5a1d861.html#ga35d32335d12e1f453977797ad5a1d861","snippet":"SubStr(${1:string str}, ${2:unsigned int idx}, ${3:unsigned int len})","description":"Extract a portion of a string."},{"leftLabel":"string","displayText":"Flatten","type":"function","descriptionMoreURL":"group__cstring_a_p_i_ga90c550f699edf34280a5740a25c0c38d.html#ga90c550f699edf34280a5740a25c0c38d","snippet":"Flatten(${1:variant num})","description":"Flatten a number to a string."},{"leftLabel":"string","displayText":"StrReplace","type":"function","descriptionMoreURL":"group__cstring_a_p_i_ga18c44b704ade62daf30101e2fcca8660.html#ga18c44b704ade62daf30101e2fcca8660","snippet":"StrReplace(${1:string str}, ${2:unsigned int idx}, ${3:string strnew})","description":"Replace a portion of a string."},{"leftLabel":"string","displayText":"FormatNum","type":"function","descriptionMoreURL":"group__cstring_a_p_i_gae1e152293a956a9911b3940664b7b9f4.html#gae1e152293a956a9911b3940664b7b9f4","snippet":"FormatNum(${1:string fmt}, ${2:variant num})","description":"Format a number."},{"leftLabel":"string","displayText":"FormatVal","type":"function","descriptionMoreURL":"group__cstring_a_p_i_ga59485b28d67d546f5efb739f6dd9539b.html#ga59485b28d67d546f5efb739f6dd9539b","snippet":"FormatVal(${1:string fmt}, ${2:variant val})","description":"Format a value."},{"leftLabel":"string","displayText":"FlattenVar","type":"function","descriptionMoreURL":"group__cstring_a_p_i_gad05dcd98d787d4497e41a84c3d8a78b6.html#gad05dcd98d787d4497e41a84c3d8a78b6","snippet":"FlattenVar(${1:variant x})","description":"Flatten any data to a string."},{"leftLabel":"int","displayText":"UnflattenVar","type":"function","descriptionMoreURL":"group__cstring_a_p_i_ga057308170bd294325c21c7ed0db989db.html#ga057308170bd294325c21c7ed0db989db","snippet":"UnflattenVar(${1:string str}, ${2:variant &x})","description":"Unflatten a string into a data type."},{"leftLabel":"int","displayText":"Pos","type":"function","descriptionMoreURL":"group__cstring_a_p_i_gafde1d6f63344e81232c5061041b416de.html#gafde1d6f63344e81232c5061041b416de","snippet":"Pos(${1:string Substr}, ${2:string S})","description":"Find substring position."},{"leftLabel":"string","displayText":"ByteArrayToStr","type":"function","descriptionMoreURL":"group__cstring_a_p_i_ga9605bc4543e9a4d67b13b551ed06d859.html#ga9605bc4543e9a4d67b13b551ed06d859","snippet":"ByteArrayToStr(${1:byte data[]})","description":"Convert a byte array to a string."},{"leftLabel":"void","displayText":"ByteArrayToStrEx","type":"function","descriptionMoreURL":"group__cstring_a_p_i_ga4bdbcfda25ea32caf850346be215df23.html#ga4bdbcfda25ea32caf850346be215df23","snippet":"ByteArrayToStrEx(${1:byte data[]}, ${2:string &str})","description":"Convert a byte array to a string."},{"leftLabel":"void","displayText":"StrToByteArray","type":"function","descriptionMoreURL":"group__cstring_a_p_i_gaa0c0df9844525dd7ce7ed39fb63bda47.html#gaa0c0df9844525dd7ce7ed39fb63bda47","snippet":"StrToByteArray(${1:string str}, ${2:byte &data[]})","description":"Convert a string to a byte array."},{"leftLabel":"string","displayText":"Copy","type":"function","descriptionMoreURL":"group__cstring_a_p_i_gabc76adbaa747c5c30b3412ac10092d8a.html#gabc76adbaa747c5c30b3412ac10092d8a","snippet":"Copy(${1:string str}, ${2:unsigned int idx}, ${3:unsigned int len})","description":"Copy a portion of a string."},{"leftLabel":"string","displayText":"MidStr","type":"function","descriptionMoreURL":"group__cstring_a_p_i_ga3e2a0a753a474359d5d92cf82411e664.html#ga3e2a0a753a474359d5d92cf82411e664","snippet":"MidStr(${1:string str}, ${2:unsigned int idx}, ${3:unsigned int len})","description":"Copy a portion from the middle of a string."},{"leftLabel":"string","displayText":"RightStr","type":"function","descriptionMoreURL":"group__cstring_a_p_i_gae6de656a583e8c6153a74da1cc7ae7ac.html#gae6de656a583e8c6153a74da1cc7ae7ac","snippet":"RightStr(${1:string str}, ${2:unsigned int size})","description":"Copy a portion from the end of a string."},{"leftLabel":"string","displayText":"LeftStr","type":"function","descriptionMoreURL":"group__cstring_a_p_i_gac2c5cae82d07e975fcf30cd3ff3a20ef.html#gac2c5cae82d07e975fcf30cd3ff3a20ef","snippet":"LeftStr(${1:string str}, ${2:unsigned int size})","description":"Copy a portion from the start of a string."},{"leftLabel":"int","displayText":"strlen","type":"function","descriptionMoreURL":"group__cstring_a_p_i_gae61811f057680a116e4cf4dc5ca6e656.html#gae61811f057680a116e4cf4dc5ca6e656","snippet":"strlen(${1:const string &str})","description":"Get string length."},{"leftLabel":"string","displayText":"strcat","type":"function","descriptionMoreURL":"group__cstring_a_p_i_gaec7ca6ec01a3aeff44b437bf26dd032e.html#gaec7ca6ec01a3aeff44b437bf26dd032e","snippet":"strcat(${1:string &dest}, ${2:const string &src})","description":"Concatenate strings."},{"leftLabel":"string","displayText":"strncat","type":"function","descriptionMoreURL":"group__cstring_a_p_i_ga725fde606db880b95a8248aaf205817b.html#ga725fde606db880b95a8248aaf205817b","snippet":"strncat(${1:string &dest}, ${2:const string &src}, ${3:unsigned int num})","description":"Append characters from string."},{"leftLabel":"string","displayText":"strcpy","type":"function","descriptionMoreURL":"group__cstring_a_p_i_ga3de92c10ed9dd0a72d79e8351d6bfdba.html#ga3de92c10ed9dd0a72d79e8351d6bfdba","snippet":"strcpy(${1:string &dest}, ${2:const string &src})","description":"Copy string."},{"leftLabel":"string","displayText":"strncpy","type":"function","descriptionMoreURL":"group__cstring_a_p_i_ga1c5956e682a5c31dd09ea4cfc1e7e3b1.html#ga1c5956e682a5c31dd09ea4cfc1e7e3b1","snippet":"strncpy(${1:string &dest}, ${2:const string &src}, ${3:unsigned int num})","description":"Copy characters from string."},{"leftLabel":"int","displayText":"strcmp","type":"function","descriptionMoreURL":"group__cstring_a_p_i_ga243861c2298764c4abf28bbb58ca7663.html#ga243861c2298764c4abf28bbb58ca7663","snippet":"strcmp(${1:const string &str1}, ${2:const string &str2})","description":"Compare two strings."},{"leftLabel":"int","displayText":"strncmp","type":"function","descriptionMoreURL":"group__cstring_a_p_i_ga337c73015b829b6cc19efd9894f4cb97.html#ga337c73015b829b6cc19efd9894f4cb97","snippet":"strncmp(${1:const string &str1}, ${2:const string &str2}, ${3:unsigned int num})","description":"Compare characters of two strings."},{"leftLabel":"void","displayText":"memcpy","type":"function","descriptionMoreURL":"group__cstring_a_p_i_ga15f3cb261c6b0b54ee6aa4dcb95097da.html#ga15f3cb261c6b0b54ee6aa4dcb95097da","snippet":"memcpy(${1:variant dest}, ${2:variant src}, ${3:byte num})","description":"Copy memory."},{"leftLabel":"void","displayText":"memmove","type":"function","descriptionMoreURL":"group__cstring_a_p_i_gaa785929d7471cb3fe8b33fcca62d5958.html#gaa785929d7471cb3fe8b33fcca62d5958","snippet":"memmove(${1:variant dest}, ${2:variant src}, ${3:byte num})","description":"Move memory."},{"leftLabel":"char","displayText":"memcmp","type":"function","descriptionMoreURL":"group__cstring_a_p_i_ga35b031b0ba754f880e5d0152634f77d8.html#ga35b031b0ba754f880e5d0152634f77d8","snippet":"memcmp(${1:variant ptr1}, ${2:variant ptr2}, ${3:byte num})","description":"Compare two blocks of memory."},{"leftLabel":"unsigned long","displayText":"addressOf","type":"function","descriptionMoreURL":"group__cstring_a_p_i_ga569febeaecaaf09f64cf52c379cf99e2.html#ga569febeaecaaf09f64cf52c379cf99e2","snippet":"addressOf(${1:variant data})","description":"Get the absolute address of a variable."},{"leftLabel":"unsigned long","displayText":"reladdressOf","type":"function","descriptionMoreURL":"group__cstring_a_p_i_gac3fa202c27ae7100e30339dbe5891ee5.html#gac3fa202c27ae7100e30339dbe5891ee5","snippet":"reladdressOf(${1:variant data})","description":"Get the relative address of a variable."},{"leftLabel":"unsigned long","displayText":"addressOfEx","type":"function","descriptionMoreURL":"group__cstring_a_p_i_gad60c14d75b6751a29b42d3d37f99116f.html#gad60c14d75b6751a29b42d3d37f99116f","snippet":"addressOfEx(${1:variant data}, ${2:bool relative})","description":"Get the absolute or relative address of a variable."},{"leftLabel":"int","displayText":"isupper","type":"function","descriptionMoreURL":"group__ctype_a_p_i_gadadd6582d46775aab6a51e29d16d9f77.html#gadadd6582d46775aab6a51e29d16d9f77","snippet":"isupper(${1:int c})","description":"Check if character is uppercase letter."},{"leftLabel":"int","displayText":"islower","type":"function","descriptionMoreURL":"group__ctype_a_p_i_ga7b8f652a0423a80922dd89d8829db5f2.html#ga7b8f652a0423a80922dd89d8829db5f2","snippet":"islower(${1:int c})","description":"Check if character is lowercase letter."},{"leftLabel":"int","displayText":"isalpha","type":"function","descriptionMoreURL":"group__ctype_a_p_i_ga25908ae63aac2df990634e1ae5bd14d9.html#ga25908ae63aac2df990634e1ae5bd14d9","snippet":"isalpha(${1:int c})","description":"Check if character is alphabetic."},{"leftLabel":"int","displayText":"isdigit","type":"function","descriptionMoreURL":"group__ctype_a_p_i_ga3fa45b35c8abf67a950b6d3d4063dede.html#ga3fa45b35c8abf67a950b6d3d4063dede","snippet":"isdigit(${1:int c})","description":"Check if character is decimal digit."},{"leftLabel":"int","displayText":"isalnum","type":"function","descriptionMoreURL":"group__ctype_a_p_i_gadf38e126f73a010f30af76db2a28c6e1.html#gadf38e126f73a010f30af76db2a28c6e1","snippet":"isalnum(${1:int c})","description":"Check if character is alphanumeric."},{"leftLabel":"int","displayText":"isspace","type":"function","descriptionMoreURL":"group__ctype_a_p_i_ga56be4166e4673843042a548a7f513dbc.html#ga56be4166e4673843042a548a7f513dbc","snippet":"isspace(${1:int c})","description":"Check if character is a white-space."},{"leftLabel":"int","displayText":"iscntrl","type":"function","descriptionMoreURL":"group__ctype_a_p_i_ga0008a4e8e7889734dc1d83297de07158.html#ga0008a4e8e7889734dc1d83297de07158","snippet":"iscntrl(${1:int c})","description":"Check if character is a control character."},{"leftLabel":"int","displayText":"isprint","type":"function","descriptionMoreURL":"group__ctype_a_p_i_ga99355d8f0fb41ec43effb95189db0ed4.html#ga99355d8f0fb41ec43effb95189db0ed4","snippet":"isprint(${1:int c})","description":"Check if character is printable."},{"leftLabel":"int","displayText":"isgraph","type":"function","descriptionMoreURL":"group__ctype_a_p_i_ga49f40fd869fd0c90e4497fda08c89561.html#ga49f40fd869fd0c90e4497fda08c89561","snippet":"isgraph(${1:int c})","description":"Check if character has graphical representation."},{"leftLabel":"int","displayText":"ispunct","type":"function","descriptionMoreURL":"group__ctype_a_p_i_gaf29554b3ec04ea7684482bffed5dbce6.html#gaf29554b3ec04ea7684482bffed5dbce6","snippet":"ispunct(${1:int c})","description":"Check if character is a punctuation."},{"leftLabel":"int","displayText":"isxdigit","type":"function","descriptionMoreURL":"group__ctype_a_p_i_gadaf3aadefe3fc4fb07b6be0d7b880f53.html#gadaf3aadefe3fc4fb07b6be0d7b880f53","snippet":"isxdigit(${1:int c})","description":"Check if character is hexadecimal digit."},{"leftLabel":"int","displayText":"toupper","type":"function","descriptionMoreURL":"group__ctype_a_p_i_ga9c2f57ac3865af9006fdbfd5db9fd517.html#ga9c2f57ac3865af9006fdbfd5db9fd517","snippet":"toupper(${1:int c})","description":"Convert lowercase letter to uppercase."},{"leftLabel":"int","displayText":"tolower","type":"function","descriptionMoreURL":"group__ctype_a_p_i_gac79d6114c9df7350cedcd8cf921a6ea4.html#gac79d6114c9df7350cedcd8cf921a6ea4","snippet":"tolower(${1:int c})","description":"Convert uppercase letter to lowercase."},{"leftLabel":"void","displayText":"glInit","type":"function","descriptionMoreURL":"group___graphics_library_gaa7ed4119aa4efc0ffb6bccbfa43c4ef2.html#gaa7ed4119aa4efc0ffb6bccbfa43c4ef2","snippet":"glInit(${1:})","description":"Initialize graphics library."},{"leftLabel":"void","displayText":"glSet","type":"function","descriptionMoreURL":"group___graphics_library_ga0570b9f8685a0b0f4a4d1a6dd345794c.html#ga0570b9f8685a0b0f4a4d1a6dd345794c","snippet":"glSet(${1:int glType}, ${2:int glValue})","description":"Set graphics library options."},{"leftLabel":"int","displayText":"glBeginObject","type":"function","descriptionMoreURL":"group___graphics_library_ga562a3ba8f37297f1da2ed152b3eea64b.html#ga562a3ba8f37297f1da2ed152b3eea64b","snippet":"glBeginObject(${1:})","description":"Begin defining an object."},{"leftLabel":"void","displayText":"glEndObject","type":"function","descriptionMoreURL":"group___graphics_library_gac4be743d20c528bea21c25c352c4b0d3.html#gac4be743d20c528bea21c25c352c4b0d3","snippet":"glEndObject(${1:})","description":"Stop defining an object."},{"leftLabel":"void","displayText":"glObjectAction","type":"function","descriptionMoreURL":"group___graphics_library_gab6507b9f7c60c2bd50496782ec961130.html#gab6507b9f7c60c2bd50496782ec961130","snippet":"glObjectAction(${1:int glObjectId}, ${2:int glAction}, ${3:int glValue})","description":"Perform an object action."},{"leftLabel":"void","displayText":"glAddVertex","type":"function","descriptionMoreURL":"group___graphics_library_ga894599fbc6762f0207d1466e7c7a2266.html#ga894599fbc6762f0207d1466e7c7a2266","snippet":"glAddVertex(${1:int glX}, ${2:int glY}, ${3:int glZ})","description":"Add a vertex to an object."},{"leftLabel":"void","displayText":"glBegin","type":"function","descriptionMoreURL":"group___graphics_library_ga3eaeea3b175fb5109a13f66a91492897.html#ga3eaeea3b175fb5109a13f66a91492897","snippet":"glBegin(${1:int glBeginMode})","description":"Begin a new polygon for the current object."},{"leftLabel":"void","displayText":"glEnd","type":"function","descriptionMoreURL":"group___graphics_library_gade1bb922b13fbe3f12bb09490af66dae.html#gade1bb922b13fbe3f12bb09490af66dae","snippet":"glEnd(${1:})","description":"Finish a polygon for the current object."},{"leftLabel":"void","displayText":"glBeginRender","type":"function","descriptionMoreURL":"group___graphics_library_ga52de2d3857c7964c8c4e98806c08b058.html#ga52de2d3857c7964c8c4e98806c08b058","snippet":"glBeginRender(${1:})","description":"Begin a new render."},{"leftLabel":"void","displayText":"glCallObject","type":"function","descriptionMoreURL":"group___graphics_library_gac91cb50537315a32a1932b896835530f.html#gac91cb50537315a32a1932b896835530f","snippet":"glCallObject(${1:int glObjectId})","description":"Call a graphic object."},{"leftLabel":"void","displayText":"glFinishRender","type":"function","descriptionMoreURL":"group___graphics_library_ga1a306cc3902441ee7c688d41f0568113.html#ga1a306cc3902441ee7c688d41f0568113","snippet":"glFinishRender(${1:})","description":"Finish the current render."},{"leftLabel":"void","displayText":"glSetAngleX","type":"function","descriptionMoreURL":"group___graphics_library_ga5553cf53c50eedb5b1be796ef056324f.html#ga5553cf53c50eedb5b1be796ef056324f","snippet":"glSetAngleX(${1:int glValue})","description":"Set the X axis angle."},{"leftLabel":"void","displayText":"glAddToAngleX","type":"function","descriptionMoreURL":"group___graphics_library_ga69a4c6b3916eecff437d1e9583689ced.html#ga69a4c6b3916eecff437d1e9583689ced","snippet":"glAddToAngleX(${1:int glValue})","description":"Add to the X axis angle."},{"leftLabel":"void","displayText":"glSetAngleY","type":"function","descriptionMoreURL":"group___graphics_library_gaf6370bda87907f0caa5f27c00aa63ada.html#gaf6370bda87907f0caa5f27c00aa63ada","snippet":"glSetAngleY(${1:int glValue})","description":"Set the Y axis angle."},{"leftLabel":"void","displayText":"glAddToAngleY","type":"function","descriptionMoreURL":"group___graphics_library_gad2a20d8676366712c06e3db7667ca237.html#gad2a20d8676366712c06e3db7667ca237","snippet":"glAddToAngleY(${1:int glValue})","description":"Add to the Y axis angle."},{"leftLabel":"void","displayText":"glSetAngleZ","type":"function","descriptionMoreURL":"group___graphics_library_ga64cde9e7f26fa9296d943a9b401fc754.html#ga64cde9e7f26fa9296d943a9b401fc754","snippet":"glSetAngleZ(${1:int glValue})","description":"Set the Z axis angle."},{"leftLabel":"void","displayText":"glAddToAngleZ","type":"function","descriptionMoreURL":"group___graphics_library_ga248f563c09de3acafe3bfcf984b50459.html#ga248f563c09de3acafe3bfcf984b50459","snippet":"glAddToAngleZ(${1:int glValue})","description":"Add to the Z axis angle."},{"leftLabel":"int","displayText":"glSin32768","type":"function","descriptionMoreURL":"group___graphics_library_gaee03e67ab7d92cf711987e9419dd8e5c.html#gaee03e67ab7d92cf711987e9419dd8e5c","snippet":"glSin32768(${1:int glAngle})","description":"Table-based sine scaled by 32768."},{"leftLabel":"int","displayText":"glCos32768","type":"function","descriptionMoreURL":"group___graphics_library_gaeb60b2d99fa9273a8fb0f827a0b0ae01.html#gaeb60b2d99fa9273a8fb0f827a0b0ae01","snippet":"glCos32768(${1:int glAngle})","description":"Table-based cosine scaled by 32768."},{"leftLabel":"int","displayText":"glBox","type":"function","descriptionMoreURL":"group___graphics_library_ga840325eac24ae7cca69d1db3c2f15b50.html#ga840325eac24ae7cca69d1db3c2f15b50","snippet":"glBox(${1:int glMode}, ${2:int glSizeX}, ${3:int glSizeY}, ${4:int glSizeZ})","description":"Create a 3D box."},{"leftLabel":"int","displayText":"glCube","type":"function","descriptionMoreURL":"group___graphics_library_gad1afb205fe30811d3f813ca86c475321.html#gad1afb205fe30811d3f813ca86c475321","snippet":"glCube(${1:int glMode}, ${2:int glSize})","description":"Create a 3D cube."},{"leftLabel":"int","displayText":"glPyramid","type":"function","descriptionMoreURL":"group___graphics_library_gab981e04cff461199d56633cb6411464e.html#gab981e04cff461199d56633cb6411464e","snippet":"glPyramid(${1:int glMode}, ${2:int glSizeX}, ${3:int glSizeY}, ${4:int glSizeZ})","description":"Create a 3D pyramid."},{"leftLabel":"void","displayText":"PosRegEnable","type":"function","descriptionMoreURL":"group___output_module_functions_gac9b2c158f131ebe909d61b8eae40a736.html#gac9b2c158f131ebe909d61b8eae40a736","snippet":"PosRegEnable(${1:byte output}, ${2:byte p=PID_3}, ${3:byte i=PID_1}, ${4:byte d=PID_1})","description":"Enable absolute position regulation with PID factors."},{"leftLabel":"void","displayText":"PosRegSetAngle","type":"function","descriptionMoreURL":"group___output_module_functions_gadbb21feba9bd8d38e9ac7accedc4855a.html#gadbb21feba9bd8d38e9ac7accedc4855a","snippet":"PosRegSetAngle(${1:byte output}, ${2:long angle})","description":"Change the current value for set angle."},{"leftLabel":"void","displayText":"PosRegAddAngle","type":"function","descriptionMoreURL":"group___output_module_functions_ga617d0da1fa87b8800a236edfbe8c1d7a.html#ga617d0da1fa87b8800a236edfbe8c1d7a","snippet":"PosRegAddAngle(${1:byte output}, ${2:long angle_add})","description":"Add to the current value for set angle."},{"leftLabel":"void","displayText":"PosRegSetMax","type":"function","descriptionMoreURL":"group___output_module_functions_ga938e600d946faf6505b60c454a7db239.html#ga938e600d946faf6505b60c454a7db239","snippet":"PosRegSetMax(${1:byte output}, ${2:byte max_speed}, ${3:byte max_acceleration})","description":"Set maximum limits."}]
--- gbglehrerclient-0.1.orig/etc/skel/.atom/packages/language-nxc/grammars/nxc.cson
+++ /dev/null
@@ -1,773 +0,0 @@
-'scopeName': 'source.nxc'
-'fileTypes': [
-  'nxc'
-]
-'firstLineMatch': '-\\*-\\s*([Mm]ode: )?C;?\\s*-\\*-'
-'name': 'NXC'
-'patterns': [
-  {
-    'include': '#preprocessor-rule-enabled'
-  }
-  {
-    'include': '#preprocessor-rule-disabled'
-  }
-  {
-    'include': '#preprocessor-rule-other'
-  }
-  {
-    'include': '#comments'
-  }
-  {
-    'match': '\\b(break|case|until|continue|default|do|else|for|goto|if|_Pragma|return|switch|while)\\b'
-    'name': 'keyword.control.nxc'
-  }
-  {
-    'match': '\\b(byte|string|asm|__asm__|auto|bool|_Bool|char|_Complex|double|enum|float|_Imaginary|int|long|short|signed|struct|typedef|union|unsigned|void)\\b'
-    'name': 'storage.type.nxc'
-  }
-  {
-    'match': '\\b(const|extern|register|restrict|static|volatile|inline)\\b'
-    'name': 'storage.modifier.nxc'
-  }
-  {
-    'comment': 'common C constant naming idiom -- kConstantVariable'
-    'match': '\\bk[A-Z]\\w*\\b'
-    'name': 'constant.other.variable.mac-classic.nxc'
-  }
-  {
-    'match': '\\bg[A-Z]\\w*\\b'
-    'name': 'variable.other.readwrite.global.mac-classic.nxc'
-  }
-  {
-    'match': '\\bs[A-Z]\\w*\\b'
-    'name': 'variable.other.readwrite.static.mac-classic.nxc'
-  }
-  {
-    'match': '\\b(NULL|true|false|TRUE|FALSE)\\b'
-    'name': 'constant.language.nxc'
-  }
-  {
-    'match': '\\b([A-Z_0-9]+)\\b'
-    'name': 'constant.language.nxc'
-  }
-  {
-    'include': '#sizeof'
-  }
-  {
-    'include': '#numbers'
-  }
-  {
-    'include': '#strings'
-  }
-  {
-    'begin': '''(?x)
-      ^\\s* ((\\#)\\s*define) \\s+     # define
-      ((?<id>[a-zA-Z_][a-zA-Z0-9_]*))  # macro name
-      (?:
-        (\\()
-          (
-            \\s* \\g<id> \\s*         # first argument
-            ((,) \\s* \\g<id> \\s*)*  # additional arguments
-            (?:\\.\\.\\.)?            # varargs ellipsis?
-          )
-        (\\))
-      )?
-    '''
-    'beginCaptures':
-      '1':
-        'name': 'keyword.control.directive.define.nxc'
-      '2':
-        'name': 'punctuation.definition.directive.nxc'
-      '3':
-        'name': 'entity.name.function.preprocessor.nxc'
-      '5':
-        'name': 'punctuation.definition.parameters.begin.nxc'
-      '6':
-        'name': 'variable.parameter.preprocessor.nxc'
-      '8':
-        'name': 'punctuation.separator.parameters.nxc'
-      '9':
-        'name': 'punctuation.definition.parameters.end.nxc'
-    'end': '(?=(?://|/\\*))|(?<!\\\\)(?=\\n)'
-    'name': 'meta.preprocessor.macro.nxc'
-    'patterns': [
-      {
-        'include': '$base'
-      }
-    ]
-  }
-  {
-    'begin': '^\\s*((#)\\s*(error|warning))\\b'
-    'captures':
-      '1':
-        'name': 'keyword.control.directive.diagnostic.$3.nxc'
-      '2':
-        'name': 'punctuation.definition.directive.nxc'
-    'end': '(?<!\\\\)(?=\\n)'
-    'name': 'meta.preprocessor.diagnostic.nxc'
-    'patterns': [
-      {
-        'include': '#line_continuation_character'
-      }
-    ]
-  }
-  {
-    'begin': '^\\s*((#)\\s*(include|import))\\b\\s*'
-    'beginCaptures':
-      '1':
-        'name': 'keyword.control.directive.$3.nxc'
-      '2':
-        'name': 'punctuation.definition.directive.nxc'
-    'end': '(?=(?://|/\\*))|(?<!\\\\)(?=\\n)'
-    'name': 'meta.preprocessor.include.nxc'
-    'patterns': [
-      {
-        'include': '#line_continuation_character'
-      }
-      {
-        'begin': '"'
-        'beginCaptures':
-          '0':
-            'name': 'punctuation.definition.string.begin.nxc'
-        'end': '"'
-        'endCaptures':
-          '0':
-            'name': 'punctuation.definition.string.end.nxc'
-        'name': 'string.quoted.double.include.nxc'
-      }
-      {
-        'begin': '<'
-        'beginCaptures':
-          '0':
-            'name': 'punctuation.definition.string.begin.nxc'
-        'end': '>'
-        'endCaptures':
-          '0':
-            'name': 'punctuation.definition.string.end.nxc'
-        'name': 'string.quoted.other.lt-gt.include.nxc'
-      }
-    ]
-  }
-  {
-    'include': '#pragma-mark'
-  }
-  {
-    'begin': '^\\s*((#)\\s*line)\\b'
-    'beginCaptures':
-      '1':
-        'name': 'keyword.control.directive.line.nxc'
-      '2':
-        'name': 'punctuation.definition.directive.nxc'
-    'end': '(?=(?://|/\\*))|(?<!\\\\)(?=\\n)'
-    'name': 'meta.preprocessor.nxc'
-    'patterns': [
-      {
-        'include': '#strings'
-      }
-      {
-        'include': '#numbers'
-      }
-      {
-        'include': '#line_continuation_character'
-      }
-    ]
-  }
-  {
-    'begin': '^\\s*(?:((#)\\s*(?:elif|else|if|ifdef|ifndef))|((#)\\s*(pragma|undef)))\\b'
-    'beginCaptures':
-      '1':
-        'name': 'keyword.control.directive.conditional.nxc'
-      '2':
-        'name': 'punctuation.definition.directive.nxc'
-      '3':
-        'name': 'keyword.control.directive.$5.nxc'
-      '4':
-        'name': 'punctuation.definition.directive.nxc'
-    'end': '(?=(?://|/\\*))|(?<!\\\\)(?=\\n)'
-    'name': 'meta.preprocessor.nxc'
-    'patterns': [
-      {
-        'include': '#line_continuation_character'
-      }
-    ]
-  }
-  {
-    'match': '\\b(u_char|u_short|u_int|u_long|ushort|uint|u_quad_t|quad_t|qaddr_t|caddr_t|daddr_t|dev_t|fixpt_t|blkcnt_t|blksize_t|gid_t|in_addr_t|in_port_t|ino_t|key_t|mode_t|nlink_t|id_t|pid_t|off_t|segsz_t|swblk_t|uid_t|id_t|clock_t|size_t|ssize_t|time_t|useconds_t|suseconds_t)\\b'
-    'name': 'support.type.sys-types.nxc'
-  }
-  {
-    'match': '\\b(pthread_attr_t|pthread_cond_t|pthread_condattr_t|pthread_mutex_t|pthread_mutexattr_t|pthread_once_t|pthread_rwlock_t|pthread_rwlockattr_t|pthread_t|pthread_key_t)\\b'
-    'name': 'support.type.pthread.nxc'
-  }
-  {
-    'match': '\\b(int8_t|int16_t|int32_t|int64_t|uint8_t|uint16_t|uint32_t|uint64_t|int_least8_t|int_least16_t|int_least32_t|int_least64_t|uint_least8_t|uint_least16_t|uint_least32_t|uint_least64_t|int_fast8_t|int_fast16_t|int_fast32_t|int_fast64_t|uint_fast8_t|uint_fast16_t|uint_fast32_t|uint_fast64_t|intptr_t|uintptr_t|intmax_t|intmax_t|uintmax_t|uintmax_t)\\b'
-    'name': 'support.type.stdint.nxc'
-  }
-  {
-    'match': '\\b(noErr|kNilOptions|kInvalidID|kVariableLengthArray)\\b'
-    'name': 'support.constant.mac-classic.nxc'
-  }
-  {
-    'match': '\\b(AbsoluteTime|Boolean|Byte|ByteCount|ByteOffset|BytePtr|CompTimeValue|ConstLogicalAddress|ConstStrFileNameParam|ConstStringPtr|Duration|Fixed|FixedPtr|Float32|Float32Point|Float64|Float80|Float96|FourCharCode|Fract|FractPtr|Handle|ItemCount|LogicalAddress|OptionBits|OSErr|OSStatus|OSType|OSTypePtr|PhysicalAddress|ProcessSerialNumber|ProcessSerialNumberPtr|ProcHandle|Ptr|ResType|ResTypePtr|ShortFixed|ShortFixedPtr|SignedByte|SInt16|SInt32|SInt64|SInt8|Size|StrFileName|StringHandle|StringPtr|TimeBase|TimeRecord|TimeScale|TimeValue|TimeValue64|UInt16|UInt32|UInt64|UInt8|UniChar|UniCharCount|UniCharCountPtr|UniCharPtr|UnicodeScalarValue|UniversalProcHandle|UniversalProcPtr|UnsignedFixed|UnsignedFixedPtr|UnsignedWide|UTF16Char|UTF32Char|UTF8Char)\\b'
-    'name': 'support.type.mac-classic.nxc'
-  }
-  {
-    'comment': 'Reserved POSIX types'
-    'match': '\\b([A-Za-z0-9_]+_t)\\b'
-    'name': 'support.type.posix-reserved.nxc'
-  }
-  {
-    'include': '#block'
-  }
-  {
-    'begin': '''(?x)
-      (?:
-        ^ |
-       (?:
-          (?=\\s)(?<!else|new|return)(?<=\\w)  # word + space before name
-          |
-          (?=\\s*[A-Za-z_])(?<!&&)(?<=[*&>])   # type modifier before name
-        )
-      )
-      (\\s*)(?!(while|for|do|until|if|else|switch|catch|enumerate|return|sizeof|[cr]?iterate)\\s*\\()
-      (
-        (?:[A-Za-z_][A-Za-z0-9_]*+|::)++  # actual name
-        |
-        (?:(?<=operator)(?:[-*&<>=+!]+|\\(\\)|\\[\\]))  # if it is a C++ operator
-      )
-      \\s*(?=\\()
-    '''
-    'beginCaptures':
-      '1':
-        'name': 'punctuation.whitespace.function.leading.nxc'
-      '3':
-        'name': 'entity.name.function.nxc'
-      '4':
-        'name': 'punctuation.definition.parameters.nxc'
-    'end': '(?<=\\})|(?=#)|(;)'
-    'name': 'meta.function.nxc'
-    'patterns': [
-      {
-        'include': '#comments'
-      }
-      {
-        'include': '#parens'
-      }
-      {
-        'match': '\\b(const|override|final)\\b'
-        'name': 'storage.modifier.nxc'
-      }
-      {
-        'include': '#block'
-      }
-    ]
-  }
-  {
-    'include': '#line_continuation_character'
-  }
-]
-'repository':
-  'access':
-    'captures':
-      '1':
-        'name': 'punctuation.separator.variable-access.nxc'
-      '2':
-        'name': 'variable.other.dot-access.nxc'
-    'match': '(\\.)([a-zA-Z_][a-zA-Z_0-9]*)\\b(?!\\s*\\()'
-  'block':
-    'patterns': [
-      {
-        'begin': '\\{'
-        'beginCaptures':
-          '0':
-            'name': 'punctuation.section.block.begin.nxc'
-        'end': '\\}|(?=\\s*#\\s*endif\\b)'
-        'endCaptures':
-          '0':
-            'name': 'punctuation.section.block.end.nxc'
-        'name': 'meta.block.nxc'
-        'patterns': [
-          {
-            'include': '#block_innards'
-          }
-        ]
-      }
-    ]
-  'block_innards':
-    'patterns': [
-      {
-        'include': '#preprocessor-rule-enabled-block'
-      }
-      {
-        'include': '#preprocessor-rule-disabled-block'
-      }
-      {
-        'include': '#preprocessor-rule-other-block'
-      }
-      {
-        'include': '#sizeof'
-      }
-      {
-        'include': '#access'
-      }
-      {
-        'include': '#libc'
-      }
-      {
-        'include': '#c_function_call'
-      }
-      {
-        'captures':
-          '1':
-            'name': 'variable.other.nxc'
-          '2':
-            'name': 'punctuation.definition.parameters.nxc'
-        'match': '(?x)\n\t\t\t        (?x)\n\t\t\t(?:  \n\t\t\t     (?: (?= \\s )           (?<!else|new|return) (?<=\\w)\\s+      #  or word + space before name\n\t\t\t     )\n\t\t\t)\n\t\t\t(\n\t\t\t\t(?: [A-Za-z_][A-Za-z0-9_]*+ | :: )++    |              # actual name\n\t\t\t\t(?: (?<=operator) (?: [-*&<>=+!]+ | \\(\\) | \\[\\] ) )  # if it is a C++ operator\n\t\t\t)\n\t\t\t \\s*(\\()'
-        'name': 'meta.initialization.nxc'
-      }
-      {
-        'include': '#block'
-      }
-      {
-        'include': '$base'
-      }
-    ]
-  'c_function_call':
-    'captures':
-      '1':
-        'name': 'punctuation.whitespace.function-call.leading.nxc'
-      '2':
-        'name': 'support.function.any-method.nxc'
-      '4':
-        'name': 'punctuation.definition.parameters.nxc'
-    'match': '(?x) (?: (?= \\s )  (?:(?<=else|new|return) | (?<!\\w)) (\\s+))?\n\t\t\t(\\b \n\t\t\t\t(?!(while|for|do|if|until|else|switch|catch|enumerate|return|sizeof|[cr]?iterate)\\s*\\()(?:(?!NS)[A-Za-z_][A-Za-z0-9_]*+\\b | :: )++                  # actual name\n\t\t\t)\n\t\t\t \\s*(\\()'
-    'name': 'meta.function-call.nxc'
-  'comments':
-    'patterns': [
-      {
-        'captures':
-          '1':
-            'name': 'meta.toc-list.banner.block.nxc'
-        'match': '^/\\* =(\\s*.*?)\\s*= \\*/$\\n?'
-        'name': 'comment.block.nxc'
-      }
-      {
-        'begin': '/\\*'
-        'beginCaptures':
-          '0':
-            'name': 'punctuation.definition.comment.begin.nxc'
-        'end': '\\*/'
-        'endCaptures':
-          '0':
-            'name': 'punctuation.definition.comment.end.nxc'
-        'name': 'comment.block.nxc'
-      }
-      {
-        'match': '\\*/.*\\n'
-        'name': 'invalid.illegal.stray-comment-end.nxc'
-      }
-      {
-        'captures':
-          '1':
-            'name': 'meta.toc-list.banner.line.nxc'
-        'match': '^// =(\\s*.*?)\\s*=\\s*$\\n?'
-        'name': 'comment.line.banner.cpp'
-      }
-      {
-        'begin': '(^[ \\t]+)?(?=//)'
-        'beginCaptures':
-          '1':
-            'name': 'punctuation.whitespace.comment.leading.cpp'
-        'end': '(?!\\G)'
-        'patterns': [
-          {
-            'begin': '//'
-            'beginCaptures':
-              '0':
-                'name': 'punctuation.definition.comment.cpp'
-            'end': '\\n'
-            'name': 'comment.line.double-slash.cpp'
-            'patterns': [
-              {
-                'include': '#line_continuation_character'
-              }
-            ]
-          }
-        ]
-      }
-    ]
-  'disabled':
-    'begin': '^\\s*#\\s*if(n?def)?\\b.*$'
-    'comment': 'eat nested preprocessor if(def)s'
-    'end': '^\\s*#\\s*endif\\b'
-    'patterns': [
-      {
-        'include': '#disabled'
-      }
-      {
-        'include': '#pragma-mark'
-      }
-    ]
-  'libc':
-    'captures':
-      '1':
-        'name': 'punctuation.whitespace.support.function.leading.nxc'
-      '2':
-        'name': 'support.function.C99.nxc'
-    'match': '(\\s*)\\b(hypot(f|l)?|s(scanf|ystem|nprintf|ca(nf|lb(n(f|l)?|ln(f|l)?))|i(n(h(f|l)?|f|l)?|gn(al|bit))|tr(s(tr|pn)|nc(py|at|mp)|c(spn|hr|oll|py|at|mp)|to(imax|d|u(l(l)?|max)|k|f|l(d|l)?)|error|pbrk|ftime|len|rchr|xfrm)|printf|et(jmp|vbuf|locale|buf)|qrt(f|l)?|w(scanf|printf)|rand)|n(e(arbyint(f|l)?|xt(toward(f|l)?|after(f|l)?))|an(f|l)?)|c(s(in(h(f|l)?|f|l)?|qrt(f|l)?)|cos(h(f)?|f|l)?|imag(f|l)?|t(ime|an(h(f|l)?|f|l)?)|o(s(h(f|l)?|f|l)?|nj(f|l)?|pysign(f|l)?)|p(ow(f|l)?|roj(f|l)?)|e(il(f|l)?|xp(f|l)?)|l(o(ck|g(f|l)?)|earerr)|a(sin(h(f|l)?|f|l)?|cos(h(f|l)?|f|l)?|tan(h(f|l)?|f|l)?|lloc|rg(f|l)?|bs(f|l)?)|real(f|l)?|brt(f|l)?)|t(ime|o(upper|lower)|an(h(f|l)?|f|l)?|runc(f|l)?|gamma(f|l)?|mp(nam|file))|i(s(space|n(ormal|an)|cntrl|inf|digit|u(nordered|pper)|p(unct|rint)|finite|w(space|c(ntrl|type)|digit|upper|p(unct|rint)|lower|al(num|pha)|graph|xdigit|blank)|l(ower|ess(equal|greater)?)|al(num|pha)|gr(eater(equal)?|aph)|xdigit|blank)|logb(f|l)?|max(div|abs))|di(v|fftime)|_Exit|unget(c|wc)|p(ow(f|l)?|ut(s|c(har)?|wc(har)?)|error|rintf)|e(rf(c(f|l)?|f|l)?|x(it|p(2(f|l)?|f|l|m1(f|l)?)?))|v(s(scanf|nprintf|canf|printf|w(scanf|printf))|printf|f(scanf|printf|w(scanf|printf))|w(scanf|printf)|a_(start|copy|end|arg))|qsort|f(s(canf|e(tpos|ek))|close|tell|open|dim(f|l)?|p(classify|ut(s|c|w(s|c))|rintf)|e(holdexcept|set(e(nv|xceptflag)|round)|clearexcept|testexcept|of|updateenv|r(aiseexcept|ror)|get(e(nv|xceptflag)|round))|flush|w(scanf|ide|printf|rite)|loor(f|l)?|abs(f|l)?|get(s|c|pos|w(s|c))|re(open|e|ad|xp(f|l)?)|m(in(f|l)?|od(f|l)?|a(f|l|x(f|l)?)?))|l(d(iv|exp(f|l)?)|o(ngjmp|cal(time|econv)|g(1(p(f|l)?|0(f|l)?)|2(f|l)?|f|l|b(f|l)?)?)|abs|l(div|abs|r(int(f|l)?|ound(f|l)?))|r(int(f|l)?|ound(f|l)?)|gamma(f|l)?)|w(scanf|c(s(s(tr|pn)|nc(py|at|mp)|c(spn|hr|oll|py|at|mp)|to(imax|d|u(l(l)?|max)|k|f|l(d|l)?|mbs)|pbrk|ftime|len|r(chr|tombs)|xfrm)|to(b|mb)|rtomb)|printf|mem(set|c(hr|py|mp)|move))|a(s(sert|ctime|in(h(f|l)?|f|l)?)|cos(h(f|l)?|f|l)?|t(o(i|f|l(l)?)|exit|an(h(f|l)?|2(f|l)?|f|l)?)|b(s|ort))|g(et(s|c(har)?|env|wc(har)?)|mtime)|r(int(f|l)?|ound(f|l)?|e(name|alloc|wind|m(ove|quo(f|l)?|ainder(f|l)?))|a(nd|ise))|b(search|towc)|m(odf(f|l)?|em(set|c(hr|py|mp)|move)|ktime|alloc|b(s(init|towcs|rtowcs)|towc|len|r(towc|len))))\\b'
-  'line_continuation_character':
-    'patterns': [
-      {
-        'match': '(\\\\)\\s*\\n'
-        'captures':
-          '1':
-            'name': 'constant.character.escape.line-continuation.nxc'
-      }
-    ]
-  'numbers':
-    'patterns': [
-      {
-        'match': '\\b((0(x|X)[0-9a-fA-F]*)|(([0-9]+\\.?[0-9]*)|(\\.[0-9]+))((e|E)(\\+|-)?[0-9]+)?)(L|l|UL|ul|u|U|F|f|ll|LL|ull|ULL)?\\b'
-        'name': 'constant.numeric.nxc'
-      }
-    ]
-  'parens':
-    'begin': '\\('
-    'beginCaptures':
-      '0':
-        'name': 'punctuation.section.parens.begin.nxc'
-    'end': '\\)'
-    'endCaptures':
-      '0':
-        'name': 'punctuation.section.parens.end.nxc'
-    'name': 'meta.parens.nxc'
-    'patterns': [
-      {
-        'include': '$base'
-      }
-    ]
-  'pragma-mark':
-    'captures':
-      '1':
-        'name': 'meta.preprocessor.nxc'
-      '2':
-        'name': 'keyword.control.directive.pragma.pragma-mark.nxc'
-      '3':
-        'name': 'punctuation.definition.directive.nxc'
-      '4':
-        'name': 'meta.toc-list.pragma-mark.nxc'
-    'match': '^\\s*(((#)\\s*pragma\\s+mark)\\s+(.*))'
-    'name': 'meta.section'
-  'preprocessor-rule-disabled':
-    'begin': '^\\s*(((#)if)\\s+(0)\\b).*'
-    'beginCaptures':
-      '1':
-        'name': 'meta.preprocessor.nxc'
-      '2':
-        'name': 'keyword.control.directive.conditional.nxc'
-      '3':
-        'name': 'punctuation.definition.directive.nxc'
-      '4':
-        'name': 'constant.numeric.preprocessor.nxc'
-    'end': '^\\s*(((#)\\s*endif)\\b)'
-    'endCaptures':
-      '1':
-        'name': 'meta.preprocessor.nxc'
-      '2':
-        'name': 'keyword.control.directive.conditional.nxc'
-      '3':
-        'name': 'punctuation.definition.directive.nxc'
-    'patterns': [
-      {
-        'begin': '^\\s*(((#)\\s*else)\\b)'
-        'beginCaptures':
-          '1':
-            'name': 'meta.preprocessor.nxc'
-          '2':
-            'name': 'keyword.control.directive.conditional.nxc'
-          '3':
-            'name': 'punctuation.definition.directive.nxc'
-        'end': '(?=^\\s*#\\s*endif\\b)'
-        'patterns': [
-          {
-            'include': '$base'
-          }
-        ]
-      }
-      {
-        'begin': '\\G'
-        'end': '(?=^\\s*#\\s*(else|endif)\\b)'
-        'contentName': 'comment.block.preprocessor.if-branch'
-        'patterns': [
-          {
-            'include': '#disabled'
-          }
-          {
-            'include': '#pragma-mark'
-          }
-        ]
-      }
-    ]
-  'preprocessor-rule-disabled-block':
-    'begin': '^\\s*(((#)if)\\s+(0)\\b).*'
-    'beginCaptures':
-      '1':
-        'name': 'meta.preprocessor.nxc'
-      '2':
-        'name': 'keyword.control.directive.conditional.nxc'
-      '3':
-        'name': 'punctuation.definition.directive.nxc'
-      '4':
-        'name': 'constant.numeric.preprocessor.nxc'
-    'end': '^\\s*(((#)\\s*endif)\\b)'
-    'endCaptures':
-      '1':
-        'name': 'meta.preprocessor.nxc'
-      '2':
-        'name': 'keyword.control.directive.conditional.nxc'
-      '3':
-        'name': 'punctuation.definition.directive.nxc'
-    'patterns': [
-      {
-        'begin': '^\\s*(((#)\\s*else\\b))'
-        'beginCaptures':
-          '1':
-            'name': 'meta.preprocessor.nxc'
-          '2':
-            'name': 'keyword.control.directive.conditional.nxc'
-          '3':
-            'name': 'punctuation.definition.directive.nxc'
-        'end': '(?=^\\s*#\\s*endif\\b)'
-        'patterns': [
-          {
-            'include': '#block_innards'
-          }
-        ]
-      }
-      {
-        'begin': '\\G'
-        'end': '(?=^\\s*#\\s*(else|endif)\\b)'
-        'contentName': 'comment.block.preprocessor.if-branch.in-block'
-        'patterns': [
-          {
-            'include': '#disabled'
-          }
-          {
-            'include': '#pragma-mark'
-          }
-        ]
-      }
-    ]
-  'preprocessor-rule-enabled':
-    'begin': '^\\s*(((#)if)\\s+(0*1)\\b)'
-    'beginCaptures':
-      '1':
-        'name': 'meta.preprocessor.nxc'
-      '2':
-        'name': 'keyword.control.directive.conditional.nxc'
-      '3':
-        'name': 'punctuation.definition.directive.nxc'
-      '4':
-        'name': 'constant.numeric.preprocessor.nxc'
-    'end': '^\\s*(((#)\\s*endif)\\b)'
-    'endCaptures':
-      '1':
-        'name': 'meta.preprocessor.nxc'
-      '2':
-        'name': 'keyword.control.directive.conditional.nxc'
-      '3':
-        'name': 'punctuation.definition.directive.nxc'
-    'patterns': [
-      {
-        'begin': '^\\s*(((#)\\s*else)\\b).*'
-        'beginCaptures':
-          '1':
-            'name': 'meta.preprocessor.nxc'
-          '2':
-            'name': 'keyword.control.directive.conditional.nxc'
-          '3':
-            'name': 'punctuation.definition.directive.nxc'
-        'contentName': 'comment.block.preprocessor.else-branch'
-        'end': '(?=^\\s*#\\s*endif\\b)'
-        'patterns': [
-          {
-            'include': '#disabled'
-          }
-          {
-            'include': '#pragma-mark'
-          }
-        ]
-      }
-      {
-        'begin': '\\G'
-        'end': '(?=^\\s*#\\s*(else|endif)\\b)'
-        'patterns': [
-          {
-            'include': '$base'
-          }
-        ]
-      }
-    ]
-  'preprocessor-rule-enabled-block':
-    'begin': '^\\s*(((#)if)\\s+(0*1)\\b)'
-    'beginCaptures':
-      '1':
-        'name': 'meta.preprocessor.nxc'
-      '2':
-        'name': 'keyword.control.directive.conditional.nxc'
-      '3':
-        'name': 'punctuation.definition.directive.nxc'
-      '4':
-        'name': 'constant.numeric.preprocessor.nxc'
-    'end': '^\\s*(((#)\\s*endif)\\b)'
-    'endCaptures':
-      '1':
-        'name': 'meta.preprocessor.nxc'
-      '2':
-        'name': 'keyword.control.directive.conditional.nxc'
-      '3':
-        'name': 'punctuation.definition.directive.nxc'
-    'patterns': [
-      {
-        'begin': '^\\s*(((#)\\s*else)\\b).*'
-        'beginCaptures':
-          '1':
-            'name': 'meta.preprocessor.nxc'
-          '2':
-            'name': 'keyword.control.directive.conditional.nxc'
-          '3':
-            'name': 'punctuation.definition.directive.nxc'
-        'contentName': 'comment.block.preprocessor.else-branch.in-block'
-        'end': '(?=^\\s*#\\s*endif\\b)'
-        'patterns': [
-          {
-            'include': '#disabled'
-          }
-          {
-            'include': '#pragma-mark'
-          }
-        ]
-      }
-      {
-        'begin': '\\G'
-        'end': '(?=^\\s*#\\s*(else|endif)\\b)'
-        'patterns': [
-          {
-            'include': '#block_innards'
-          }
-        ]
-      }
-    ]
-  'preprocessor-rule-other':
-    'begin': '^\\s*(((#)\\s*if(n?def)?)\\b.*?(?:(?=(?://|/\\*))|$))'
-    'beginCaptures':
-      '1':
-        'name': 'meta.preprocessor.nxc'
-      '2':
-        'name': 'keyword.control.directive.conditional.nxc'
-      '3':
-        'name': 'punctuation.definition.directive.nxc'
-    'end': '^\\s*(((#)\\s*(endif))\\b)'
-    'endCaptures':
-      '1':
-        'name': 'meta.preprocessor.nxc'
-      '2':
-        'name': 'keyword.control.directive.conditional.nxc'
-      '3':
-        'name': 'punctuation.definition.directive.nxc'
-    'patterns': [
-      {
-        'include': '$base'
-      }
-    ]
-  'preprocessor-rule-other-block':
-    'begin': '^\\s*(((#)\\s*if(n?def)?)\\b.*?(?:(?=(?://|/\\*))|$))'
-    'beginCaptures':
-      '1':
-        'name': 'meta.preprocessor.nxc'
-      '2':
-        'name': 'keyword.control.directive.conditional.nxc'
-      '3':
-        'name': 'punctuation.definition.directive.nxc'
-    'end': '^\\s*(((#)\\s*endif)\\b)'
-    'endCaptures':
-      '1':
-        'name': 'meta.preprocessor.nxc'
-      '2':
-        'name': 'keyword.control.directive.conditional.nxc'
-      '3':
-        'name': 'punctuation.definition.directive.nxc'
-    'patterns': [
-      {
-        'include': '#block_innards'
-      }
-    ]
-  'sizeof':
-    'match': '\\b(sizeof)\\b'
-    'name': 'keyword.operator.sizeof.nxc'
-  'strings':
-    'patterns': [
-      {
-        'begin': '"'
-        'beginCaptures':
-          '0':
-            'name': 'punctuation.definition.string.begin.nxc'
-        'end': '"'
-        'endCaptures':
-          '0':
-            'name': 'punctuation.definition.string.end.nxc'
-        'name': 'string.quoted.double.nxc'
-        'patterns': [
-          {
-            'include': '#string_escaped_char'
-          }
-          {
-            'include': '#string_placeholder'
-          }
-          {
-            'include': '#line_continuation_character'
-          }
-        ]
-      }
-      {
-        'begin': '\''
-        'beginCaptures':
-          '0':
-            'name': 'punctuation.definition.string.begin.nxc'
-        'end': '\''
-        'endCaptures':
-          '0':
-            'name': 'punctuation.definition.string.end.nxc'
-        'name': 'string.quoted.single.nxc'
-        'patterns': [
-          {
-            'include': '#string_escaped_char'
-          }
-          {
-            'include': '#line_continuation_character'
-          }
-        ]
-      }
-    ]
-  'string_escaped_char':
-    'patterns': [
-      {
-        'match': '\\\\(\\\\|[abefnprtv\'"?]|[0-3]\\d{,2}|[4-7]\\d?|x[a-fA-F0-9]{,2}|u[a-fA-F0-9]{,4}|U[a-fA-F0-9]{,8})'
-        'name': 'constant.character.escape.nxc'
-      }
-      {
-        'match': '\\\\.'
-        'name': 'invalid.illegal.unknown-escape.nxc'
-      }
-    ]
-  'string_placeholder':
-    'patterns': [
-      {
-        'match': '(?x)%\n    \t\t\t\t\t\t(\\d+\\$)?                             # field (argument #)\n    \t\t\t\t\t\t[#0\\- +\']*                           # flags\n    \t\t\t\t\t\t[,;:_]?                              # separator character (AltiVec)\n    \t\t\t\t\t\t((-?\\d+)|\\*(-?\\d+\\$)?)?              # minimum field width\n    \t\t\t\t\t\t(\\.((-?\\d+)|\\*(-?\\d+\\$)?)?)?         # precision\n    \t\t\t\t\t\t(hh|h|ll|l|j|t|z|q|L|vh|vl|v|hv|hl)? # length modifier\n    \t\t\t\t\t\t[diouxXDOUeEfFgGaACcSspn%]           # conversion type\n    \t\t\t\t\t'
-        'name': 'constant.other.placeholder.nxc'
-      }
-      {
-        'match': '%'
-        'name': 'invalid.illegal.placeholder.nxc'
-      }
-    ]
--- gbglehrerclient-0.1.orig/etc/skel/.atom/packages/language-nxc/keymaps/language-nxc.cson
+++ /dev/null
@@ -1,2 +0,0 @@
-'atom-workspace':
-  'ctrl-alt-u': 'nxc:upload'
--- gbglehrerclient-0.1.orig/etc/skel/.atom/packages/language-nxc/lib/main.coffee
+++ /dev/null
@@ -1,89 +0,0 @@
-Provider = require './provider'
-
-module.exports =
-
-  config:
-    useEnhancedFirmware:
-      type: 'boolean'
-      default: false
-    allowOtherAutocompleationProvidors:
-      type: 'boolean'
-      default: true
-    showReturnTypeInAutocompleation:
-      type: 'boolean'
-      default: false
-
-  getProvider: -> Provider
-
-  activate: ->
-    Provider.updateDocs()
-    atom.commands.add 'atom-workspace',
-      'nxc:compile': => @compile()
-      'nxc:upload': => @upload()
-      'nxc:run': => @run()
-
-  compile: ->
-    @nbc 'compile'
-  upload: ->
-    @nbc 'upload'
-  run: ->
-    @nbc 'run'
-
-  nbc: (type) ->
-
-    if process.platform == 'win32'
-      userHome = process.env.USERPROFILE
-    else
-      userHome = process.env.HOME
-
-    activeItem = atom.workspace.getActivePaneItem()
-
-    # save current file
-    potentialPromise = activeItem.buffer.save().then ->
-      args = []
-
-      # generate the command to run
-      switch process.platform
-        when 'linux'
-          command = "#{userHome}/.atom/packages/language-nxc/nbc-linux"
-        when 'darwin'
-          command = "#{userHome}/.atom/packages/language-nxc/nbc-osx"
-        when 'win32'
-          command = "#{userHome}\\.atom\\packages\\language-nxc\\nbc-windows.exe"
-
-      args.push '-T=NXT'
-      args.push '-S=usb'
-      switch type
-        when 'upload'
-          args.push '-d'
-        when 'run'
-          args.push '-r'
-
-      if atom.config.get 'language-nxc.useEnhancedFirmware'
-        args.push '-EF'
-
-      args.push activeItem.buffer.file.path
-      console.debug "language-nxc: executing command `#{command}` with args `#{args}"
-
-      filename = activeItem.buffer.file.path.split('.');
-      if filename[filename.length-1] != 'nxc'
-        atom.notifications.addWarning "not working on an nxc file!"
-        return
-
-      require('child_process').execFile command, args, (error, stdout, stderr) ->
-        # do we have an error?
-        if error?
-          if stdout == "" && stderr == ""
-            atom.notifications.addFatalError(error, {detail: "stdout:\n#{stdout}\nstderr:\n#{stderr}"})
-          if stderr != ""
-            atom.notifications.addError "You got a bug!",
-              icon: 'bug'
-              detail: stderr
-              dismissable: true
-          else
-            atom.notifications.addWarning "Robot not connected!",
-              detail: "If the robot is connected, please view the trobble " +
-                      "shooting tips at https://goo.gl/lWWy0s"
-              dismissable: true
-        else
-            atom.notifications.addSuccess "Succesfull!"
--- gbglehrerclient-0.1.orig/etc/skel/.atom/packages/language-nxc/lib/provider.coffee
+++ /dev/null
@@ -1,144 +0,0 @@
-docs = require('../docs')
-docsURL = 'http://bricxcc.sourceforge.net/nbc/nxcdoc/nxcapi/'
-
-module.exports =
-  # This will work on JavaScript and CoffeeScript files, but not in js comments.
-  selector: '.source.nxc'
-  disableForSelector: '.source.nxc .comment'
-  # `excludeLowerPriority` will suppress any providers with a lower priority
-
-  inclusionPriority: 1
-  excludeLowerPriority:
-    !atom.config.get 'language-nxc.allowOtherAutocompleationProvidors'
-
-  watchingDocuments: {}
-
-  localDocs: {}
-
-  lastShowReturnTypeInAutocompleation:
-    atom.config.get 'language-nxc.showReturnTypeInAutocompleation'
-
-  updateDocs: ->
-    console.log 'updating docs'
-    @docs = require('../docs')
-
-  updateLocalDocs: ->
-    editor = atom.workspace.getActivePaneItem()
-    path = editor.buffer.file.path
-    @localDocs[path] = []
-    for line in editor.buffer.getLines()
-      # is this a function?
-      func = /((?:(?:signed|unsigned)[ ]+)*(?:byte|string|bool|char|double|float|int|long|short|void))[ ]+([A-Za-z]+)[ ]*\(([^)]*)\)/.exec line
-      if func?
-        args = func[3].split(",")
-        for arg, i in args
-          arg = arg.trim()
-          args[i] = "${"+(i+1)+":"+arg+"}"
-        add =
-          leftLabel: func[1]
-          displayText: func[2]
-          type:'function'
-        add.snippet=add.displayText+"("+args.join(", ")+")"
-
-        @localDocs[path].push add
-
-      else if line.indexOf("#define") == 0
-        @localDocs[path].push
-          text: line.split(" ")[1]
-          type: 'constant'
-
-    varRegEx = /(?:byte|string|bool|char|double|float|int|long|short)[ ]+([\w]+)/g
-    editorText = atom.workspace.getActivePaneItem().buffer.getText()
-    while true
-      currentVar = varRegEx.exec(editorText)
-      break unless currentVar?
-
-
-      addThisOne = true
-      for func in @localDocs[path]
-        if func.displayText? && currentVar[1] == func.displayText
-          addThisOne = false
-
-      @localDocs[path].push
-        text: currentVar[1]
-        type: 'variable'
-
-
-    # console.log vars
-    # console.log @localDocs
-
-
-  # Required: Return a promise, an array of suggestions, or null.
-  getSuggestions: (request) ->
-    return unless request.prefix.length > 0
-
-    editor = atom.workspace.getActivePaneItem()
-    editorView = atom.views.getView editor
-    path = editor.buffer.file.path
-    if !@watchingDocuments[path]?
-      @watchingDocuments[path] = "used" # becuse addEventListener doesn't return
-      # an event
-      @updateLocalDocs()
-      editorView.addEventListener 'keydown', (event) =>
-        if event.keyIdentifier == "Enter"
-          @updateLocalDocs()
-
-    suggestions = []
-
-    # we aren't case sensetive
-    # request.prefix = request.prefix.toLowerCase()
-
-    # grab the item in the docs that match
-    for item in @docs
-      # text = item.displayText.toLowerCase()
-      if item.displayText.indexOf(request.prefix) > -1
-        add = item
-        if add.descriptionMoreURL.indexOf(docsURL) == -1
-          add.descriptionMoreURL = docsURL+add.descriptionMoreURL;
-        add.replacementPrefix = request.prefix
-        suggestions.push add
-
-    for item in @localDocs[editor.buffer.file.path]
-      if item.displayText?
-        currentText = item.displayText
-      else
-        currentText = item.text
-
-      if currentText.indexOf(request.prefix) > -1
-        add = item
-        add.replacementPrefix = request.prefix
-        suggestions.push add
-
-    # sort them so that OnFwd comes before OnFwdReg
-    suggestions.sort (a, b) ->
-      if a.displayText?
-        aText = a.displayText
-      else
-        aText = a.text
-
-      if b.displayText?
-        bText = b.displayText
-      else
-        bText = b.text
-
-      if aText.length < bText.length
-        return -1
-      else if aText.length > bText.length
-        return 1
-      else return 0
-
-    showReturnType =
-      atom.config.get 'language-nxc.showReturnTypeInAutocompleation'
-    if @lastShowReturnTypeInAutocompleation != showReturnType &&
-          atom.config.get 'language-nxc.showReturnTypeInAutocompleation'
-        @updateDocs()
-    if !showReturnType
-      for suggestion in suggestions
-        suggestion.leftLabel = null
-
-    @lastShowReturnTypeInAutocompleation =
-      atom.config.get 'language-nxc.showReturnTypeInAutocompleation'
-
-    # return the suggestions
-    return suggestions
-    # resolve [{text: 'just a sugestion'}]
--- gbglehrerclient-0.1.orig/etc/skel/.atom/packages/language-nxc/package.json
+++ /dev/null
@@ -1,66 +0,0 @@
-{
-  "_args": [
-    [
-      {
-        "raw": "/tmp/d-118317-9044-1ygzhlb.ug8dleg66r/package.tgz",
-        "scope": null,
-        "escapedName": null,
-        "name": null,
-        "rawSpec": "/tmp/d-118317-9044-1ygzhlb.ug8dleg66r/package.tgz",
-        "spec": "/tmp/d-118317-9044-1ygzhlb.ug8dleg66r/package.tgz",
-        "type": "local"
-      },
-      "/tmp/apm-install-dir-118317-9044-e501qr.hijf9zr529"
-    ]
-  ],
-  "_from": "../d-118317-9044-1ygzhlb.ug8dleg66r/package.tgz",
-  "_id": "language-nxc@3.6.1",
-  "_inCache": true,
-  "_location": "/language-nxc",
-  "_phantomChildren": {},
-  "_requested": {
-    "raw": "/tmp/d-118317-9044-1ygzhlb.ug8dleg66r/package.tgz",
-    "scope": null,
-    "escapedName": null,
-    "name": null,
-    "rawSpec": "/tmp/d-118317-9044-1ygzhlb.ug8dleg66r/package.tgz",
-    "spec": "/tmp/d-118317-9044-1ygzhlb.ug8dleg66r/package.tgz",
-    "type": "local"
-  },
-  "_requiredBy": [
-    "#USER"
-  ],
-  "_resolved": "file:../d-118317-9044-1ygzhlb.ug8dleg66r/package.tgz",
-  "_shasum": "f7b1924ddcdc97045dcee4932953ecf77b270f66",
-  "_shrinkwrap": null,
-  "_spec": "/tmp/d-118317-9044-1ygzhlb.ug8dleg66r/package.tgz",
-  "_where": "/tmp/apm-install-dir-118317-9044-e501qr.hijf9zr529",
-  "bugs": {
-    "url": "https://github.com/nloomans/language-nxc/issues"
-  },
-  "dependencies": {},
-  "description": "Atom language support for NXC",
-  "devDependencies": {},
-  "engines": {
-    "atom": ">=1.19.0 <2.0.0"
-  },
-  "homepage": "https://github.com/nloomans/language-nxc#readme",
-  "license": "MIT",
-  "main": "./lib/main",
-  "name": "language-nxc",
-  "optionalDependencies": {},
-  "providedServices": {
-    "autocomplete.provider": {
-      "versions": {
-        "2.0.0": "getProvider"
-      }
-    }
-  },
-  "readme": "# NXC language support in Atom\n\nlanguage-nxc makes it easier to develop in NXC, which requires little to no setup (depending on your OS / distribution). Its goal is to make developing for NXC easier for everyone.\n\n## Features\n### Comping and uploading\nbuilt-in (cross-platform) compiling and uploading, try `nxc:upload`. **This works on Linux as well!**\n\n![menu](http://i.imgur.com/92Gd8cA.png)\n![bug](http://i.imgur.com/6yuUSmT.png)\n\n### Auto completion\nauto completion for ~~built in~~ **all** functions\n- description\n- link to docs\n\n![Example Usage](http://i.imgur.com/I1v9dMs.gif)\n\n### Syntax highlighting\n\n![syntax highlighting](http://i.imgur.com/SrMTC46.png)\n",
-  "readmeFilename": "README.md",
-  "repository": {
-    "type": "git",
-    "url": "git+https://github.com/nloomans/language-nxc.git"
-  },
-  "version": "3.6.1"
-}
--- gbglehrerclient-0.1.orig/etc/skel/.atom/packages/language-nxc/settings/language-nxc.cson
+++ /dev/null
@@ -1,19 +0,0 @@
-'.source.nxc':
-  'editor':
-    'commentStart': '// '
-    'increaseIndentPattern': '(?x)
-       ^ .* \\{ [^}"\']* $
-      |^ .* \\( [^\\)"\']* $
-      |^ \\s* (public|private|protected): \\s* $
-      |^ \\s* @(public|private|protected) \\s* $
-      |^ \\s* \\{ \\} $
-      '
-    'decreaseIndentPattern': '(?x)
-       ^ \\s* (\\s* /[*] .* [*]/ \\s*)* \\}
-      |^ \\s* (\\s* /[*] .* [*]/ \\s*)* \\)
-      |^ \\s* (public|private|protected): \\s* $
-      |^ \\s* @(public|private|protected) \\s* $
-      '
-'.source.nxc':
-  'editor':
-    'foldEndPattern': '(?<!\\*)\\*\\*/|^\\s*\\}'
--- gbglehrerclient-0.1.orig/etc/skel/.atom/packages/language-nxc/snippets/language-nxc.cson
+++ /dev/null
@@ -1,43 +0,0 @@
-'.source.nxc':
-  '#define':
-    'prefix': 'def'
-    'body': '#define ${1:NAME} ${2:value}'
-  'task main()':
-    'prefix': 'task'
-    'body': 'task main() {\n\t$1\n}'
-  'For Loop':
-    'prefix': 'for'
-    'body': 'for (${1:int} ${2:i} = 0; ${2:i} < ${3:count}; ${2:i}++) {\n\t${4:/* code */}\n}'
-  'While Loop':
-    'prefix': 'while'
-    'body': 'while (${1:/* condition */}) {\n\t${2:/* code */}\n}'
-  'NumOut':
-    'prefix': 'NumOut'
-    'body': 'NumOut(0,LCD_LINE${1:1},${2:number});'
-  'TextOut':
-    'prefix': 'TextOut'
-    'body': 'TextOut(0,LCD_LINE${1:1},${2:"string"});'
-  'If Condition':
-    'prefix': 'if'
-    'body': 'if (${1:/* condition */}) {\n\t${2:/* code */}\n}'
-  'If Else':
-    'prefix': 'ife'
-    'body': 'if (${1:/* condition */}) {\n\t${2:/* code */}\n} else {\n\t${3:/* code */}\n}'
-  'If ElseIf':
-    'prefix': 'iff'
-    'body': 'if (${1:/* condition */}) {\n\t${2:/* code */}\n} else if (${3:/* condition */}) {\n\t${4:/* code */}\n}'
-  'If ElseIf Else':
-    'prefix': 'iffe'
-    'body': 'if (${1:/* condition */}) {\n\t${2:/* code */}\n} else if (${3:/* condition */}) {\n\t${4:/* code */}\n} else {\n\t${5:/* code */}\n}'
-  'Switch Statement':
-    'prefix': 'switch'
-    'body': 'switch (${1:/* expression */}) {\n\tcase ${2:/* value */}:\n\t\t$3\n\t\tbreak;\n}'
-  'case':
-    'prefix': 'case'
-    'body': 'case ${1:/* value */}:\n\t$2\n\tbreak;'
-  'void':
-    'prefix': 'void'
-    'body': 'void ${1:name}(${2:/* arguments */}) {\n\t${3:/* code */}\n}'
-  'any function':
-    'prefix': 'func'
-    'body': '${1:int} ${2:name}(${3:/* arguments */}) {\n\t${5:/* code */}\n\treturn ${4:0};\n}'
--- gbglehrerclient-0.1.orig/etc/skel/.atom/packages/language-nxc/spec/nxc-spec.coffee
+++ /dev/null
@@ -1,578 +0,0 @@
-TextEditor = null
-buildTextEditor = (params) ->
-  if atom.workspace.buildTextEditor?
-    atom.workspace.buildTextEditor(params)
-  else
-    TextEditor ?= require('atom').TextEditor
-    new TextEditor(params)
-
-describe "Language-NXC", ->
-  grammar = null
-
-  beforeEach ->
-    waitsForPromise ->
-      atom.packages.activatePackage('language-nxc')
-
-  describe "NXC", ->
-    beforeEach ->
-      grammar = atom.grammars.grammarForScopeName('source.nxc')
-
-    it "parses the grammar", ->
-      expect(grammar).toBeTruthy()
-      expect(grammar.scopeName).toBe 'source.nxc'
-
-    it "tokenizes functions", ->
-      lines = grammar.tokenizeLines '''
-        int something(int param) {
-          return 0;
-        }
-      '''
-      expect(lines[0][0]).toEqual value: 'int', scopes: ['source.nxc', 'storage.type.nxc']
-      expect(lines[0][2]).toEqual value: 'something', scopes: ['source.nxc', 'meta.function.nxc', 'entity.name.function.nxc']
-      expect(lines[0][3]).toEqual value: '(', scopes: ['source.nxc', 'meta.function.nxc', 'meta.parens.nxc', 'punctuation.section.parens.begin.nxc']
-      expect(lines[0][4]).toEqual value: 'int', scopes: ['source.nxc', 'meta.function.nxc', 'meta.parens.nxc', 'storage.type.nxc']
-      expect(lines[0][6]).toEqual value: ')', scopes: ['source.nxc', 'meta.function.nxc', 'meta.parens.nxc', 'punctuation.section.parens.end.nxc']
-      expect(lines[0][8]).toEqual value: '{', scopes: ['source.nxc', 'meta.function.nxc', 'meta.block.nxc', 'punctuation.section.block.begin.nxc']
-      expect(lines[1][1]).toEqual value: 'return', scopes: ['source.nxc', 'meta.function.nxc', 'meta.block.nxc', 'keyword.control.nxc']
-      expect(lines[1][3]).toEqual value: '0', scopes: ['source.nxc', 'meta.function.nxc', 'meta.block.nxc', 'constant.numeric.nxc']
-      expect(lines[2][0]).toEqual value: '}', scopes: ['source.nxc', 'meta.function.nxc', 'meta.block.nxc', 'punctuation.section.block.end.nxc']
-
-    it "tokenizes various _t types", ->
-      {tokens} = grammar.tokenizeLine 'size_t var;'
-      expect(tokens[0]).toEqual value: 'size_t', scopes: ['source.nxc', 'support.type.sys-types.nxc']
-
-      {tokens} = grammar.tokenizeLine 'pthread_t var;'
-      expect(tokens[0]).toEqual value: 'pthread_t', scopes: ['source.nxc', 'support.type.pthread.nxc']
-
-      {tokens} = grammar.tokenizeLine 'int32_t var;'
-      expect(tokens[0]).toEqual value: 'int32_t', scopes: ['source.nxc', 'support.type.stdint.nxc']
-
-      {tokens} = grammar.tokenizeLine 'myType_t var;'
-      expect(tokens[0]).toEqual value: 'myType_t', scopes: ['source.nxc', 'support.type.posix-reserved.nxc']
-
-    it "tokenizes 'line continuation' character", ->
-      {tokens} = grammar.tokenizeLine 'ma' + '\\' + '\n' + 'in(){};'
-      expect(tokens[0]).toEqual value: 'ma', scopes: ['source.nxc']
-      expect(tokens[1]).toEqual value: '\\', scopes: ['source.nxc', 'constant.character.escape.line-continuation.nxc']
-      expect(tokens[3]).toEqual value: 'in', scopes: ['source.nxc', 'meta.function.nxc', 'entity.name.function.nxc']
-
-    describe "strings", ->
-      it "tokenizes them", ->
-        delimsByScope =
-          'string.quoted.double.nxc': '"'
-          'string.quoted.single.nxc': '\''
-
-        for scope, delim of delimsByScope
-          {tokens} = grammar.tokenizeLine delim + 'a' + delim
-          expect(tokens[0]).toEqual value: delim, scopes: ['source.nxc', scope, 'punctuation.definition.string.begin.nxc']
-          expect(tokens[1]).toEqual value: 'a', scopes: ['source.nxc', scope]
-          expect(tokens[2]).toEqual value: delim, scopes: ['source.nxc', scope, 'punctuation.definition.string.end.nxc']
-
-          {tokens} = grammar.tokenizeLine delim + 'a' + '\\' + '\n' + 'b' + delim
-          expect(tokens[0]).toEqual value: delim, scopes: ['source.nxc', scope, 'punctuation.definition.string.begin.nxc']
-          expect(tokens[1]).toEqual value: 'a', scopes: ['source.nxc', scope]
-          expect(tokens[2]).toEqual value: '\\', scopes: ['source.nxc', scope, 'constant.character.escape.line-continuation.nxc']
-          expect(tokens[4]).toEqual value: 'b', scopes: ['source.nxc', scope]
-          expect(tokens[5]).toEqual value: delim, scopes: ['source.nxc', scope, 'punctuation.definition.string.end.nxc']
-
-    describe "comments", ->
-      it "tokenizes them", ->
-        {tokens} = grammar.tokenizeLine '/**/'
-        expect(tokens[0]).toEqual value: '/*', scopes: ['source.nxc', 'comment.block.nxc', 'punctuation.definition.comment.begin.nxc']
-        expect(tokens[1]).toEqual value: '*/', scopes: ['source.nxc', 'comment.block.nxc', 'punctuation.definition.comment.end.nxc']
-
-        {tokens} = grammar.tokenizeLine '/* foo */'
-        expect(tokens[0]).toEqual value: '/*', scopes: ['source.nxc', 'comment.block.nxc', 'punctuation.definition.comment.begin.nxc']
-        expect(tokens[1]).toEqual value: ' foo ', scopes: ['source.nxc', 'comment.block.nxc']
-        expect(tokens[2]).toEqual value: '*/', scopes: ['source.nxc', 'comment.block.nxc', 'punctuation.definition.comment.end.nxc']
-
-        {tokens} = grammar.tokenizeLine '*/*'
-        expect(tokens[0]).toEqual value: '*/*', scopes: ['source.nxc', 'invalid.illegal.stray-comment-end.nxc']
-
-    describe "preprocessor directives", ->
-      it "tokenizes '#line'", ->
-        {tokens} = grammar.tokenizeLine '#line 151 "copy.c"'
-        expect(tokens[0]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.line.nxc', 'punctuation.definition.directive.nxc']
-        expect(tokens[1]).toEqual value: 'line', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.line.nxc']
-        expect(tokens[3]).toEqual value: '151', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'constant.numeric.nxc']
-        expect(tokens[5]).toEqual value: '"', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'string.quoted.double.nxc', 'punctuation.definition.string.begin.nxc']
-        expect(tokens[6]).toEqual value: 'copy.nxc', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'string.quoted.double.nxc']
-        expect(tokens[7]).toEqual value: '"', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'string.quoted.double.nxc', 'punctuation.definition.string.end.nxc']
-
-      it "tokenizes '#undef'", ->
-        {tokens} = grammar.tokenizeLine '#undef FOO'
-        expect(tokens[0]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.undef.nxc', 'punctuation.definition.directive.nxc']
-        expect(tokens[1]).toEqual value: 'undef', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.undef.nxc']
-        expect(tokens[2]).toEqual value: ' FOO', scopes: ['source.nxc', 'meta.preprocessor.nxc']
-
-      it "tokenizes '#pragma'", ->
-        {tokens} = grammar.tokenizeLine '#pragma once'
-        expect(tokens[0]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.pragma.nxc', 'punctuation.definition.directive.nxc']
-        expect(tokens[1]).toEqual value: 'pragma', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.pragma.nxc']
-        expect(tokens[2]).toEqual value: ' once', scopes: ['source.nxc', 'meta.preprocessor.nxc']
-
-        {tokens} = grammar.tokenizeLine '#pragma clang diagnostic push'
-        expect(tokens[0]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.pragma.nxc', 'punctuation.definition.directive.nxc']
-        expect(tokens[1]).toEqual value: 'pragma', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.pragma.nxc']
-        expect(tokens[2]).toEqual value: ' clang diagnostic push', scopes: ['source.nxc', 'meta.preprocessor.nxc']
-
-        {tokens} = grammar.tokenizeLine '#pragma mark  Initialization'
-        expect(tokens[0]).toEqual value: '#', scopes: ['source.nxc', 'meta.section', 'meta.preprocessor.nxc', 'keyword.control.directive.pragma.pragma-mark.nxc',  'punctuation.definition.directive.nxc']
-        expect(tokens[1]).toEqual value: 'pragma mark', scopes: ['source.nxc', 'meta.section',  'meta.preprocessor.nxc', 'keyword.control.directive.pragma.pragma-mark.nxc']
-        expect(tokens[3]).toEqual value: ' Initialization', scopes: ['source.nxc', 'meta.section',  'meta.preprocessor.nxc', 'meta.toc-list.pragma-mark.nxc']
-
-      describe "define", ->
-        it "tokenizes '#define [identifier name]'", ->
-          {tokens} = grammar.tokenizeLine '#define _FILE_NAME_H_'
-          expect(tokens[0]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'keyword.control.directive.define.nxc', 'punctuation.definition.directive.nxc']
-          expect(tokens[1]).toEqual value: 'define', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'keyword.control.directive.define.nxc']
-          expect(tokens[3]).toEqual value: '_FILE_NAME_H_', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'entity.name.function.preprocessor.nxc']
-
-        it "tokenizes '#define [identifier name] [value]'", ->
-          {tokens} = grammar.tokenizeLine '#define WIDTH 80'
-          expect(tokens[0]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'keyword.control.directive.define.nxc', 'punctuation.definition.directive.nxc']
-          expect(tokens[1]).toEqual value: 'define', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'keyword.control.directive.define.nxc']
-          expect(tokens[3]).toEqual value: 'WIDTH', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'entity.name.function.preprocessor.nxc']
-          expect(tokens[5]).toEqual value: '80', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'constant.numeric.nxc']
-
-          {tokens} = grammar.tokenizeLine '#define ABC XYZ(1)'
-          expect(tokens[0]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'keyword.control.directive.define.nxc', 'punctuation.definition.directive.nxc']
-          expect(tokens[1]).toEqual value: 'define', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'keyword.control.directive.define.nxc']
-          expect(tokens[3]).toEqual value: 'ABC', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'entity.name.function.preprocessor.nxc']
-          expect(tokens[4]).toEqual value: ' ', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'meta.function.nxc', 'punctuation.whitespace.function.leading.nxc']
-          expect(tokens[5]).toEqual value: 'XYZ', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'meta.function.nxc', 'entity.name.function.nxc']
-          expect(tokens[6]).toEqual value: '(', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'meta.function.nxc', 'meta.parens.nxc', 'punctuation.section.parens.begin.nxc']
-          expect(tokens[7]).toEqual value: '1', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'meta.function.nxc', 'meta.parens.nxc', 'constant.numeric.nxc']
-          expect(tokens[8]).toEqual value: ')', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'meta.function.nxc', 'meta.parens.nxc', 'punctuation.section.parens.end.nxc']
-
-          {tokens} = grammar.tokenizeLine '#define PI_PLUS_ONE (3.14 + 1)'
-          expect(tokens[0]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'keyword.control.directive.define.nxc', 'punctuation.definition.directive.nxc']
-          expect(tokens[1]).toEqual value: 'define', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'keyword.control.directive.define.nxc']
-          expect(tokens[3]).toEqual value: 'PI_PLUS_ONE', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'entity.name.function.preprocessor.nxc']
-          expect(tokens[4]).toEqual value: ' (', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc']
-          expect(tokens[5]).toEqual value: '3.14', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'constant.numeric.nxc']
-          expect(tokens[6]).toEqual value: ' + ', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc']
-          expect(tokens[7]).toEqual value: '1', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'constant.numeric.nxc']
-          expect(tokens[8]).toEqual value: ')', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc']
-
-        describe "macros", ->
-          it "tokenizes them", ->
-            {tokens} = grammar.tokenizeLine '#define INCREMENT(x) x++'
-            expect(tokens[0]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'keyword.control.directive.define.nxc', 'punctuation.definition.directive.nxc']
-            expect(tokens[1]).toEqual value: 'define', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'keyword.control.directive.define.nxc']
-            expect(tokens[3]).toEqual value: 'INCREMENT', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'entity.name.function.preprocessor.nxc']
-            expect(tokens[4]).toEqual value: '(', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'punctuation.definition.parameters.begin.nxc']
-            expect(tokens[5]).toEqual value: 'x', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'variable.parameter.preprocessor.nxc']
-            expect(tokens[6]).toEqual value: ')', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'punctuation.definition.parameters.end.nxc']
-            expect(tokens[7]).toEqual value: ' x++', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc']
-
-            {tokens} = grammar.tokenizeLine '#define MULT(x, y) (x) * (y)'
-            expect(tokens[0]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'keyword.control.directive.define.nxc', 'punctuation.definition.directive.nxc']
-            expect(tokens[1]).toEqual value: 'define', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'keyword.control.directive.define.nxc']
-            expect(tokens[3]).toEqual value: 'MULT', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'entity.name.function.preprocessor.nxc']
-            expect(tokens[4]).toEqual value: '(', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'punctuation.definition.parameters.begin.nxc']
-            expect(tokens[5]).toEqual value: 'x', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'variable.parameter.preprocessor.nxc']
-            expect(tokens[6]).toEqual value: ',', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'variable.parameter.preprocessor.nxc', 'punctuation.separator.parameters.nxc']
-            expect(tokens[7]).toEqual value: ' y', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'variable.parameter.preprocessor.nxc']
-            expect(tokens[8]).toEqual value: ')', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'punctuation.definition.parameters.end.nxc']
-            expect(tokens[9]).toEqual value: ' (x) * (y)', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc']
-
-            {tokens} = grammar.tokenizeLine '#define SWAP(a, b)  do { a ^= b; b ^= a; a ^= b; } while ( 0 )'
-            expect(tokens[0]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'keyword.control.directive.define.nxc', 'punctuation.definition.directive.nxc']
-            expect(tokens[1]).toEqual value: 'define', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'keyword.control.directive.define.nxc']
-            expect(tokens[3]).toEqual value: 'SWAP', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'entity.name.function.preprocessor.nxc']
-            expect(tokens[4]).toEqual value: '(', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'punctuation.definition.parameters.begin.nxc']
-            expect(tokens[5]).toEqual value: 'a', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'variable.parameter.preprocessor.nxc']
-            expect(tokens[6]).toEqual value: ',', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'variable.parameter.preprocessor.nxc', 'punctuation.separator.parameters.nxc']
-            expect(tokens[7]).toEqual value: ' b', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'variable.parameter.preprocessor.nxc']
-            expect(tokens[8]).toEqual value: ')', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'punctuation.definition.parameters.end.nxc']
-            expect(tokens[10]).toEqual value: 'do', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'keyword.control.nxc']
-            expect(tokens[12]).toEqual value: '{', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'meta.block.nxc', 'punctuation.section.block.begin.nxc']
-            expect(tokens[13]).toEqual value: ' a ^= b; b ^= a; a ^= b; ', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'meta.block.nxc']
-            expect(tokens[14]).toEqual value: '}', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'meta.block.nxc', 'punctuation.section.block.end.nxc']
-            expect(tokens[16]).toEqual value: 'while', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'keyword.control.nxc']
-            expect(tokens[17]).toEqual value: ' ( ', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc']
-            expect(tokens[18]).toEqual value: '0', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'constant.numeric.nxc']
-            expect(tokens[19]).toEqual value: ' )', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc']
-
-          it "tokenizes multiline macros", ->
-            lines = grammar.tokenizeLines '''
-              #define max(a,b) (a>b)? \\
-                                a:b
-            '''
-            expect(lines[0][10]).toEqual value: '\\', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'constant.character.escape.line-continuation.nxc']
-
-            lines = grammar.tokenizeLines '''
-              #define SWAP(a, b)  { \\
-                a ^= b; \\
-                b ^= a; \\
-                a ^= b; \\
-              }
-            '''
-            expect(lines[0][0]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'keyword.control.directive.define.nxc', 'punctuation.definition.directive.nxc']
-            expect(lines[0][1]).toEqual value: 'define', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'keyword.control.directive.define.nxc']
-            expect(lines[0][3]).toEqual value: 'SWAP', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'entity.name.function.preprocessor.nxc']
-            expect(lines[0][4]).toEqual value: '(', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'punctuation.definition.parameters.begin.nxc']
-            expect(lines[0][5]).toEqual value: 'a', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'variable.parameter.preprocessor.nxc']
-            expect(lines[0][6]).toEqual value: ',', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'variable.parameter.preprocessor.nxc', 'punctuation.separator.parameters.nxc']
-            expect(lines[0][7]).toEqual value: ' b', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'variable.parameter.preprocessor.nxc']
-            expect(lines[0][8]).toEqual value: ')', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'punctuation.definition.parameters.end.nxc']
-            expect(lines[0][10]).toEqual value: '{', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'meta.block.nxc', 'punctuation.section.block.begin.nxc']
-            expect(lines[0][12]).toEqual value: '\\', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'meta.block.nxc', 'constant.character.escape.line-continuation.nxc']
-            expect(lines[1][0]).toEqual value: '  a ^= b; ', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'meta.block.nxc']
-            expect(lines[1][1]).toEqual value: '\\', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'meta.block.nxc', 'constant.character.escape.line-continuation.nxc']
-            expect(lines[2][0]).toEqual value: '  b ^= a; ', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'meta.block.nxc']
-            expect(lines[2][1]).toEqual value: '\\', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'meta.block.nxc', 'constant.character.escape.line-continuation.nxc']
-            expect(lines[3][0]).toEqual value: '  a ^= b; ', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'meta.block.nxc']
-            expect(lines[3][1]).toEqual value: '\\', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'meta.block.nxc', 'constant.character.escape.line-continuation.nxc']
-            expect(lines[4][0]).toEqual value: '}', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'meta.block.nxc', 'punctuation.section.block.end.nxc']
-
-      describe "includes", ->
-        it "tokenizes '#include'", ->
-          {tokens} = grammar.tokenizeLine '#include <stdio.h>'
-          expect(tokens[0]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.include.nxc', 'keyword.control.directive.include.nxc', 'punctuation.definition.directive.nxc']
-          expect(tokens[1]).toEqual value: 'include', scopes: ['source.nxc', 'meta.preprocessor.include.nxc', 'keyword.control.directive.include.nxc']
-          expect(tokens[3]).toEqual value: '<', scopes: ['source.nxc', 'meta.preprocessor.include.nxc', 'string.quoted.other.lt-gt.include.nxc', 'punctuation.definition.string.begin.nxc']
-          expect(tokens[4]).toEqual value: 'stdio.h', scopes: ['source.nxc', 'meta.preprocessor.include.nxc', 'string.quoted.other.lt-gt.include.nxc']
-          expect(tokens[5]).toEqual value: '>', scopes: ['source.nxc', 'meta.preprocessor.include.nxc', 'string.quoted.other.lt-gt.include.nxc', 'punctuation.definition.string.end.nxc']
-
-          {tokens} = grammar.tokenizeLine '#include<stdio.h>'
-          expect(tokens[0]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.include.nxc', 'keyword.control.directive.include.nxc', 'punctuation.definition.directive.nxc']
-          expect(tokens[1]).toEqual value: 'include', scopes: ['source.nxc', 'meta.preprocessor.include.nxc', 'keyword.control.directive.include.nxc']
-          expect(tokens[2]).toEqual value: '<', scopes: ['source.nxc', 'meta.preprocessor.include.nxc', 'string.quoted.other.lt-gt.include.nxc', 'punctuation.definition.string.begin.nxc']
-          expect(tokens[3]).toEqual value: 'stdio.h', scopes: ['source.nxc', 'meta.preprocessor.include.nxc', 'string.quoted.other.lt-gt.include.nxc']
-          expect(tokens[4]).toEqual value: '>', scopes: ['source.nxc', 'meta.preprocessor.include.nxc', 'string.quoted.other.lt-gt.include.nxc', 'punctuation.definition.string.end.nxc']
-
-          {tokens} = grammar.tokenizeLine '#include_<stdio.h>'
-          expect(tokens[0]).toEqual value: '#include_<stdio.h>', scopes: ['source.nxc']
-
-          {tokens} = grammar.tokenizeLine '#include "file"'
-          expect(tokens[0]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.include.nxc', 'keyword.control.directive.include.nxc', 'punctuation.definition.directive.nxc']
-          expect(tokens[1]).toEqual value: 'include', scopes: ['source.nxc', 'meta.preprocessor.include.nxc', 'keyword.control.directive.include.nxc']
-          expect(tokens[3]).toEqual value: '"', scopes: ['source.nxc', 'meta.preprocessor.include.nxc', 'string.quoted.double.include.nxc', 'punctuation.definition.string.begin.nxc']
-          expect(tokens[4]).toEqual value: 'file', scopes: ['source.nxc', 'meta.preprocessor.include.nxc', 'string.quoted.double.include.nxc']
-          expect(tokens[5]).toEqual value: '"', scopes: ['source.nxc', 'meta.preprocessor.include.nxc', 'string.quoted.double.include.nxc', 'punctuation.definition.string.end.nxc']
-
-        it "tokenizes '#import'", ->
-          {tokens} = grammar.tokenizeLine '#import "file"'
-          expect(tokens[0]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.include.nxc', 'keyword.control.directive.import.nxc', 'punctuation.definition.directive.nxc']
-          expect(tokens[1]).toEqual value: 'import', scopes: ['source.nxc', 'meta.preprocessor.include.nxc', 'keyword.control.directive.import.nxc']
-          expect(tokens[3]).toEqual value: '"', scopes: ['source.nxc', 'meta.preprocessor.include.nxc', 'string.quoted.double.include.nxc', 'punctuation.definition.string.begin.nxc']
-          expect(tokens[4]).toEqual value: 'file', scopes: ['source.nxc', 'meta.preprocessor.include.nxc', 'string.quoted.double.include.nxc']
-          expect(tokens[5]).toEqual value: '"', scopes: ['source.nxc', 'meta.preprocessor.include.nxc', 'string.quoted.double.include.nxc', 'punctuation.definition.string.end.nxc']
-
-      describe "diagnostics", ->
-        it "tokenizes '#error'", ->
-          {tokens} = grammar.tokenizeLine '#error NXC compiler required.'
-          expect(tokens[0]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.diagnostic.nxc', 'keyword.control.directive.diagnostic.error.nxc', 'punctuation.definition.directive.nxc']
-          expect(tokens[1]).toEqual value: 'error', scopes: ['source.nxc', 'meta.preprocessor.diagnostic.nxc', 'keyword.control.directive.diagnostic.error.nxc']
-          expect(tokens[2]).toEqual value: ' NXC compiler required.', scopes: ['source.nxc', 'meta.preprocessor.diagnostic.nxc']
-
-        it "tokenizes '#warning'", ->
-          {tokens} = grammar.tokenizeLine '#warning This is a warning.'
-          expect(tokens[0]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.diagnostic.nxc', 'keyword.control.directive.diagnostic.warning.nxc', 'punctuation.definition.directive.nxc']
-          expect(tokens[1]).toEqual value: 'warning', scopes: ['source.nxc', 'meta.preprocessor.diagnostic.nxc', 'keyword.control.directive.diagnostic.warning.nxc']
-          expect(tokens[2]).toEqual value: ' This is a warning.', scopes: ['source.nxc', 'meta.preprocessor.diagnostic.nxc']
-
-      describe "conditionals", ->
-        it "tokenizes if-elif-else preprocessor blocks", ->
-          lines = grammar.tokenizeLines '''
-            #if defined(CREDIT)
-                credit();
-            #elif defined(DEBIT)
-                debit();
-            #else
-                printerror();
-            #endif
-          '''
-          expect(lines[0][0]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc', 'punctuation.definition.directive.nxc']
-          expect(lines[0][1]).toEqual value: 'if', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc']
-          expect(lines[0][2]).toEqual value: ' defined(CREDIT)', scopes: ['source.nxc', 'meta.preprocessor.nxc']
-          expect(lines[1][1]).toEqual value: 'credit', scopes: ['source.nxc', 'meta.function.nxc', 'entity.name.function.nxc']
-          expect(lines[1][2]).toEqual value: '(', scopes: ['source.nxc', 'meta.function.nxc', 'meta.parens.nxc', 'punctuation.section.parens.begin.nxc']
-          expect(lines[1][3]).toEqual value: ')', scopes: ['source.nxc', 'meta.function.nxc', 'meta.parens.nxc', 'punctuation.section.parens.end.nxc']
-          expect(lines[2][0]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc', 'punctuation.definition.directive.nxc']
-          expect(lines[2][1]).toEqual value: 'elif', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc']
-          expect(lines[2][2]).toEqual value: ' defined(DEBIT)', scopes: ['source.nxc', 'meta.preprocessor.nxc']
-          expect(lines[3][1]).toEqual value: 'debit', scopes: ['source.nxc', 'meta.function.nxc', 'entity.name.function.nxc']
-          expect(lines[3][2]).toEqual value: '(', scopes: ['source.nxc', 'meta.function.nxc', 'meta.parens.nxc', 'punctuation.section.parens.begin.nxc']
-          expect(lines[3][3]).toEqual value: ')', scopes: ['source.nxc', 'meta.function.nxc', 'meta.parens.nxc', 'punctuation.section.parens.end.nxc']
-          expect(lines[4][0]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc', 'punctuation.definition.directive.nxc']
-          expect(lines[4][1]).toEqual value: 'else', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc']
-          expect(lines[5][1]).toEqual value: 'printerror', scopes: ['source.nxc', 'meta.function.nxc', 'entity.name.function.nxc']
-          expect(lines[5][2]).toEqual value: '(', scopes: ['source.nxc', 'meta.function.nxc', 'meta.parens.nxc', 'punctuation.section.parens.begin.nxc']
-          expect(lines[5][3]).toEqual value: ')', scopes: ['source.nxc', 'meta.function.nxc', 'meta.parens.nxc', 'punctuation.section.parens.end.nxc']
-          expect(lines[6][0]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc', 'punctuation.definition.directive.nxc']
-          expect(lines[6][1]).toEqual value: 'endif', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc']
-
-        it "tokenizes if-true-else blocks", ->
-          lines = grammar.tokenizeLines '''
-            #if 1
-            int something() {
-              #if 1
-                return 1;
-              #else
-                return 0;
-              #endif
-            }
-            #else
-            int something() {
-              return 0;
-            }
-            #endif
-          '''
-          expect(lines[0][0]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc', 'punctuation.definition.directive.nxc']
-          expect(lines[0][1]).toEqual value: 'if', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc']
-          expect(lines[0][3]).toEqual value: '1', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'constant.numeric.preprocessor.nxc']
-          expect(lines[1][0]).toEqual value: 'int', scopes: ['source.nxc', 'storage.type.nxc']
-          expect(lines[1][2]).toEqual value: 'something', scopes: ['source.nxc', 'meta.function.nxc', 'entity.name.function.nxc']
-          expect(lines[2][1]).toEqual value: '#', scopes: ['source.nxc', 'meta.function.nxc', 'meta.block.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc', 'punctuation.definition.directive.nxc']
-          expect(lines[2][2]).toEqual value: 'if', scopes: ['source.nxc', 'meta.function.nxc', 'meta.block.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc']
-          expect(lines[2][4]).toEqual value: '1', scopes: ['source.nxc', 'meta.function.nxc', 'meta.block.nxc', 'meta.preprocessor.nxc', 'constant.numeric.preprocessor.nxc']
-          expect(lines[3][1]).toEqual value: 'return', scopes: ['source.nxc', 'meta.function.nxc', 'meta.block.nxc', 'keyword.control.nxc']
-          expect(lines[3][3]).toEqual value: '1', scopes: ['source.nxc', 'meta.function.nxc', 'meta.block.nxc', 'constant.numeric.nxc']
-          expect(lines[4][1]).toEqual value: '#', scopes: ['source.nxc', 'meta.function.nxc', 'meta.block.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc', 'punctuation.definition.directive.nxc']
-          expect(lines[4][2]).toEqual value: 'else', scopes: ['source.nxc', 'meta.function.nxc', 'meta.block.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc']
-          expect(lines[5][0]).toEqual value: '    return 0;', scopes: ['source.nxc', 'meta.function.nxc', 'meta.block.nxc', 'comment.block.preprocessor.else-branch.in-block']
-          expect(lines[6][1]).toEqual value: '#', scopes: ['source.nxc', 'meta.function.nxc', 'meta.block.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc', 'punctuation.definition.directive.nxc']
-          expect(lines[6][2]).toEqual value: 'endif', scopes: ['source.nxc', 'meta.function.nxc', 'meta.block.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc']
-          expect(lines[8][0]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc', 'punctuation.definition.directive.nxc']
-          expect(lines[8][1]).toEqual value: 'else', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc']
-          expect(lines[9][0]).toEqual value: 'int something() {', scopes: ['source.nxc', 'comment.block.preprocessor.else-branch']
-          expect(lines[12][0]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc', 'punctuation.definition.directive.nxc']
-          expect(lines[12][1]).toEqual value: 'endif', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc']
-
-        it "tokenizes if-false-else blocks", ->
-          lines = grammar.tokenizeLines '''
-            int something() {
-              #if 0
-                return 1;
-              #else
-                return 0;
-              #endif
-            }
-          '''
-          expect(lines[0][0]).toEqual value: 'int', scopes: ['source.nxc', 'storage.type.nxc']
-          expect(lines[0][2]).toEqual value: 'something', scopes: ['source.nxc', 'meta.function.nxc', 'entity.name.function.nxc']
-          expect(lines[1][1]).toEqual value: '#', scopes: ['source.nxc', 'meta.function.nxc', 'meta.block.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc', 'punctuation.definition.directive.nxc']
-          expect(lines[1][2]).toEqual value: 'if', scopes: ['source.nxc', 'meta.function.nxc', 'meta.block.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc']
-          expect(lines[1][4]).toEqual value: '0', scopes: ['source.nxc', 'meta.function.nxc', 'meta.block.nxc', 'meta.preprocessor.nxc', 'constant.numeric.preprocessor.nxc']
-          expect(lines[2][0]).toEqual value: '    return 1;', scopes: ['source.nxc', 'meta.function.nxc', 'meta.block.nxc', 'comment.block.preprocessor.if-branch.in-block']
-          expect(lines[3][1]).toEqual value: '#', scopes: ['source.nxc', 'meta.function.nxc', 'meta.block.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc', 'punctuation.definition.directive.nxc']
-          expect(lines[3][2]).toEqual value: 'else', scopes: ['source.nxc', 'meta.function.nxc', 'meta.block.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc']
-          expect(lines[4][1]).toEqual value: 'return', scopes: ['source.nxc', 'meta.function.nxc', 'meta.block.nxc', 'keyword.control.nxc']
-          expect(lines[4][3]).toEqual value: '0', scopes: ['source.nxc', 'meta.function.nxc', 'meta.block.nxc', 'constant.numeric.nxc']
-          expect(lines[5][1]).toEqual value: '#', scopes: ['source.nxc', 'meta.function.nxc', 'meta.block.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc', 'punctuation.definition.directive.nxc']
-          expect(lines[5][2]).toEqual value: 'endif', scopes: ['source.nxc', 'meta.function.nxc', 'meta.block.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc']
-
-          lines = grammar.tokenizeLines '''
-            #if 0
-              something();
-            #endif
-          '''
-          expect(lines[0][0]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc', 'punctuation.definition.directive.nxc']
-          expect(lines[0][1]).toEqual value: 'if', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc']
-          expect(lines[0][3]).toEqual value: '0', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'constant.numeric.preprocessor.nxc']
-          expect(lines[1][0]).toEqual value: '  something();', scopes: ['source.nxc', 'comment.block.preprocessor.if-branch']
-          expect(lines[2][0]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc', 'punctuation.definition.directive.nxc']
-          expect(lines[2][1]).toEqual value: 'endif', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc']
-
-        it "tokenizes ifdef-elif blocks", ->
-          lines = grammar.tokenizeLines '''
-            #ifdef __unix__ /* is defined by compilers targeting Unix systems */
-              # include <unistd.h>
-            #elif defined _WIN32 /* is defined by compilers targeting Windows systems */
-              # include <windows.h>
-            #endif
-          '''
-          expect(lines[0][0]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc', 'punctuation.definition.directive.nxc']
-          expect(lines[0][1]).toEqual value: 'ifdef', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc']
-          expect(lines[0][2]).toEqual value: ' __unix__ ', scopes: ['source.nxc', 'meta.preprocessor.nxc']
-          expect(lines[0][3]).toEqual value: '/*', scopes: ['source.nxc', 'comment.block.nxc', 'punctuation.definition.comment.begin.nxc']
-          expect(lines[0][4]).toEqual value: ' is defined by compilers targeting Unix systems ', scopes: ['source.nxc', 'comment.block.nxc']
-          expect(lines[0][5]).toEqual value: '*/', scopes: ['source.nxc', 'comment.block.nxc', 'punctuation.definition.comment.end.nxc']
-          expect(lines[1][1]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.include.nxc', 'keyword.control.directive.include.nxc', 'punctuation.definition.directive.nxc']
-          expect(lines[1][2]).toEqual value: ' include', scopes: ['source.nxc', 'meta.preprocessor.include.nxc', 'keyword.control.directive.include.nxc']
-          expect(lines[1][4]).toEqual value: '<', scopes: ['source.nxc', 'meta.preprocessor.include.nxc', 'string.quoted.other.lt-gt.include.nxc', 'punctuation.definition.string.begin.nxc']
-          expect(lines[1][5]).toEqual value: 'unistd.h', scopes: ['source.nxc', 'meta.preprocessor.include.nxc', 'string.quoted.other.lt-gt.include.nxc']
-          expect(lines[1][6]).toEqual value: '>', scopes: ['source.nxc', 'meta.preprocessor.include.nxc', 'string.quoted.other.lt-gt.include.nxc', 'punctuation.definition.string.end.nxc']
-          expect(lines[2][0]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc', 'punctuation.definition.directive.nxc']
-          expect(lines[2][1]).toEqual value: 'elif', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc']
-          expect(lines[2][2]).toEqual value: ' defined _WIN32 ', scopes: ['source.nxc', 'meta.preprocessor.nxc']
-          expect(lines[2][3]).toEqual value: '/*', scopes: ['source.nxc', 'comment.block.nxc', 'punctuation.definition.comment.begin.nxc']
-          expect(lines[2][4]).toEqual value: ' is defined by compilers targeting Windows systems ', scopes: ['source.nxc', 'comment.block.nxc']
-          expect(lines[2][5]).toEqual value: '*/', scopes: ['source.nxc', 'comment.block.nxc', 'punctuation.definition.comment.end.nxc']
-          expect(lines[3][1]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.include.nxc', 'keyword.control.directive.include.nxc', 'punctuation.definition.directive.nxc']
-          expect(lines[3][2]).toEqual value: ' include', scopes: ['source.nxc', 'meta.preprocessor.include.nxc', 'keyword.control.directive.include.nxc']
-          expect(lines[3][4]).toEqual value: '<', scopes: ['source.nxc', 'meta.preprocessor.include.nxc', 'string.quoted.other.lt-gt.include.nxc', 'punctuation.definition.string.begin.nxc']
-          expect(lines[3][5]).toEqual value: 'windows.h', scopes: ['source.nxc', 'meta.preprocessor.include.nxc', 'string.quoted.other.lt-gt.include.nxc']
-          expect(lines[3][6]).toEqual value: '>', scopes: ['source.nxc', 'meta.preprocessor.include.nxc', 'string.quoted.other.lt-gt.include.nxc', 'punctuation.definition.string.end.nxc']
-          expect(lines[4][0]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc', 'punctuation.definition.directive.nxc']
-          expect(lines[4][1]).toEqual value: 'endif', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc']
-
-        it "tokenizes ifndef blocks", ->
-          lines = grammar.tokenizeLines '''
-            #ifndef _INCL_GUARD
-              #define _INCL_GUARD
-            #endif
-          '''
-          expect(lines[0][0]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc', 'punctuation.definition.directive.nxc']
-          expect(lines[0][1]).toEqual value: 'ifndef', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc']
-          expect(lines[0][2]).toEqual value: ' _INCL_GUARD', scopes: ['source.nxc', 'meta.preprocessor.nxc']
-          expect(lines[1][1]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'keyword.control.directive.define.nxc', 'punctuation.definition.directive.nxc']
-          expect(lines[1][2]).toEqual value: 'define', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'keyword.control.directive.define.nxc']
-          expect(lines[1][4]).toEqual value: '_INCL_GUARD', scopes: ['source.nxc', 'meta.preprocessor.macro.nxc', 'entity.name.function.preprocessor.nxc']
-          expect(lines[2][0]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc', 'punctuation.definition.directive.nxc']
-          expect(lines[2][1]).toEqual value: 'endif', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc']
-
-    describe "indentation", ->
-      editor = null
-
-      beforeEach ->
-        editor = buildTextEditor()
-        editor.setGrammar(grammar)
-
-      expectPreservedIndentation = (text) ->
-        editor.setText(text)
-        editor.autoIndentBufferRows(0, editor.getLineCount() - 1)
-
-        expectedLines = text.split('\n')
-        actualLines = editor.getText().split('\n')
-        for actualLine, i in actualLines
-          expect([
-            actualLine,
-            editor.indentLevelForLine(actualLine)
-          ]).toEqual([
-            expectedLines[i],
-            editor.indentLevelForLine(expectedLines[i])
-          ])
-
-      it "indents allman-style curly braces", ->
-        expectPreservedIndentation '''
-          if (a)
-          {
-            for (;;)
-            {
-              do
-              {
-                while (b)
-                {
-                  c();
-                }
-              }
-              while (d)
-            }
-          }
-        '''
-
-      it "indents non-allman-style curly braces", ->
-        expectPreservedIndentation '''
-          if (a) {
-            for (;;) {
-              do {
-                while (b) {
-                  c();
-                }
-              } while (d)
-            }
-          }
-        '''
-
-      it "indents function arguments", ->
-        expectPreservedIndentation '''
-          a(
-            b,
-            c(
-              d
-            )
-          );
-        '''
-
-      it "indents array and struct literals", ->
-        expectPreservedIndentation '''
-          some_t a[3] = {
-            { .b = c },
-            { .b = c, .d = {1, 2} },
-          };
-        '''
-
-  describe "NXC", ->
-    beforeEach ->
-      grammar = atom.grammars.grammarForScopeName('source.nxc')
-
-    it "parses the grammar", ->
-      expect(grammar).toBeTruthy()
-      expect(grammar.scopeName).toBe 'source.nxc'
-
-    it "tokenizes this with `.this` class", ->
-      {tokens} = grammar.tokenizeLine 'this.x'
-      expect(tokens[0]).toEqual value: 'this', scopes: ['source.nxc', 'variable.language.this.nxc']
-
-    it "tokenizes classes", ->
-      lines = grammar.tokenizeLines '''
-        class Thing {
-          int x;
-        }
-      '''
-      expect(lines[0][0]).toEqual value: 'class', scopes: ['source.nxc', 'meta.class-struct-block.nxc', 'storage.type.nxc']
-      expect(lines[0][2]).toEqual value: 'Thing', scopes: ['source.nxc', 'meta.class-struct-block.nxc', 'entity.name.type.nxc']
-
-    it "tokenizes 'extern NXC'", ->
-      lines = grammar.tokenizeLines '''
-        extern "NXC" {
-        #include "legacy_NXC_header.h"
-        }
-      '''
-      expect(lines[0][0]).toEqual value: 'extern', scopes: ['source.nxc', 'meta.extern-block.nxc', 'storage.modifier.nxc']
-      expect(lines[0][2]).toEqual value: '"', scopes: ['source.nxc', 'meta.extern-block.nxc', 'string.quoted.double.nxc', 'punctuation.definition.string.begin.nxc']
-      expect(lines[0][3]).toEqual value: 'C', scopes: ['source.nxc', 'meta.extern-block.nxc', 'string.quoted.double.nxc']
-      expect(lines[0][4]).toEqual value: '"', scopes: ['source.nxc', 'meta.extern-block.nxc', 'string.quoted.double.nxc', 'punctuation.definition.string.end.nxc']
-      expect(lines[0][6]).toEqual value: '{', scopes: ['source.nxc', 'meta.extern-block.nxc', 'punctuation.section.block.begin.nxc']
-      expect(lines[1][0]).toEqual value: '#', scopes: ['source.nxc', 'meta.extern-block.nxc', 'meta.preprocessor.include.nxc', 'keyword.control.directive.include.nxc', 'punctuation.definition.directive.nxc']
-      expect(lines[1][1]).toEqual value: 'include', scopes: ['source.nxc', 'meta.extern-block.nxc', 'meta.preprocessor.include.nxc', 'keyword.control.directive.include.nxc']
-      expect(lines[1][3]).toEqual value: '"', scopes: ['source.nxc', 'meta.extern-block.nxc', 'meta.preprocessor.include.nxc', 'string.quoted.double.include.nxc', 'punctuation.definition.string.begin.nxc']
-      expect(lines[1][4]).toEqual value: 'legacy_C_header.h', scopes: ['source.nxc', 'meta.extern-block.nxc', 'meta.preprocessor.include.nxc', 'string.quoted.double.include.nxc']
-      expect(lines[1][5]).toEqual value: '"', scopes: ['source.nxc', 'meta.extern-block.nxc', 'meta.preprocessor.include.nxc', 'string.quoted.double.include.nxc', 'punctuation.definition.string.end.nxc']
-      expect(lines[2][0]).toEqual value: '}', scopes: ['source.nxc', 'meta.extern-block.nxc', 'punctuation.section.block.end.nxc']
-
-      lines = grammar.tokenizeLines '''
-        #ifdef __cplusplus
-        extern "NXC" {
-        #endif
-          // legacy NXC code here
-        #ifdef __cplusplus
-        }
-        #endif
-      '''
-      expect(lines[0][0]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc', 'punctuation.definition.directive.nxc']
-      expect(lines[0][1]).toEqual value: 'ifdef', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc']
-      expect(lines[0][2]).toEqual value: ' __cplusplus', scopes: ['source.nxc', 'meta.preprocessor.nxc']
-      expect(lines[1][0]).toEqual value: 'extern', scopes: ['source.nxc', 'meta.extern-block.nxc', 'storage.modifier.nxc']
-      expect(lines[1][2]).toEqual value: '"', scopes: ['source.nxc', 'meta.extern-block.nxc', 'string.quoted.double.nxc', 'punctuation.definition.string.begin.nxc']
-      expect(lines[1][3]).toEqual value: 'C', scopes: ['source.nxc', 'meta.extern-block.nxc', 'string.quoted.double.nxc']
-      expect(lines[1][4]).toEqual value: '"', scopes: ['source.nxc', 'meta.extern-block.nxc', 'string.quoted.double.nxc', 'punctuation.definition.string.end.nxc']
-      expect(lines[1][6]).toEqual value: '{', scopes: ['source.nxc', 'meta.extern-block.nxc', 'punctuation.section.block.begin.nxc']
-      expect(lines[2][0]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc', 'punctuation.definition.directive.nxc']
-      expect(lines[2][1]).toEqual value: 'endif', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc']
-      expect(lines[3][1]).toEqual value: '//', scopes: ['source.nxc', 'comment.line.double-slash.nxc', 'punctuation.definition.comment.nxc']
-      expect(lines[3][2]).toEqual value: ' legacy NXC code here', scopes: ['source.nxc', 'comment.line.double-slash.nxc']
-      expect(lines[4][0]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc', 'punctuation.definition.directive.nxc']
-      expect(lines[4][1]).toEqual value: 'ifdef', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc']
-      expect(lines[5][0]).toEqual value: '}', scopes: ['source.nxc']
-      expect(lines[6][0]).toEqual value: '#', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc', 'punctuation.definition.directive.nxc']
-      expect(lines[6][1]).toEqual value: 'endif', scopes: ['source.nxc', 'meta.preprocessor.nxc', 'keyword.control.directive.conditional.nxc']
-
-    describe "comments", ->
-      it "tokenizes them", ->
-        {tokens} = grammar.tokenizeLine '// comment'
-        expect(tokens[0]).toEqual value: '//', scopes: ['source.nxc', 'comment.line.double-slash.nxc', 'punctuation.definition.comment.nxc']
-        expect(tokens[1]).toEqual value: ' comment', scopes: ['source.nxc', 'comment.line.double-slash.nxc']
-
-        lines = grammar.tokenizeLines '''
-          // separated\\
-          comment
-        '''
-        expect(lines[0][0]).toEqual value: '//', scopes: ['source.nxc', 'comment.line.double-slash.nxc', 'punctuation.definition.comment.nxc']
-        expect(lines[0][1]).toEqual value: ' separated', scopes: ['source.nxc', 'comment.line.double-slash.nxc']
-        expect(lines[0][2]).toEqual value: '\\', scopes: ['source.nxc', 'comment.line.double-slash.nxc', 'constant.character.escape.line-continuation.nxc']
-        expect(lines[1][0]).toEqual value: 'comment', scopes: ['source.nxc', 'comment.line.double-slash.nxc']
